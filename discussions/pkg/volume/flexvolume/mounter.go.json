[
  {
    "id" : "c96e2411-d22c-4433-a9e7-53511aa3fd54",
    "prId" : 95866,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/95866#pullrequestreview-517320974",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82b828e4-a0b5-431a-b6fa-9eca12478b6c",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Should the plugin name be \"flexvolume\" or the name of the flex driver?",
        "createdAt" : "2020-10-26T22:37:40Z",
        "updatedAt" : "2020-10-26T22:56:58Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "2ff66a1b-050f-4728-ab7d-c6f1a3e22b36",
        "parentId" : "82b828e4-a0b5-431a-b6fa-9eca12478b6c",
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : "@msau42, I change it to \"kubernetes.io/flexvolume:[flex driver name]\". see https://github.com/kubernetes/kubernetes/pull/95892/. ",
        "createdAt" : "2020-10-27T03:21:24Z",
        "updatedAt" : "2020-10-27T03:22:11Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ed770977443cf0cf34cab743085d5c31b2f8034",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +95,99 @@\tif !f.readOnly {\n\t\tif f.plugin.capabilities.FSGroup {\n\t\t\tvolume.SetVolumeOwnership(f, mounterArgs.FsGroup, mounterArgs.FSGroupChangePolicy, util.FSGroupCompleteHook(f.plugin.GetPluginName()))\n\t\t}\n\t}"
  },
  {
    "id" : "56ea8745-1ec5-4006-af2d-baa2c45d262e",
    "prId" : 41804,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41804#pullrequestreview-22975674",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7133aaf6-4969-4b82-a4a0-e1fe15c1e5dd",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "if `fsGroup` is present and !readOnly, call [SetVolumeOwnership](https://github.com/kubernetes/kubernetes/blob/master/pkg/volume/gce_pd/gce_pd.go#L311) ",
        "createdAt" : "2017-02-21T14:58:17Z",
        "updatedAt" : "2017-02-25T01:18:26Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d2af70e95dc25141d6d179a088b3d1af26eb206",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +78,82 @@\tcall.AppendSpec(f.spec, f.plugin.host, extraOptions)\n\n\t_, err = call.Run()\n\tif isCmdNotSupportedErr(err) {\n\t\terr = (*mounterDefaults)(f).SetUpAt(dir, fsGroup)"
  },
  {
    "id" : "3355af32-fc3b-4320-80f9-58f0c6117cd2",
    "prId" : 39488,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/39488#pullrequestreview-36328914",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a024fc3-789e-416b-9133-f40f7140a3d8",
        "parentId" : null,
        "authorId" : "65c676d6-aec8-4761-943f-80e1f66d400b",
        "body" : "I have not studied this pr closely but am curious about what if in addition to, or instead of a service-account, a pod defines a securityContext? Does that need to be stored here?",
        "createdAt" : "2017-04-25T01:02:42Z",
        "updatedAt" : "2017-05-18T04:49:28Z",
        "lastEditedBy" : "65c676d6-aec8-4761-943f-80e1f66d400b",
        "tags" : [
        ]
      },
      {
        "id" : "9fe8b12f-3959-4d2d-8e31-7145ddaf9424",
        "parentId" : "1a024fc3-789e-416b-9133-f40f7140a3d8",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "fsGroup is already passed in. I'm not sure what else a flexvolume plugin would want/need, but my primary interest is enabling flex volumes to inject pod identity types of things, for which we'd want pod name, namespace, uid, and possibly service account name.",
        "createdAt" : "2017-05-04T16:02:41Z",
        "updatedAt" : "2017-05-18T04:49:28Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "0521a78e-72be-456b-8177-be3a7e205342",
        "parentId" : "1a024fc3-789e-416b-9133-f40f7140a3d8",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "For now, volume drivers don't use service account (though in the future they could). But if we pass service account, should we also pass the secret too?",
        "createdAt" : "2017-05-04T16:55:53Z",
        "updatedAt" : "2017-05-18T04:49:28Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "d5d6918b-f93f-4684-95a5-730ea4262e09",
        "parentId" : "1a024fc3-789e-416b-9133-f40f7140a3d8",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> if we pass service account, should we also pass the secret too?\r\n\r\nNo, the point is not to let the volume plugin act as the service account, it is to inform the volume plugin *which* service account the pod is using. Think of a vault plugin that injects credentials from vault for that service account.",
        "createdAt" : "2017-05-04T17:05:36Z",
        "updatedAt" : "2017-05-18T04:49:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b22ff256387ab7d99da0b8fbbdf7fccbae8ea0b6",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +72,76 @@\textraOptions[optionKeyPodUID] = string(f.podUID)\n\t// service account metadata\n\textraOptions[optionKeyServiceAccountName] = f.podServiceAccountName\n\n\t// Extract secret and pass it as options."
  }
]
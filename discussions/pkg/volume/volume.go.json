[
  {
    "id" : "f55b023a-902d-434d-b60a-617d230709ea",
    "prId" : 97972,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97972#pullrequestreview-642426137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8df1d48-0e8c-4488-9dd7-27f9705d3ca6",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "What happens for other block volume types (such as gce-pd, aws etc) where `MetricsProvider` is not initialized but now we try to grab metrics from them? Will that result in crash?",
        "createdAt" : "2021-02-11T03:17:56Z",
        "updatedAt" : "2021-04-22T16:23:03Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "92296ca0-7eb6-4a7b-92fe-75f61b27e863",
        "parentId" : "b8df1d48-0e8c-4488-9dd7-27f9705d3ca6",
        "authorId" : "1f54c5d1-c5cf-41c1-b046-4894d8619116",
        "body" : "I guess the assigning in `func (s *volumeStatCalculator) calcAndStoreStats()` would fail, as the particular blockVolume does not implement the `MetricsProvider` interface.\r\n\r\nI'll add a type assertion there, that should be sufficient. Or do you suggest an other approach?",
        "createdAt" : "2021-02-12T15:16:35Z",
        "updatedAt" : "2021-04-22T16:23:04Z",
        "lastEditedBy" : "1f54c5d1-c5cf-41c1-b046-4894d8619116",
        "tags" : [
        ]
      },
      {
        "id" : "17fe0326-a3ed-4fc1-a1ea-1af8e630267d",
        "parentId" : "b8df1d48-0e8c-4488-9dd7-27f9705d3ca6",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "We could fix other drivers to ensure they are initializing the `BlockVolume` interface correctly.  If a driver says it implements `BlockVolume` then it should implement it. Using type assertion here will fix the code but I wonder if this will cause further maintenance headaches. ",
        "createdAt" : "2021-02-12T16:50:23Z",
        "updatedAt" : "2021-04-22T16:23:04Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "9a39efda-bc9b-4214-9195-2ec1e38365c8",
        "parentId" : "b8df1d48-0e8c-4488-9dd7-27f9705d3ca6",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Another thing we could do is - remove `MetricsProvider` from `BlockVolume` definition here but have a type assertion like following in csi_block.go:\r\n\r\n```\r\nvar _ volume.MetricsProvider = &csiBlockMapper{}\r\n```\r\nand then in `calcAndStoreStats` only pick volumes that implement `volume.MetricsProvider` . This would avoid having to initialize `MetricsProvider` in other plugins. \r\n\r\nAnother thing though is - if we leave other plugins untouched, we will not get block volume metrics for them and hence our e2e will be kind of useless (unless it is refactored to work with csi volumes).",
        "createdAt" : "2021-02-12T17:05:59Z",
        "updatedAt" : "2021-04-22T16:23:04Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "1e131a42-c7a0-4619-8caf-8cff3851c282",
        "parentId" : "b8df1d48-0e8c-4488-9dd7-27f9705d3ca6",
        "authorId" : "1f54c5d1-c5cf-41c1-b046-4894d8619116",
        "body" : "I would like to implement this for in-tree drivers, similar to how basic statistics for filesystems are gathered. Unfortunately I can not tell yet when I will be able to spend time on this.",
        "createdAt" : "2021-04-22T16:30:10Z",
        "updatedAt" : "2021-04-22T16:30:10Z",
        "lastEditedBy" : "1f54c5d1-c5cf-41c1-b046-4894d8619116",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb703b4cc1a9a7f3c56660a2b665a429dcc11fa4",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +53,57 @@\t// used, available space).\n\tMetricsProvider\n}\n\n// MetricsProvider exposes metrics (e.g. used,available space) related to a"
  },
  {
    "id" : "02a25398-b096-400a-aad0-cac228235629",
    "prId" : 89193,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89193#pullrequestreview-378072773",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e851302-7a16-4e11-96cf-55cb0c6c7ad5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "document behavior when nil",
        "createdAt" : "2020-03-19T14:19:52Z",
        "updatedAt" : "2020-05-05T01:25:34Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b2ec61e3-3b6f-45e0-9bf6-d1e355408672",
        "parentId" : "1e851302-7a16-4e11-96cf-55cb0c6c7ad5",
        "authorId" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "body" : "done",
        "createdAt" : "2020-03-19T20:33:44Z",
        "updatedAt" : "2020-05-05T01:25:34Z",
        "lastEditedBy" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "tags" : [
        ]
      }
    ],
    "commit" : "3db7275b549559696c42c0b5f51c9a2397e9571d",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +107,111 @@\t// owned and writable by FsUser. Otherwise, there is no side effects.\n\t// Currently only supported with projected service account tokens.\n\tFsUser              *int64\n\tFsGroup             *int64\n\tFSGroupChangePolicy *v1.PodFSGroupChangePolicy"
  },
  {
    "id" : "654c35b8-f6ea-4dcb-a3f5-998734dc7fa5",
    "prId" : 89193,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89193#pullrequestreview-404394093",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1734c964-3d41-4c5c-8978-0f3e5b09c73f",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Add a comment that this is currently only supported with projected service account tokens",
        "createdAt" : "2020-05-01T20:17:42Z",
        "updatedAt" : "2020-05-05T01:25:34Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "6b85c9e0-2c01-49da-9398-f961cfa8bff8",
        "parentId" : "1734c964-3d41-4c5c-8978-0f3e5b09c73f",
        "authorId" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "body" : "done",
        "createdAt" : "2020-05-01T20:50:48Z",
        "updatedAt" : "2020-05-05T01:25:34Z",
        "lastEditedBy" : "f64c354b-61cb-4b89-b58f-f464e7ad4f94",
        "tags" : [
        ]
      }
    ],
    "commit" : "3db7275b549559696c42c0b5f51c9a2397e9571d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +105,109 @@type MounterArgs struct {\n\t// When FsUser is set, the ownership of the volume will be modified to be\n\t// owned and writable by FsUser. Otherwise, there is no side effects.\n\t// Currently only supported with projected service account tokens.\n\tFsUser              *int64"
  },
  {
    "id" : "43119b80-0935-4efa-b95d-a75f10d4afc5",
    "prId" : 66884,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66884#pullrequestreview-145890158",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63f23c7c-5974-4158-bec7-09428ed647c6",
        "parentId" : null,
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "Can we drop `block volume` word from here? it seems iffy - there are block volumes which don't necessarily use `DeviceMounter` and there could be non-block volumes that use the interface?",
        "createdAt" : "2018-08-13T16:59:19Z",
        "updatedAt" : "2018-08-14T03:15:11Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      },
      {
        "id" : "21de66f9-a9a6-4702-b551-4c3935f0880e",
        "parentId" : "63f23c7c-5974-4158-bec7-09428ed647c6",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : ">there are block volumes which don't necessarily use DeviceMounter\r\n\r\nwhich is true, for block mode.\r\n\r\n>there could be non-block volumes that use the interface\r\n\r\nActually, for now, local storage is the only use case that we only implement DeviceMounter( not implement Attacher interface). \r\nWe will only mount block device to a global path. If the local storage is a fs dir, we will do nothing, just set global path to its `Path` in pv spec.",
        "createdAt" : "2018-08-14T01:20:38Z",
        "updatedAt" : "2018-08-14T03:24:44Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      }
    ],
    "commit" : "55784f88d443c4d9b6c5263721c0256faa935aa0",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +224,228 @@}\n\n// DeviceMounter can mount a block volume to a global path.\ntype DeviceMounter interface {\n\t// GetDeviceMountPath returns a path where the device should"
  },
  {
    "id" : "47da766e-a023-46a4-b5d1-9188741588d6",
    "prId" : 64094,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/64094#pullrequestreview-125687234",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59d27e4b-a2ca-4aed-a2ed-c89cfe78b807",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Do you need a symmetric `UnmapVolume` call too?",
        "createdAt" : "2018-06-01T23:36:29Z",
        "updatedAt" : "2018-06-03T21:26:46Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "f278d599-9ac7-4202-8d47-7d108e00c9c2",
        "parentId" : "59d27e4b-a2ca-4aed-a2ed-c89cfe78b807",
        "authorId" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "body" : "Yeah, i thought about that too.   But there is an `unmapper.Teardown()` method defined where custom code could go.",
        "createdAt" : "2018-06-01T23:42:28Z",
        "updatedAt" : "2018-06-03T21:26:46Z",
        "lastEditedBy" : "54b8eb75-28dd-421d-a52b-63bf897147a9",
        "tags" : [
        ]
      },
      {
        "id" : "d223c002-5c95-484e-9c00-d4988445a900",
        "parentId" : "59d27e4b-a2ca-4aed-a2ed-c89cfe78b807",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Do we need to do any similar moving around of common logic?",
        "createdAt" : "2018-06-04T18:17:59Z",
        "updatedAt" : "2018-06-04T18:18:09Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "3569287993ed5b04e85473a3d29c2a6cb441498f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +164,168 @@\tSetUpDevice() (string, error)\n\n\t// Map maps the block device path for the specified spec and pod.\n\tMapDevice(devicePath, globalMapPath, volumeMapPath, volumeMapName string, podUID types.UID) error\n}"
  },
  {
    "id" : "a085c890-39ac-4bc4-836a-3dfaddd36ea1",
    "prId" : 31707,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97e8f1ee-4ac0-41c5-bb5b-4222df74a313",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Let's conditionalize this on runtime.GOOS==windows\n",
        "createdAt" : "2016-08-30T23:14:09Z",
        "updatedAt" : "2016-11-01T21:45:56Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "6daab2628000c65229f5617bfcb6f04feded5e03",
    "line" : null,
    "diffHunk" : "@@ -1,1 +218,222 @@\t}\n\n\t// os.Rename call fails on windows (https://github.com/golang/go/issues/14527)\n\t// Replacing with copyFolder to the newPath and deleting the oldPath directory\n\tif runtime.GOOS == \"windows\" {"
  },
  {
    "id" : "d99c717d-058d-4e51-89fc-84c1bbf01d23",
    "prId" : 24557,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad8e6af5-1dad-4fc2-b21f-9ba9742fa1f2",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Comment on `GetPath()` above:\n\n``` GO\ntype Volume interface {\n    // GetPath returns the directory path the volume is mounted to.\n    GetPath() string\n\n    // MetricsProvider embeds methods for exposing metrics (e.g. used,available space).\n    MetricsProvider\n}\n```\n\nWe need to make a clear distinction between the global mount path and the bind mount path. So let's break `GetPath()` in to `GetDeviceMountPath()` `GetPodBindMountPath()`\n",
        "createdAt" : "2016-04-20T22:10:53Z",
        "updatedAt" : "2016-05-04T14:35:01Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "57be86bd-3911-41b5-9045-ea3a68323331",
        "parentId" : "ad8e6af5-1dad-4fc2-b21f-9ba9742fa1f2",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Comments on both should make it clear that the paths may not necessarily exist, just what the expected location is.\n",
        "createdAt" : "2016-04-20T22:13:47Z",
        "updatedAt" : "2016-05-04T14:35:01Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "9437b856-fae8-43f3-8e95-440deaef9c33",
        "parentId" : "ad8e6af5-1dad-4fc2-b21f-9ba9742fa1f2",
        "authorId" : null,
        "body" : "hmm.. The global vs bind concept is only applicable to attachable volumes. So how about I add `GetDeviceMountPath()` to `PhysicalAttacher` and leave `GetPath()` as is but expand the comment ?\n",
        "createdAt" : "2016-04-21T18:09:01Z",
        "updatedAt" : "2016-05-04T14:35:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0bf5621c-cdc0-44aa-890b-9e134cfabe73",
        "parentId" : "ad8e6af5-1dad-4fc2-b21f-9ba9742fa1f2",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Good point. Actually both only make sense on kubelet. So it would make sense to move both to `PhysicalAttacher`\n",
        "createdAt" : "2016-04-21T20:29:45Z",
        "updatedAt" : "2016-05-04T14:35:01Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      },
      {
        "id" : "0831d8c5-7128-4fbe-a724-918cd467a705",
        "parentId" : "ad8e6af5-1dad-4fc2-b21f-9ba9742fa1f2",
        "authorId" : null,
        "body" : "Hmm.. only one can be moved I think because GetPath() is applicable to all volumes not just attachable ones \n",
        "createdAt" : "2016-04-25T19:15:06Z",
        "updatedAt" : "2016-05-04T14:35:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "71e7dba84525761db1436cf2c7daaffb2a730d27",
    "line" : null,
    "diffHunk" : "@@ -1,1 +133,137 @@type Attacher interface {\n\tVolume\n\n\t// Attach the volume specified by the given spec to the given host\n\tAttach(spec *Spec, hostName string) error"
  },
  {
    "id" : "9ceae584-2859-460e-8322-c40385b55597",
    "prId" : 24557,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da7689f5-6662-4908-be6e-91a9f579fbb2",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "Just realized none of the plugins actually implement the Attacher interface yet. They all just overload the Mounter code. Nice.\n",
        "createdAt" : "2016-04-29T23:40:45Z",
        "updatedAt" : "2016-05-04T14:35:01Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "71e7dba84525761db1436cf2c7daaffb2a730d27",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +131,135 @@\n// Attacher can attach a volume to a node.\ntype Attacher interface {\n\tVolume\n"
  },
  {
    "id" : "5e49b601-7d0e-4a67-8791-2b2ad3d747fa",
    "prId" : 19503,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3017a8dc-6b8a-4653-aebc-b3e477bfa440",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Does this need to inline `Volume` as well?\n",
        "createdAt" : "2016-01-20T17:54:01Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "4f8efdf3-fb43-4822-b8e6-cfaeb6c300f8",
        "parentId" : "3017a8dc-6b8a-4653-aebc-b3e477bfa440",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Probably?  I'm not sure either really needs to inline `Volume`.  I haven't digested that thought fully.\n\nDoes any other volume interface that's not Builder/Cleaner (soon to be Mounter/Unmounter) need `Volume`?  \n",
        "createdAt" : "2016-01-20T18:07:30Z",
        "updatedAt" : "2016-02-07T22:38:46Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "a242a3d5fe618444edc44b6194df2c48a9799251",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +134,138 @@\n// Detacher can detach a volume from a node.\ntype Detacher interface {\n\tDetach() error\n}"
  },
  {
    "id" : "1651d28b-cc45-4f32-9a82-5aedba134ce3",
    "prId" : 13650,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "260dbca6-e9b1-414c-96f5-e69dd2ef89ec",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Shouldn't this be `Creator`?  I don't want to pick a nit at the last minute if this is otherwise good.  Follow-up if you agree?\n",
        "createdAt" : "2015-09-20T07:16:34Z",
        "updatedAt" : "2015-09-20T07:16:34Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "9c7d03b2b6f37d8e12c0cceccb2ab099cf08552a",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +69,73 @@// Create adds a new resource in the storage provider and creates a PersistentVolume for the new resource.\n// Calls to Create should block until complete.\ntype Creater interface {\n\tCreate() (*api.PersistentVolume, error)\n}"
  },
  {
    "id" : "9687c10b-2d97-410d-8255-01ecdc058e53",
    "prId" : 13650,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f88631a-d44d-478b-b7fe-c65f46c8ebce",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I think now this is a little bit backward or should at least be 2 operations:\n1.  the provisioner needs to provide a template PV for it's plugin according to the volumeOptions.\n2.  the provisioner needs to invoke its internal logic for creation of the resource in the infrastructure.\n\nA Claim's provisioning should be like this:\n1. Create PVC with experimental annotation.  will only bind to a PV with a matching pre-bind annotation.\n2. Watch claim, Create PV - but unfulfilled in infrastructure.  special annotation prevents binding until fulfillment.\n3. Watch volumes, create resource -- use real PV name to link to provider -- remove unfulfilled annotation and save real volumeID.\n4. claim will bind to newly provisioned volume\n",
        "createdAt" : "2015-10-02T19:09:38Z",
        "updatedAt" : "2015-10-02T19:09:38Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      },
      {
        "id" : "0bb56cfe-ab0a-4982-b91e-249c9a8617cf",
        "parentId" : "3f88631a-d44d-478b-b7fe-c65f46c8ebce",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Yeah, I think that if we're retooling the controllers this makes more sense to be lifted out of the plugin.\n\nAlso, we've done sort of a poor job of defining exactly what logic belongs in the the GCE volume code vs what belongs in the GCE cloud provider code.  More and more I am feeling that the GCE-API stuff should be in the cloud provider - the GCE specific provider, not as a generic abstraction.  That module becomes our \"one true place\" to interface with GCE APIs.  The GCEPD volume uses that to get PDs attached and mounted.  (I mean eventually :)\n",
        "createdAt" : "2015-10-02T21:41:11Z",
        "updatedAt" : "2015-10-02T21:41:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e6a382b1-bb0e-4456-9513-820e369511c6",
        "parentId" : "3f88631a-d44d-478b-b7fe-c65f46c8ebce",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin @markturansky \n\n>  That module becomes our \"one true place\" to interface with GCE APIs. The GCEPD volume uses that to get PDs attached and mounted. (I mean eventually :)\n\nThinking through that a bit -- so we will wind up with a provisioner for GCEPD that gets the cloud provider from the `VolumeHost` interface, the makes a downcast to GCECloudProvider, that uses some special function of that type to create a new PD.\n\nThat seems simple enough, but it's not going to be as cut and dry for other volume types.  NFS, for example:\n1.  You want a provisioner that knows how to provision EFS volumes that are used as NFS volumes\n2.  You want a provisioner that knows how to provision using the netapp ONTAP API\n3.  What happens when you have a cluster with an aws cloud provider and you want to provision some NFS volumes via EFS and some via ONTAP against a machine running the ONTAP server in AWS?\n\nMaybe we solve (3) by differentiating distinct volume types for differently provisioned volumes of the same type, but that doesn't sit quite right with me.  I guess the question is whether there is really utility for an encompassing 'type' for each permutation of (client-side-concerns,provisioning-concerns) versus decoupling them.\n",
        "createdAt" : "2015-10-02T22:15:16Z",
        "updatedAt" : "2015-10-02T22:15:16Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "86d254ef-ccc9-4071-9086-d217f1a106f8",
        "parentId" : "3f88631a-d44d-478b-b7fe-c65f46c8ebce",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "> Thinking through that a bit -- so we will wind up with a provisioner for GCEPD that gets the cloud provider from the VolumeHost interface, the makes a downcast to GCECloudProvider, that uses some special function of that type to create a new PD.\n\nCorrect - it's just a matter of where the code lives.\n\n> That seems simple enough, but it's not going to be as cut and dry for other volume types. NFS, for example:\n> \n> You want a provisioner that knows how to provision EFS volumes that are used as NFS volumes\n> You want a provisioner that knows how to provision using the netapp ONTAP API\n> What happens when you have a cluster with an aws cloud provider and you want to provision some NFS volumes via EFS and some via ONTAP against a machine running the ONTAP server in AWS?\n\nThe NetApp NFS provisioner is a totally different beast than the GCE\nprovisioner.    I do not think we should have a single provisioner\nthat knows how to provision every volume type.\n\n> Maybe we solve (3) by differentiating distinct volume types for differently provisioned volumes of the same type, but that doesn't sit quite right with me. I guess the question is whether there is really utility for an encompassing 'type' for each permutation of (client-side-concerns,provisioning-concerns) versus decoupling them.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-10-02T22:26:25Z",
        "updatedAt" : "2015-10-02T22:26:25Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e1a62d29-c09a-451a-9492-4b5ad147c84d",
        "parentId" : "3f88631a-d44d-478b-b7fe-c65f46c8ebce",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin \n\n> The NetApp NFS provisioner is a totally different beast than the GCE\n> provisioner.    I do not think we should have a single provisioner\n> that knows how to provision every volume type.\n\nI wasn't talking about a single provisioner that knows how to provision all types.  I was saying, we'll have an EFS provisioner and netapp provisioner, do we need to differentiate entire plugins for those since they're both NFS on the client side (afaik), or do we need to have a mapping of the PV concerns to plugins that allows for us to DNR on volume plugins just to differentiate provisioners.\n",
        "createdAt" : "2015-10-02T22:31:40Z",
        "updatedAt" : "2015-10-02T22:31:40Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "b43a9fe2-76ef-49d3-a905-40f4539aa12e",
        "parentId" : "3f88631a-d44d-478b-b7fe-c65f46c8ebce",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "The provisioner will map what it gets from PVC onto what it knows to\ncreate.  That might start with \"class = gold\" mapping to netapp while\n\"class = bronze\" maps to NFS on a RasPi.\n\nOn Fri, Oct 2, 2015 at 3:32 PM, Paul Morie notifications@github.com wrote:\n\n> In pkg/volume/volume.go\n> https://github.com/kubernetes/kubernetes/pull/13650#discussion_r41074722\n> :\n> \n> > @@ -65,6 +66,12 @@ type Recycler interface {\n> >     Recycle() error\n> >  }\n> > \n> > +// Create adds a new resource in the storage provider and creates a PersistentVolume for the new resource.\n> > +// Calls to Create should block until complete.\n> > +type Creater interface {\n> > -   Create() (*api.PersistentVolume, error)\n> \n> @thockin https://github.com/thockin\n> \n> The NetApp NFS provisioner is a totally different beast than the GCE\n> provisioner. I do not think we should have a single provisioner\n> that knows how to provision every volume type.\n> \n> I wasn't talking about a single provisioner that knows how to provision\n> all types. I was saying, we'll have an EFS provisioner and netapp\n> provisioner, do we need to differentiate entire plugins for those since\n> they're both NFS on the client side (afaik), or do we need to have a\n> mapping of the PV concerns to plugins that allows for us to DNR on volume\n> plugins just to differentiate provisioners.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13650/files#r41074722.\n",
        "createdAt" : "2015-10-02T23:47:47Z",
        "updatedAt" : "2015-10-02T23:47:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "9c7d03b2b6f37d8e12c0cceccb2ab099cf08552a",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +70,74 @@// Calls to Create should block until complete.\ntype Creater interface {\n\tCreate() (*api.PersistentVolume, error)\n}\n"
  },
  {
    "id" : "712ba2d7-c3a6-475f-889e-aafdae148b3d",
    "prId" : 1337,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67ea52f7-296b-48bf-9233-ad3ac631f1cf",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "seems like Attaching and Detaching is not unique to GCE.\n",
        "createdAt" : "2014-09-26T06:24:24Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "75229451-b4de-4a3e-96ed-4a1de778dbf8",
        "parentId" : "67ea52f7-296b-48bf-9233-ad3ac631f1cf",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Will generalize when we have more than one solution.\n",
        "createdAt" : "2014-10-07T21:13:12Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ec25f3b8121a25242c6743a0bbdaa90df8d1536",
    "line" : null,
    "diffHunk" : "@@ -1,1 +51,55 @@}\n\ntype gcePersistentDiskUtil interface {\n\t// Attaches the disk to the kubelet's host machine.\n\tAttachDisk(PD *GCEPersistentDisk) error"
  },
  {
    "id" : "2dc8eb85-6345-41e9-b0be-df2f36110eab",
    "prId" : 1337,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36c759b4-8de3-488b-adcf-5c2fe71f4404",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "What collisions is he referring to?  \n",
        "createdAt" : "2014-09-26T06:29:48Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "b96810c5-e0f8-4c33-a568-a416ad6c84ad",
        "parentId" : "36c759b4-8de3-488b-adcf-5c2fe71f4404",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Different pods referring to the same volume.  Will address w/ a fit predicate in a different PR.\n",
        "createdAt" : "2014-10-07T21:14:02Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ec25f3b8121a25242c6743a0bbdaa90df8d1536",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +217,221 @@}\n\n//TODO(jonesdl) prevent name collisions by using designated pod space as well.\n// Ex. (ROOT_DIR)/pods/...\nfunc makeGlobalPDName(rootDir, devName string, readOnly bool) string {"
  },
  {
    "id" : "87be5cab-eb58-42c0-8630-0c53095f78dc",
    "prId" : 1337,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e662ec30-78d1-471c-bb6d-e6b505ecff0a",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Why is mounter per GCEPersistentDisk instead of one per Kubelet?\n",
        "createdAt" : "2014-09-26T06:31:32Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "f5d615d5-b368-4808-b9e6-1e9bbae38a46",
        "parentId" : "e662ec30-78d1-471c-bb6d-e6b505ecff0a",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "covereged below.\n",
        "createdAt" : "2014-10-07T21:16:12Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ec25f3b8121a25242c6743a0bbdaa90df8d1536",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +152,156 @@\t// Utility interface that provides API calls to the provider to attach/detach disks.\n\tutil gcePersistentDiskUtil\n\t// Mounter interface that provides system calls to mount the disks.\n\tmounter mounter\n}"
  },
  {
    "id" : "4a6f2dde-5083-4c9f-9e3c-7d41aec0e898",
    "prId" : 1337,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "937fc78a-62a3-47c1-bf11-5fe5c99d2bcb",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Seems like both GCEDiskUtil and DiskMounter are per-Kubelet, not per volume.\n",
        "createdAt" : "2014-09-26T06:32:23Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "8771e00e-84c6-4646-b9b3-b4a17211b236",
        "parentId" : "937fc78a-62a3-47c1-bf11-5fe5c99d2bcb",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "TODO'd to move this up into the kubelet.  Doesn't cost much to have it here, though....\n",
        "createdAt" : "2014-10-07T21:16:32Z",
        "updatedAt" : "2014-10-09T03:04:11Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "4ec25f3b8121a25242c6743a0bbdaa90df8d1536",
    "line" : null,
    "diffHunk" : "@@ -1,1 +244,248 @@\treadOnly := volume.Source.GCEPersistentDisk.ReadOnly\n\t// TODO: move these up into the Kubelet.\n\tutil := &GCEDiskUtil{}\n\tmounter := &DiskMounter{}\n\treturn &GCEPersistentDisk{"
  },
  {
    "id" : "d946ccef-9bf5-479e-85ac-1a1bc27d27c5",
    "prId" : 688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7bd2d168-8730-4e62-aa29-8c1ff260477c",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Note that it embeds the above Interface?\n",
        "createdAt" : "2014-07-30T23:00:06Z",
        "updatedAt" : "2014-08-06T18:20:43Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "9f2e0e93-5469-44ad-bcc4-006c576e15f9",
        "parentId" : "7bd2d168-8730-4e62-aa29-8c1ff260477c",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Also _why_ does it embed the above interface?\n",
        "createdAt" : "2014-07-30T23:00:25Z",
        "updatedAt" : "2014-08-06T18:20:43Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "5a64af1e-fdf3-48d1-9e34-fd54f1de33db",
        "parentId" : "7bd2d168-8730-4e62-aa29-8c1ff260477c",
        "authorId" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "body" : "The context in which a builder is used in kubelet also requires providing the path as the binding point for Docker. \n",
        "createdAt" : "2014-07-30T23:35:49Z",
        "updatedAt" : "2014-08-06T18:20:43Z",
        "lastEditedBy" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c28e0849f2617995b5b902a25e1c2c66d008e84",
    "line" : null,
    "diffHunk" : "@@ -1,1 +36,40 @@}\n\n// The Builder interface provides the method to set up/mount the volume.\ntype Builder interface {\n\t// Uses Interface to provide the path for Docker binds."
  },
  {
    "id" : "a509c7e1-4fb5-4687-a8e3-2cd8d76ef307",
    "prId" : 527,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f68d60e7-329d-4eec-9afc-caa24b2fa78c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Why is this copied to every Empty?\n",
        "createdAt" : "2014-07-22T05:07:47Z",
        "updatedAt" : "2014-07-24T20:04:19Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3311615f-0dd6-4539-8d88-25a8a579f376",
        "parentId" : "f68d60e7-329d-4eec-9afc-caa24b2fa78c",
        "authorId" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "body" : "I thought about making RootDir an argument to GetPath, which on second thought makes more sense than having every volume have RootDir as a member.\n\nedit: turns out this is uglier, leaving the rootDir as a member of the volume for now.\n",
        "createdAt" : "2014-07-22T18:03:53Z",
        "updatedAt" : "2014-07-24T20:04:19Z",
        "lastEditedBy" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfa46420552df58e12a7121f8d695af95e6a7100",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +60,64 @@\tName    string\n\tPodID   string\n\tRootDir string\n}\n"
  },
  {
    "id" : "6d5c2ed5-3ed7-4f73-8ed8-b7c279432834",
    "prId" : 527,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bd8f9f6-3b93-4914-8278-ca64f9f283d5",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Instead of Stat, recommend just calling MkdirAll, and whatever you do, I think it's important to check the error on os.MkdirAll; do not want that to fail silently. In fact, I think that should fail in a way that causes us to not attempt to start the pod. Otherwise, users are going to have a very unpleasant debugging experience. So maybe I'm asking for SetUp() to return an error.\n",
        "createdAt" : "2014-07-23T18:17:19Z",
        "updatedAt" : "2014-07-24T20:04:19Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfa46420552df58e12a7121f8d695af95e6a7100",
    "line" : null,
    "diffHunk" : "@@ -1,1 +67,71 @@\tpath := emptyDir.GetPath()\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\tos.MkdirAll(path, 0750)\n\t} else {\n\t\tglog.Warningf(\"Directory already exists: (%v)\", path)"
  },
  {
    "id" : "5bd877e4-a9b4-4f88-bbc0-ca7e576c2c25",
    "prId" : 452,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b82e410e-00dd-442f-9f08-d6647ace8024",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "A comment from before that I don't see addressed - how can HostDirectory indicate that it can ONLY be mounted read-only ?\n",
        "createdAt" : "2014-07-16T21:46:17Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "193069e4-ec20-496e-a488-30e3217432ba",
        "parentId" : "b82e410e-00dd-442f-9f08-d6647ace8024",
        "authorId" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "body" : "Do we want this restriction for all HostDirectories or make read/write a privileged feature?\n",
        "createdAt" : "2014-07-16T22:56:40Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "tags" : [
        ]
      },
      {
        "id" : "0e8f340a-db9b-4fe7-b860-b81ce17b6f94",
        "parentId" : "b82e410e-00dd-442f-9f08-d6647ace8024",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "As per converstaion with vmarmol - we can't :(\n",
        "createdAt" : "2014-07-17T00:04:09Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb2843498df6d534741fa7554bc36502dc9c603a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +36,40 @@\t// This procedure must be idempotent.\n\tTearDown()\n}\n\n// Host Directory volumes represent a bare host directory mount."
  },
  {
    "id" : "41ca5eba-28b3-45a4-802b-a2911b7f78b1",
    "prId" : 452,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c73c3b2-b3ac-486d-99b1-1308fb391cee",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think it was export (singular) before,.\n",
        "createdAt" : "2014-07-16T21:47:29Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "f2c52285-d9b5-4df5-b5be-7803b8478539",
        "parentId" : "6c73c3b2-b3ac-486d-99b1-1308fb391cee",
        "authorId" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "body" : "It's exports (line 199 of kubelet.go).\n",
        "createdAt" : "2014-07-16T22:23:17Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "tags" : [
        ]
      },
      {
        "id" : "32c82abc-c91d-44b0-b4ca-4d2d0a7e5f53",
        "parentId" : "6c73c3b2-b3ac-486d-99b1-1308fb391cee",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "damn.\n",
        "createdAt" : "2014-07-17T00:04:23Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb2843498df6d534741fa7554bc36502dc9c603a",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +77,81 @@\t// TODO(jonesdl) We will want to add a flag to designate a root\n\t// directory for kubelet to write to. For now this will just be /exports\n\treturn fmt.Sprintf(\"/exports/%v/%v\", emptyDir.PodID, emptyDir.Name)\n}\n"
  },
  {
    "id" : "48cf7e5e-e5cd-4585-b1f3-bebaebf0fa73",
    "prId" : 452,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58725667-d6f8-4956-a3e8-ce777e35b44b",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "comment: Must be idempotent\n",
        "createdAt" : "2014-07-17T05:31:11Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb2843498df6d534741fa7554bc36502dc9c603a",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +28,32 @@// All volume types are expected to implement this interface\ntype Interface interface {\n\t// Prepares and mounts/unpacks the volume to a directory path.\n\t// This procedure must be idempotent.\n\tSetUp()"
  },
  {
    "id" : "f28a3fc7-ed71-42da-aaa6-5b115aa78799",
    "prId" : 452,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b991a181-c055-4b8a-a059-92a5643f6dad",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Must be idempotent.\n",
        "createdAt" : "2014-07-17T05:31:23Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb2843498df6d534741fa7554bc36502dc9c603a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +33,37 @@\t// Returns the directory path the volume is mounted to.\n\tGetPath() string\n\t// Unmounts the volume and removes traces of the SetUp procedure.\n\t// This procedure must be idempotent.\n\tTearDown()"
  },
  {
    "id" : "7629233e-a3fb-46af-a790-07b716f2e28a",
    "prId" : 452,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5256d963-ff3e-43a5-ba14-f7fad05e8764",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Maybe log a warning here? Up to you.\n",
        "createdAt" : "2014-07-17T20:54:28Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "7b816e93-484e-4d35-845b-3d04dd152ada",
        "parentId" : "5256d963-ff3e-43a5-ba14-f7fad05e8764",
        "authorId" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "body" : "Added a warning.\n",
        "createdAt" : "2014-07-17T22:04:00Z",
        "updatedAt" : "2014-07-17T22:26:07Z",
        "lastEditedBy" : "5047b1e4-a97e-4cdf-96ee-2e59b9b3fe43",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb2843498df6d534741fa7554bc36502dc9c603a",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +72,76 @@// TODO(jonesdl) when we can properly invoke TearDown(), we should delete\n// the directory created by SetUp.\nfunc (emptyDir *EmptyDirectory) TearDown() {}\n\nfunc (emptyDir *EmptyDirectory) GetPath() string {"
  }
]
[
  {
    "id" : "b8cbf019-cffd-43e0-bd6c-f9488e04e176",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-92261551",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3080cba8-66d0-4043-883a-c1c95a023a75",
        "parentId" : null,
        "authorId" : "6c37c694-3f72-4ff3-ac3a-5fbddf4d5796",
        "body" : "Just a nit, I think we should use RBD and not Rbd. At least lint will not be happy with Rbd/Nbd",
        "createdAt" : "2018-01-29T16:19:57Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "6c37c694-3f72-4ff3-ac3a-5fbddf4d5796",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +70,74 @@\n// Search /sys/bus for rbd device that matches given pool and image.\nfunc getRbdDevFromImageAndPool(pool string, image string) (string, bool) {\n\t// /sys/bus/rbd/devices/X/name and /sys/bus/rbd/devices/X/pool\n\tsys_path := \"/sys/bus/rbd/devices\""
  },
  {
    "id" : "3b37204c-11b4-4aa2-af0e-258444ad1e1e",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-93773488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7808c6fd-a9b8-4c29-9e0e-b8b51678bfd2",
        "parentId" : null,
        "authorId" : "6c37c694-3f72-4ff3-ac3a-5fbddf4d5796",
        "body" : "Would it not be more efficient to pass what to look for (rbd or nbd)? This way you always run getRBD even if you really need only getNBD.",
        "createdAt" : "2018-01-29T16:22:13Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "6c37c694-3f72-4ff3-ac3a-5fbddf4d5796",
        "tags" : [
        ]
      },
      {
        "id" : "8e66ef24-5122-422c-a0e1-5ec0f806bacf",
        "parentId" : "7808c6fd-a9b8-4c29-9e0e-b8b51678bfd2",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "This method is called only from other other location, and keeping this method helps hide some of the details from the caller.",
        "createdAt" : "2018-02-02T22:15:05Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +57,61 @@)\n\nfunc getDevFromImageAndPool(pool, image string) (string, bool) {\n\tdevice, found := getRbdDevFromImageAndPool(pool, image)\n\tif found {"
  },
  {
    "id" : "0a2a3daa-900d-476e-88bf-7841b9ca948f",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-93769539",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54b5b0d3-65b6-4bd1-8233-84dcffdd212f",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "what happens if you map using rbd, can you unmap using rbd-nbd ? If that is not a supported scenario we should detect and error out ",
        "createdAt" : "2018-02-02T00:31:40Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "38810621-8620-415c-8201-8c430851d739",
        "parentId" : "54b5b0d3-65b6-4bd1-8233-84dcffdd212f",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "No you cannot unmap rbd devices using rbd-nbd, as per comments on L412 & L413. This code detects how the device was mapped, and uses the appropriate command to unmap.",
        "createdAt" : "2018-02-02T21:57:44Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 382,
    "diffHunk" : "@@ -1,1 +459,463 @@\n\t// rbd unmap\n\toutput, err := exec.Run(rbdCmd, \"unmap\", device)\n\tif err != nil {\n\t\treturn rbdErrors(err, fmt.Errorf(\"rbd: failed to unmap device %s, error %v, rbd output: %v\", device, err, output))"
  },
  {
    "id" : "c4a5002b-f5ad-427e-83fd-2f51ea5b4224",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-98993789",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7a1feac-a59a-490b-be34-acb9d60cce93",
        "parentId" : null,
        "authorId" : "89888ad4-0dac-48c1-b890-5f4449a2de2b",
        "body" : "why not return when `maxNbdsErr` results in an error?. That way in the `for` loop, you dont have to check whether `maxNbdsErr != nil`. And you dont have to check it again to `break` out of the loop.",
        "createdAt" : "2018-02-21T23:44:17Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "89888ad4-0dac-48c1-b890-5f4449a2de2b",
        "tags" : [
        ]
      },
      {
        "id" : "6259bb66-4da9-4adf-8307-328d2e4af995",
        "parentId" : "f7a1feac-a59a-490b-be34-acb9d60cce93",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "maxNbds is a more accurate way to know the number of rbd devices to loop through in the code below. Otherwise, below we loop until we get an error.",
        "createdAt" : "2018-02-22T14:42:51Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      },
      {
        "id" : "fb255bea-5413-4f65-8536-5a24ed2d9e4b",
        "parentId" : "f7a1feac-a59a-490b-be34-acb9d60cce93",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "agree with @kokhang return when `maxNbdsErr !=nil` makes the loop more readable.\r\n",
        "createdAt" : "2018-02-23T14:30:25Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "fcb98302-e82b-495b-b4a6-aa8c23578ba7",
        "parentId" : "f7a1feac-a59a-490b-be34-acb9d60cce93",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "@rootfs @kokhang - We've updated the code accordingly, to return if there is an error reading nbds_max.",
        "createdAt" : "2018-02-23T17:45:21Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +147,151 @@\timgPath := fmt.Sprintf(\"%s/%s\", pool, image)\n\n\tmaxNbds, maxNbdsErr := getMaxNbds()\n\tif maxNbdsErr != nil {\n\t\tglog.V(4).Infof(\"error reading nbds_max %v\", maxNbdsErr)"
  },
  {
    "id" : "53f7e4db-2e25-4213-9ad4-edc7122b1fac",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-98685152",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf251312-0bdd-48e5-a6a2-5d6568019d85",
        "parentId" : null,
        "authorId" : "89888ad4-0dac-48c1-b890-5f4449a2de2b",
        "body" : "Should we care about supporting old versions of rbd-nbd? Can we just support the new version where `rbd-nbd list-mapped` will return you the device? This will make this code cleaner. \r\n\r\nThe nice thing abour rbd-nbd is that it is not kernel dependent. So it being in userspace, users can easily install the new version.",
        "createdAt" : "2018-02-21T23:51:09Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "89888ad4-0dac-48c1-b890-5f4449a2de2b",
        "tags" : [
        ]
      },
      {
        "id" : "625e9dbd-22b8-4105-8dbf-b1700d0993e3",
        "parentId" : "cf251312-0bdd-48e5-a6a2-5d6568019d85",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "list-mapped depends on \"newer\" versions of rbd-nbd which are not found in distributions like centos-7, and we've found that list-mapped did not work properly in several ceph rbd-nbd releases. Therefore, we've gone with the lowest common denominator. \r\n\r\nIn the future if `list-mapped` becomes more available, this code be refactored. +1\r\n",
        "createdAt" : "2018-02-22T18:52:30Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +137,141 @@\n// Locate any existing rbd-nbd process mapping given a <pool, image>.\n// Recent versions of rbd-nbd tool can correctly provide this info using list-mapped\n// but older versions of list-mapped don't.\n// The implementation below peeks at the command line of nbd bound processes"
  },
  {
    "id" : "0d4cb1ce-2d5c-46a1-9b74-fa49a4a4938a",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-99325662",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f76b59f2-99aa-4c46-9bf1-464b0cfa5d88",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "can you provide a sample content? ",
        "createdAt" : "2018-02-26T14:48:52Z",
        "updatedAt" : "2018-02-26T15:06:26Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 140,
    "diffHunk" : "@@ -1,1 +177,181 @@\t\t// Only accepted pattern of cmdline is from execRbdMap:\n\t\t// rbd-nbd map pool/image ...\n\t\tif len(cmdlineArgs) < 3 || cmdlineArgs[0] != \"rbd-nbd\" || cmdlineArgs[1] != \"map\" {\n\t\t\tglog.V(4).Infof(\"nbd device %s is not used by rbd\", nbdPath)\n\t\t\tcontinue"
  },
  {
    "id" : "17a8571a-b63c-4597-8ecd-f8ea2b9327f1",
    "prId" : 58916,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58916#pullrequestreview-109727450",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86c9f91c-1492-4200-99a5-038cc932da36",
        "parentId" : null,
        "authorId" : "5e99327b-41e1-4793-ae5e-b2fabb22c363",
        "body" : "@ianchakeres is nbd with this code working for you?\r\n\r\nnbdToolsFound would be always false as you are trying to redefine the variable in if scope.",
        "createdAt" : "2018-04-05T12:21:25Z",
        "updatedAt" : "2018-04-05T12:21:44Z",
        "lastEditedBy" : "5e99327b-41e1-4793-ae5e-b2fabb22c363",
        "tags" : [
        ]
      },
      {
        "id" : "f9af3736-e8d2-45a0-8b16-2ff3fcf6271f",
        "parentId" : "86c9f91c-1492-4200-99a5-038cc932da36",
        "authorId" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "body" : "@spronin-aurea - Thanks for pointing this out. We'll investigate and get an update in process.",
        "createdAt" : "2018-04-05T14:04:05Z",
        "updatedAt" : "2018-04-05T14:04:05Z",
        "lastEditedBy" : "9f5e3cfe-0c8a-43e2-8374-3cbe3b3568ab",
        "tags" : [
        ]
      },
      {
        "id" : "6d490f76-bccd-48b0-be9a-754c78462341",
        "parentId" : "86c9f91c-1492-4200-99a5-038cc932da36",
        "authorId" : "b67f62d7-da23-4ded-ad58-d056fb98cc11",
        "body" : "Here's PR created for that bug https://github.com/kubernetes/kubernetes/pull/62168",
        "createdAt" : "2018-04-05T14:14:17Z",
        "updatedAt" : "2018-04-05T14:14:17Z",
        "lastEditedBy" : "b67f62d7-da23-4ded-ad58-d056fb98cc11",
        "tags" : [
        ]
      }
    ],
    "commit" : "110447844d5cc2fae4f1c653369d647bb584d608",
    "line" : 297,
    "diffHunk" : "@@ -1,1 +373,377 @@\n\tif !mapped {\n\t\tnbdToolsFound := checkRbdNbdTools(b.exec)\n\t\tif nbdToolsFound {\n\t\t\tdevicePath, mapped = waitForPath(b.Pool, b.Image, 1 /*maxRetries*/, true /*useNbdDriver*/)"
  },
  {
    "id" : "6b3dbf79-30e9-4188-9073-92e7a03fad18",
    "prId" : 52767,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52767#pullrequestreview-78156080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca69f8a4-ac20-4802-b398-609738e43ae3",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "why not just parse json or use regex (for better clarity)?",
        "createdAt" : "2017-11-21T15:23:05Z",
        "updatedAt" : "2017-11-22T11:48:39Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "cdfc1b79-e5a4-4b08-bd51-22ecfd03904b",
        "parentId" : "ca69f8a4-ac20-4802-b398-609738e43ae3",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : "Yeah, i parsed json at first and found that rbd info would return different items with different version. So i changed to cut string in the end",
        "createdAt" : "2017-11-21T15:40:24Z",
        "updatedAt" : "2017-11-22T11:48:39Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      },
      {
        "id" : "3dd769b1-d323-40f6-b2ec-61e94e34a652",
        "parentId" : "ca69f8a4-ac20-4802-b398-609738e43ae3",
        "authorId" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "body" : "will look into this in a separate PR",
        "createdAt" : "2017-11-21T15:42:29Z",
        "updatedAt" : "2017-11-22T11:48:39Z",
        "lastEditedBy" : "cf088828-7f69-4b6e-8956-1842c94daa02",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f7a1983eff67e950ffb457d46d4c84887120876",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +549,553 @@\n\t// get the size value string, just between `size ` and ` MB in`, such as `size 1024 MB in 256 objects`\n\tsizeIndex := strings.Index(output, imageSizeStr)\n\tdivIndex := strings.Index(output, sizeDivStr)\n\tif sizeIndex == -1 || divIndex == -1 || divIndex <= sizeIndex+5 {"
  },
  {
    "id" : "6bbcbc62-fc4d-4eb2-91d9-d8f7a5384d28",
    "prId" : 52767,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/52767#pullrequestreview-78150817",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3e2f311-1472-444e-bc2c-aea87f799824",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "return an error instead? invalid resize",
        "createdAt" : "2017-11-21T15:25:08Z",
        "updatedAt" : "2017-11-22T11:48:39Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "ccc5baf2-cf5d-493a-9f9b-5ed2b89ca6f6",
        "parentId" : "a3e2f311-1472-444e-bc2c-aea87f799824",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "No, we want this function to be idempotent. If current disk size already satisfies user requested size then resize should be NOOP and success should be returned. ",
        "createdAt" : "2017-11-21T15:29:16Z",
        "updatedAt" : "2017-11-22T11:48:39Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f7a1983eff67e950ffb457d46d4c84887120876",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +462,466 @@\t}\n\tif curSize >= sz {\n\t\treturn newSizeQuant, nil\n\t}\n"
  },
  {
    "id" : "241c0d62-4ef0-4e07-b7c8-9d2c707195b0",
    "prId" : 46016,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46016#pullrequestreview-39289894",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1f880c6-d601-4f85-a530-7f8ca5677637",
        "parentId" : null,
        "authorId" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "body" : "Instead, can you check if the module is already loaded?  Then return an error if it isn't loaded, and ignore this error if it is loaded already.",
        "createdAt" : "2017-05-19T17:35:13Z",
        "updatedAt" : "2017-05-19T17:35:14Z",
        "lastEditedBy" : "209ee091-cf29-4efa-8a1b-a98334ea3f9a",
        "tags" : [
        ]
      },
      {
        "id" : "e643cf24-6b4a-4a63-8959-46484dcdb0f3",
        "parentId" : "c1f880c6-d601-4f85-a530-7f8ca5677637",
        "authorId" : "89888ad4-0dac-48c1-b890-5f4449a2de2b",
        "body" : "The issue with checking is that if Kubelet runs as a self-hosted or in a container, it wouldnt be able to do any modprobe operation. Ideally, this plugin should not be responsible for loading the kernel module. This is usually a one-time operation and done by the admin that setups the hosts. Even If the module is not loaded, we will get an error just a few lines after when it tries to attach the volume.",
        "createdAt" : "2017-05-19T20:14:42Z",
        "updatedAt" : "2017-05-19T20:14:42Z",
        "lastEditedBy" : "89888ad4-0dac-48c1-b890-5f4449a2de2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab77633c95dc620d100d1266d9510dfddafe9a8e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +265,269 @@\t\t_, err = b.plugin.execCommand(\"modprobe\", []string{\"rbd\"})\n\t\tif err != nil {\n\t\t\tglog.Warningf(\"rbd: failed to load rbd kernel module:%v\", err)\n\t\t}\n"
  },
  {
    "id" : "a0c90aca-df14-42cf-9b4e-e0565223330b",
    "prId" : 31251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb4f2db8-65d9-4de8-a734-7f74701afd93",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "This expects that `/bin/rbd`  is installed on all masters. I am not against, however this should be documented somewhere. And in the long term, we should spawn a pod for this.\n",
        "createdAt" : "2016-08-24T12:32:59Z",
        "updatedAt" : "2016-08-25T19:32:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "81d95967-154a-4925-8906-d4b190e9322d",
        "parentId" : "bb4f2db8-65d9-4de8-a734-7f74701afd93",
        "authorId" : "3553e8c4-7450-4274-b7f8-6dc02f45e043",
        "body" : "I can add this to the docs.\n",
        "createdAt" : "2016-08-24T17:08:34Z",
        "updatedAt" : "2016-08-25T19:32:33Z",
        "lastEditedBy" : "3553e8c4-7450-4274-b7f8-6dc02f45e043",
        "tags" : [
        ]
      }
    ],
    "commit" : "0c3b2f44a47836501957c19643ec5850cc04b348",
    "line" : null,
    "diffHunk" : "@@ -1,1 +328,332 @@\t\tglog.V(4).Infof(\"rbd: create %s size %s using mon %s, pool %s id %s key %s\", p.rbdMounter.Image, volSz, mon, p.rbdMounter.Pool, p.rbdMounter.adminId, p.rbdMounter.adminSecret)\n\t\tvar output []byte\n\t\toutput, err = p.rbdMounter.plugin.execCommand(\"rbd\",\n\t\t\t[]string{\"create\", p.rbdMounter.Image, \"--size\", volSz, \"--pool\", p.rbdMounter.Pool, \"--id\", p.rbdMounter.adminId, \"-m\", mon, \"--key=\" + p.rbdMounter.adminSecret, \"--image-format\", \"1\"})\n\t\tif err == nil {"
  },
  {
    "id" : "bcf5870e-bbe1-421a-aa64-9e6649d1a4fa",
    "prId" : 31251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71f20290-88bb-443c-b708-4084bdafd811",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "This pattern is used several times, perhaps it would be better to use a separate function for looping over mons starting with a a random one\n\n```\nr.loopOverMonitors(p.rbdMounter.Mon, func(mon string) error {\n  output, err = p.plugin.execCommand(\"rbd\", ...)\n  if err == nil {\n    return nil\n  } else {\n  return fmt.Errorf(\"failed to delete rbd image, error %v ouput %v\", err, string(output))\n})\n```\n",
        "createdAt" : "2016-08-24T12:39:05Z",
        "updatedAt" : "2016-08-25T19:32:33Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "0c3b2f44a47836501957c19643ec5850cc04b348",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +364,368 @@\tstart := rand.Int() % l\n\t// iterate all monitors until rm succeeds.\n\tfor i := start; i < start+l; i++ {\n\t\tmon := p.rbdMounter.Mon[i%l]\n\t\tglog.V(4).Infof(\"rbd: rm %s using mon %s, pool %s id %s key %s\", p.rbdMounter.Image, mon, p.rbdMounter.Pool, p.rbdMounter.adminId, p.rbdMounter.adminSecret)"
  },
  {
    "id" : "2f13d879-51f9-48ef-9c3f-ba016a006a69",
    "prId" : 10563,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e092fdc3-7e37-4ed7-8f24-1389acf081c8",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "won't this write to the RBD volume itself?  Shouldn't this be stored in host.GetPodPluginDir() instead (see secret for example)\n",
        "createdAt" : "2015-07-04T21:54:13Z",
        "updatedAt" : "2015-07-24T15:50:52Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "45a6ed24-50e6-4c83-af3c-89a76a8c1253",
        "parentId" : "e092fdc3-7e37-4ed7-8f24-1389acf081c8",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "json won't be written to rbd volume, because mount is called afer persist.\n\ncall it poor man's data protection. I don't want the json to be exposed (so it gets protected). Best way to do it, IMHO, is to make it invisible. So `persitRBD()` is called before `mount`, and thus the new mountpoint masks content in the local directory.\n",
        "createdAt" : "2015-07-06T13:14:20Z",
        "updatedAt" : "2015-07-24T15:50:52Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "8b64bb2e-a0a0-442a-82c8-da89c81172ec",
        "parentId" : "e092fdc3-7e37-4ed7-8f24-1389acf081c8",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "added comments about this behavior.\n",
        "createdAt" : "2015-07-06T13:45:10Z",
        "updatedAt" : "2015-07-24T15:50:52Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa8a2ef81ddccfb6e8ba9a80d6568634ed20c202",
    "line" : 89,
    "diffHunk" : "@@ -1,1 +129,133 @@\nfunc (util *RBDUtil) persistRBD(rbd rbd, mnt string) error {\n\tfile := path.Join(mnt, \"rbd.json\")\n\tfp, err := os.Create(file)\n\tif err != nil {"
  },
  {
    "id" : "815f0c43-f8c0-4a63-977a-87ef8efe4e1d",
    "prId" : 9957,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e53a9b1c-6681-4926-ba54-ac97e812d330",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I would add a note saying that the mountpoint not existing is a contingency.\n\nDo you want this method to continue running if there's already a mountpoint for this volume?\n",
        "createdAt" : "2015-06-17T18:57:50Z",
        "updatedAt" : "2015-06-17T19:25:24Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "21c66299-0fcd-4552-8c41-bc6ab427fb8c",
        "parentId" : "e53a9b1c-6681-4926-ba54-ac97e812d330",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "yes, if directory is not there, that indicates it is the first time to create then mountpoint. the method should continue to run. the mountpoint is later created.\n",
        "createdAt" : "2015-06-17T19:10:36Z",
        "updatedAt" : "2015-06-17T19:25:24Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "e14c28bc-0370-4af1-9a53-2955b428473e",
        "parentId" : "e53a9b1c-6681-4926-ba54-ac97e812d330",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "K, then I would add a comment there to that effect.\n",
        "createdAt" : "2015-06-17T19:18:10Z",
        "updatedAt" : "2015-06-17T19:25:24Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "0280dac6b1ad735690144717cf81568392e8a526",
    "line" : null,
    "diffHunk" : "@@ -1,1 +103,107 @@\tmountpoint, err := rbd.mounter.IsMountPoint(globalPDPath)\n\t// in the first time, the path shouldn't exist and IsMountPoint is expected to get NotExist\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"rbd: %s failed to check mountpoint\", globalPDPath)\n\t}"
  },
  {
    "id" : "30af6300-0ebf-4ff5-be3d-27b124925c9f",
    "prId" : 6578,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "18947d04-3304-4f66-bb0d-688d02d3b28e",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "nit: Can you add a file level comment that describes the logic in this file? The same would be useful for the disk_manager.go as well.\n",
        "createdAt" : "2015-04-09T18:53:05Z",
        "updatedAt" : "2015-05-21T18:51:35Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "9cb4b00a-111e-491d-994d-58fcbd130ae5",
        "parentId" : "18947d04-3304-4f66-bb0d-688d02d3b28e",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "fixed\n",
        "createdAt" : "2015-04-13T16:39:54Z",
        "updatedAt" : "2015-05-21T18:51:35Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a800fd10ea2eb1bd2f424994c6d33b5716940d0",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +35,39 @@\t\"github.com/golang/glog\"\n)\n\n// stat a path, if not exists, retry maxRetries times\nfunc waitForPathToExist(devicePath string, maxRetries int) bool {"
  },
  {
    "id" : "5c0dfda9-7380-4aa8-8719-c92fbbd8bb07",
    "prId" : 6578,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a2b0034-1edf-465a-a987-b65010c354a8",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This error should be checked and logged, or returned.  It is not checked elsewhere later in the code.  Why would the mount check fail, and is it ignorable?  If it's ignorable, make the variable '_' to indicate it is ignored and add a comment\n",
        "createdAt" : "2015-05-21T00:23:35Z",
        "updatedAt" : "2015-05-21T18:51:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "78a0d237-aa85-44c4-aed4-42578b0773e0",
        "parentId" : "5a2b0034-1edf-465a-a987-b65010c354a8",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "error check added\n",
        "createdAt" : "2015-05-21T14:28:36Z",
        "updatedAt" : "2015-05-21T18:51:35Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a800fd10ea2eb1bd2f424994c6d33b5716940d0",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +101,105 @@\t// mount it\n\tglobalPDPath := rbd.manager.MakeGlobalPDName(rbd)\n\tmountpoint, err := rbd.mounter.IsMountPoint(globalPDPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"rbd: %s failed to check mountpoint\", globalPDPath)"
  }
]
[
  {
    "id" : "e4574d46-c20f-4633-b9df-f0446e16da77",
    "prId" : 25912,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6575c00-3681-4d17-acb6-9aaec65c46d8",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "I'd recommend leaving a comment on why we compress the username\n",
        "createdAt" : "2016-05-19T22:26:00Z",
        "updatedAt" : "2016-05-19T23:04:33Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "08ff964a-1474-487e-818b-f5a043359efe",
        "parentId" : "b6575c00-3681-4d17-acb6-9aaec65c46d8",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Done.\n",
        "createdAt" : "2016-05-19T23:05:41Z",
        "updatedAt" : "2016-05-19T23:05:41Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      }
    ],
    "commit" : "0124e234500c799b0f0a21bae18d3c921a2752b7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +91,95 @@// authorized_user_requests metric, and to avoid pushing actual usernames in the\n// metric.\nfunc compressUsername(username string) string {\n\tswitch {\n\t// Known internal identities."
  },
  {
    "id" : "ffac9962-de35-437c-b310-0ed228e44e9b",
    "prId" : 25912,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1c70548-ccf0-42a0-9bd5-1c02825971da",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "a hardcoded list of a few usernames seems suspect\n",
        "createdAt" : "2016-05-22T13:49:09Z",
        "updatedAt" : "2016-05-22T13:49:09Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "ea2914e0-9cab-43ff-9f9e-bf8442f7c30d",
        "parentId" : "b1c70548-ccf0-42a0-9bd5-1c02825971da",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Agree it's hacky. I just needed a metric that differentiated between requests from some internal identities vs. end-user identities. I don't want to expose real usernames on the `/metrics` endpoint, but I do want to see how often the `admin`/`client` users are being used compared to real users. Are you thinking this would be useful in a more generic way? \n",
        "createdAt" : "2016-05-22T16:48:34Z",
        "updatedAt" : "2016-05-22T16:48:34Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "60ef0b6f-fdb4-4c1d-8cce-7f28ee7622ea",
        "parentId" : "b1c70548-ccf0-42a0-9bd5-1c02825971da",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I think there's enough variety in kube deployments that that list of \"internal\" usernames is of questionable use\n",
        "createdAt" : "2016-05-22T16:54:30Z",
        "updatedAt" : "2016-05-22T16:54:30Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "fdab2d5f-6a2d-43f5-8d42-190a4b7e9ea8",
        "parentId" : "b1c70548-ccf0-42a0-9bd5-1c02825971da",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Yeah I could plumb flags through with a list of \"metric-tracked identities\". It felt like overkill, but if you guys want to make use of this metric, and if we want it to be more generally useful, I can make that happen.\n",
        "createdAt" : "2016-05-22T17:07:08Z",
        "updatedAt" : "2016-05-22T17:07:08Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      }
    ],
    "commit" : "0124e234500c799b0f0a21bae18d3c921a2752b7",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +98,102 @@\t\tusername == \"kube_proxy\" ||\n\t\tusername == \"kubelet\" ||\n\t\tusername == \"system:serviceaccount:kube-system:default\":\n\t\treturn username\n\t// Probably an email address."
  },
  {
    "id" : "32653842-adb6-423b-9b4a-8fbee1360285",
    "prId" : 1529,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "debbafe9-42e5-4c08-8e2b-14e089ad9c25",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Do you forsee a pattern of chaining together handlers that follow this format:\n`func DoStepN(context Request, doer StepNDoer, failed http.Handler, handler http.Hander)`\nfor steps like authentication, authorization, quota checking, REST object read/write, field projection, response compression?\n\nIf so, I think I like it.\n",
        "createdAt" : "2014-10-03T19:31:06Z",
        "updatedAt" : "2014-10-07T17:25:43Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8ef4b8230a14fd2ded7263ceb25396bedb6d36b",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +35,39 @@// stores any such user found onto the provided context for the request. If authentication fails or returns an error\n// the failed handler is used. On success, handler is invoked to serve the request.\nfunc NewRequestAuthenticator(context RequestContext, auth authenticator.Request, failed http.Handler, handler http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n\t\tuser, ok, err := auth.AuthenticateRequest(req)"
  }
]
[
  {
    "id" : "4480162d-d42b-4991-b71e-f48eaa8895b6",
    "prId" : 2437,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I don't think it is necessary to introduce a Builder type.  \nYou can do this in an interactive client:\n\n```\napiClient, err := clientcmd.NewFromPersistentFlags(cmds.PersistentFlags())\nif os.IsNotExist(err) {\n    apiClient, err := clientcmd.NewFromPrompt(cmds.PersistentFlags())\n}\nif err {\n  fmt.Println(\"Could not make a client\", err)\n}\n```\n\nFor the case of a non-interactive client things simplify to:\n\n```\napiClient, err := clientcmd.New()\nif err {\n  fmt.Println(\"Could not make a client\", err)\n}\n```\n\nThis makes non-interactive client code more concise, and I expect there will be more non-interactive clients than interactive ones.\nEven for interactive clients, I find it preferable, in terms of readability, to get forego introducing a new type and gain a few more lines of error handling (which will be familiar to any go programmer.)\n",
        "createdAt" : "2014-11-24T21:18:17Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "68f6055b-428d-4afa-8dc9-7aae845faf0e",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "One of the issues today is keeping the flag names consistent across multiple different commands.   That means that a BindFlags method is still required (or at least a call to create the flags).  So we're looking having two calls no matter what we do.\n\nBy having an object holding that state information (the builder), we avoid having two discrete calls\n    clientcmd.BindFlags(cmd.PersistentFlags())\n    clientcmd.Client(cmd.PersistentFlags))\nthat rely upon having two different methods being called with matching arguments.  This is especially useful when you look at the common kubernetes usage that has methods trying to build clients relatively removed from the the point where the flags are bound.\n",
        "createdAt" : "2014-11-24T21:31:36Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "fd300f32-a480-4a6c-af9d-084c09c2d67b",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Also we may be instantiating multiple clients - the kubectl use needs that (so you map restclients across multiple component plugins).  Builder just happened to be a convenient holder for that.  Having a simpler path for single client types isn't bad, and seems like that could be a simple static call.\n\n> On Nov 24, 2014, at 3:31 PM, David Eads notifications@github.com wrote:\n> \n> In pkg/client/clientcmd/doc.go:\n> \n> > +You may obtain a copy of the License at\n> > +\n> > -    http://www.apache.org/licenses/LICENSE-2.0\n> >   +\n> >   +Unless required by applicable law or agreed to in writing, software\n> >   +distributed under the License is distributed on an \"AS IS\" BASIS,\n> >   +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n> >   +See the License for the specific language governing permissions and\n> >   +limitations under the License.\n> >   +_/\n> >   +\n> >   +/_\n> >   +Package cmd provides one stop shopping for a command line executable to bind the correct flags,\n> >   +build the client config, and create a working client. The code for usage looks like this:\n> >   +\n> > -    clientBuilder := clientcmd.NewBuilder(clientcmd.NewDefaultAuthLoader())\n> >   One of the issues today is keeping the flag names consistent across multiple different commands. That means that a BindFlags method is still required (or at least a call to create the flags). So we're looking having two calls no matter what we do.\n> \n> By having an object holding that state information (the builder), we avoid having two discrete calls\n> clientcmd.BindFlags(cmd.PersistentFlags())\n> clientcmd.Client(cmd.PersistentFlags))\n> that rely upon having two different methods being called with matching arguments. This is especially useful when you look at the common kubernetes usage that has methods trying to build clients relatively removed from the the point where the flags are bound.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-11-24T21:42:00Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "59b1c087-1c97-4901-b76d-9431f5fc268c",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I'm skeptical that clients other than kubectl (non-interactive ones) will want to use persistent flags.  And, in the case of kubectl, the two lines in question are right next to each other.\n",
        "createdAt" : "2014-11-25T19:50:15Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "f9f70356-8a31-4401-8c7f-7dad2d82cc4d",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Call site for binding seems like it could be in many places (usually in init, while client is going to be in main), and persistent flags and other flags are both FlagSet.\n",
        "createdAt" : "2014-11-25T20:20:47Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "91c95714-eec7-49a1-9b44-9b498a0e4e7b",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Did you just want a more realistic example?\n",
        "createdAt" : "2014-11-25T22:32:46Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "8fed90d3-8fcf-4fa5-ad6b-a5bd862a6493",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Builder feels to me like using a pattern for the sake of using patterns. \n",
        "createdAt" : "2014-11-26T01:18:53Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "38bda9fb-235e-45e1-8cfc-1ec47b4bb0a8",
        "parentId" : "8df9a605-aea6-4dfc-b1d7-73afb2958a9a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Hrm.  Usually you create an object and then bind its params with *VarP, and then use the object you bound to get a client.  So it feels patterny, but that because it's a pattern :)\n\nYou have to bind before you can create a client, and you can't read the values you bound until after flags are parsed.  The example doesn't show that and it should.  So it's always a two step process.\n\n> On Nov 25, 2014, at 7:19 PM, Eric Tune notifications@github.com wrote:\n> \n> In pkg/client/clientcmd/doc.go:\n> \n> > +You may obtain a copy of the License at\n> > +\n> > -    http://www.apache.org/licenses/LICENSE-2.0\n> >   +\n> >   +Unless required by applicable law or agreed to in writing, software\n> >   +distributed under the License is distributed on an \"AS IS\" BASIS,\n> >   +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n> >   +See the License for the specific language governing permissions and\n> >   +limitations under the License.\n> >   +_/\n> >   +\n> >   +/_\n> >   +Package cmd provides one stop shopping for a command line executable to bind the correct flags,\n> >   +build the client config, and create a working client. The code for usage looks like this:\n> >   +\n> > -    clientBuilder := clientcmd.NewBuilder(clientcmd.NewDefaultAuthLoader())\n> >   Builder feels to me like using a pattern for the sake of using patterns.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-11-26T01:34:35Z",
        "updatedAt" : "2014-11-26T14:46:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dbfb803497017b074422886dbb6bcb02af9e9e9",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +19,23 @@build the client config, and create a working client. The code for usage looks like this:\n\n    clientBuilder := clientcmd.NewBuilder(clientcmd.NewDefaultAuthLoader())\n    clientBuilder.BindFlags(cmds.PersistentFlags())\n    apiClient, err := clientBuilder.Client()"
  }
]
[
  {
    "id" : "d217f24e-957f-4900-b5e3-2b1415ac54c3",
    "prId" : 32125,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Could we pass \"sync bool\" to queueActionLocked()?\n",
        "createdAt" : "2016-09-06T14:12:41Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f470858f-6935-4f26-bfd3-42c826817282",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Ideally, I think that we should introduce a new type of event \"Replace\" (next to Added, Updated, Deleted and Sync), but maybe not in 1.4 timeframe?\n\nWDYT?\n",
        "createdAt" : "2016-09-06T14:16:38Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "6b066b2d-f0df-4988-8a36-46c43baed061",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Hrm - isn't replace Sync?\n",
        "createdAt" : "2016-09-06T14:30:27Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "3016b437-62fd-497f-a1cb-3b549c4645aa",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "It is treated as Sync now. But those two are different in fact:\n- Sync is supposed to be purely \"process my with whatever value I have now\"\n- Replace is \"replace me with that value no matter what value I had before\"\n\nConceptually they are different, but in the code they are treated the same way.\n",
        "createdAt" : "2016-09-06T14:35:26Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "bfefc62d-cfc1-49ba-ac6d-5da381c54fa5",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm worried about all the places that will now get a new event type that didn't before.\n",
        "createdAt" : "2016-09-06T15:49:55Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e6f045d2-05b3-445c-bd21-936950580cf5",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I think there is only one such place (except from DeltaFIFO). But that's the main reason why I don't want to change it for 1.4.\n",
        "createdAt" : "2016-09-06T15:59:14Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "71c3e851-5920-4bd9-847c-487313a3d186",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "\"replace\" should not be a new event type, just compute the corresponding add/update/delete object.\n",
        "createdAt" : "2016-09-06T18:41:04Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f59f5695-dfd5-48f9-b998-62c309714946",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I don't understand your comment. Basically we are calling Replace e.g. when we are doing \"relist\", if we are not able to get all the deltas from in-between. This is effectively an \"update\", but this is handled in the code as \"Sync\".\n",
        "createdAt" : "2016-09-06T18:45:14Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "ed05d549-1568-43d9-9b0f-6a14e329c738",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "That's probably wrong. If it changes a value \"sync\" is probably wrong. Scary to change, though.\n",
        "createdAt" : "2016-09-06T18:46:43Z",
        "updatedAt" : "2016-09-06T18:48:31Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "2ded407b-1451-40e8-9531-96634774f167",
        "parentId" : "d102f81f-4967-43bb-9ab6-0f6e16e89c90",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Yeah - we can try changing it in 1.5, but definitely not now.\n",
        "createdAt" : "2016-09-06T18:48:44Z",
        "updatedAt" : "2016-09-06T18:48:44Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0779df721a52b4187a2af896f4faf058168d17a",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +523,527 @@\t}\n\n\t// If we are doing Resync() and there is already an event queued for that object,\n\t// we ignore the Resync for it. This is to avoid the race, in which the resync\n\t// comes with the previous value of object (since queueing an event for the object"
  },
  {
    "id" : "8b5d153d-fc99-4b89-a5d6-2ac02fdcd39c",
    "prId" : 27435,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6c04da1-76a4-423c-af75-3730c8d43874",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This TODO is no longer true, right?\n",
        "createdAt" : "2016-06-15T17:45:13Z",
        "updatedAt" : "2016-06-15T17:45:13Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "ef3dec6b-6620-4d1d-9742-21eb03075d65",
        "parentId" : "c6c04da1-76a4-423c-af75-3730c8d43874",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I think so.\n",
        "createdAt" : "2016-06-15T17:47:39Z",
        "updatedAt" : "2016-06-15T17:47:39Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ccd42e923608481ed1977b0cb9282ccbf620ff17",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +200,204 @@\t\t\t// Presumably, this was deleted when a relist happened.\n\t\t\t// Don't provide a second report of the same deletion.\n\t\t\t// TODO(lavalamp): This may be racy-- we aren't properly locked\n\t\t\t// with knownObjects.\n\t\t\treturn nil"
  },
  {
    "id" : "bd212a0e-4659-4b74-be83-65e3b3dd3902",
    "prId" : 27435,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bbd1c67-b9d4-43d5-a214-a6a163bba128",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "This is clever. Thanks a bunch.\n",
        "createdAt" : "2016-06-15T18:01:20Z",
        "updatedAt" : "2016-06-15T18:01:20Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "ccd42e923608481ed1977b0cb9282ccbf620ff17",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +193,197 @@\t\t// We only want to skip the \"deletion\" action if the object doesn't\n\t\t// exist in knownObjects and it doesn't have corresponding item in items.\n\t\t// Note that even if there is a \"deletion\" action in items, we can ignore it,\n\t\t// because it will be deduped automatically in \"queueActionLocked\"\n\t\t_, exists, err := f.knownObjects.GetByKey(id)"
  },
  {
    "id" : "075729f3-8a98-4afc-bf31-f144bcadb276",
    "prId" : 24142,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e76daff-6f75-4e93-be12-4bf56d020c3f",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Actually, as @rrati observed offline, we should probably iterate over f.items instead.\nknownObjects seem to contain objects that were already removed, and for those we don't want to do resync.\n",
        "createdAt" : "2016-05-16T12:34:28Z",
        "updatedAt" : "2016-05-19T11:53:25Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "6a2789c0-b59b-46ab-b330-8dba6075f61b",
        "parentId" : "5e76daff-6f75-4e93-be12-4bf56d020c3f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Wait - what I wrote above probably also isn't correct.\n",
        "createdAt" : "2016-05-16T12:36:52Z",
        "updatedAt" : "2016-05-19T11:53:25Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "190adcae-5d31-4da9-a0b9-cf52eb857ee6",
        "parentId" : "5e76daff-6f75-4e93-be12-4bf56d020c3f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Actually, I was completely wrong here.\nI think it's enough to iterate over knownObjects.\n\nWe can ignore f.items, because those things are already queue for processing, so adding an \"artificial Sync\" event for them doesn't change anything, because those would be processed anyway.\n",
        "createdAt" : "2016-05-16T12:50:11Z",
        "updatedAt" : "2016-05-19T11:53:25Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "97368218-dea7-4216-bb91-419c028ce6be",
        "parentId" : "5e76daff-6f75-4e93-be12-4bf56d020c3f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "So what you have here is correct.\n",
        "createdAt" : "2016-05-16T12:50:23Z",
        "updatedAt" : "2016-05-19T11:53:25Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e388c137bba8d97be9607661b62d7cb1ec77c416",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +461,465 @@\tf.lock.RLock()\n\tdefer f.lock.RUnlock()\n\tfor _, k := range f.knownObjects.ListKeys() {\n\t\tobj, exists, err := f.knownObjects.GetByKey(k)\n\t\tif err != nil {"
  },
  {
    "id" : "859c1357-688d-44a4-a53f-1b020e7f5506",
    "prId" : 14881,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93badb04-33d8-4d3c-b2ee-6f831b18d37f",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I know its pre-existing, but can you add a comment indicating that this non-deterministic append (may or may not update `f.items[id]` is safe because access is locked and if `f.items[id]` is modified, it will be stomped before the function finishes.\n",
        "createdAt" : "2015-10-08T11:46:49Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "814ed9c9-49ca-4c91-bd0c-90b6383a4000",
        "parentId" : "93badb04-33d8-4d3c-b2ee-6f831b18d37f",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Sorry, I somehow totally missed this comment. But I don't understand what is non-deterministic about this. Getting a non-existing map element returns the zero value but it doesn't affect the map; see https://play.golang.org/p/0_tmN9pysk\n",
        "createdAt" : "2015-10-15T21:14:01Z",
        "updatedAt" : "2015-10-15T21:14:01Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "725d6ec3-975d-418e-9631-f305f01a041d",
        "parentId" : "93badb04-33d8-4d3c-b2ee-6f831b18d37f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "It might have had a value, that's why check here https://github.com/kubernetes/kubernetes/pull/14881/files#diff-b32f14c6f3cce65061c1673064448839R268 and stomp here https://github.com/kubernetes/kubernetes/pull/14881/files#diff-b32f14c6f3cce65061c1673064448839R273 .\n\nIf there was a slice in the map that had enough capacity, the `append` would modify the existing map and `newDeltas` and `f.items[id]` would both point it.\n\nIf there wasn't a slice in the map or there wasn't enough capacity, the `append` would try to `realloc` and would `newDeltas` and `f.items[id]` would point to different locations and have different content.\n",
        "createdAt" : "2015-10-16T11:49:43Z",
        "updatedAt" : "2015-10-16T11:49:43Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "86670f7c-458c-4eeb-a407-0741cfac8500",
        "parentId" : "93badb04-33d8-4d3c-b2ee-6f831b18d37f",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@deads2k That's not how append works-- it doesn't change the slice. It might change the memory the slice points to, but that's only important if someone else has a differently-sliced pointer to the same memory. Merely having a slice with enough capacity in the map is not enough to trigger a bug, because append doesn't change the slice that's stored in the map.\n\nCompare: https://play.golang.org/p/mWvfcMX3mM\nWith: https://play.golang.org/p/aI6OSdMtPd\n\nI don't have the bug the latter demonstrates for reasons beyond the scope of this one line-- we own the delta slice if it's in the map, we don't own it if it isn't. If I understand you correctly, though, your model of append would have printed out \"[hi mom] [hi mom]\", not \"[hi] [hi mom]\" for the first line, which is not the case. Did I misunderstand you?\n",
        "createdAt" : "2015-10-16T19:20:36Z",
        "updatedAt" : "2015-10-16T19:20:36Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "575161e6-d14c-437e-8a4b-c90ab7682a7e",
        "parentId" : "93badb04-33d8-4d3c-b2ee-6f831b18d37f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> If I understand you correctly, though, your model of append would have printed out \"[hi mom] [hi mom]\", not \"[hi] [hi mom]\" for the first line, which is not the case. Did I misunderstand you?\n\nNo.  I stand corrected.\n",
        "createdAt" : "2015-10-16T19:50:42Z",
        "updatedAt" : "2015-10-16T19:50:42Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "57c6dd93ea714154cc3fd39b457f23298ca98402",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +260,264 @@\t\treturn KeyError{obj, err}\n\t}\n\tnewDeltas := append(f.items[id], Delta{actionType, obj})\n\tnewDeltas = dedupDeltas(newDeltas)\n\tif f.deltaCompressor != nil {"
  },
  {
    "id" : "3a666660-501e-4498-9443-8d5c81a2bcc4",
    "prId" : 14881,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4415328-2594-4117-9f52-c588c9e0ebd9",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Does go handle the `Lock()`, `Lock()`, `Unlock()`, `Unlock()` sequence how I'd want it to?  If so, trust of this function would be enhanced by locking and unlocking itself.  This being my first time in the code, I felt the need to chase it and make sure it was being used how I thought it was being used.\n",
        "createdAt" : "2015-10-08T11:54:24Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "0982cbc8-cb13-4382-9937-4e84b2c6b36b",
        "parentId" : "b4415328-2594-4117-9f52-c588c9e0ebd9",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "No-- go mutexes are not re-entrant. The \"locked\" suffix on the name means that it shouldn't be called unless it's already locked. I added a comment.\n",
        "createdAt" : "2015-10-14T23:09:56Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "57c6dd93ea714154cc3fd39b457f23298ca98402",
    "line" : null,
    "diffHunk" : "@@ -1,1 +255,259 @@// queueActionLocked appends to the delta list for the object, calling\n// f.deltaCompressor if needed. Caller must lock first.\nfunc (f *DeltaFIFO) queueActionLocked(actionType DeltaType, obj interface{}) error {\n\tid, err := f.KeyOf(obj)\n\tif err != nil {"
  },
  {
    "id" : "798acd4e-65ee-4b6d-bba7-9f045527cd3a",
    "prId" : 14881,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b2afe10-6f25-4355-8187-63ba0c58f46d",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I don't know, but function godoc should indicate that its only catching the deletion dupes.\n",
        "createdAt" : "2015-10-08T11:55:46Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "57c6dd93ea714154cc3fd39b457f23298ca98402",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +237,241 @@\t\treturn out\n\t}\n\t// TODO: Detect other duplicate situations? Are there any?\n\treturn nil\n}"
  },
  {
    "id" : "04e5c2ac-6a68-4991-83fb-ee662e287034",
    "prId" : 14881,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "370fd147-ac82-4ad1-b472-24f764827f3f",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "No load factor?  I haven't sized maps in go, but this reads a little weird.\n",
        "createdAt" : "2015-10-08T12:05:33Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "44fa1396-6e15-43aa-a379-a960127b41db",
        "parentId" : "370fd147-ac82-4ad1-b472-24f764827f3f",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "https://golang.org/pkg/builtin/#make\n\n_shrug_\n",
        "createdAt" : "2015-10-14T23:15:07Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "57c6dd93ea714154cc3fd39b457f23298ca98402",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +373,377 @@\tf.lock.Lock()\n\tdefer f.lock.Unlock()\n\tkeys := make(sets.String, len(list))\n\tfor _, item := range list {\n\t\tkey, err := f.KeyOf(item)"
  },
  {
    "id" : "d4a6a7f5-fae1-471e-b329-4d852228da39",
    "prId" : 14881,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1754bb4-14f4-4dbd-8e21-3088776bc866",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Oh my.  I see it now and it scares me.  The behavior we observe will be influenced by the order of notification/updates from distinct `Stores` in distinct goroutines with distinct `ListerWatchers`?  That's what it looks like to me.  It seems like it would be unreliable.\n",
        "createdAt" : "2015-10-08T12:25:59Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "5e46d11e-1a87-411f-ad7d-f8359be3bfd4",
        "parentId" : "c1754bb4-14f4-4dbd-8e21-3088776bc866",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I've haven't been able to repro it in a test, and this PR is a strict improvement, in that fewer races are possible.\n",
        "createdAt" : "2015-10-14T23:18:28Z",
        "updatedAt" : "2015-10-14T23:19:13Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "57c6dd93ea714154cc3fd39b457f23298ca98402",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +405,409 @@\t// TODO(lavalamp): This may be racy-- we aren't properly locked\n\t// with knownObjects. Unproven.\n\tknownKeys := f.knownObjects.ListKeys()\n\tfor _, k := range knownKeys {\n\t\tif keys.Has(k) {"
  },
  {
    "id" : "035e768f-f13e-4c57-8543-200595de6a94",
    "prId" : 8822,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3277fb36-96d6-4e4d-995a-059bd800d617",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Thanks, this is what I was looking for.\n",
        "createdAt" : "2015-05-27T22:44:27Z",
        "updatedAt" : "2015-05-27T23:46:04Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fa66bd962c694f286e349e2f6618dd64fe330b9",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +345,349 @@\t\t}\n\t\tvar deletedObj interface{}\n\t\tif keyGetter, ok := f.knownObjectKeys.(KeyGetter); ok {\n\t\t\tvar exists bool\n\t\t\tvar err error"
  },
  {
    "id" : "9da5dd66-894c-495c-b45e-e138a3f934ec",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea0080a4-2353-4f07-aea4-688c50de95f5",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "perhaps a type switch here instead of two casts + check?\n",
        "createdAt" : "2015-03-17T14:55:13Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "80a2620a-3a4e-4d42-808b-41630cb7c11a",
        "parentId" : "ea0080a4-2353-4f07-aea4-688c50de95f5",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "nope-- has to be done serially because the deletion marker would be stored as a delta...\n",
        "createdAt" : "2015-03-26T22:12:12Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +119,123 @@// DeletedFinalStateUnknown objects.\nfunc (f *DeltaFIFO) KeyOf(obj interface{}) (string, error) {\n\tif d, ok := obj.(Deltas); ok {\n\t\tif len(d) == 0 {\n\t\t\treturn \"\", KeyError{obj, ErrZeroLengthDeltasObject}"
  },
  {
    "id" : "cbab4c04-385d-45c3-bb9c-c88a3235bd19",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "faee68ac-377c-40ed-b1d9-cc2a6759ae00",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Comment on thread safety?  (\"The slice is clean, but the contained interfaces are references\")\n",
        "createdAt" : "2015-03-17T15:01:25Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : 215,
    "diffHunk" : "@@ -1,1 +213,217 @@\n// List returns a list of all the items; it returns the object\n// from the most recent Delta.\n// You should treat the items returned inside the deltas as immutable.\nfunc (f *DeltaFIFO) List() []interface{} {"
  },
  {
    "id" : "4440dfaa-2cec-449a-b982-f6497df64c64",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "637afcbe-d723-4af1-8018-eefa2b9915f7",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "I'm not sure that this comment is correct, since the empty list is the correct list for a missing item, and you are setting exists no matter what.\n",
        "createdAt" : "2015-03-17T17:20:03Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "c1f10a2c-3c13-4225-8b44-e44a48043469",
        "parentId" : "637afcbe-d723-4af1-8018-eefa2b9915f7",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "'or' is inclusive, so this is technically correct... the best kind of correct. However, I'll change it.\n",
        "createdAt" : "2015-03-26T21:52:42Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : 253,
    "diffHunk" : "@@ -1,1 +251,255 @@}\n\n// GetByKey returns the complete list of deltas for the requested item,\n// setting exists=false if that list is empty.\n// You should treat the items returned inside the deltas as immutable."
  },
  {
    "id" : "3ab3d1d8-b738-4f3b-8f6e-11376ddfefa2",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8705763-93be-4eb7-8123-3dcacd3a3454",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "now that I think about it, I'm not sure what this interface buys you over the func typedef.  I'd delete this interface.\n",
        "createdAt" : "2015-03-17T22:30:23Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "dfee4b83-db1d-4afd-8e3c-fa7c4a174567",
        "parentId" : "c8705763-93be-4eb7-8123-3dcacd3a3454",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "It lets you skip a helper function if you have an object that already has the right method; also it's self-documenting that your object Foo implements Xer with the DoX() method. It's the pattern the standard library uses.\n",
        "createdAt" : "2015-03-18T22:05:14Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "bdb56394-d08c-4916-a80f-d8ddcf655581",
        "parentId" : "c8705763-93be-4eb7-8123-3dcacd3a3454",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "But with the function typedef you can just pass foo.Function instead of passing the full foo, I think that is actually much clearer.  There's no interface that your object implements.  It just has a function that implements that interface.\n",
        "createdAt" : "2015-03-23T21:12:05Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "d0dc5b01-0dec-46a0-9c34-1e148dde1ccf",
        "parentId" : "c8705763-93be-4eb7-8123-3dcacd3a3454",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I maintain that this code is consistent with http://golang.org/pkg/net/http/#Handler, and I provide the function adapter below, so it's easy enough to use however is necessary. On a scale of 1 - 10, my preference for leaving this is about a 7.\n",
        "createdAt" : "2015-03-26T21:41:42Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : 358,
    "diffHunk" : "@@ -1,1 +356,360 @@\n// DeltaCompressor is an algorithm that removes redundant changes.\ntype DeltaCompressor interface {\n\tCompress(Deltas) Deltas\n}"
  },
  {
    "id" : "a9907432-17ce-431f-9db8-db7f0a542d4e",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71f42388-204c-45a1-afb8-3387e88b8dd8",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "This is sketchy in the context of slice growth/change.  We should at least annotate the thread semantics, and consider making the slice be of `*Deltas` instead of `Deltas`\n",
        "createdAt" : "2015-03-17T22:32:44Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "9bf9d521-18b1-4e21-8068-74700ec9d4d4",
        "parentId" : "71f42388-204c-45a1-afb8-3387e88b8dd8",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Pop() removes from the queue, so there's only ever one owner. Arguably Get()/List() is problematic.\n",
        "createdAt" : "2015-03-18T21:53:25Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : 406,
    "diffHunk" : "@@ -1,1 +404,408 @@func (d Deltas) Oldest() *Delta {\n\tif len(d) > 0 {\n\t\treturn &d[0]\n\t}\n\treturn nil"
  },
  {
    "id" : "4546a9bb-9501-4df0-9201-ab5426dd7bb7",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e751c97e-9c8a-49b0-908e-78c9953fdd82",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "here too.\n",
        "createdAt" : "2015-03-17T22:33:31Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : 415,
    "diffHunk" : "@@ -1,1 +413,417 @@func (d Deltas) Newest() *Delta {\n\tif n := len(d); n > 0 {\n\t\treturn &d[n-1]\n\t}\n\treturn nil"
  },
  {
    "id" : "b4991a38-b8cf-4d3b-92cd-dfb6212f5a92",
    "prId" : 5473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a77fa85b-a90a-45b5-b8eb-71b0df9d41d0",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "More documentation of the model and intended usage is necessary.\n",
        "createdAt" : "2015-03-19T03:58:17Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "b8038f52-a760-4762-b75f-888a2d625c06",
        "parentId" : "a77fa85b-a90a-45b5-b8eb-71b0df9d41d0",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "This is basically a producer-consumer workqueue implementation?\n",
        "createdAt" : "2015-03-19T04:04:48Z",
        "updatedAt" : "2015-03-31T17:25:34Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "68287713a0b56e95ab5684cf600ca4fa0fd7f216",
    "line" : null,
    "diffHunk" : "@@ -1,1 +62,66 @@// the Pop() method.\n//\n// DeltaFIFO solves this use case:\n//  * You want to process every object change (delta) at most once.\n//  * When you process an object, you want to see everything"
  }
]
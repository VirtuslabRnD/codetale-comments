[
  {
    "id" : "a5bd78f0-6b25-4a03-bc54-8af440776eaf",
    "prId" : 34740,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34740#pullrequestreview-5086772",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9695f28-3e69-460d-9187-acd6e9548c01",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "@ncdc when you write the generator, I'd like it to make things like this.\n",
        "createdAt" : "2016-10-20T14:54:12Z",
        "updatedAt" : "2016-10-20T14:54:12Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "39da9d19f0d36aece5055ffbddfcf8b9f8e424d6",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +455,459 @@\n// StorageClassLister knows how to list storage classes\ntype StorageClassLister interface {\n\tList(selector labels.Selector) (ret []*storage.StorageClass, err error)\n\tGet(name string) (*storage.StorageClass, error)"
  },
  {
    "id" : "6f61ea8a-1cd0-4f52-a15b-d3384d680dc4",
    "prId" : 32888,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32888#pullrequestreview-423843",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c172a7f-c96c-42d6-b9b0-55b772a93d5c",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Godoc\n",
        "createdAt" : "2016-09-16T20:37:10Z",
        "updatedAt" : "2016-09-20T12:25:11Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "16fbb47189a2f957178d1971b88a071807289db0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +34,38 @@\n// AppendFunc is used to add a matching item to whatever list the caller is using\ntype AppendFunc func(interface{})\n\nfunc ListAll(store Store, selector labels.Selector, appendFn AppendFunc) error {"
  },
  {
    "id" : "9f4f5e1d-baa5-43c6-b6a9-ad624c956375",
    "prId" : 30730,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e4ad1f4-9874-48fb-a3f3-9dfb0d61e7c4",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Can somebody else from @kubernetes/deployment also vet this? The relationship between replica sets and pods regarding selectors is obvious. What the relationship between 1) deployments and replica sets and subsequently 2) deployments and pods should really be? Up to this point, in order to determine that a pod belonged to a deployment, we listed all replica sets that manage the pod and then listed all deployments with selectors that match the **replica set labels**. So there is no guarantee that the deployment selector will match the pods matched by the matching replicas sets? Is the deployment selector destined to select amongst replica sets or should its selector be a part of hierarchy ie. it should be able to match all pods from all replica sets and replica set selectors should inherit and add on top the unique label?\n",
        "createdAt" : "2016-08-22T08:22:38Z",
        "updatedAt" : "2016-08-23T21:33:47Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "c5cef18735c96eb2dda98609cafd96a505958f78",
    "line" : null,
    "diffHunk" : "@@ -1,1 +400,404 @@\t\t}\n\t\t// If a deployment with a nil or empty selector creeps in, it should match nothing, not everything.\n\t\tif selector.Empty() || !selector.Matches(labels.Set(pod.Labels)) {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "6f0c5665-9441-4bb5-82ed-c382d37de922",
    "prId" : 30730,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4635985d-7eec-4ea2-86e7-ac930c01a310",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "I guess this is ok for now and more correct than previously since our utilities work in the same way but ultimately this can get out of hand especially with brave users. How about a follow-up issue to determine if we can maintain the deployment selector in its replica set labels even after users try to remove such a label?\n",
        "createdAt" : "2016-08-23T10:50:11Z",
        "updatedAt" : "2016-08-23T21:33:47Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "9e3c8d53-11a5-403d-9a6b-e9da5615b676",
        "parentId" : "4635985d-7eec-4ea2-86e7-ac930c01a310",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Sounds good \n",
        "createdAt" : "2016-08-23T18:34:47Z",
        "updatedAt" : "2016-08-23T21:33:47Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "c5cef18735c96eb2dda98609cafd96a505958f78",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +325,329 @@\t\t}\n\t\t// If a deployment with a nil or empty selector creeps in, it should match nothing, not everything.\n\t\tif selector.Empty() || !selector.Matches(labels.Set(rs.Labels)) {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "29309b89-16cf-49dd-bda4-e5f4bda4c8b1",
    "prId" : 28781,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7f1988d-3ccf-43f5-b1f2-0038daa6e708",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "@lavalamp @davidopp \n\nThis is the main change in this PR (most of other change are test fixes and stuff like that).\n\nThis has significant performance impact on scheduler, but before I finish fixing tests, I would like to get your opinion on it.\n\nIn particular, I think that:\n- ideally api.XxxList should all be []*api.Xxx instead of []api.Xxx (e.g. api.NodeList should be []*api.Node instead of []api.Node (plus all the metadata that we currently have))\n- however, since this seems to be backward-incompatible change, we may consider changing all listers here to api like I'm changing it here.\n\nThoughts?\n",
        "createdAt" : "2016-07-11T17:34:40Z",
        "updatedAt" : "2016-07-12T08:15:16Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "0999c595-bea2-44c3-a828-8ca50b3b282a",
        "parentId" : "c7f1988d-3ccf-43f5-b1f2-0038daa6e708",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think I'm OK with this. It was originally this way to try and match the client interface but I think it's already diverged, so I'd say go for it.\n",
        "createdAt" : "2016-07-11T18:55:53Z",
        "updatedAt" : "2016-07-11T19:02:47Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "6388d12a-1851-4e66-9d97-84a30fc2941b",
        "parentId" : "c7f1988d-3ccf-43f5-b1f2-0038daa6e708",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Thanks Daniel!\n",
        "createdAt" : "2016-07-11T19:03:06Z",
        "updatedAt" : "2016-07-11T19:03:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d14fe0f26992442fe945e7b438ca22e6edccd7bd",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +152,156 @@\n// List returns a list of nodes that match the conditions defined by the predicate functions in the storeToNodeConditionLister.\nfunc (s storeToNodeConditionLister) List() (nodes []*api.Node, err error) {\n\tfor _, m := range s.store.List() {\n\t\tnode := m.(*api.Node)"
  },
  {
    "id" : "4e4b99ee-cfcd-4e68-afee-a03e8de93e86",
    "prId" : 25921,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/25921#pullrequestreview-497003122",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "240aab83-73ff-41bf-bb90-3f8dc7fc16ec",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "The usual semantics is that empty label selector matches everything, so I think you should omit the first part of the expression here?\n",
        "createdAt" : "2016-07-09T22:34:18Z",
        "updatedAt" : "2016-08-16T22:20:58Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "f81184f3-6d34-42e8-ad4e-70beb5dce673",
        "parentId" : "240aab83-73ff-41bf-bb90-3f8dc7fc16ec",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "I'll add a comment, but in this case I'm copying behavior from other controllers.\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/client/cache/listers.go#L254\n\nSearch for \"nil or empty\" in that file.\n\nIIRC, during validation I verify that we have a non-empty selector, so this is sort of defense-in-depth.\n",
        "createdAt" : "2016-07-11T18:21:56Z",
        "updatedAt" : "2016-08-16T22:20:58Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      },
      {
        "id" : "bf203530-b5a3-451e-8989-59f0da33c6e2",
        "parentId" : "240aab83-73ff-41bf-bb90-3f8dc7fc16ec",
        "authorId" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "body" : "Four years later, see #95083.",
        "createdAt" : "2020-09-26T12:58:48Z",
        "updatedAt" : "2020-09-26T12:58:48Z",
        "lastEditedBy" : "2d9afee7-a404-4340-8fd9-d3187ed4f1da",
        "tags" : [
        ]
      }
    ],
    "commit" : "d60ba3c6e2b7d57441405a108fbfe2b8e38495cc",
    "line" : null,
    "diffHunk" : "@@ -1,1 +743,747 @@\n\t\t// If a PDB with a nil or empty selector creeps in, it should match nothing, not everything.\n\t\tif selector.Empty() || !selector.Matches(labels.Set(pod.Labels)) {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "75d4bf22-dcd5-4f64-a6b1-c3f143ec081a",
    "prId" : 25921,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09157e19-b0b3-4689-aa65-57fbed90e343",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Do we have other lists where we error out if nothing is found? If so, should we continue doing this? Usually, we don't do that (for example `kubectl get pods` won't return an error if there are no pods)\n",
        "createdAt" : "2016-07-20T21:05:44Z",
        "updatedAt" : "2016-08-16T22:20:59Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "dd7bd8b9-326e-44dd-a4ed-7c48beba0f2a",
        "parentId" : "09157e19-b0b3-4689-aa65-57fbed90e343",
        "authorId" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "body" : "Yes.  Search in this file for `if len.*== 0`\n",
        "createdAt" : "2016-07-25T16:14:51Z",
        "updatedAt" : "2016-08-16T22:20:59Z",
        "lastEditedBy" : "d324e241-a7f0-4ace-bda2-4174b07bdb18",
        "tags" : [
        ]
      }
    ],
    "commit" : "d60ba3c6e2b7d57441405a108fbfe2b8e38495cc",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +749,753 @@\t}\n\tif len(pdbList) == 0 {\n\t\terr = fmt.Errorf(\"could not find PodDisruptionBudget for pod %s in namespace %s with labels: %v\", pod.Name, pod.Namespace, pod.Labels)\n\t}\n\treturn"
  },
  {
    "id" : "04b42cab-aab1-48c7-bd2f-df5523b92302",
    "prId" : 23795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ede3240-1500-41f6-822b-9aa49fc6bf6d",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Can you please also fallback to the old behavior here?\n",
        "createdAt" : "2016-05-05T10:15:04Z",
        "updatedAt" : "2016-05-06T13:23:39Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c10f43a2e54fc555c93526b0e1f20c60f5d9aa9d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +216,220 @@\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\tfor _, m := range items {"
  },
  {
    "id" : "010a86ee-4bb2-45c1-8e84-1b0aa2c83683",
    "prId" : 23795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0bfbac31-687d-4a93-80f8-ccd459cbf753",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "This was a really good idea. I like it a lot.\n",
        "createdAt" : "2016-05-06T11:36:42Z",
        "updatedAt" : "2016-05-06T13:23:39Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "c10f43a2e54fc555c93526b0e1f20c60f5d9aa9d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +42,46 @@// l.List()\ntype StoreToPodLister struct {\n\tIndexer\n}\n"
  },
  {
    "id" : "5560ee2e-2824-4369-8073-6d8793a96f7a",
    "prId" : 17916,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e550e2a-fe97-4d17-83cb-46dc79d234fd",
        "parentId" : null,
        "authorId" : null,
        "body" : "It seems that the client would want to easily distinguish between these two \"errors\"?  Suggest distinct return types?\n",
        "createdAt" : "2015-11-30T18:54:26Z",
        "updatedAt" : "2015-12-31T17:27:22Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "cdc5cc14-2dd7-4a63-bc5e-f0a2386ec7fc",
        "parentId" : "1e550e2a-fe97-4d17-83cb-46dc79d234fd",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I agree; but this is effectively a copy-and-paste of GetNodeInfo (also in pkg/client/cache/listers.go).  I'm happy to change this to return either (_api.PersistentVolume, bool, error) or (_api.PersistentVolume, error), so not-found would be (_, false, nil) or (nil, nil).  What do you think?\n",
        "createdAt" : "2015-12-07T00:21:49Z",
        "updatedAt" : "2015-12-31T17:27:22Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "e2ffb233-b6f3-4e7b-b353-141333ef1c9d",
        "parentId" : "1e550e2a-fe97-4d17-83cb-46dc79d234fd",
        "authorId" : null,
        "body" : "I was originally thinking more along the lines of a custom error type and type assertion as described [here](http://blog.golang.org/error-handling-and-go).  But that's arguably more work than it's worth, so maybe just returning (nil, nil) for not-found would be fine.  Just be sure to document it in the function header.\n",
        "createdAt" : "2015-12-12T02:48:34Z",
        "updatedAt" : "2015-12-31T17:27:22Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "f9a6ac077e653ee9c44b561fbdd9fc14d18308b5",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +433,437 @@\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"PersistentVolume '%v' is not in cache\", id)\n\t}\n"
  },
  {
    "id" : "df8c2911-6418-43ad-9b95-83c61e57dc3a",
    "prId" : 17916,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff57759b-47a6-4213-b9bc-78bb55571c13",
        "parentId" : null,
        "authorId" : null,
        "body" : "Same comment as above.\n",
        "createdAt" : "2015-11-30T18:55:11Z",
        "updatedAt" : "2015-12-31T17:27:22Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "f9a6ac077e653ee9c44b561fbdd9fc14d18308b5",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +452,456 @@\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"PersistentVolumeClaim '%s/%s' is not in cache\", namespace, id)\n\t}\n"
  },
  {
    "id" : "83751e99-928c-4387-b038-f24fa9ab2505",
    "prId" : 17398,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5841d24-2704-41f6-8906-07a0c1fc8a38",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "I think it's reasonable to break here once we have a deployment.\n",
        "createdAt" : "2015-11-23T22:18:45Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "d0b23b6c-e342-4d11-9014-9da156dc9770",
        "parentId" : "a5841d24-2704-41f6-8906-07a0c1fc8a38",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "But this function tries to return a list of all deployments... (although the consumer only takes the first element)\n",
        "createdAt" : "2015-11-24T01:39:17Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1200ba66f29b4816836dd8d6f2fdc23126bb77",
    "line" : null,
    "diffHunk" : "@@ -1,1 +238,242 @@\t\t\tcontinue\n\t\t}\n\t\tdeployments = append(deployments, d)\n\t}\n\tif len(deployments) == 0 {"
  },
  {
    "id" : "d1d66056-0bc9-43cd-bd9e-8a2c6d5b1a85",
    "prId" : 17398,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ad935c3-40d1-4a7e-9dbb-222e1f889aba",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "do we set any labels in the replication controllers we create for deployments?\n",
        "createdAt" : "2015-11-23T22:24:13Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "5e915825-616d-48a9-ac11-a3b06ea3b22a",
        "parentId" : "9ad935c3-40d1-4a7e-9dbb-222e1f889aba",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Yes. We add the podTemplateHash label unless user sets uniqueLabelKey to empty string.\n",
        "createdAt" : "2015-11-23T23:35:25Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "ff6d7976-311f-490b-a023-a22467d20776",
        "parentId" : "9ad935c3-40d1-4a7e-9dbb-222e1f889aba",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "This is added in the rc selector but not in the rc labels though, right?\n",
        "createdAt" : "2015-11-23T23:48:31Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "58cc0f11-76c0-4a32-85c0-2b29cf576231",
        "parentId" : "9ad935c3-40d1-4a7e-9dbb-222e1f889aba",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "It's added both in the rc selector and rc labels. \n",
        "createdAt" : "2015-11-24T01:38:15Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1200ba66f29b4816836dd8d6f2fdc23126bb77",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +220,224 @@\tvar d extensions.Deployment\n\n\tif len(rc.Labels) == 0 {\n\t\terr = fmt.Errorf(\"no deployments found for replication controller %v because it has no labels\", rc.Name)\n\t\treturn"
  },
  {
    "id" : "5569b9c1-c937-4d83-bca6-3488eca99b0c",
    "prId" : 17398,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad4cf957-4736-4826-8fc2-a91db39d02a7",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "It would be really nice if you wrote this PR to use an IndexInformer\n",
        "createdAt" : "2015-11-30T19:00:05Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "6b30e71d-49dc-407d-8484-78ae72f0224d",
        "parentId" : "ad4cf957-4736-4826-8fc2-a91db39d02a7",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "I'll add this as a follow-up PR.\n",
        "createdAt" : "2015-12-01T21:49:29Z",
        "updatedAt" : "2015-12-18T03:59:03Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd1200ba66f29b4816836dd8d6f2fdc23126bb77",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +228,232 @@\tfor _, m := range s.Store.List() {\n\t\td = *m.(*extensions.Deployment)\n\t\tif d.Namespace != rc.Namespace {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "8380d76e-4ca0-4d02-8a9b-4c9238626ad3",
    "prId" : 16962,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd369ac5-a465-49d4-ab63-8cf337061240",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "It definitely looks like the old version was bugged (always pointed to the last loop variable that held the last condition in the array), so this is an improvement  However, the old behavior tried (and failed) to take the last matching condition and this takes the first.  I don't know enough to definitively say which behavior is correct.\n",
        "createdAt" : "2015-11-09T13:05:19Z",
        "updatedAt" : "2015-11-09T13:05:19Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "36834011-e29f-450a-93e6-185e505c02b4",
        "parentId" : "cd369ac5-a465-49d4-ab63-8cf337061240",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "At the moment, we store only a single entry for a given condition type in node.Status.Conditions array. So break exists to ensure that we don't continue searching (do more work) even after finding our desired condition, because there cannot be one.\n\nMore over this fix is only for <=1.1. https://github.com/kubernetes/kubernetes/commit/a2570926da1b87856351c783c908c255042a9193#diff-53f28720440ab4b589ef2273346cecfcL139. In 1.2, this whole thing is going to change. https://github.com/kubernetes/kubernetes/pull/16179/files.\n\nSo it is pretty safe to apply this to 1.0.x even with break.\n",
        "createdAt" : "2015-11-09T20:43:52Z",
        "updatedAt" : "2015-11-09T20:43:52Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "98259334a388ac8ce5e2aca8b40637c8e8607d3f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +137,141 @@\t\t\tif cond.Type == s.conditionType {\n\t\t\t\tcondCopy := cond\n\t\t\t\tnodeCondition = &condCopy\n\t\t\t\tbreak\n\t\t\t} else {"
  },
  {
    "id" : "b3b81f37-5300-43eb-af4b-66e7177b832f",
    "prId" : 16962,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cbdadf5-642a-4ae0-a581-da106f81c772",
        "parentId" : null,
        "authorId" : "b04ab4f5-5d69-4d32-9c1b-fecc0eb76d11",
        "body" : "I wasn't sure about the correct behavior either, so I went with the same change that made it into upstream here: https://github.com/kubernetes/kubernetes/commit/a2570926da1b87856351c783c908c255042a9193#diff-53f28720440ab4b589ef2273346cecfcR139\n\nBut per the code comment above this block, I would expect to drop this break and have it use the last matching condition.\n",
        "createdAt" : "2015-11-09T17:38:35Z",
        "updatedAt" : "2015-11-09T17:38:35Z",
        "lastEditedBy" : "b04ab4f5-5d69-4d32-9c1b-fecc0eb76d11",
        "tags" : [
        ]
      }
    ],
    "commit" : "98259334a388ac8ce5e2aca8b40637c8e8607d3f",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +138,142 @@\t\t\t\tcondCopy := cond\n\t\t\t\tnodeCondition = &condCopy\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tglog.V(4).Infof(\"Ignoring condition type %v for node %v\", cond.Type, node.Name)"
  },
  {
    "id" : "f24959be-285d-4b57-9920-f15b585adca1",
    "prId" : 7668,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "91e1703c-a8a9-456a-af57-812b329f96bf",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "s/kubelet/node controller/\n",
        "createdAt" : "2015-05-04T17:43:04Z",
        "updatedAt" : "2015-05-07T01:33:19Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "14e5a6b9-d54b-4f15-b4a1-77d8cd3a1c86",
        "parentId" : "91e1703c-a8a9-456a-af57-812b329f96bf",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "The nodecontroller sets it to unknown when the kubelet hasn't updated it in so long, the kubelet sets it to something sensible usually.\n",
        "createdAt" : "2015-05-06T02:30:55Z",
        "updatedAt" : "2015-05-07T01:33:19Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "9c8eafd0-8890-44b6-921c-32214bdb0503",
        "parentId" : "91e1703c-a8a9-456a-af57-812b329f96bf",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I see, thanks.\n",
        "createdAt" : "2015-05-06T20:06:48Z",
        "updatedAt" : "2015-05-07T01:33:19Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0607cf0b7619faba71e2f30b5240c42e562e4a",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +129,133 @@\t\t// We currently only use a conditionType of \"Ready\". If the kubelet doesn't\n\t\t// periodically report the status of a node, the nodecontroller sets its\n\t\t// ConditionStatus to \"Unknown\". If the kubelet thinks a node is unhealthy\n\t\t// it can (in theory) set its ConditionStatus to \"False\".\n\t\tvar nodeCondition *api.NodeCondition"
  },
  {
    "id" : "f898bb75-e934-417b-915d-32595fa7faec",
    "prId" : 7668,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4fcf434-0f52-44f8-a926-b6cdd1109aa4",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think my preference would be to do the filtering in the scheduler, but I guess this is ok too. Perhaps the name \"FilterConditions\"?\n\nAlso add a // TODO: make this into a field selector query so the work can be pushed down the stack into apiserver.\n",
        "createdAt" : "2015-05-04T17:48:51Z",
        "updatedAt" : "2015-05-07T01:33:19Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "62e536cf-2db2-4569-8687-5165888f1610",
        "parentId" : "a4fcf434-0f52-44f8-a926-b6cdd1109aa4",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "I had initially thought that as well, but it's awkward to filter this because it's a list of conditions and you only want the latest. It also might get a lot more complicated down the line (nodecontroller code is all written in way that indicates a lot more condition types/statuses that might influence each other down the line). Still put in a TODO?\n",
        "createdAt" : "2015-05-06T02:30:57Z",
        "updatedAt" : "2015-05-07T01:33:19Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "94bb4bf1-4be0-4153-aa51-cced9f274238",
        "parentId" : "a4fcf434-0f52-44f8-a926-b6cdd1109aa4",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Yeah still a TODO; I don't think our selector is advanced enough to specify the condition(s) we care about at the moment. But eventually we'd want to do this server side. Presumably it'd be maximally efficient if we push doing this work down into our storage layer.\n",
        "createdAt" : "2015-05-06T20:06:22Z",
        "updatedAt" : "2015-05-07T01:33:19Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0607cf0b7619faba71e2f30b5240c42e562e4a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +109,113 @@\n// NodeCondition returns a storeToNodeConditionLister\nfunc (s *StoreToNodeLister) NodeCondition(conditionType api.NodeConditionType, conditionStatus api.ConditionStatus) storeToNodeConditionLister {\n\t// TODO: Move this filtering server side. Currently our selectors don't facilitate searching through a list so we\n\t// have the reflector filter out the Unschedulable field and sift through node conditions in the lister."
  },
  {
    "id" : "cf7a3177-1da5-4d8e-b412-de54daea9e55",
    "prId" : 6943,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c4fb443-32e8-4d72-912e-e8c62ca1cb8f",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Why do you return error, if it always return nil?\n",
        "createdAt" : "2015-04-17T09:10:33Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      },
      {
        "id" : "f07f485c-6974-4e3e-9c22-c9f80da73431",
        "parentId" : "5c4fb443-32e8-4d72-912e-e8c62ca1cb8f",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "To match the client interface.\n",
        "createdAt" : "2015-04-17T17:20:24Z",
        "updatedAt" : "2015-04-17T22:32:58Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2953fdc7ef5a9705f9e595a8c332eab055af4a2",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +72,76 @@// the store; there may have been some filtering that already happened before\n// that.\nfunc (s storePodsNamespacer) List(selector labels.Selector) (pods api.PodList, err error) {\n\tlist := api.PodList{}\n\tfor _, m := range s.store.List() {"
  },
  {
    "id" : "3ff8e21b-f7a4-4b15-8266-4fb1f4ea7505",
    "prId" : 6866,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b207bd14-c514-4018-a684-875f99b05c17",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "nit: combine this with labelSet above.\n",
        "createdAt" : "2015-04-27T20:44:31Z",
        "updatedAt" : "2015-04-28T20:45:49Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "58eae2b9-79a5-4a40-a37c-67ddef761cf4",
        "parentId" : "b207bd14-c514-4018-a684-875f99b05c17",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "done\n",
        "createdAt" : "2015-04-28T20:47:54Z",
        "updatedAt" : "2015-04-28T20:47:54Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7592dabeba854da7b3b4045dbb9b19e848f17271",
    "line" : null,
    "diffHunk" : "@@ -1,1 +163,167 @@\t\t}\n\t\tlabelSet := labels.Set(rc.Spec.Selector)\n\t\tselector = labels.Set(rc.Spec.Selector).AsSelector()\n\n\t\t// If an rc with a nil or empty selector creeps in, it should match nothing, not everything."
  },
  {
    "id" : "b69eeed9-e453-4577-a16f-b0de62f809df",
    "prId" : 3810,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8fc1c8f-cc09-494b-9fef-c4a321bb3f7f",
        "parentId" : null,
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "@smarterclayton So, this replaces all the interface changes, _only if_ Nodes have an empty namespace. If they are stored with some uniform non-blank namespace, either:\n1. That namespace would have to be hard-coded here or,\n2. The Node would need to propagate down to here via the interfaces.\n\nThoughts?\n",
        "createdAt" : "2015-01-29T18:27:56Z",
        "updatedAt" : "2015-01-29T22:39:57Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "b035db08-9174-432c-8d0e-2beeddb62358",
        "parentId" : "f8fc1c8f-cc09-494b-9fef-c4a321bb3f7f",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "Correction: If Node is namespaced uniformly, it could be hard-coded here. If Node is namespaced ad-hoc, the namespace or Node would have to become an arg of the interfaces to provide cache query context.\n",
        "createdAt" : "2015-01-29T18:31:22Z",
        "updatedAt" : "2015-01-29T22:39:57Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      },
      {
        "id" : "5bc910f8-5279-45a2-aaec-37ce0c03f64d",
        "parentId" : "f8fc1c8f-cc09-494b-9fef-c4a321bb3f7f",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Nodes don't have namespaces, and won't.  So until that happens, node name is sufficient.\n\nMaybe not understanding.\n\n----- Original Message -----\n\n> > @@ -69,10 +69,17 @@ func (s _StoreToNodeLister) List() (machines\n> > api.NodeList, err error) {\n> >  // rather than a method of StoreToNodeLister.\n> >  // GetNodeInfo returns cached data for the minion 'id'.\n> >  func (s *StoreToNodeLister) GetNodeInfo(id string) (_api.Node, error) {\n> > -   if minion, ok := s.Get(id); ok {\n> > -       return minion.(*api.Node), nil\n> > -   minion, exists, err := s.Get(&api.Node{ObjectMeta: api.ObjectMeta{Name:\n> >   id}})\n> \n> @smarterclayton So, this replaces all the interface changes, _only if_ Nodes\n> have an empty namespace. If they are stored with some uniform non-blank\n> namespace, either:\n> 1. That namespace would have to be hard-coded here or,\n> 2. The Node would need to propagate down to here via the interfaces.\n> \n> Thoughts?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/3810/files#r23789908\n",
        "createdAt" : "2015-01-29T19:02:59Z",
        "updatedAt" : "2015-01-29T22:39:57Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "d7038cd8-9a29-4de9-a26c-ac980d9a69f4",
        "parentId" : "f8fc1c8f-cc09-494b-9fef-c4a321bb3f7f",
        "authorId" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "body" : "I think we're on the same page. I've got e2e running again now.\n",
        "createdAt" : "2015-01-29T19:06:57Z",
        "updatedAt" : "2015-01-29T22:39:57Z",
        "lastEditedBy" : "f04ec747-f3ff-4334-a66e-6daaf4497091",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ee943d683134f7233c80110b7ae0586f3be4119",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +70,74 @@// GetNodeInfo returns cached data for the minion 'id'.\nfunc (s *StoreToNodeLister) GetNodeInfo(id string) (*api.Node, error) {\n\tminion, exists, err := s.Get(&api.Node{ObjectMeta: api.ObjectMeta{Name: id}})\n\n\tif err != nil {"
  }
]
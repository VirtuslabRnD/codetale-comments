[
  {
    "id" : "f285fb5d-6572-4e62-a042-a2ff8d3dc3c6",
    "prId" : 16126,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62967fd3-50ee-42f2-83b4-6a59f7da7946",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I'm still having a hard time seeing the benefit of deeply nested config structs... presumably, we would eventually want client.Config to contain transport.Config, at which point we'd have this:\n\n```\nclient.Config\n  transport.Config\n    transport.AuthConfig\n      transport.TokenAuthConfig\n        Token string\n```\n\nThat seems like a lot of levels. Just like you have the `UserAgent string` field that drives the creation of the user-agent round tripper wrapper, it seems simpler to keep the username,password fields to drive the basic auth wrapper, and the token field to drive the bearer auth wrapper.\n\nThe value seems to be in the helper functions you are checking to drive the wrapper creation (like `hasBasicAuth`, etc), and those could simply check the fields directly in the transport config, they don't needs structs within structs within structs.\n",
        "createdAt" : "2015-11-16T15:59:46Z",
        "updatedAt" : "2015-11-19T22:56:56Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "38aaa02e-1c24-4d46-8a6e-d785dc7d24cd",
        "parentId" : "62967fd3-50ee-42f2-83b4-6a59f7da7946",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "I think it provides a clearer grouping of related data.\n\nAlso, the clients we plan on generating will take an *http.Client an know nothing else of the transport layer. So it won't be nested like you say.\n",
        "createdAt" : "2015-11-16T22:52:50Z",
        "updatedAt" : "2015-11-19T22:56:56Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      },
      {
        "id" : "c6ac43c0-84e3-46b1-8871-54de98327487",
        "parentId" : "62967fd3-50ee-42f2-83b4-6a59f7da7946",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "The transport config is still something every consumer will have to build, right? It's nice that the client gets a `*http.Client` with a transport already built, but the options that drive that come from somewhere... what benefit is a four-level structure like this providing?\n\n```\n  transport.Config\n    transport.AuthConfig\n      transport.TokenAuthConfig\n        Token string\n```\n",
        "createdAt" : "2015-11-19T17:27:59Z",
        "updatedAt" : "2015-11-19T22:56:56Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "ff34f20c-b644-481b-8acd-d9c417f1e7f3",
        "parentId" : "62967fd3-50ee-42f2-83b4-6a59f7da7946",
        "authorId" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "body" : "Yes. The benefit still is better organization and separation of data, but for understanding and manipulation. With this you could have a function that just returns `AuthConfig` and assign that into your struct instead of either it taking a config and assigning the fields it needs to or requiring the user to merge it themselves.\n",
        "createdAt" : "2015-11-19T17:45:25Z",
        "updatedAt" : "2015-11-19T22:56:56Z",
        "lastEditedBy" : "ad0a3561-db60-47a9-b82f-ac613199f968",
        "tags" : [
        ]
      }
    ],
    "commit" : "9b75b88d4e9eb3f3b07cc1459c9b052543250bf2",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +20,24 @@\n// Config holds various options for establishing a transport.\ntype Config struct {\n\t// UserAgent is an optional field that specifies the caller of this\n\t// request."
  }
]
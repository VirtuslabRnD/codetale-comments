[
  {
    "id" : "fafb2e38-ae9f-4906-8adf-f67f49432cb3",
    "prId" : 33474,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33474#pullrequestreview-1727797",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02a29ac3-f9fd-43df-909d-b8a4458f4961",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Why switch this?  Doesn't the tighter interface cover usage?\n",
        "createdAt" : "2016-09-27T12:35:02Z",
        "updatedAt" : "2016-09-27T13:23:40Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "07d93c40-21a6-4478-9688-508a8eed853c",
        "parentId" : "02a29ac3-f9fd-43df-909d-b8a4458f4961",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I think that all over the code we are using clientset.Interface and it's good to be consistent.\n\nAlso, since @timothysc is going to switch the lock to something different than endpoints (some third party object), we will need a wider interface anyway.\n",
        "createdAt" : "2016-09-27T12:40:24Z",
        "updatedAt" : "2016-09-27T13:23:40Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "71ff7db7-5914-46ea-a74d-274bb91af14a",
        "parentId" : "02a29ac3-f9fd-43df-909d-b8a4458f4961",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Also, since @timothysc is going to switch the lock to something different than endpoints (some third party object), we will need a wider interface anyway.\n\nI prefer having it tighter, but I don't make an issue of it.\n\n@timothysc thirdpartyresource for leader election?  Is there an issue for that?  I'm certainly for using something other than endpoints, but I think that third party resources may not be a great fit.\n",
        "createdAt" : "2016-09-27T12:47:02Z",
        "updatedAt" : "2016-09-27T13:23:40Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "73baef69-8946-45ff-a27f-00ea066fef26",
        "parentId" : "02a29ac3-f9fd-43df-909d-b8a4458f4961",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "@deads2k #18386 #26637\n",
        "createdAt" : "2016-09-27T13:15:16Z",
        "updatedAt" : "2016-09-27T13:23:40Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbcce2c90f7700253eb96c0752963bf3079ce7fa",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +104,108 @@\tIdentity string\n\n\tClient        clientset.Interface\n\tEventRecorder record.EventRecorder\n"
  },
  {
    "id" : "3eeae44a-1f3d-4e8a-ab5f-86a6430357d2",
    "prId" : 29699,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8397088b-9347-495d-b6d1-cd52139e62b2",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Reduce to defer le.config.Callbacks.OnStoppedLeading()?\n",
        "createdAt" : "2016-07-27T23:57:29Z",
        "updatedAt" : "2016-07-29T16:22:16Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "0198b287-1cf6-4078-9462-d8ccdb8feb7d",
        "parentId" : "8397088b-9347-495d-b6d1-cd52139e62b2",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "https://godoc.org/k8s.io/kubernetes/pkg/util/runtime \n\n```\nTODO: remove this function. We are switching to a world where it's safe for apiserver to panic, since it will be restarted \nby kubelet. At the beginning of the Kubernetes project, nothing was going to restart apiserver and so catching panics \nwas important. But it's actually much simpler for montoring software if we just exit when an unexpected panic happens.\n```\n",
        "createdAt" : "2016-07-28T13:58:59Z",
        "updatedAt" : "2016-07-29T16:22:16Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "512b073a-0f43-4e5b-91a1-fb1fab41fa68",
        "parentId" : "8397088b-9347-495d-b6d1-cd52139e62b2",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Happy to remove if you don't want it in this PR, and can follow on with a separate PR. \n",
        "createdAt" : "2016-07-28T17:07:56Z",
        "updatedAt" : "2016-07-29T16:22:16Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a02bffe6d293d26167fd88561f199eb8f62702c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +169,173 @@// Run starts the leader election loop\nfunc (le *LeaderElector) Run() {\n\tdefer func() {\n\t\truntime.HandleCrash()\n\t\tle.config.Callbacks.OnStoppedLeading()"
  },
  {
    "id" : "28b85efb-6acf-4403-b831-6e1ae77f0987",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e9fec82-4220-480e-8bef-3928b7907feb",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "By definition this is not LeaderElection, it's lock-leasing. \n",
        "createdAt" : "2015-11-06T16:47:13Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : null,
    "diffHunk" : "@@ -1,1 +147,151 @@// with a random string (e.g. UUID) with only slight modification of this code.\n// TODO(mikedanese): this should potentially be versioned\ntype LeaderElectionRecord struct {\n\tHolderIdentity       string           `json:\"holderIdentity\"`\n\tLeaseDurationSeconds int              `json:\"leaseDurationSeconds\"`"
  },
  {
    "id" : "c384c577-fab7-4e08-b031-bc951da64715",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21392f2f-0a05-4dd1-9f8e-a2aa24945cc7",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "please change name to locklease\n",
        "createdAt" : "2015-11-19T22:20:23Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "cd9aa753-4338-4fcf-bb37-626d2f7b1efb",
        "parentId" : "21392f2f-0a05-4dd1-9f8e-a2aa24945cc7",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Is the wikipedia [summary](https://en.wikipedia.org/wiki/Leader_election) and [definition](https://en.wikipedia.org/wiki/Leader_election#Definition) wrong? \n\nI think there is value in an api that has higher level semantics than lock/lease nor do I want this to be used or become a generic lock lease/library on kubernetes objects. I still hold that the internal lease is an implementation detail.\n",
        "createdAt" : "2015-11-19T23:29:18Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "3c06743b-da66-4daf-bc09-24f9a1164595",
        "parentId" : "21392f2f-0a05-4dd1-9f8e-a2aa24945cc7",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "How about some middle-ground, b/c we are applying no algorithm of election.  As denoted (https://en.wikipedia.org/wiki/Leader_election#Definition).\n\nhow does 'leaderlock' sound?  \n",
        "createdAt" : "2015-11-19T23:39:11Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "626bbeed-8747-4935-8193-013f3dc62c84",
        "parentId" : "21392f2f-0a05-4dd1-9f8e-a2aa24945cc7",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "If you can decouple the mechanics and leverage through an interface I'm ok with with calling it leaderelection b/c I could back end against my own algorithm which may/may-not talk to some other facility.  This way the plumbing is the same, and implementation specifics are hidden.  In this case you would hide the implementation of endpoints annotation such that controllers and scheduler only pass in a \"key\".   This 1 layer of indirection would make it general enough such that someone else could write an algo and all the plumbing would be the same.  This implementation would be a endpointslock, where I could easily write a etcd/zk leader elect behind the same interface.  This would also minimize technical debt as we may change things in the future. \n\nHow does this sound?  Happy to do 1:1 hangout if what I said was confusing. \n",
        "createdAt" : "2015-11-20T16:47:00Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "e25aba47-4a29-4cee-9421-e75988a441a1",
        "parentId" : "21392f2f-0a05-4dd1-9f8e-a2aa24945cc7",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "leaderlock SGTM.\nOther options:\nendpointslease, endpointslock, masterendpoint, leaderendpoint, leadendpoint, leaderlease.\n",
        "createdAt" : "2015-11-20T17:54:51Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "3ae1de64-07ab-4ea2-8335-6ca7c4ccd3f9",
        "parentId" : "21392f2f-0a05-4dd1-9f8e-a2aa24945cc7",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "> applying no algorithm of election\n\nI'd consider this to be a variant of [randomized leader election](https://en.wikipedia.org/wiki/Leader_election#Randomized_.28probabilistic.29_leader_election) where the identity is the order that the processes make \"aquire\" requests to etcd. Randomness is added by processor speed and network latency. We pick the first \"aquirer\" to be leader.\n\nI think this satisfies the definition of leader election and I want to call it that because that's what people know it by.\n\n> If you can decouple the mechanics and leverage through an interface\n\nAgree that we should do this. The interface should last longer than the implementation. I'll see what i can do.\n",
        "createdAt" : "2015-11-22T18:56:51Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : null,
    "diffHunk" : "@@ -1,1 +48,52 @@// your own risk.\n\npackage leaderelection\n\nimport ("
  },
  {
    "id" : "40baf763-1bfc-481b-8576-c03081d28065",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d73e0ec-031d-4fb0-9b3f-2e2bbae4a008",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "We should probably denote that the life of this library is subject to change and should be leveraged only by certain components. \n",
        "createdAt" : "2015-11-19T23:58:26Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "59b9fa33-2286-4049-8d15-893a3093d976",
        "parentId" : "1d73e0ec-031d-4fb0-9b3f-2e2bbae4a008",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "SGTM\n",
        "createdAt" : "2015-11-22T18:59:28Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "75bb586a-984d-44db-b52b-2dac3b275ecb",
        "parentId" : "1d73e0ec-031d-4fb0-9b3f-2e2bbae4a008",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.\n",
        "createdAt" : "2015-12-03T17:18:14Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +15,19 @@*/\n\n// Package leaderelection implements leader election of a set of endpoints.\n// It uses an annotation in the endpoints object to store the record of the\n// election state."
  },
  {
    "id" : "7a104493-ee06-4514-a597-48f214276fe9",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf265ce9-760b-4520-8ca1-e2f62aeaeff2",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "These fields deserve comments.\n",
        "createdAt" : "2015-11-20T18:01:48Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "bfbaa44b-0143-4ba7-9c52-c90f47345585",
        "parentId" : "cf265ce9-760b-4520-8ca1-e2f62aeaeff2",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.\n",
        "createdAt" : "2015-12-03T17:18:24Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +92,96 @@}\n\ntype LeaderElectionConfig struct {\n\t// EndpointsMeta should contain a Name and a Namespace of an\n\t// Endpoints object that the LeaderElector will attempt to lead."
  },
  {
    "id" : "cb7bbd81-9245-4006-896c-75f6a395271e",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a0b8c8fb-7f70-4ec1-a938-536e4ec2e523",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Consul calls this a \"session\" (https://www.consul.io/docs/guides/leader-election.html)\n",
        "createdAt" : "2015-11-20T18:08:42Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : null,
    "diffHunk" : "@@ -1,1 +147,151 @@// with a random string (e.g. UUID) with only slight modification of this code.\n// TODO(mikedanese): this should potentially be versioned\ntype LeaderElectionRecord struct {\n\tHolderIdentity       string           `json:\"holderIdentity\"`\n\tLeaseDurationSeconds int              `json:\"leaseDurationSeconds\"`"
  },
  {
    "id" : "1ee089c3-cce5-4350-929c-154281d34e3a",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4213499b-4b2a-4240-b925-ff9bcfc0b30f",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I'm not sure I follow the logic behind this panic handler.\nIf the panic is, say, due to being out of memory, then the OnStoppedLeading callback may not be able to do anything useful.\n\nNot sure if this is needed for correct behavior or just an \"optimization\"?\n",
        "createdAt" : "2015-11-20T18:21:19Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "619ba494-42e9-44e6-aaec-5de6f2421efb",
        "parentId" : "4213499b-4b2a-4240-b925-ff9bcfc0b30f",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "This is an optimization. I would prefer an OOM kill to an out of memory panic here... We should catch a nil pointer in the aquire though. e.g.:\n\n```\nOnStartedLeading: func() {\n    go controller.Run()\n    var bad map[string]string\n    // nil deref\n    a := bad[\"a\"]\n}\n```\n\nWhat i want here is for Run to call OnStoppLeading before it returns. It won't unless I handle crash.\n",
        "createdAt" : "2015-11-22T19:12:37Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "efe9e050-3878-4bd7-8085-5e1386fe25b3",
        "parentId" : "4213499b-4b2a-4240-b925-ff9bcfc0b30f",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "seems like somewhat duplicated effort given the `stop` chan, which could signal the same thing (if it was closed via `defer` as I suggested). the difference being that a client won't have a reference to `stop` unless they've received the start callback.\n\nI think the API would be more clear if \"started\" and \"stopped\" were NOT callbacks, but instead were exposed as latches:\n\n``` go\n// Started returns a chan that closes upon being elected for leadership. No objects are ever sent over the chan.\nfunc (le *LeaderElector) Started() <-chan struct{} {... }\n// Stopped returns a chan that closes upon being removed from leadership. No objects are ever sent over the chan.\nfunc (le *LeaderElector) Stopped() <-chan struct{} {... }\n```\n\n.. and get rid of callbacks all together.\n",
        "createdAt" : "2015-12-08T21:36:14Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 161,
    "diffHunk" : "@@ -1,1 +159,163 @@\t\tutil.HandleCrash()\n\t\tle.config.Callbacks.OnStoppedLeading()\n\t}()\n\tle.acquire()\n\tstop := make(chan struct{})"
  },
  {
    "id" : "2dcc599e-720b-4c14-8892-2b47fc98ad12",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9befbb0-5142-4b21-a591-e0862f609310",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "You are marshalling time.Now() using the default formatter, which I think prints out the time in local time zone.  But nodes may be in different time zones.  Are two nodes guaranteed to be able to parse time zones used by other zones?  Seems like it depends on ZONEINFO and such.  I know nodes in a cluster are supposed to have synchronized clocks, but I don't know what syncs time zone info.  Suggest either format time in UTC or document this requirement.\n",
        "createdAt" : "2015-11-22T15:14:58Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "f82b9764-4570-46df-a021-dad0c449f226",
        "parentId" : "a9befbb0-5142-4b21-a591-e0862f609310",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I guess this is safe because the times are just used for debugging and not for correctness?\n",
        "createdAt" : "2015-11-22T15:17:45Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "06d32445-dab3-424a-b056-f74edd6e3bae",
        "parentId" : "a9befbb0-5142-4b21-a591-e0862f609310",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We should serialize with unversioned.Time but I wouldn't want to take a\ndependency on that package.\n",
        "createdAt" : "2015-11-22T16:17:16Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6dfcc531-ddd8-485f-9c47-fcbc2c613e1d",
        "parentId" : "a9befbb0-5142-4b21-a591-e0862f609310",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "> I guess this is safe because the times are just used for debugging and not for correctness?\n\nYes.\n\n> We should serialize with unversioned.Time but I wouldn't want to take a\n> dependency on that package.\n\nWe already depend on it indirectly since we are depending on pkg/api.\n",
        "createdAt" : "2015-11-22T18:34:46Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "e2e235da-c5a6-40a4-b407-f49a64c5ec97",
        "parentId" : "a9befbb0-5142-4b21-a591-e0862f609310",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Using unversioned.Time now\n",
        "createdAt" : "2015-12-03T17:19:09Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 210,
    "diffHunk" : "@@ -1,1 +208,212 @@\t\tHolderIdentity:       le.config.Identity,\n\t\tLeaseDurationSeconds: int(le.config.LeaseDuration / time.Second),\n\t\tRenewTime:            now,\n\t\tAcquireTime:          now,\n\t}"
  },
  {
    "id" : "8968fd28-fdf0-4449-b2d0-0450c8ca9c02",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f247f15d-37f3-4f54-8705-ea5b9c01ac54",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "In practice, will it sometimes be difficult for a processes that loses leadership to drain all its work in progress before the next leader starts leading?  Is there any advice for library users in this area?\n",
        "createdAt" : "2015-11-22T17:50:27Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "47f2bd71-035a-4b6c-b3a0-73980f36ef65",
        "parentId" : "f247f15d-37f3-4f54-8705-ea5b9c01ac54",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "I think default and general usage should be a fatal log. I'll document.\n",
        "createdAt" : "2015-11-22T18:33:43Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "826f88b7-9543-440b-96be-122078707674",
        "parentId" : "f247f15d-37f3-4f54-8705-ea5b9c01ac54",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Every other implementation to date was fatal.  \n",
        "createdAt" : "2015-11-23T02:40:50Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : null,
    "diffHunk" : "@@ -1,1 +128,132 @@\tOnStartedLeading func(stop <-chan struct{})\n\t// OnStoppedLeading is called when a LeaderElector client stops leading\n\tOnStoppedLeading func()\n}\n"
  },
  {
    "id" : "741fd201-6df1-4ac6-a433-d3912f5e3628",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95f10751-4a56-48ab-bd44-8f1d96d6a3fc",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "nit: godoc please\n",
        "createdAt" : "2015-11-30T19:22:56Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : null,
    "diffHunk" : "@@ -1,1 +74,78 @@\n// NewLeadereElector creates a LeaderElector from a LeaderElecitionConfig\nfunc NewLeaderElector(lec LeaderElectionConfig) (*LeaderElector, error) {\n\tif lec.LeaseDuration <= lec.RenewDeadline {\n\t\treturn nil, fmt.Errorf(\"leaseDuration must be greater than renewDeadline\")"
  },
  {
    "id" : "4d0e189c-157d-459a-ad32-a81950453312",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e201340-3c9a-4d21-afad-66cfcbbef447",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "remove blank. \n",
        "createdAt" : "2015-12-04T19:47:37Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@const (\n\tJitterFactor = 1.2\n\n\tLeaderElectionRecordAnnotationKey = \"control-plane.alpha.kubernetes.io/leader\"\n)"
  },
  {
    "id" : "b26a1f3e-7f5e-422c-873c-6ea4ca5b2f27",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe11a336-1bcc-4dc7-9c31-5acf69219b2e",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "is there a reason for a struct in the channel, it looks like it's only signaling as if it were a bool. \n",
        "createdAt" : "2015-12-04T19:54:01Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "ddaee4ec-8027-4ec0-aa5b-d862c3d06b24",
        "parentId" : "fe11a336-1bcc-4dc7-9c31-5acf69219b2e",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "ahh nvmd looks like a constraint of the until functions. \n",
        "createdAt" : "2015-12-04T19:58:40Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "83797b32-2684-4ce0-8ed8-67cdc62cc98b",
        "parentId" : "fe11a336-1bcc-4dc7-9c31-5acf69219b2e",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "We mostly use a struct chan for stop signal\n",
        "createdAt" : "2015-12-04T20:27:17Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "7af778b9-c848-4d61-b1f7-d94c27354dfb",
        "parentId" : "fe11a336-1bcc-4dc7-9c31-5acf69219b2e",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "how does closure of the stop chan here differ from `OnStoppedLeading`? can we document what it's actually signalling?\n",
        "createdAt" : "2015-12-08T17:18:41Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +126,130 @@type LeaderCallbacks struct {\n\t// OnStartedLeading is called when a LeaderElector client starts leading\n\tOnStartedLeading func(stop <-chan struct{})\n\t// OnStoppedLeading is called when a LeaderElector client stops leading\n\tOnStoppedLeading func()"
  },
  {
    "id" : "a7453562-e484-4cb4-85fb-5b15f7e4f0bd",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f027021-71e4-41f7-827e-3e970915b969",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "I think this should be default to fatal honestly, as you enter into unsafe territory if a controller tries to do something during a rectification loop. \n\nIs there a legit reason you would not want to fail immediately?\n",
        "createdAt" : "2015-12-04T20:03:56Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "3fb9a054-7293-4518-940e-c3b4445cfca6",
        "parentId" : "8f027021-71e4-41f7-827e-3e970915b969",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Yes. A client might want to execute a shutdown routine or even transition to a candidate. It should be the responsibility of the library user to decide what happens here\n",
        "createdAt" : "2015-12-04T20:21:54Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "d713b68c-4027-4e94-87c4-79b0bfd5ba55",
        "parentId" : "8f027021-71e4-41f7-827e-3e970915b969",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "In leader election \"fail fast\" applies because you widen the window for a split brain.  Optimistic concurrency can't save you if your controllers are in flux.  \n\nI think the recommendation would be to immediate fatal, which was specified in the original document. \n",
        "createdAt" : "2015-12-04T20:53:10Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "16e89c30-4d2b-469a-abb9-54c83446aa1e",
        "parentId" : "8f027021-71e4-41f7-827e-3e970915b969",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Sure, it's a reasonable default. In response to \"Is there a legit reason you would not want to fail immediately?\" I think the answer is yes.\n",
        "createdAt" : "2015-12-04T20:55:17Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +128,132 @@\tOnStartedLeading func(stop <-chan struct{})\n\t// OnStoppedLeading is called when a LeaderElector client stops leading\n\tOnStoppedLeading func()\n}\n"
  },
  {
    "id" : "ce80c7ac-5b3a-411a-a1c5-c0982769fce8",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "What about clock-skew...? \n\nBefore we relied on TTL from write, but now you're relying on what is essentially relative time.  \n",
        "createdAt" : "2015-12-04T20:14:49Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "5f7dfd28-0003-406e-acf3-3b24a5fb802c",
        "parentId" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "We rely only on timestamps captured locally to function correctly.\n",
        "createdAt" : "2015-12-04T20:18:46Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "7ada362a-da65-4508-9177-da6484278b84",
        "parentId" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "That's a pretty dangerous supposition to rely on, that forces hard NTP requirements.  Even then, there is a good reason why both ZK and etcd provide the consensus on variable state. \n",
        "createdAt" : "2015-12-04T20:41:38Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "891cd753-2c93-4bca-9bf0-cabd38e66fbf",
        "parentId" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Why does it force hard NTP requirements? Machines could have hours or days of skew and this would work. \n",
        "createdAt" : "2015-12-04T20:50:40Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "677b1ce3-5b05-49ee-82aa-47ac89002bec",
        "parentId" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "b/c your using relative local times, there exists the condition where leader (X) has accurate time and sets duration of say 1 hour, then immediately crashes.  Now standby (Y) has a slow clock b/c lets say it's running on a VM in a overly provisioned environment.  For (Y) 1 hour wall clock duration from \"now\" could be 2 hours or 3 days, you don't really know.  This leaves you headless for that period of time.  For (Y) it only thinks 1 hour has passed. \n",
        "createdAt" : "2015-12-04T21:40:28Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "a7d0787f-a9c8-4ba2-abdc-a922e28d04f8",
        "parentId" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "This approach is tolerant of arbitrary clock skew, but not arbitrary skew rate. You can configure your skew rate tolerance by setting RenewDeadline and LeaseDuration appropriately. The problem described will be a problem for any system that doesn't apply fencing during write transactions, including podmaster.go. We said we aren't going to fence. The limitations of this approach are discussed above, and well understood. This approach works well in practice and it's battle tested. I'm not sure what else we can do.\n",
        "createdAt" : "2015-12-04T22:05:15Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "b7c3dbc6-0442-4fc9-a928-7f1a6b92986f",
        "parentId" : "ce9d9a5d-164c-4aa2-a151-9cdb0c8aabe8",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "> I'm not sure what else we can do.\n\nDocumentation, and I would indeed recommend some form of clock synchronization.  I probably would in any case, but denoting this would be good, along with extra comments in the code to make it clear to other readers. \n",
        "createdAt" : "2015-12-04T22:26:34Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 206,
    "diffHunk" : "@@ -1,1 +204,208 @@// on success else returns false.\nfunc (le *LeaderElector) tryAcquireOrRenew() bool {\n\tnow := unversioned.Now()\n\tleaderElectionRecord := LeaderElectionRecord{\n\t\tHolderIdentity:       le.config.Identity,"
  },
  {
    "id" : "4742114c-2f38-42e8-a802-5a48fb7f3026",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83ac23df-1b14-4528-960f-2f7c3d61c456",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Slight problem here is that on 1k node cluster \"now\" could be upwards of a second from the time you actually set the value.   \n\ne.g. you're relying on some level of SLA so windows should be large. \n\nwhat if I had a cluster that spanned multiple availability zones.  \n",
        "createdAt" : "2015-12-04T20:17:37Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "ede37b8f-6b32-42d3-a491-bde7527bdfb7",
        "parentId" : "83ac23df-1b14-4528-960f-2f7c3d61c456",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Are the knobs in the config object not sufficiently flexible to fit slower SLA envs? We need to send \"now\" with the request and it's for observational purposes only... \n",
        "createdAt" : "2015-12-04T20:25:29Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "8993c243-75f5-4e0e-9c6b-5986c6cad2c0",
        "parentId" : "83ac23df-1b14-4528-960f-2f7c3d61c456",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "We should document to denote. \n",
        "createdAt" : "2015-12-04T22:29:07Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 211,
    "diffHunk" : "@@ -1,1 +209,213 @@\t\tLeaseDurationSeconds: int(le.config.LeaseDuration / time.Second),\n\t\tRenewTime:            now,\n\t\tAcquireTime:          now,\n\t}\n"
  },
  {
    "id" : "a6cb667f-b3c2-4667-934a-3ef5abf39dcd",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8f24850-5a8b-47ae-968b-b93927e667f0",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "nit: would this be better named `RenewPeriod`? it's not really a deadline (timestamp)\n",
        "createdAt" : "2015-12-08T17:16:07Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "4ed7dac2-6dc7-4912-b178-00b0ff33ca18",
        "parentId" : "b8f24850-5a8b-47ae-968b-b93927e667f0",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "It is a deadline. If the LeaderElector is unable to renew within the deadline, it fails and gives up it's leader slot. Can you explain what you mean a bit more?\n",
        "createdAt" : "2015-12-08T17:31:21Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "59952679-b7d0-4a83-970c-1fcc15b155d2",
        "parentId" : "b8f24850-5a8b-47ae-968b-b93927e667f0",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "\"deadline\", to me, identifies a specific point in time. this duration doesn't do that, it only defines a the size of a time window. not a big deal, just think that Deadline suffix is somewhat misleading.\n",
        "createdAt" : "2015-12-08T21:28:32Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "4eccc735-83ad-4ef3-bf28-8c2ecbd6adf2",
        "parentId" : "b8f24850-5a8b-47ae-968b-b93927e667f0",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "We use deadline in the API in the same way that we use it here. The type (duration as opposed to time) should signify the meaning.\n\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/api/types.go#L988\n\nhttps://github.com/kubernetes/kubernetes/blob/master/docs/devel/api-conventions.md#naming-conventions\n",
        "createdAt" : "2015-12-08T21:35:55Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +108,112 @@\t// RenewDeadline is the duration that the acting master will retry\n\t// refreshing leadership before giving up.\n\tRenewDeadline time.Duration\n\t// RetryPeriod is the duration the LeaderElector clients should wait\n\t// between tries of actions."
  },
  {
    "id" : "8e85d027-49b2-4ddb-9092-a963eb376206",
    "prId" : 16830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44d1b880-202c-4c67-81b8-503aaf74a2e9",
        "parentId" : null,
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "It looks like these may be invoked concurrently. Can we document that fact?\n",
        "createdAt" : "2015-12-08T17:24:46Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      },
      {
        "id" : "d6cdaba2-52a9-4fd9-9a0c-5cce5120abbd",
        "parentId" : "44d1b880-202c-4c67-81b8-503aaf74a2e9",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "They are invoked asynchronously\n",
        "createdAt" : "2015-12-08T18:46:11Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "4bb9405f-170a-472d-8d72-d8c247d6e351",
        "parentId" : "44d1b880-202c-4c67-81b8-503aaf74a2e9",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.\n",
        "createdAt" : "2015-12-08T19:28:24Z",
        "updatedAt" : "2015-12-08T21:40:10Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "68cf14695c5acc75dc1fa97d2e1a57e5484fe353",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +118,122 @@}\n\n// LeaderCallbacks are callbacks that are triggered during certain\n// lifecycle events of the LeaderElector. These are invoked asynchronously.\n//"
  }
]
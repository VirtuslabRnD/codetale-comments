[
  {
    "id" : "abbfb4ce-6d33-435b-acef-a3e8313923b8",
    "prId" : 25273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce011fc7-89aa-489f-93d0-a8d088180b70",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Godoc missing for public type.\n",
        "createdAt" : "2016-07-01T10:38:44Z",
        "updatedAt" : "2016-07-13T21:06:20Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b21a9901bcd48bb452d3bf1a0cddc90dae142c4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +36,40 @@// protocols, input/output streams, if the client is requesting a TTY, and a terminal size queue to\n// support terminal resizing.\ntype StreamOptions struct {\n\tSupportedProtocols []string\n\tStdin              io.Reader"
  },
  {
    "id" : "693d1813-bd12-4c25-b452-fe8795482aa3",
    "prId" : 15961,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eaaa3e3c-b5b2-4238-a9b8-6269b7956e6b",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Unit test for this\n",
        "createdAt" : "2015-10-22T19:53:58Z",
        "updatedAt" : "2015-10-23T18:10:05Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "6fddb0e83ac582f7a33c43ea7ac2a073f9ff98c5",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +161,165 @@// Stream opens a protocol streamer to the server and streams until a client closes\n// the connection or the server disconnects.\nfunc (e *streamExecutor) Stream(stdin io.Reader, stdout, stderr io.Writer, tty bool) error {\n\tsupportedProtocols := []string{StreamProtocolV2Name, StreamProtocolV1Name}\n\tconn, protocol, err := e.Dial(supportedProtocols...)"
  },
  {
    "id" : "b129f649-b397-449a-bdc4-de62f1371aa6",
    "prId" : 14618,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a64abd0-b718-4f48-9f09-642cbdc75418",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "This doesn't appear to be used anywhere. Do we need it?\n",
        "createdAt" : "2015-10-07T15:59:42Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "b757a2e2-d0f8-47e8-89e5-a97176b7af50",
        "parentId" : "0a64abd0-b718-4f48-9f09-642cbdc75418",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It's used from OpenShift code - it's the thing that lets you bypass the\nopinionated round tripper we provide\n\nOn Wed, Oct 7, 2015 at 11:59 AM, Andy Goldstein notifications@github.com\nwrote:\n\n> In pkg/client/unversioned/remotecommand/remotecommand.go\n> https://github.com/kubernetes/kubernetes/pull/14618#discussion_r41408836\n> :\n> \n> >  }\n> > \n> > -// NewAttach creates a new RemoteAttach\n> > -func NewAttach(req *client.Request, config *client.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool) *Attach {\n> > -   return &Attach{\n> > -       Streamer: Streamer{\n> > -           req:    req,\n> > -           config: config,\n> > -           stdin:  stdin,\n> > -           stdout: stdout,\n> > -           stderr: stderr,\n> > -           tty:    tty,\n> > -       },\n> >   +// NewStreamExecutor upgrades the request so that it supports multiplexed bidirectional\n> >   +// streams. This method takes a stream upgrader and an optional function that is invoked\n> >   +// to wrap the connection.\n> >   +func NewStreamExecutor(upgrader httpstream.UpgradeRoundTripper, fn func(http.RoundTripper) http.RoundTripper, method string, url *url.URL) (StreamExecutor, error) {\n> \n> This doesn't appear to be used anywhere. Do we need it?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/14618/files#r41408836.\n",
        "createdAt" : "2015-10-07T17:47:05Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ce8683db-8433-4739-81c1-42868dae6cc4",
        "parentId" : "0a64abd0-b718-4f48-9f09-642cbdc75418",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It prevents streamExecutor from being a public type.\n",
        "createdAt" : "2015-10-07T17:47:30Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1be76ff9-af1c-4eb4-81a8-46a7f0827afb",
        "parentId" : "0a64abd0-b718-4f48-9f09-642cbdc75418",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Ok. The usage in OpenShift doesn't pass a `fn`... What was your plan for that?\n",
        "createdAt" : "2015-10-07T19:16:04Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "e93ef691-a227-4db7-ac50-d7e4339afb6b",
        "parentId" : "0a64abd0-b718-4f48-9f09-642cbdc75418",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Wrapping the round tripper.  I'll add a test case to clarify it shouldn't\nbe removed.\n\nOn Oct 7, 2015, at 3:16 PM, Andy Goldstein notifications@github.com wrote:\n\nIn pkg/client/unversioned/remotecommand/remotecommand.go\nhttps://github.com/kubernetes/kubernetes/pull/14618#discussion_r41433112:\n\n>  }\n> \n> -// NewAttach creates a new RemoteAttach\n> -func NewAttach(req *client.Request, config *client.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool) *Attach {\n> - return &Attach{\n> -     Streamer: Streamer{\n> -         req:    req,\n> -         config: config,\n> -         stdin:  stdin,\n> -         stdout: stdout,\n> -         stderr: stderr,\n> -         tty:    tty,\n> -     },\n>   +// NewStreamExecutor upgrades the request so that it supports multiplexed bidirectional\n>   +// streams. This method takes a stream upgrader and an optional function that is invoked\n>   +// to wrap the connection.\n>   +func NewStreamExecutor(upgrader httpstream.UpgradeRoundTripper, fn func(http.RoundTripper) http.RoundTripper, method string, url *url.URL) (StreamExecutor, error) {\n\nOk. The usage in OpenShift doesn't pass a fn... What was your plan for that?\n\n—\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/14618/files#r41433112.\n",
        "createdAt" : "2015-10-07T19:19:02Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "f0a1014f-3331-4374-86d7-8c32111fd09f",
        "parentId" : "0a64abd0-b718-4f48-9f09-642cbdc75418",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Still working on the test case?\n",
        "createdAt" : "2015-10-08T13:09:35Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1b18fbba80ba871d4e1494fbc44a551c99354b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +85,89 @@// to wrap the round tripper. This method may be used by clients that are lower level than\n// Kubernetes clients or need to provide their own upgrade round tripper.\nfunc NewStreamExecutor(upgrader httpstream.UpgradeRoundTripper, fn func(http.RoundTripper) http.RoundTripper, method string, url *url.URL) (StreamExecutor, error) {\n\tvar rt http.RoundTripper = upgrader\n\tif fn != nil {"
  },
  {
    "id" : "dd6c7776-2ffa-42b9-9e55-fb7b8c6c25ca",
    "prId" : 14618,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "453e1adf-1090-40f5-bf77-c2eff3ba7326",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "I don't see anywhere this is used, other than where it's embedded in StreamExecutor below.\n",
        "createdAt" : "2015-10-07T19:12:13Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "0ad6a284-ee9a-4cb6-ae6b-537ab6f97c37",
        "parentId" : "453e1adf-1090-40f5-bf77-c2eff3ba7326",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Please add godoc if we're going to keep this\n",
        "createdAt" : "2015-10-08T13:08:40Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1b18fbba80ba871d4e1494fbc44a551c99354b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +33,37 @@\n// Executor is an interface for transporting shell-style streams.\ntype Executor interface {\n\t// Stream initiates the transport of the standard shell streams. It will transport any\n\t// non-nil stream to a remote system, and return an error if a problem occurs. If tty"
  },
  {
    "id" : "4f95a85c-b4b8-46ee-bb90-dff0c101b862",
    "prId" : 14618,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6977ffa-fbb1-4e38-8898-3db3429e2d58",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Any chance to handle this TODO now?\n",
        "createdAt" : "2015-10-07T19:12:42Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "31f6cc6a-ee66-4b8f-beca-2d0df2fc3d2e",
        "parentId" : "b6977ffa-fbb1-4e38-8898-3db3429e2d58",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Actually, this is handled.\n",
        "createdAt" : "2015-10-07T19:18:27Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "e57fd48f-ed39-4557-9631-54d3bfad6879",
        "parentId" : "b6977ffa-fbb1-4e38-8898-3db3429e2d58",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "I think what's bothering me is that you have port forward code that calls `remotecommand.NewExecutor` just so it can get an `httpstream.Dialer` that you can use to call `Dial()` so you can get an `httpstream.Connection`. None of that is really about \"remote command\", at least not in the \"exec/attach\" sense.\n",
        "createdAt" : "2015-10-07T19:21:12Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "8ebc4807-a092-4369-83aa-250814940a68",
        "parentId" : "b6977ffa-fbb1-4e38-8898-3db3429e2d58",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That's the TODO\n\nOn Wed, Oct 7, 2015 at 3:21 PM, Andy Goldstein notifications@github.com\nwrote:\n\n> In pkg/client/unversioned/remotecommand/remotecommand.go\n> https://github.com/kubernetes/kubernetes/pull/14618#discussion_r41433747\n> :\n> \n> >  }\n> > \n> > -// Executor executes a command on a pod container\n> > -type Executor struct {\n> > -   Streamer\n> > -   command []string\n> >   -}\n> >   +// NewExecutor connects to the provided server and upgrades the connection to\n> >   +// multiplexed bidirectional streams. The current implementation uses SPDY,\n> >   +// but this could be replaced with HTTP/2 once it's available, or something else.\n> >   +// TODO: the common code between this and portforward could be abstracted.\n> \n> I think what's bothering me is that you have port forward code that calls\n> remotecommand.NewExecutor just so it can get an httpstream.Dialer that\n> you can use to call Dial() so you can get an httpstream.Connection. None\n> of that is really about \"remote command\", at least not in the \"exec/attach\"\n> sense.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/14618/files#r41433747.\n",
        "createdAt" : "2015-10-07T20:49:51Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1b18fbba80ba871d4e1494fbc44a551c99354b",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +60,64 @@// multiplexed bidirectional streams. The current implementation uses SPDY,\n// but this could be replaced with HTTP/2 once it's available, or something else.\n// TODO: the common code between this and portforward could be abstracted.\nfunc NewExecutor(config *client.Config, method string, url *url.URL) (StreamExecutor, error) {\n\ttlsConfig, err := client.TLSConfigFor(config)"
  },
  {
    "id" : "3efa30cd-7a28-4933-8741-df3f6924e7ae",
    "prId" : 14618,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "109bd19c-d440-43ee-83a3-ce2f8930f27c",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "How would you feel about doing something like pkg/client/unversioned/streaming and have a Dialer that returns httpstream.Connection, and a either an Executor or Streamer that takes in an httpstream.Connection and lets you Stream() stdin/stdout/stderr?\n",
        "createdAt" : "2015-10-07T19:40:11Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "ae1df485-c0a3-41b1-b5ed-c5d89eb7ecb2",
        "parentId" : "109bd19c-d440-43ee-83a3-ce2f8930f27c",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I was trying to keep the refactor minimal to move things in the right\ndirection.  That's a big chunk more work on top - I'd prefer to start the\ncleanup and move it along, vs trying to change everything with exec.\n\nOn Wed, Oct 7, 2015 at 3:40 PM, Andy Goldstein notifications@github.com\nwrote:\n\n> In pkg/client/unversioned/remotecommand/remotecommand.go\n> https://github.com/kubernetes/kubernetes/pull/14618#discussion_r41435886\n> :\n> \n> >  }\n> > \n> > ## -type defaultUpgrader struct{}\n> > \n> > -func (u *defaultUpgrader) upgrade(req *client.Request, config *client.Config) (httpstream.Connection, error) {\n> > -   return req.Upgrade(config, spdy.NewRoundTripper)\n> >   +type StreamExecutor interface {\n> \n> How would you feel about doing something like\n> pkg/client/unversioned/streaming and have a Dialer that returns\n> httpstream.Connection, and a either an Executor or Streamer that takes in\n> an httpstream.Connection and lets you Stream() stdin/stdout/stderr?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/14618/files#r41435886.\n",
        "createdAt" : "2015-10-07T20:50:36Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "0bbdfcd7-4a12-4b8f-a851-3b6aba591a63",
        "parentId" : "109bd19c-d440-43ee-83a3-ce2f8930f27c",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Godoc\n",
        "createdAt" : "2015-10-08T13:08:56Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1b18fbba80ba871d4e1494fbc44a551c99354b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +43,47 @@// StreamExecutor supports the ability to dial an httpstream connection and the ability to\n// run a command line stream protocol over that dialer.\ntype StreamExecutor interface {\n\tExecutor\n\thttpstream.Dialer"
  },
  {
    "id" : "44609a5d-c4b1-49ce-b3ec-de3316b997cf",
    "prId" : 14618,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "faf7a2c3-ec47-4dcf-943e-016f412d690a",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Godoc\n",
        "createdAt" : "2015-10-08T13:08:48Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1b18fbba80ba871d4e1494fbc44a551c99354b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +38,42 @@\t// is set, the stderr stream is not used (raw TTY manages stdout and stderr over the\n\t// stdout stream).\n\tStream(stdin io.Reader, stdout, stderr io.Writer, tty bool) error\n}\n"
  },
  {
    "id" : "a80e2026-9c17-4bfe-bd53-f14001b6d748",
    "prId" : 14618,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a72e9803-2ab7-4e5d-ac2c-e8206e51b2a9",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "+1 to negotiation. For example, I want to add support for SIGWINCH which will require a new stream for exec, and that obviously won't work for older clients.\n",
        "createdAt" : "2015-10-08T13:10:37Z",
        "updatedAt" : "2015-10-09T18:34:51Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1b18fbba80ba871d4e1494fbc44a551c99354b",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +113,117 @@\tdefer resp.Body.Close()\n\n\t// TODO: handle protocol selection in the future\n\treturn e.upgrader.NewConnection(resp)\n}"
  },
  {
    "id" : "53af9624-33b8-41cc-8a4a-ea9b9dfee19b",
    "prId" : 13058,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b95237a0-fc3d-447e-97c7-ca323845237d",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "waiting here means a hung stdout/stderr stream can keep us from returning, even if we encountered an error\n",
        "createdAt" : "2015-08-25T20:04:20Z",
        "updatedAt" : "2015-09-10T21:33:35Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "04f8acd8-f567-47dd-8e42-dbcf0ef6b3f4",
        "parentId" : "b95237a0-fc3d-447e-97c7-ca323845237d",
        "authorId" : "e17c0720-a868-4134-a8e1-a3896b8caa8b",
        "body" : "That was the original intended behaviour. What do you suggest instead of waiting?\n",
        "createdAt" : "2015-08-25T20:31:58Z",
        "updatedAt" : "2015-09-10T21:33:35Z",
        "lastEditedBy" : "e17c0720-a868-4134-a8e1-a3896b8caa8b",
        "tags" : [
        ]
      },
      {
        "id" : "efd74fee-187a-4779-b97b-272b70f08205",
        "parentId" : "b95237a0-fc3d-447e-97c7-ca323845237d",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "more noting the change than objecting to it... I like waiting for all three streams, but I wasn't sure if there was a situation where an error propagated via the errorStream was expected to exit early and save us from a hung stderr/stdout stream\n",
        "createdAt" : "2015-08-25T21:02:03Z",
        "updatedAt" : "2015-09-10T21:33:35Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d15de72a92c8841d069b1265e433eb52edc29822",
    "line" : null,
    "diffHunk" : "@@ -1,1 +259,263 @@\n\t// we're waiting for stdout/stderr to finish copying\n\twg.Wait()\n\n\t// waits for errorStream to finish reading with an error or nil"
  }
]
[
  {
    "id" : "5a5b40a0-7bee-4bdc-a146-a96f5f805bd4",
    "prId" : 10557,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efa3ac29-3a51-41a5-a5be-a534052ae450",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Not sure about this. Does basicAuthRoundTripper need it too? Maybe you should make a maybeAuth round tripper that can be inserted in the roundTripper stack?\n",
        "createdAt" : "2015-07-01T17:49:58Z",
        "updatedAt" : "2015-07-01T20:14:24Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "e94dd2b8-d23e-4e3b-abc8-f8f1be81484c",
        "parentId" : "efa3ac29-3a51-41a5-a5be-a534052ae450",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "At the very least, can you repeat your commit message as a comments here, and better yet, add it as a godoc for NewBearerAuthRoundTripper?\n",
        "createdAt" : "2015-07-01T17:50:33Z",
        "updatedAt" : "2015-07-01T20:14:24Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "cca92fe2-9221-4de2-93a2-4aeadf026e2b",
        "parentId" : "efa3ac29-3a51-41a5-a5be-a534052ae450",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Sure\n\nOn Wed, Jul 1, 2015 at 1:50 PM, Daniel Smith notifications@github.com\nwrote:\n\n> In pkg/client/transport.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/10557#discussion_r33704545\n> :\n> \n> > @@ -68,6 +68,10 @@ func NewBearerAuthRoundTripper(bearer string, rt http.RoundTripper) http.RoundTr\n> >  }\n> > \n> >  func (rt _bearerAuthRoundTripper) RoundTrip(req *http.Request) (_http.Response, error) {\n> > -   if len(req.Header.Get(\"Authorization\")) != 0 {\n> \n> At the very least, can you repeat your commit message as a comments here,\n> and better yet, add it as a godoc for NewBearerAuthRoundTripper?\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/10557/files#r33704545\n> .\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-07-01T19:00:55Z",
        "updatedAt" : "2015-07-01T20:14:24Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e7526fc18ca6c19518649230f95fef28cdec6fa",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +76,80 @@\nfunc (rt *bearerAuthRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {\n\tif len(req.Header.Get(\"Authorization\")) != 0 {\n\t\treturn rt.rt.RoundTrip(req)\n\t}"
  },
  {
    "id" : "209d9704-108c-4c86-9cf0-dfd0fb0495f2",
    "prId" : 3959,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "059e2c0d-dab6-4afd-915a-6344a6dfe0a1",
        "parentId" : null,
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Shouldn't this case be `hasCert && hasCA`? `NewClientCertTLSConfig` requires both.\n",
        "createdAt" : "2015-01-30T23:52:55Z",
        "updatedAt" : "2015-01-30T23:52:55Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      },
      {
        "id" : "06185a28-ea72-40b6-aade-50a1dcf80941",
        "parentId" : "059e2c0d-dab6-4afd-915a-6344a6dfe0a1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The original code here (if I remember correctly) is - you told us you wanted insecure, but then you gave us a CA.  You can't do both, because CA without verify is pointless.\n\n----- Original Message -----\n\n> > @@ -54,44 +54,84 @@ func (rt _bearerAuthRoundTripper) RoundTrip(req\n> > *http.Request) (_http.Response,\n> >     return rt.rt.RoundTrip(req)\n> >  }\n> > \n> > -func NewClientCertTLSTransport(certData, keyData, caData []byte)\n> > (_http.Transport, error) {\n> > +// TLSConfigFor returns a tls.Config that will provide the transport level\n> > security defined\n> > +// by the provided Config. Will return nil if no transport level security\n> > is requested.\n> > +func TLSConfigFor(config *Config) (_tls.Config, error) {\n> > -   hasCA := len(config.CAFile) > 0 || len(config.CAData) > 0\n> > -   hasCert := len(config.CertFile) > 0 || len(config.CertData) > 0\n> >   +\n> > -   if hasCA && config.Insecure {\n> > -       return nil, fmt.Errorf(\"specifying a root certificates file with the\n> >   insecure flag is not allowed\")\n> > -   }\n> > -   var tlsConfig *tls.Config\n> > -   switch {\n> > -   case hasCert:\n> \n> Shouldn't this case be `hasCert && hasCA`? `NewClientCertTLSConfig` requires\n> both.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/3959/files#r23881524\n",
        "createdAt" : "2015-01-31T00:07:45Z",
        "updatedAt" : "2015-01-31T00:07:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a27c715b-0df4-4723-a78d-51ff9dbadff9",
        "parentId" : "059e2c0d-dab6-4afd-915a-6344a6dfe0a1",
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Ah, on second look this is desired behavior. I had thought the cases should be\n\n```\nswitch {\ncase hasCert && hasCA:\n..\ncase hasCA:\n...\ncase config.Insecure:\n...\n```\n\nSince the hasCert case will error out if there is no CA, but that's intended, vs silently switching to a plain http transport.\n",
        "createdAt" : "2015-01-31T00:18:58Z",
        "updatedAt" : "2015-01-31T00:18:58Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      }
    ],
    "commit" : "d072232d4a6352459aabb374cf7e78600e9e37e1",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +66,70 @@\tvar tlsConfig *tls.Config\n\tswitch {\n\tcase hasCert:\n\t\tcertData, err := dataFromSliceOrFile(config.CertData, config.CertFile)\n\t\tif err != nil {"
  }
]
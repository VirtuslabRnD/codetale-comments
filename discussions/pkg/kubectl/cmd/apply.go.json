[
  {
    "id" : "fdad9007-8ae0-42c4-8cbd-f6be37a190d8",
    "prId" : 66602,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/66602#pullrequestreview-140709055",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a3116c3-651b-4de5-98a0-3678b59529a7",
        "parentId" : null,
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : " super nit: @dixudx how do you think about pruing `err != nil` here? it might be unneccesary to do the nil value check here because neither `IsConflict ` or `IsInvalid ` would return true on a nil error AFAICT. Not really sure if the additional judge here is for a better human-read :)",
        "createdAt" : "2018-07-25T16:13:23Z",
        "updatedAt" : "2018-08-09T14:59:19Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      },
      {
        "id" : "6e2423fa-bb39-4a4b-9467-3bc0a8a85bdb",
        "parentId" : "8a3116c3-651b-4de5-98a0-3678b59529a7",
        "authorId" : "3c1422a0-6358-4857-8f56-961979171514",
        "body" : "@yue9944882 Although both `IsConflict` and `IsInvalid` return `False` for `nil.(Type)`, I'd prefer to keep it for several reasons,\r\n\r\n1. Like you said, for better human readable and code convention.\r\n2. `ReasonForError(nil)` will return `StatusReasonUnknown`, which is not right and confusing. `Nil` is different from status code 500.",
        "createdAt" : "2018-07-26T12:31:22Z",
        "updatedAt" : "2018-08-09T14:59:19Z",
        "lastEditedBy" : "3c1422a0-6358-4857-8f56-961979171514",
        "tags" : [
        ]
      },
      {
        "id" : "761f41fd-0adb-4810-afe6-c83f77dbca8b",
        "parentId" : "8a3116c3-651b-4de5-98a0-3678b59529a7",
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "reasonable :)",
        "createdAt" : "2018-07-26T12:44:25Z",
        "updatedAt" : "2018-08-09T14:59:19Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      }
    ],
    "commit" : "0af6faed09535ba2763c07e25ac9402cd1f7270e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +754,758 @@\t\tpatchBytes, patchObject, err = p.patchSimple(current, modified, source, namespace, name, errOut)\n\t}\n\tif err != nil && (errors.IsConflict(err) || errors.IsInvalid(err)) && p.force {\n\t\tpatchBytes, patchObject, err = p.deleteAndCreate(current, modified, namespace, name)\n\t}"
  },
  {
    "id" : "d8cc3782-7293-406f-8d0e-45931735e076",
    "prId" : 62664,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62664#pullrequestreview-112568810",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9f29297-bada-4bca-8612-aa4a5ba65d32",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "much better",
        "createdAt" : "2018-04-16T20:08:38Z",
        "updatedAt" : "2018-04-16T20:53:21Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "813a854b99cbb93cd69cb821df29411fb419bcd1",
    "line" : 157,
    "diffHunk" : "@@ -1,1 +300,304 @@\t\t}\n\n\t\tif err := o.Recorder.Record(info.Object); err != nil {\n\t\t\tglog.V(4).Infof(\"error recording current command: %v\", err)\n\t\t}"
  },
  {
    "id" : "99c708e4-1788-4ce0-8cae-ab8a2d9b70fa",
    "prId" : 51321,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51321#pullrequestreview-74950013",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d655a7f3-2f68-4840-ac73-fa728a7e788b",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this introduces a failure mode that does not fall back to struct info gracefully",
        "createdAt" : "2017-10-30T13:48:02Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e13a6cfb-ee31-45e5-befd-686acb9b8881",
        "parentId" : "d655a7f3-2f68-4840-ac73-fa728a7e788b",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "Fixed. Thanks for catching this.",
        "createdAt" : "2017-10-30T20:01:18Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "505d4f11-9ac3-49fa-ab58-94c450f34b1a",
        "parentId" : "d655a7f3-2f68-4840-ac73-fa728a7e788b",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Fixed. Thanks for catching this.\r\n\r\nthis means there was no test for this case, right? should add one to ensure we don't regress.",
        "createdAt" : "2017-10-30T20:06:00Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "c6af870e-097f-4adc-a7de-a9df0f6f7587",
        "parentId" : "d655a7f3-2f68-4840-ac73-fa728a7e788b",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "I will add a test for it.",
        "createdAt" : "2017-10-30T23:11:29Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "140babc2-57a8-4520-9314-d3933079c7bc",
        "parentId" : "d655a7f3-2f68-4840-ac73-fa728a7e788b",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "Done. Add test cases that return error when fetching openapi spec.",
        "createdAt" : "2017-11-07T23:48:37Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      }
    ],
    "commit" : "be20a6753748bbece8c07fd9dfc9e31e22c06dfc",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +199,203 @@\tvar openapiSchema openapi.Resources\n\tif cmdutil.GetFlagBool(cmd, \"openapi-patch\") {\n\t\topenapiSchema, err = f.OpenAPISchema()\n\t\tif err != nil {\n\t\t\topenapiSchema = nil"
  },
  {
    "id" : "3012d411-d59a-43b7-96a6-2e169df58a20",
    "prId" : 51321,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51321#pullrequestreview-78026338",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f5743c4-be13-4ccb-a7a2-63bb6854729d",
        "parentId" : null,
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "@pwittrock FYI, right now the flag is called `openapi-patch` and is enabled by default.",
        "createdAt" : "2017-11-15T22:09:21Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "3a830d20-16ee-4faf-9137-513fcc24ab1a",
        "parentId" : "8f5743c4-be13-4ccb-a7a2-63bb6854729d",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "\"Use openapi schema information from the server to build the update patch when possible\"?",
        "createdAt" : "2017-11-21T08:16:36Z",
        "updatedAt" : "2017-11-21T18:25:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "be20a6753748bbece8c07fd9dfc9e31e22c06dfc",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +130,134 @@\tcmd.Flags().Bool(\"all\", false, \"Select all resources in the namespace of the specified resource types.\")\n\tcmd.Flags().StringArray(\"prune-whitelist\", []string{}, \"Overwrite the default whitelist with <group/version/kind> for --prune\")\n\tcmd.Flags().Bool(\"openapi-patch\", true, \"If true, use openapi to calculate diff when the openapi presents and the resource can be found in the openapi spec. Otherwise, fall back to use baked-in types.\")\n\tcmdutil.AddDryRunFlag(cmd)\n\tcmdutil.AddPrinterFlags(cmd)"
  },
  {
    "id" : "01f1743a-1c2a-47ec-8517-1729bcd76a55",
    "prId" : 51321,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51321#pullrequestreview-80697517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is there any indication in the discovery doc that the resource supports strategic merge patch? I would not assume the mere presence of an openapi schema to mean SMP is supported.",
        "createdAt" : "2017-11-30T15:06:05Z",
        "updatedAt" : "2017-11-30T15:39:38Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8b6f02f6-0506-4f05-af61-800d48e832c7",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "I guess this question is related to the discussion https://github.com/kubernetes/kubernetes/pull/56606#issuecomment-348202176.\r\n\r\n> is there any indication in the discovery doc that the resource supports strategic merge patch?\r\n\r\nI don't think there is an explicit indicator.\r\nIf there are patch metadata (e.g. PatchStrategy, MergeKey) in the discovery doc, then this type supports SMP. But if there is not patch metadata, the type may still support SMP and it uses the default behavior(replacing lists).\r\n\r\n> I would not assume the mere presence of an openapi schema to mean SMP is supported.\r\n\r\nIt's not clear what does `SMP is supported` mean.\r\nIf a type and its schema appear in the openapi schema with no patch metadada, SMP will process it with the default approach (replacing a list). It should not do anything wrong.\r\n\r\nDid I miss anything?\r\n",
        "createdAt" : "2017-11-30T18:40:35Z",
        "updatedAt" : "2017-11-30T18:40:35Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "28162633-5b76-48ff-a60c-c219d2f0ebc6",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Yes, it assumes every API server that publishes openapi schemas is able to accept strategic merge patches. Previously, the client only assumed that compiled-in known core kubernetes types were served by a server supporting SMP.",
        "createdAt" : "2017-11-30T18:45:52Z",
        "updatedAt" : "2017-11-30T18:45:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9af58138-c132-4949-b5db-7bdf2d32778e",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "Let me summarize it for SMP\r\n\r\nBefore this PR:\r\nOnly compiled-in types (native k8s api resources) are supported.\r\nNo support for user-defined api resource no support for CRD.\r\n\r\nAfter this PR:\r\nThere are 2 approaches:\r\nUsing baked-in types: only support native k8s api resources\r\nUsing openapi schema: support native k8s api resources and user-defined api resource. But no support for CRD.\r\n\r\nCorrect me if anything is wrong.",
        "createdAt" : "2017-11-30T20:42:23Z",
        "updatedAt" : "2017-11-30T20:42:23Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "aa521255-1eb4-4dcd-a8eb-6f916910b9c1",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Using openapi schema: support native k8s api resources and user-defined api resource\r\n\r\nIt assumes user-defined api resources support strategic merge patch",
        "createdAt" : "2017-11-30T20:56:07Z",
        "updatedAt" : "2017-11-30T20:56:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "bf3e423a-543a-44b4-800b-08a4198b5065",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "> It assumes user-defined api resources support strategic merge patch\r\n\r\nYes. Even though there may be no patch metadata defined in user-defined api resources, SMP will simply use default behavior which is similar to JSON merge patch as long as it has openapi schema.\r\n\r\nI don't understand in what scenario this may be a problem. Can you clarify your concern?",
        "createdAt" : "2017-11-30T21:25:56Z",
        "updatedAt" : "2017-11-30T21:25:56Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "092eeca4-1b4a-47bb-b009-7fdf6ea1f5ad",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> I don't understand in what scenario this may be a problem. Can you clarify your concern?\r\n\r\nThis is not checking the \"consumes\" portion of the published openapi spec to see if strategic merge patches are accepted. If the patch operation on the resource does not indicate it consumes \"application/strategic-merge-patch+json\", we shouldn't assume we can send it a strategic merge patch.\r\n\r\n```\r\n    \"patch\": {\r\n     \"description\": \"partially update the specified ConfigMap\",\r\n     \"consumes\": [\r\n      \"application/json-patch+json\",\r\n      \"application/merge-patch+json\",\r\n      \"application/strategic-merge-patch+json\"\r\n     ],\r\n```\r\n\r\nThe same is actually true for json merge patch as well, but it is *far* more trivial for a server to support json merge patch than strategic merge patch (and that was the behavior prior to this PR, which meant that servers for arbitrary types only had to support json merge patch)\r\n\r\nBasically, if we're going to use schema discovery, we should use it correctly and make sure we can send the patch type, rather than assuming",
        "createdAt" : "2017-11-30T21:32:23Z",
        "updatedAt" : "2017-11-30T21:43:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d596a57e-b822-4043-a107-43d2c64bcc67",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "Got your point now. \r\n\r\nDo you think that checking server accepted types logic is necessary for 1.9 release? If so, I will start to work on that today.",
        "createdAt" : "2017-11-30T21:53:12Z",
        "updatedAt" : "2017-11-30T21:53:12Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "20cdaa10-009d-4791-ab83-85db4e5d3b6a",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "If we want to start sending SMP requests based on openapi schemas, yes",
        "createdAt" : "2017-11-30T21:56:18Z",
        "updatedAt" : "2017-11-30T21:56:18Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b36e2fee-ac50-4cf4-9ca3-210facca6c6d",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Did this PR change whether kubectl sends a SMP vs a JP based on the presence of openapi data?",
        "createdAt" : "2017-12-01T01:01:09Z",
        "updatedAt" : "2017-12-01T01:01:09Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "1391cd40-c6ce-4cc2-b9c9-736e128bf97f",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Yes. Previously, non-compiled types would send JP. Now if there is an openapi schema, it sends SMP unless it errors building the patch. It should also check for consumes SMP type patch",
        "createdAt" : "2017-12-01T01:17:06Z",
        "updatedAt" : "2017-12-01T01:17:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "fd154f13-c2d3-4c7c-a13c-aeac74b573d6",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "There is a potential simpler way to make this work:\r\n- construct the SMP from openapi schema even for a non-compiled type\r\n- send it to the server with MIME type: SMP\r\n- server reject it and return some HTTP error code (maybe 406)\r\n- retry with the JMP\r\n\r\nIs this way acceptable?\r\n",
        "createdAt" : "2017-12-01T01:24:25Z",
        "updatedAt" : "2017-12-01T01:24:25Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "cb64d09d-64a5-4b07-8daa-0b66465b3a25",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "That doesn't sound simpler than using the information about the accepted mime types that is in the discovery doc we already have here. That's not how we do other negotiation (e.g. \"send various versions of an API object until we find one the server doesn't return an http error for\")",
        "createdAt" : "2017-12-01T01:32:39Z",
        "updatedAt" : "2017-12-01T02:09:28Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9b45639a-07d3-4c49-9c59-da04ac369143",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I agree with a jordan here.  Mime type negotiation exists for a reason.  We shouldnâ€™t invent a new way to do something that already exists.",
        "createdAt" : "2017-12-01T02:09:08Z",
        "updatedAt" : "2017-12-01T02:09:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c10b4c7b-6319-44ab-b488-eab0c74684f0",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "I agree the best practice should be MIME type negotiation.\r\n\r\nBut to do MIME type negotiation, we need to parse the `endpoints` part of openapi schema.\r\nThere is no facility to support parsing the `endpoints` part of openapi schema, we only have the code to parse the `models` part. \r\nSo we will need to introduce quite some new code to support that. So this way will require much more efforts than the approach I mentioned above. \r\nIMO it may be risky to introduce a lot of new code at this point.\r\n",
        "createdAt" : "2017-12-01T04:50:20Z",
        "updatedAt" : "2017-12-01T04:50:20Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "13533afe-f924-411c-b3a2-d19d1d9d2e38",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> But to do MIME type negotiation, we need to parse the endpoints part of openapi schema.\r\n\r\nIf we want to use openapi docs dynamically to form patch requests, I think that's what we need to do.\r\n\r\n> So this way will require much more efforts than the approach I mentioned above.\r\n> IMO it may be risky to introduce a lot of new code at this point.\r\n\r\nI agree it is more effort, but I have a hard time accepting the \"if at first you don't succeed\" negotiation approach when we've already been given exactly the information we need to know what patch types are accepted\r\n\r\n> and is risky at this point\r\n\r\nI also agree with this. Which is better at this point for this release?\r\n* attempting multiple patch types falling back to merge patch if SMP is rejected with 406?\r\n* defaulting this feature off\r\n* disabling this feature\r\n\r\nWhatever we choose for the moment, we should work to make use of the accepted content in the next release.",
        "createdAt" : "2017-12-01T05:13:00Z",
        "updatedAt" : "2017-12-01T05:13:00Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a65acc78-ee3e-44fd-86e1-d548463280c2",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "body" : "Can we: send SMP if the type is registered, JMP otherwise? AFAIU that wouldn't really change the existing behavior (before that pull-request), yet exercise that code and already have some benefits?",
        "createdAt" : "2017-12-01T05:42:52Z",
        "updatedAt" : "2017-12-01T05:43:02Z",
        "lastEditedBy" : "a139439a-9f9e-4518-b4f3-9c602d956c57",
        "tags" : [
        ]
      },
      {
        "id" : "4ded2e66-70eb-441b-aa1a-a794cccb0e22",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "This is a good example of why we need libraries that combine the discovery and openapi information for each resource type.  We need and abstraction that hides the specific source of metadata for the resources.\r\n\r\n@liggitt What do you recommend for 1.9?  Disable or try to get a fix in?",
        "createdAt" : "2017-12-01T18:59:09Z",
        "updatedAt" : "2017-12-01T18:59:09Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "acf1770e-cb51-4a8a-a7c0-59675d8d3232",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "I'm leaning to what @apelisse suggested in https://github.com/kubernetes/kubernetes/pull/51321#discussion_r154271945.\r\nIt should be a trivial change with fewer than 50 lines of code change.\r\n",
        "createdAt" : "2017-12-01T19:17:15Z",
        "updatedAt" : "2017-12-01T19:17:15Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "19f129a0-3031-4d68-828e-e96180f0d64e",
        "parentId" : "bfdf321b-35f7-46e6-b4e6-c33c30e15065",
        "authorId" : "54f3e5e9-1cb7-407a-b12d-39bb41fa5e9e",
        "body" : "hi @liggitt @mengqiy about the MIME type negotiation part is that means we check the \"consumes\" portion of a related resource in discovery doc, if it support, then use SMP, if not use JMP.  if so what we need maybe in 1.10 is to add the function as @mengqiy memtioned\r\n\r\n>But to do MIME type negotiation, we need to parse the endpoints part of openapi schema.\r\nThere is no facility to support parsing the endpoints part of openapi schema, we only have the code to parse the models part. \r\n\r\nso all we have to do is make `NewOpenAPIData` also return `paths` and add some lookup/indication function ?  @mengqiy @apelisse  I would like to take a look of adding this openapi helper function if you haven't yet.\r\n\r\n>This is a good example of why we need libraries that combine the discovery and openapi information for each resource type. We need and abstraction that hides the specific source of metadata for the resources.\r\n\r\nThis also sounds interesting, but I haven't got the idea of \"combine\" @pwittrock could you explain more ? thanks",
        "createdAt" : "2017-12-03T10:28:56Z",
        "updatedAt" : "2017-12-03T10:29:28Z",
        "lastEditedBy" : "54f3e5e9-1cb7-407a-b12d-39bb41fa5e9e",
        "tags" : [
        ]
      }
    ],
    "commit" : "be20a6753748bbece8c07fd9dfc9e31e22c06dfc",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +608,612 @@\t// Otherwise, fall back to baked-in types.\n\tif p.openapiSchema != nil {\n\t\tif schema = p.openapiSchema.LookupResource(p.mapping.GroupVersionKind); schema != nil {\n\t\t\tlookupPatchMeta = strategicpatch.PatchMetaFromOpenAPI{Schema: schema}\n\t\t\tif openapiPatch, err := strategicpatch.CreateThreeWayMergePatch(original, modified, current, lookupPatchMeta, p.overwrite); err != nil {"
  },
  {
    "id" : "53e427ef-4519-48ff-af45-4a7e359e5306",
    "prId" : 47204,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47204#pullrequestreview-43878040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e8c3cde-f51c-4044-a4e3-9b7b4ef30a87",
        "parentId" : null,
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "```\r\npatchBytes, patchedObject, err := patcher.patch(info.Object, modified, info.Source, info.Namespace, info.Name)\r\n```\r\nIt seems that patch is using `info.Object`. If storing the change in `info.VersionedObject`, it will cause the annotation missing when calculating the patch, right?",
        "createdAt" : "2017-06-13T21:31:27Z",
        "updatedAt" : "2017-06-13T21:31:32Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      },
      {
        "id" : "f4bbef04-65f6-4c27-8702-39c7dd7e8589",
        "parentId" : "2e8c3cde-f51c-4044-a4e3-9b7b4ef30a87",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Actually, both `info.Object` and `info.VersionedObject` are updated with the annotation (otherwise the test-cmd would have failed). It seems that changes made to meta.Accessor affect both objects.",
        "createdAt" : "2017-06-13T22:38:28Z",
        "updatedAt" : "2017-06-13T22:38:28Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "f8c10db8-36dc-48ac-bb7f-6574156847cd",
        "parentId" : "2e8c3cde-f51c-4044-a4e3-9b7b4ef30a87",
        "authorId" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "body" : "NVM\r\nIt's fine. The `record` change is actually in `modified`. And it is handled correctly by function `GetModifiedConfiguration`.",
        "createdAt" : "2017-06-13T23:02:55Z",
        "updatedAt" : "2017-06-13T23:02:56Z",
        "lastEditedBy" : "cdb05f24-d700-4d96-a683-3e4de7effbf5",
        "tags" : [
        ]
      }
    ],
    "commit" : "03af5233bd00f5a9aa7540d5d69bc610eb040657",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +243,247 @@\t\t// Add change-cause annotation to resource info if it should be recorded\n\t\tif cmdutil.ShouldRecord(cmd, info) {\n\t\t\trecordInObj := info.VersionedObject\n\t\t\tif info.VersionedObject == nil {\n\t\t\t\trecordInObj = info.Object"
  },
  {
    "id" : "f5e49ac9-1ca6-4242-8f49-a875678af13e",
    "prId" : 38112,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38112#pullrequestreview-11698977",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83f3b390-a03e-4f05-a4dc-9841c63d670f",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Please extract this code into `pkg/kubectl` - appears to be identical across all three.",
        "createdAt" : "2016-12-06T15:56:36Z",
        "updatedAt" : "2016-12-12T21:09:33Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "7440595f-7fda-4b35-a0bb-4e2479b419ea",
        "parentId" : "83f3b390-a03e-4f05-a4dc-9841c63d670f",
        "authorId" : "0385dfd1-e8a7-41a8-8213-eabe697d14cd",
        "body" : "@smarterclayton done! extracted this out to `kubectl/cmd/util/printing.go` PTAL",
        "createdAt" : "2016-12-06T22:39:25Z",
        "updatedAt" : "2016-12-12T21:09:33Z",
        "lastEditedBy" : "0385dfd1-e8a7-41a8-8213-eabe697d14cd",
        "tags" : [
        ]
      }
    ],
    "commit" : "cbe479039b04095f1af606166cbd6d2ad5b0e723",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +254,258 @@\n\t\t\tcount++\n\t\t\tif len(output) > 0 && !shortOutput {\n\t\t\t\treturn cmdutil.PrintResourceInfoForCommand(cmd, info, f, out)\n\t\t\t}"
  },
  {
    "id" : "efbf995e-ffa6-4d87-b829-95d298d232cc",
    "prId" : 37397,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/37397#pullrequestreview-9968439",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8fa684c2-7fe1-43f9-9cb1-8154f4e50aca",
        "parentId" : null,
        "authorId" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "body" : "Beside the prune part, this command will only apply objects in manifest.yaml that match label `app=nginx`. Feel like this comment does not say it clearly.",
        "createdAt" : "2016-11-24T01:20:56Z",
        "updatedAt" : "2016-11-28T17:53:10Z",
        "lastEditedBy" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f32b48b25985dff2edd86ee449f3391dd31104e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +83,87 @@\t\t# Note: --prune is still in Alpha\n\t\t# Apply the configuration in manifest.yaml that matches label app=nginx and delete all the other resources that are not in the file and match label app=nginx.\n\t\tkubectl apply --prune -f manifest.yaml -l app=nginx\n\n\t\t# Apply the configuration in manifest.yaml and delete all the other configmaps that are not in the file."
  },
  {
    "id" : "c36c9e3d-3e40-4645-8321-db6562b14de4",
    "prId" : 34836,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34836#pullrequestreview-4381629",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7ea7adb-0f26-4079-b707-293750807eae",
        "parentId" : null,
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Optional but maybe add a warning here for falling back to non cascading deletion?\n",
        "createdAt" : "2016-10-16T00:19:57Z",
        "updatedAt" : "2016-10-16T00:20:23Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "c17a8a773d7def92b3b61a1acd671d3435693358",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +355,359 @@\t\t\treturn err\n\t\t}\n\t\treturn resource.NewHelper(c, mapping).Delete(namespace, name)\n\t}\n\tif err := r.Stop(namespace, name, 2*time.Minute, api.NewDeleteOptions(int64(p.gracePeriod))); err != nil {"
  },
  {
    "id" : "0fd25004-b850-4e2e-a559-ec773088aa0e",
    "prId" : 34028,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34028#pullrequestreview-3844806",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a4f041f-10f5-4589-8185-9f5a1704fb85",
        "parentId" : null,
        "authorId" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "body" : "what's output of this? The resource is not actually created.\n",
        "createdAt" : "2016-10-11T23:54:10Z",
        "updatedAt" : "2016-10-12T20:48:35Z",
        "lastEditedBy" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "tags" : [
        ]
      },
      {
        "id" : "53d127b0-a648-4b18-9549-95babb4ef7de",
        "parentId" : "9a4f041f-10f5-4589-8185-9f5a1704fb85",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : "The use of this function is my suggestion. Generally, you'll get a similar output to running that command without `--dry-run` flag, iow. it'll print you `resource X created` w/wo `(dry run)` at the end. \n",
        "createdAt" : "2016-10-12T10:18:29Z",
        "updatedAt" : "2016-10-12T20:48:35Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      }
    ],
    "commit" : "63e0279d93da0f44319ae38c36d697e4fd706042",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +212,216 @@\n\t\t\tcount++\n\t\t\tcmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, dryRun, \"created\")\n\t\t\treturn nil\n\t\t}"
  },
  {
    "id" : "c9033e0f-08c0-4b1b-9005-6e59fc62cc04",
    "prId" : 34028,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34028#pullrequestreview-3787663",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59dc07fb-2a5e-4cf1-8042-c1bfa0b8c2bd",
        "parentId" : null,
        "authorId" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "body" : "the same.\n",
        "createdAt" : "2016-10-11T23:54:22Z",
        "updatedAt" : "2016-10-12T20:48:35Z",
        "lastEditedBy" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "tags" : [
        ]
      }
    ],
    "commit" : "63e0279d93da0f44319ae38c36d697e4fd706042",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +244,248 @@\t\t}\n\t\tcount++\n\t\tcmdutil.PrintSuccess(mapper, shortOutput, out, info.Mapping.Resource, info.Name, dryRun, \"configured\")\n\t\treturn nil\n\t})"
  },
  {
    "id" : "4b4435f6-b7f5-4557-a789-de68caefbacc",
    "prId" : 33075,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33075#pullrequestreview-752557",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f600d13f-dc69-4923-84cc-47283c49fbc9",
        "parentId" : null,
        "authorId" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "body" : "Would it be more user-friendly to say \"Wait forever if negative.\"? (Given I even understood this correctly).\n",
        "createdAt" : "2016-09-20T08:32:32Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "tags" : [
        ]
      },
      {
        "id" : "12eb8e99-612e-455d-ac9f-fe511ce58639",
        "parentId" : "f600d13f-dc69-4923-84cc-47283c49fbc9",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "It's actually defaulted by the apiserver, not wait forever but I can say something to that effect\n",
        "createdAt" : "2016-09-20T14:01:01Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "62960aace74ef097546f17ff7550c53b9dcb9b98",
    "line" : null,
    "diffHunk" : "@@ -1,1 +98,102 @@\tcmd.Flags().BoolVar(&options.Prune, \"prune\", false, \"Automatically delete resource objects that do not appear in the configs\")\n\tcmd.Flags().BoolVar(&options.Cascade, \"cascade\", true, \"Only relevant during a prune. If true, cascade the deletion of the resources managed by pruned resources (e.g. Pods created by a ReplicationController).\")\n\tcmd.Flags().IntVar(&options.GracePeriod, \"grace-period\", -1, \"Period of time in seconds given to pruned resources to terminate gracefully. Ignored if negative.\")\n\tcmdutil.AddValidateFlags(cmd)\n\tcmd.Flags().StringVarP(&options.Selector, \"selector\", \"l\", \"\", \"Selector (label query) to filter on\")"
  },
  {
    "id" : "789456d1-05a1-4d36-95aa-a2909d3b9b31",
    "prId" : 33075,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33075#pullrequestreview-753840",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a99b984f-32dc-48af-bd42-a65b5ca68abf",
        "parentId" : null,
        "authorId" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "body" : "When a user may need to use this? May be `--no-cascaded-prune` would be a better name for this.\n",
        "createdAt" : "2016-09-20T08:34:40Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "tags" : [
        ]
      },
      {
        "id" : "e7f8f45b-8cd8-4dbb-89b6-141e895612cd",
        "parentId" : "a99b984f-32dc-48af-bd42-a65b5ca68abf",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "--cascade is already used in multiple other commands in kubectl. I think continuity of experience outweighs a nice descriptive flag. \n\n> When a user may need to use this?\n\nThis is the default behavior. When we prime a deployment, we should also prune it's replicasets or they will become orphaned and unmanaged. \n",
        "createdAt" : "2016-09-20T14:06:00Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "62960aace74ef097546f17ff7550c53b9dcb9b98",
    "line" : null,
    "diffHunk" : "@@ -1,1 +97,101 @@\tcmd.Flags().Bool(\"overwrite\", true, \"Automatically resolve conflicts between the modified and live configuration by using values from the modified configuration\")\n\tcmd.Flags().BoolVar(&options.Prune, \"prune\", false, \"Automatically delete resource objects that do not appear in the configs\")\n\tcmd.Flags().BoolVar(&options.Cascade, \"cascade\", true, \"Only relevant during a prune. If true, cascade the deletion of the resources managed by pruned resources (e.g. Pods created by a ReplicationController).\")\n\tcmd.Flags().IntVar(&options.GracePeriod, \"grace-period\", -1, \"Period of time in seconds given to pruned resources to terminate gracefully. Ignored if negative.\")\n\tcmdutil.AddValidateFlags(cmd)"
  },
  {
    "id" : "85c8bbb8-6456-43c7-8ab4-6e48082cd8b5",
    "prId" : 33075,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33075#pullrequestreview-939252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79159097-73f7-435c-8d54-57cf4412fdec",
        "parentId" : null,
        "authorId" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "body" : "Something like `return visitAndPruneIfNeeded(options.Selector)` could be easier to read, wdyt?\n",
        "createdAt" : "2016-09-20T08:44:52Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "tags" : [
        ]
      },
      {
        "id" : "b7c65ae4-0b1d-46f2-8632-8e6687726e7a",
        "parentId" : "79159097-73f7-435c-8d54-57cf4412fdec",
        "authorId" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "body" : ":+1: for separate function, but I'd rather have it return err and check it here, than what you propose. \n",
        "createdAt" : "2016-09-21T12:26:00Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "b7d2a698-a6e1-4031-bb69-8b45505badb5",
        "tags" : [
        ]
      }
    ],
    "commit" : "62960aace74ef097546f17ff7550c53b9dcb9b98",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +251,255 @@\t}\n\n\tselector, err := labels.Parse(options.Selector)\n\tif err != nil {\n\t\treturn err"
  },
  {
    "id" : "f84936cc-39ea-4a81-9a26-b00a69ca602f",
    "prId" : 33075,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33075#pullrequestreview-701418",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e4fef9c-8f38-41d3-b935-300e6e3e90f4",
        "parentId" : null,
        "authorId" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "body" : "To me it'd be perfectly reasonable to put have this in a separate file, when I was trying to read `apply.go` last time, it seemed rather big and not quite structured.\n",
        "createdAt" : "2016-09-20T08:47:46Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "d37d9758-bdf5-4c23-a40e-a85099689a0c",
        "tags" : [
        ]
      }
    ],
    "commit" : "62960aace74ef097546f17ff7550c53b9dcb9b98",
    "line" : 169,
    "diffHunk" : "@@ -1,1 +284,288 @@}\n\ntype pruner struct {\n\tmapper        meta.RESTMapper\n\tclientFunc    resource.ClientMapperFunc"
  },
  {
    "id" : "eee08f50-2ed7-4fa0-be45-d00781d409fe",
    "prId" : 33075,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33075#pullrequestreview-1842692",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9448444c-4104-4f76-844c-46e9b0d22170",
        "parentId" : null,
        "authorId" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "body" : "Is using `visitedRESTMappings` here enough to cover all cases?\n\nGiven a YAML file which has a ReplicationController before, and now it is replaced with a Deployment. If we need to prune the RC,  I think this logic will fail? Because resource kind RC will not be visited this time -> RCs will not be listed by pruner -> fail to prune existing RC?\n",
        "createdAt" : "2016-09-27T22:22:12Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "tags" : [
        ]
      },
      {
        "id" : "85d625ec-9785-4b62-9ef4-42c395a24c13",
        "parentId" : "9448444c-4104-4f76-844c-46e9b0d22170",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Good point. I think we might need to add a --types flag to explicitly override visitedRESTMappings.\n",
        "createdAt" : "2016-09-27T22:58:47Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "62960aace74ef097546f17ff7550c53b9dcb9b98",
    "line" : 164,
    "diffHunk" : "@@ -1,1 +279,283 @@\t\t\treturn fmt.Errorf(\"error pruning objects: %v\", err)\n\t\t}\n\t}\n\n\treturn nil"
  },
  {
    "id" : "11cef540-e102-494f-8721-2394bc08e665",
    "prId" : 33075,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33075#pullrequestreview-3233174",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2256471-183c-445d-a350-68bf91eafc2c",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "@pwittrock \n",
        "createdAt" : "2016-10-06T21:47:49Z",
        "updatedAt" : "2016-10-07T00:49:13Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      },
      {
        "id" : "d15bcc29-0bc5-4936-8aa2-f0a7381cda60",
        "parentId" : "c2256471-183c-445d-a350-68bf91eafc2c",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "LGTM\n",
        "createdAt" : "2016-10-07T01:13:23Z",
        "updatedAt" : "2016-10-07T01:13:32Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "62960aace74ef097546f17ff7550c53b9dcb9b98",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +66,70 @@\t\tJSON and YAML formats are accepted.\n\t\t\n\t\tAlpha Disclaimer: the --prune functionality is not yet complete. Do not use unless you are aware of what the current state is. See https://issues.k8s.io/34274.`)\n\n\tapply_example = dedent.Dedent(`"
  },
  {
    "id" : "747e8aec-c314-44e6-ba6d-e2c72e81a616",
    "prId" : 26557,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93a4e0f6-a112-43a5-b612-1a42673823f7",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Shouldn't we backoff between retries, or is there a reason this is unwise?\n",
        "createdAt" : "2016-06-01T16:47:21Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "8bb14a92-93dd-4eae-89e0-e3d1f8c56bf1",
        "parentId" : "93a4e0f6-a112-43a5-b612-1a42673823f7",
        "authorId" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "body" : "I did consider adding some interval between retries, and this is just what we did with `kubectl scale`. WDYT?\n",
        "createdAt" : "2016-06-08T03:20:45Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "tags" : [
        ]
      },
      {
        "id" : "5aaec5cc-2d0e-4550-90be-658b4dbf469d",
        "parentId" : "93a4e0f6-a112-43a5-b612-1a42673823f7",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Maybe retry immediately and then back off for 1 second each time?  Don't want to make this more complex than needed, but generally backoffs are a good thing.\n",
        "createdAt" : "2016-06-08T04:16:00Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "69bcdc20ffe93d0f4b285570ebf12752276b86a3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +268,272 @@\t\t}\n\t\tpatchBytes, err = p.patchSimple(current, modified, source, namespace, name)\n\t}\n\n\treturn patchBytes, err"
  },
  {
    "id" : "df563740-01ca-48fd-abac-534cfb1cae37",
    "prId" : 26557,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7f76247-d9bd-43c9-a561-a84c4993d01a",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "For my own knowledge, why is updating the change cause done in a separate call instead of the same call as patching the object itself?\n",
        "createdAt" : "2016-06-01T16:55:30Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "16725347-8ce4-4b4d-bbf3-9574c224f747",
        "parentId" : "e7f76247-d9bd-43c9-a561-a84c4993d01a",
        "authorId" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "body" : "I think that's because of different change source, I am not sure. Maybe @janetkuo has more opinions.\n",
        "createdAt" : "2016-06-08T03:34:11Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "9eb1241d-3dca-4a34-a85d-a880ba615f8c",
        "tags" : [
        ]
      },
      {
        "id" : "7b09b3d7-d94d-4486-92ad-4f44df6719a6",
        "parentId" : "e7f76247-d9bd-43c9-a561-a84c4993d01a",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "We should at least add a TODO here to figure out if it should also be retried.  Since it isn't updated atomically with the changes to the original object, there may be some complications figuring out what to do if there is a conflict at this point.\n",
        "createdAt" : "2016-06-08T20:04:35Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "e39e3606-e39d-421d-b8a5-5f3ff339edc2",
        "parentId" : "e7f76247-d9bd-43c9-a561-a84c4993d01a",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Just talked with Janet.  Plz add a TODO to do the annotation as part of the original change.\n",
        "createdAt" : "2016-06-08T21:14:53Z",
        "updatedAt" : "2016-06-09T04:20:37Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "69bcdc20ffe93d0f4b285570ebf12752276b86a3",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +176,180 @@\n\t\tif cmdutil.ShouldRecord(cmd, info) {\n\t\t\tpatch, err := cmdutil.ChangeResourcePatch(info, f.Command())\n\t\t\tif err != nil {\n\t\t\t\treturn err"
  },
  {
    "id" : "2d728534-83ba-46bf-8d6a-e48c2a263f28",
    "prId" : 14621,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab8a7971-8111-42dc-845c-50b22376e508",
        "parentId" : null,
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Per above, remove `Latest()` and change the order you serialize `current`, `original`, `modified` to\n\n```\n// Do this BEFORE calling info.Get()\nmodified, err := kubectl.GetModifiedConfiguration(info, true)\nif err != nil {\n        ...\n}\n\n// Now call info.Get() to retrieve the latest version\nif err := info.Get(); err != nil {\n   ...\n}\n\ncurrent, err := info.Mapping.Codec.Encode(info.Object)\nif err != nil {\n        ...\n}\n\n// Now, retrieve original configuration from the latest server-side version of the object\noriginal, err := kubectl.GetOriginalConfiguration(info)\nif err != nil {\n        ...\n}\n\n// Compute a three way strategic merge patch ...\n```\n",
        "createdAt" : "2015-10-02T23:10:55Z",
        "updatedAt" : "2015-10-08T00:15:11Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      },
      {
        "id" : "284584b5-ca26-43db-845c-b1d2d81c185b",
        "parentId" : "ab8a7971-8111-42dc-845c-50b22376e508",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "All of the code works correctly today. I'd like to better understand what you're asking for before changing anything. I'll set up a meeting to walk through it together.\n",
        "createdAt" : "2015-10-05T16:31:17Z",
        "updatedAt" : "2015-10-08T00:15:11Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "703a3e19aabfc4050effa70cb1d4cc26d4fcb1f6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +124,128 @@\n\t\t// Serialize the current configuration of the object from the server.\n\t\tcurrent, err := info.Mapping.Codec.Encode(info.Object)\n\t\tif err != nil {\n\t\t\treturn cmdutil.AddSourceToErr(fmt.Sprintf(\"serializing current configuration from:\\n%v\\nfor:\", info), info.Source, err)"
  },
  {
    "id" : "40939cc9-be80-4733-8690-e03b4b4ae723",
    "prId" : 14621,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17b23d39-70e8-4e8a-85bf-95c52bbd024f",
        "parentId" : null,
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Another thing : did you intend to do the 3way merge patch with the \"original\" annotation still in the object? I would think the correct procedure would be to do the threeway merge patch without the `latest-applied-configuration`, then insert it into the patch afterwards. i.e.\n1. extract `original` from `current`'s annotation\n2. delete annotation from `current`\n3. threewaymergepatch original, modified, current\n4. add annotation = modified to the patch\n\nCould also be you worked thru this case and merging the annotation is correct. If so, it deserves a comment explaining why.\n",
        "createdAt" : "2015-10-02T23:11:47Z",
        "updatedAt" : "2015-10-08T00:15:11Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      },
      {
        "id" : "c12982ae-6c8a-4e72-b1c6-ab73116d1aff",
        "parentId" : "17b23d39-70e8-4e8a-85bf-95c52bbd024f",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "The new annotation in the patch will overwrite the previous one. That should be clear from the semantics of 3 way merge patch, per the comments there, but I'll leave another comment here to make sure the reader understands. \n",
        "createdAt" : "2015-10-05T16:30:32Z",
        "updatedAt" : "2015-10-08T00:15:11Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "703a3e19aabfc4050effa70cb1d4cc26d4fcb1f6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +136,140 @@\n\t\t// Compute a three way strategic merge patch to send to server.\n\t\tpatch, err := strategicpatch.CreateThreeWayMergePatch(original, modified, current, info.VersionedObject, false)\n\t\tif err != nil {\n\t\t\tformat := \"creating patch with:\\noriginal:\\n%s\\nmodified:\\n%s\\ncurrent:\\n%s\\nfrom:\\n%v\\nfor:\""
  }
]
[
  {
    "id" : "e44df211-8f33-446a-8ba9-913fb176b48c",
    "prId" : 86175,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86175#pullrequestreview-330815407",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e24ffcd-7386-45a0-96a6-6446a96761d6",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "We need to export this and other related functions so that we can generate it via the PreFilter ",
        "createdAt" : "2019-12-11T20:17:46Z",
        "updatedAt" : "2019-12-12T20:20:25Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "2fdf1fa3c14b54dcae43bc2c5622fbcbb4857c17",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +181,185 @@\n// PodAffinityMetadata pre-computed state for inter-pod affinity predicate.\ntype PodAffinityMetadata struct {\n\t// A map of topology pairs to the number of existing pods that has anti-affinity terms that match the \"pod\".\n\ttopologyToMatchedExistingAntiAffinityTerms topologyToMatchedTermCount"
  },
  {
    "id" : "1d9b4216-4b10-4d38-8ab8-6294380d0d25",
    "prId" : 86046,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86046#pullrequestreview-329207186",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Can we use `map[topologyPair]*int64` so that in the initialization of the metadata, we can concurrently manipulate the value without locking (`appendResult()`).\r\n\r\n(can be a followup PR maybe)",
        "createdAt" : "2019-12-09T18:19:31Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "6c815e43-0139-4313-aec5-cd25653c6516",
        "parentId" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Nvm, if possible, I believe it can be a followup along with comment:\r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/55f81314cc4f8ed08aab64d31d4f842587f2f17e/pkg/scheduler/algorithm/predicates/metadata.go#L443-L444",
        "createdAt" : "2019-12-09T19:26:42Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "f4f084f7-6b72-4138-a358-2b30bcbfa505",
        "parentId" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "Yeah, I thought about that, I did a mutex contention profile, and this can potentially bring ~10% improvement. We can do that in a followup PR.",
        "createdAt" : "2019-12-09T19:27:20Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "4b46a136-3894-4519-97c0-528434690b45",
        "parentId" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "+1 for isolating in a separate PR. There might be other forms of locking that we could consider too. Or using a channel.",
        "createdAt" : "2019-12-09T19:40:09Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "9cb47486-9e4c-460f-9359-de8d2cb36ca9",
        "parentId" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "to initialize, you can do something like this:\r\n\r\n```\r\nif topologyToMatchedTermCount[pair]  == nil {\r\n  mutex.Lock()\r\n  // we have to check again since by the time we get the lock, another thread might have already initialized the entry.\r\n  if topologyToMatchedTermCount[pair]  == nil {\r\n    topologyToMatchedTermCount[pair] = new(int64)\r\n  } \r\n  mutex.Unlock ()\r\n}\r\n```",
        "createdAt" : "2019-12-09T19:42:48Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "74bf0806-e3fc-488e-bdcd-73e1b9af9f4e",
        "parentId" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "I'm not so sure that's thread safe. But let's leave the discussion for another PR :)",
        "createdAt" : "2019-12-09T20:31:50Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "5c39c6d1-9947-4448-b787-2dc655105208",
        "parentId" : "fc060a55-4552-40d0-a683-1460f137bba3",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "I guess we will need to use an RLock:\r\n\r\n```\r\nmutex.RLock \r\nptr := topologyToMatchedTermCount[pair]\r\nmutex.RUnlock\r\nif ptr  == nil {\r\n  mutex.Lock()\r\n  // we have to check again since by the time we get the lock, another thread might have already initialized the entry.\r\n  if topologyToMatchedTermCount[pair]  == nil {\r\n    topologyToMatchedTermCount[pair] = new(int64)\r\n  } \r\n  ptr = topologyToMatchedTermCount[pair]\r\n  mutex.Unlock ()\r\n}\r\n\r\natomicAdd(ptr, value)\r\n```",
        "createdAt" : "2019-12-09T20:44:59Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "32dc70e0f137305f37e3c233a1d1d7576fef2503",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +55,59 @@// we can do atomic additions instead of using a global mutext, however we need to consider\n// how to init each topologyToMatchedTermCount.\ntype topologyToMatchedTermCount map[topologyPair]int64\n\ntype criticalPath struct {"
  },
  {
    "id" : "eb6b9057-1a15-44fb-a878-77d6406cfa48",
    "prId" : 86046,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86046#pullrequestreview-329165396",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d9db898-5ec1-4773-9b51-c705eec87671",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "is it actually worth deleting? we might end up re-adding it with the preemption algorithm.",
        "createdAt" : "2019-12-09T18:44:27Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "5dec7501-b01a-4f36-b5f9-d6232122f6e8",
        "parentId" : "1d9db898-5ec1-4773-9b51-c705eec87671",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Same here: checking `if m[pair] == 0` works for both a non-existing entry or existing entry but with value 0.\r\n\r\n- if we want to manually delete the entry, we'd better keep the logic consistent to use `if _, ok := m[pair]; ok` on the logic of checking its existence\r\n- if we don't delete the entry, probably it increases some memory footprint, but we save time on checking and deletion. in this case, checking `if m[pair] == 0` should be used to check its existence.",
        "createdAt" : "2019-12-09T19:30:37Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "f28bc091-9ed9-4092-bb80-a65c27725874",
        "parentId" : "1d9db898-5ec1-4773-9b51-c705eec87671",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "since the previous logic relied on the existence of the entry rather than whether or not it is zero, I opted to do this to avoid potential bugs. Doing this also made it easy to pass the tests that does DeepEqual test. We can clean this up in a followup PR that converts the type to *int64 so that we can do atomic adds instead of using a global mutex.",
        "createdAt" : "2019-12-09T19:31:28Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "32dc70e0f137305f37e3c233a1d1d7576fef2503",
    "line" : 72,
    "diffHunk" : "@@ -1,1 +199,203 @@\t\t\t\t// value could be a negative value, hence we delete the entry if\n\t\t\t\t// the entry is down to zero.\n\t\t\t\tif m[pair] == 0 {\n\t\t\t\t\tdelete(m, pair)\n\t\t\t\t}"
  },
  {
    "id" : "160f040a-31c6-4027-a6cf-3b0f8a919f7e",
    "prId" : 86046,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86046#pullrequestreview-329200299",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b971e57-745b-425c-aad8-0ea5aa1d1b49",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "`type podAffinityTerm` which is the processed version of `v1.PodAffinityTerm`. Then instead of term, it should store the topologykey.",
        "createdAt" : "2019-12-09T18:49:56Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "81f0ea56-9f80-490e-9e95-a4aca869c135",
        "parentId" : "7b971e57-745b-425c-aad8-0ea5aa1d1b49",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "I feel it is easier to search when using a slightly different name. But if we really want to do that, I think we should do in a separate PR, there are multiple functions suffixed with \"properties\", let alone the more than few variable names.",
        "createdAt" : "2019-12-09T20:24:36Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "b68094ae-7dd5-463c-9fc7-3284d8408cbb",
        "parentId" : "7b971e57-745b-425c-aad8-0ea5aa1d1b49",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "sg",
        "createdAt" : "2019-12-09T20:32:10Z",
        "updatedAt" : "2019-12-09T21:22:49Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "32dc70e0f137305f37e3c233a1d1d7576fef2503",
    "line" : 259,
    "diffHunk" : "@@ -1,1 +666,670 @@\n// A processed version of v1.PodAffinityTerm.\ntype affinityTermProperties struct {\n\tnamespaces  sets.String\n\tselector    labels.Selector"
  },
  {
    "id" : "13127c15-4cc5-4112-b82a-5bb5d6522531",
    "prId" : 85157,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85157#pullrequestreview-316310931",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1b23f91-c7b3-4b58-a722-65dd60283783",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "To not confuse with v1.TopologySpreadConstraint, suggest to rename to `internal TopologySpreadConstraint` or similar name.",
        "createdAt" : "2019-11-12T23:49:38Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "bc3b70ac-b798-44b0-a455-24809ffa8f7b",
        "parentId" : "b1b23f91-c7b3-4b58-a722-65dd60283783",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "One is just the parsed version of the other. I don't see any harm on them having the same name.",
        "createdAt" : "2019-11-13T01:24:48Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "a35d2a18-16dc-46a8-a7bf-959e10bb0a3d",
        "parentId" : "b1b23f91-c7b3-4b58-a722-65dd60283783",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "or, let's put a comment to emphasize that (1) it's an internal version which has a particular `labels.Selector` field instead of `metav1.Selector`, (2) it's for simplifying the matching logic and performance.",
        "createdAt" : "2019-11-13T06:47:01Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "ac0619f9-9ea5-46f2-9d03-5de350370a49",
        "parentId" : "b1b23f91-c7b3-4b58-a722-65dd60283783",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Done",
        "createdAt" : "2019-11-13T15:08:05Z",
        "updatedAt" : "2019-11-13T15:10:33Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3bdb4b20b98350887d5cff9811bce5f46e27586",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +130,134 @@// unsatisfiable constraint action) v1.TopologySpreadConstraint and where the\n// selector is parsed.\ntype topologySpreadConstraint struct {\n\tmaxSkew     int32\n\ttopologyKey string"
  },
  {
    "id" : "b5c5ad79-bde3-48e8-b480-4494cc37b395",
    "prId" : 85157,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85157#pullrequestreview-316256263",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9151c91-62c0-452a-953d-cbcf8f0dd248",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "It seems this is the key perf of the improvement - `LabelSelectorAsSelector` doesn't sound like a cheap operation, and if we cache the result, we seem to get a lot of benefits.\r\n\r\nA followup is to do a thorough check of \"repeated usage of LabelSelectorAsSelector\" and do similar refactoring. I do recall there was a PR using the same rationale improving the performance of PodAffinity, probably #79465. We should consolidate this.",
        "createdAt" : "2019-11-13T00:12:52Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "4b9a6ed6-befe-4082-95ef-9c84543c8ea2",
        "parentId" : "b9151c91-62c0-452a-953d-cbcf8f0dd248",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "sounds like suggestion. cc @liu-cong who is looking into performance in general.",
        "createdAt" : "2019-11-13T01:27:57Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "152d2f7c-ced1-4d83-8700-c5497181125d",
        "parentId" : "b9151c91-62c0-452a-953d-cbcf8f0dd248",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "We should run some benchmarks first, but we could annotate the pods in the scheduler cache with already processed Selectors for affinity and spread constraints, and so we do this conversion per pod rather than per pod per cycle.",
        "createdAt" : "2019-11-13T03:12:13Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "8bc55939-108b-4b07-9ed5-fe96a750381b",
        "parentId" : "b9151c91-62c0-452a-953d-cbcf8f0dd248",
        "authorId" : "a650878f-0c10-41c7-b0fc-033031305d77",
        "body" : "SG:) I was discussing with ahg-g yesterday about what can be cached per pod and this seems to fall into that category.",
        "createdAt" : "2019-11-13T13:50:59Z",
        "updatedAt" : "2019-11-13T15:10:19Z",
        "lastEditedBy" : "a650878f-0c10-41c7-b0fc-033031305d77",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3bdb4b20b98350887d5cff9811bce5f46e27586",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +504,508 @@\tfor _, c := range constraints {\n\t\tif c.WhenUnsatisfiable == v1.DoNotSchedule {\n\t\t\tselector, err := metav1.LabelSelectorAsSelector(c.LabelSelector)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err"
  },
  {
    "id" : "8f8da3be-26c1-4fc8-acc8-c4c2f4f4e6c6",
    "prId" : 84389,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84389#pullrequestreview-307740079",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5ca03e9-0c02-4d73-8d07-e3a3a6dcad6a",
        "parentId" : null,
        "authorId" : "df8dc16d-08c7-457c-8593-619395912000",
        "body" : "It seems be enough to use `NodeInfoLister` instead of `sharedLister`?",
        "createdAt" : "2019-10-28T09:52:13Z",
        "updatedAt" : "2019-10-28T09:55:10Z",
        "lastEditedBy" : "df8dc16d-08c7-457c-8593-619395912000",
        "tags" : [
        ]
      },
      {
        "id" : "135d5c7a-4755-4a29-9d1c-30ad3f80a466",
        "parentId" : "f5ca03e9-0c02-4d73-8d07-e3a3a6dcad6a",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "perhaps for now, may be not in the future.",
        "createdAt" : "2019-10-28T10:01:11Z",
        "updatedAt" : "2019-10-28T10:01:12Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "05cb38235798348bdb4ae015ee0638deaf027708",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +332,336 @@\n// GetPredicateMetadata returns the predicateMetadata which will be used by various predicates.\nfunc GetPredicateMetadata(pod *v1.Pod, sharedLister schedulerlisters.SharedLister) PredicateMetadata {\n\t// If we cannot compute metadata, just return nil\n\tif pod == nil {"
  },
  {
    "id" : "f0fbf661-d0ac-4cfd-9dae-99820d7af04b",
    "prId" : 83286,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83286#pullrequestreview-295971578",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fdd2d1dc-694e-4ed5-ba36-ef919262d4fa",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "return nil if m is nil?",
        "createdAt" : "2019-10-01T15:16:36Z",
        "updatedAt" : "2019-10-08T02:05:35Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "3075644a-6e22-4c5f-86fe-5651a9ab17ac",
        "parentId" : "fdd2d1dc-694e-4ed5-ba36-ef919262d4fa",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "done",
        "createdAt" : "2019-10-02T01:10:32Z",
        "updatedAt" : "2019-10-08T02:05:35Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "9554276d171880e3902591101d658c47ed72f503",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +257,261 @@}\n\nfunc (m *podFitsResourcesMetadata) clone() *podFitsResourcesMetadata {\n\tif m == nil {\n\t\treturn nil"
  },
  {
    "id" : "f671db93-5ec8-49b5-98cd-977c642ea5c7",
    "prId" : 83286,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83286#pullrequestreview-295971599",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03d9468d-8e54-4044-a869-bca9ae0795f3",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "ditto: return nil if m is nil",
        "createdAt" : "2019-10-01T15:16:55Z",
        "updatedAt" : "2019-10-08T02:05:35Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "edb5d9e9-17ee-4397-92bc-ace88ad422e5",
        "parentId" : "03d9468d-8e54-4044-a869-bca9ae0795f3",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "done",
        "createdAt" : "2019-10-02T01:10:36Z",
        "updatedAt" : "2019-10-08T02:05:35Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "9554276d171880e3902591101d658c47ed72f503",
    "line" : 186,
    "diffHunk" : "@@ -1,1 +273,277 @@}\n\nfunc (m *podFitsHostPortsMetadata) clone() *podFitsHostPortsMetadata {\n\tif m == nil {\n\t\treturn nil"
  },
  {
    "id" : "e66fe61e-3f5d-4802-9570-e2df071cc6e5",
    "prId" : 83286,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83286#pullrequestreview-297415797",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb592d5b-658a-44d3-b809-9fdb208794c3",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "create addPod for evenPodsSpreadMetadata",
        "createdAt" : "2019-10-04T11:58:01Z",
        "updatedAt" : "2019-10-08T02:05:35Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "9554276d171880e3902591101d658c47ed72f503",
    "line" : 428,
    "diffHunk" : "@@ -1,1 +650,654 @@\t\treturn err\n\t}\n\t// Update meta.evenPodsSpreadMetadata if meta.pod has hard spread constraints\n\t// and addedPod matches that\n\tif err := meta.evenPodsSpreadMetadata.addPod(addedPod, meta.pod, node); err != nil {"
  },
  {
    "id" : "44dfdd52-313a-4d40-b298-fb30dfac9a7a",
    "prId" : 83234,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83234#pullrequestreview-294225007",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d562820-107e-4e5a-bf41-70591dcccf1e",
        "parentId" : null,
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "Could you elaborate the reason on this change? I don't see the necessity.",
        "createdAt" : "2019-09-27T09:18:56Z",
        "updatedAt" : "2019-09-29T02:12:08Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "81d0b4ed-1868-4398-b0c0-b40ed8117e86",
        "parentId" : "7d562820-107e-4e5a-bf41-70591dcccf1e",
        "authorId" : "e7b8fd7e-f93b-44b6-b6d0-4331207d901c",
        "body" : "1. Using more specific arguments makes the meaning of the method clearer and easier to understand ( We actually need `Node` instead of `NodeInfo` ）\r\n2. Keep the code style consistent，as we already used `Node` in `RemovePod` https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/predicates/metadata.go#L41",
        "createdAt" : "2019-09-27T09:43:29Z",
        "updatedAt" : "2019-09-29T02:12:08Z",
        "lastEditedBy" : "e7b8fd7e-f93b-44b6-b6d0-4331207d901c",
        "tags" : [
        ]
      },
      {
        "id" : "8b24ea4d-7af8-4a39-9ce3-8446be116f62",
        "parentId" : "7d562820-107e-4e5a-bf41-70591dcccf1e",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "SG",
        "createdAt" : "2019-09-27T09:55:07Z",
        "updatedAt" : "2019-09-29T02:12:08Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcaa99167639b139f81fce9ee3af59adca77e67e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +38,42 @@type PredicateMetadata interface {\n\tShallowCopy() PredicateMetadata\n\tAddPod(addedPod *v1.Pod, node *v1.Node) error\n\tRemovePod(deletedPod *v1.Pod, node *v1.Node) error\n}"
  },
  {
    "id" : "4f36a42e-d186-423c-b6f0-d4f2d94c673a",
    "prId" : 81068,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81068#pullrequestreview-271972527",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb853742-dfbb-4fa0-9564-ebc66122240a",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "We should consider implementing a well defined data structure in our utilities library. Atomic map counters is a very common use case for implementing scheduling algorithms. I'll give it a thought.",
        "createdAt" : "2019-08-07T13:55:19Z",
        "updatedAt" : "2019-08-20T16:27:12Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f559ea53b6f6f8a4d406d975a448c1808e77aa3",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +258,262 @@\tvar lock sync.Mutex\n\n\t// TODO(Huang-Wei): It might be possible to use \"make(map[topologyPair]*int32)\".\n\t// In that case, need to consider how to init each tpPairToCount[pair] in an atomic fashion.\n\tm := podSpreadCache{"
  },
  {
    "id" : "8d1c05e0-5f57-43f3-a882-0ab72f96aa2c",
    "prId" : 81068,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81068#pullrequestreview-273842253",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38fa22d9-4f18-4569-9aeb-a3792408da18",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Is this just reverting the initial changes to affinity structures?",
        "createdAt" : "2019-08-12T15:45:46Z",
        "updatedAt" : "2019-08-20T16:27:12Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "e7e8222a-325d-4c45-956c-41d5fe06de5b",
        "parentId" : "38fa22d9-4f18-4569-9aeb-a3792408da18",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Correct :)",
        "createdAt" : "2019-08-12T17:36:01Z",
        "updatedAt" : "2019-08-20T16:27:12Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f559ea53b6f6f8a4d406d975a448c1808e77aa3",
    "line" : 224,
    "diffHunk" : "@@ -1,1 +371,375 @@func (m *topologyPairsMaps) addTopologyPair(pair topologyPair, pod *v1.Pod) {\n\tpodFullName := schedutil.GetPodFullName(pod)\n\tif m.topologyPairToPods[pair] == nil {\n\t\tm.topologyPairToPods[pair] = make(map[*v1.Pod]struct{})\n\t}"
  },
  {
    "id" : "153c1e54-1859-47da-a432-67e997542b41",
    "prId" : 81068,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81068#pullrequestreview-276846086",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e5518a4-8ca2-4642-9c88-0be3281dfc72",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "we need to also clarify that this works also because each node is evaluated on a separate copy of the metadata.",
        "createdAt" : "2019-08-19T20:06:23Z",
        "updatedAt" : "2019-08-20T16:27:12Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "d66d4ece-07df-4ed9-88a1-51ac3c7921dd",
        "parentId" : "4e5518a4-8ca2-4642-9c88-0be3281dfc72",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "SG.",
        "createdAt" : "2019-08-19T22:22:54Z",
        "updatedAt" : "2019-08-20T16:27:12Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f559ea53b6f6f8a4d406d975a448c1808e77aa3",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +80,84 @@// Fact 2: each node is evaluated on a separate copy of the metadata during its preemption cycle.\n// If we plan to turn to a more complex algorithm like \"arbitrary pods on multiple nodes\", this\n// structure needs to be revisited.\ntype criticalPaths [2]criticalPath\n"
  },
  {
    "id" : "70b35764-cd6e-4537-9952-4a9cffdba575",
    "prId" : 80503,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80503#pullrequestreview-265920979",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bc5ef1d-b876-46fc-b785-fe195dddd9ef",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "If current `node.Labels` match on the 1st constraint's `topologyKey` **only**, we're wasting a large number of cycles on this loop, correct?",
        "createdAt" : "2019-07-24T04:19:02Z",
        "updatedAt" : "2019-07-25T14:15:29Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "ae058870-2644-4477-9700-d20e4d048aab",
        "parentId" : "5bc5ef1d-b876-46fc-b785-fe195dddd9ef",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "When you say 'current node.Labels', did you mean existingPod.Labels ?\r\n\r\nHow would existing code be able to short circuit and avoid the waste ?\r\n\r\nThanks",
        "createdAt" : "2019-07-24T04:32:35Z",
        "updatedAt" : "2019-07-25T14:15:29Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "6d232f1f-d8e3-4fdb-9bb4-61ce69716904",
        "parentId" : "5bc5ef1d-b876-46fc-b785-fe195dddd9ef",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "No, I mean node.Labels.\r\n\r\nSuppose you have 2 constraints, the 2nd constraint's topology isn't present in the node's labels.\r\n- Without this PR, it directly returns without processing any pod.\r\n- With this PR, it has to process nodeInfo.Pods() and only return when it hits the 2nd constraint. ",
        "createdAt" : "2019-07-24T05:38:08Z",
        "updatedAt" : "2019-07-25T14:15:29Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "88b377c1-7854-4f1e-8013-b6ee2180b283",
        "parentId" : "5bc5ef1d-b876-46fc-b785-fe195dddd9ef",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "I restored the first loop over constraints.",
        "createdAt" : "2019-07-24T10:09:13Z",
        "updatedAt" : "2019-07-25T14:15:29Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "89818d8d09633a4b0e2e277cb0089f89927237b0",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +242,246 @@\t\t\tpairAdded := false\n\t\t\t// nodeInfo.Pods() can be empty; or all pods don't fit\n\t\t\tfor _, existingPod := range nodeInfo.Pods() {\n\t\t\t\tif existingPod.Namespace != pod.Namespace {\n\t\t\t\t\tcontinue"
  },
  {
    "id" : "69f21b47-f9a1-4ad7-8383-2fa480a3baa5",
    "prId" : 79777,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79777#pullrequestreview-258510970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d680c06-520d-4ce8-a1c5-f41560d1da6e",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "remove line.",
        "createdAt" : "2019-07-05T18:19:42Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab1948a1be09f86f1d31d424e37a11d2a0c20a4",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +402,406 @@\t}\n\tworkqueue.ParallelizeUntil(ctx, 16, len(allNodeNames), processNode)\n\n\tif err := errCh.ReceiveError(); err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "83c5fccb-8f9f-4e97-bfe2-ea6e928b9c04",
    "prId" : 79777,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79777#pullrequestreview-258510970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fd8af34-63f6-4199-b11f-7b1980870bef",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "remove line",
        "createdAt" : "2019-07-05T18:20:23Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab1948a1be09f86f1d31d424e37a11d2a0c20a4",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +446,450 @@\t\treturn nil, nil, err\n\t}\n\n\tantiAffinityTerms := GetPodAntiAffinityTerms(affinity.PodAntiAffinity)\n"
  },
  {
    "id" : "77dde3c0-9acb-44bb-997e-2e45342adce8",
    "prId" : 79777,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79777#pullrequestreview-258510970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28a90844-b6c5-4eba-b3d5-20b869db2728",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "remove line",
        "createdAt" : "2019-07-05T18:20:37Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab1948a1be09f86f1d31d424e37a11d2a0c20a4",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +492,496 @@\t}\n\tworkqueue.ParallelizeUntil(ctx, 16, len(allNodeNames), processNode)\n\n\tif err := errCh.ReceiveError(); err != nil {\n\t\treturn nil, nil, err"
  },
  {
    "id" : "6be72dc3-2d2c-4958-a37f-ba890b68ecce",
    "prId" : 79777,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79777#pullrequestreview-258510970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1638a24-5798-4cd7-a8b6-09dd08a95be6",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "remove line",
        "createdAt" : "2019-07-05T18:21:00Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab1948a1be09f86f1d31d424e37a11d2a0c20a4",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +496,500 @@\t\treturn nil, nil, err\n\t}\n\n\treturn topologyPairsAffinityPodsMaps, topologyPairsAntiAffinityPodsMaps, nil\n}"
  },
  {
    "id" : "8941c00b-c3e3-4b3c-bf6d-f65e9f87493b",
    "prId" : 79777,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79777#pullrequestreview-258510970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f8fb716-b16b-4dae-8dea-255dc630b4d5",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "remove line",
        "createdAt" : "2019-07-05T18:21:58Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab1948a1be09f86f1d31d424e37a11d2a0c20a4",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +402,406 @@\t}\n\tworkqueue.ParallelizeUntil(ctx, 16, len(allNodeNames), processNode)\n\n\tif err := errCh.ReceiveError(); err != nil {\n\t\treturn nil, err"
  },
  {
    "id" : "d5d82450-a7b9-42de-9f31-3bfa31979f93",
    "prId" : 79777,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79777#pullrequestreview-260834919",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "To potentially address @bsalamat concern about readability, and help establish a clear pattern for signaling errors, we could make capturing the error a function as well, and by that we have a clearer and established error send/receive pattern.\r\n\r\n1) Create a function for receiving the error similar to send in utils.go:\r\n```\r\nfunc NonBlockingReceiveError(errCh chan<- error) error {\r\n  select {\r\n\tcase err := <-errCh:\r\n\t\treturn err\r\n\tdefault:\r\n  }\r\n  return nil\r\n}\r\n```\r\n\r\n2) here we just call the function:\r\n```\r\nif err := schedulerutil.NonBlockingReceiveError(errCh); err != nil {\r\n return nil, nil, err\r\n}\r\nreturn topologyPairsAffinityPodsMaps, topologyPairsAntiAffinityPodsMaps, nil\r\n```\r\n\r\nThis NonBlockingSendError/NonBlockingReceiveError pattern can now be used in all places where we need to capture a single error from parallel loops.",
        "createdAt" : "2019-07-11T02:17:32Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "c31e3fee-7a28-4e8a-a6aa-df377a9b7da9",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "What does an `ErrorChannel` with the following APIs sounds, it encapsulates related functions and provides an approach to collect errors?\r\n\r\n```go\r\nfunc NewErrorChannel(buffers int64) *ErrorChannel\r\nfunc (c *ErrorChannel) SendError(err error) bool\r\nfunc (c *ErrorChannel) ReceiveError() error\r\n```",
        "createdAt" : "2019-07-11T14:10:03Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "1bc8b5a2-97a6-49ec-bd55-f1419360ca45",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "Adding an explicit abstraction sounds good to me, this is even better.\r\n\r\nI would not call suffix it with Channel since that exposes the implementation detail of the abstraction. I would suggest two modifications: \r\n\r\n1) give the option to pass a callback to NewErrorRecorder so that it gets called by send error if set. \r\n2) change error to interface because in some places we have other ways to report errors, like the framework Status.\r\n\r\n```\r\nfunc NewErrorRecorder(bufferSize int, cancel context.CancelFunc) *ErrorRecorder\r\n\r\nfunc (c *ErrorChannel) SendError(err interface{}) bool\r\n\r\nfunc (c *ErrorChannel) ReceiveError() interface{}\r\n```\r\n",
        "createdAt" : "2019-07-11T15:32:36Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "943f9cb6-6625-4d0f-9368-fb85bbdb8a55",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "> Adding an explicit abstraction sounds good to me, this is even better.\r\n> \r\n> I would not call suffix it with Channel since that exposes the implementation detail of the abstraction. I would suggest two modifications:\r\n> \r\n> 1. give the option to pass a callback to NewErrorRecorder so that it gets called by send error if set.\r\n> 2. change error to interface because in some places we have other ways to report errors, like the framework Status.\r\n> \r\n> ```\r\n> func NewErrorRecorder(bufferSize int, cancel context.CancelFunc) *ErrorRecorder\r\n> \r\n> func (c *ErrorChannel) SendError(err interface{}) bool\r\n> \r\n> func (c *ErrorChannel) ReceiveError() interface{}\r\n> ```\r\n\r\nChange the type to interface{} would cause an extra explicit conversion to error which looks bad...\r\n\r\n```go\r\nrecorder.RecieverError().(error)\r\n```",
        "createdAt" : "2019-07-11T15:44:38Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "10e378f9-b84d-4580-9a11-b9faf8e873d4",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "Hi @bsalamat @Huang-Wei, could you give us some suggestions on this? Do we need to `ErrorRecorder` to encapsulate methods and if it sounds good, how should we define the API it provided?\r\n\r\nRelated discussions on this https://github.com/kubernetes/kubernetes/pull/79109#discussion_r302558861",
        "createdAt" : "2019-07-11T15:47:41Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "0c264961-bec6-4ca0-a902-3a522f960eb5",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "I found similar logic here in these places which do not need to call `CancelFunc`, and I still think it should not be part of the API.\r\n\r\n+ https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/priorities/interpod_affinity.go#L194-L218 \r\n+ https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/podautoscaler/horizontal.go#L760-L782\r\n+ https://github.com/kubernetes/kubernetes/blob/master/test/e2e/framework/util.go#L1563-L1596\r\n+ https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kube-aggregator/pkg/controllers/status/available_controller.go#L267-L298\r\n\r\nAnd we probably go too far on this, use select and channel to capture errors is quite common in the codebase, I use following cmd and find many similar structures.\r\n\r\n```go\r\n$ ag \"case.*errCh.*\" -l\r\ncmd/kube-controller-manager/app/testing/testserver.go\r\ncmd/kube-scheduler/app/testing/testserver.go\r\ncmd/cloud-controller-manager/app/testing/testserver.go\r\ncmd/kube-proxy/app/server_test.go\r\ncmd/kube-apiserver/app/testing/testserver.go\r\nstaging/src/k8s.io/kube-aggregator/pkg/controllers/status/available_controller.go\r\nstaging/src/k8s.io/apiextensions-apiserver/pkg/cmd/server/testing/testserver.go\r\nstaging/src/k8s.io/apiserver/pkg/endpoints/handlers/rest.go\r\nstaging/src/k8s.io/apiserver/pkg/storage/etcd3/watcher.go\r\ntest/e2e_node/services/util.go\r\ntest/e2e/framework/util.go\r\nvendor/google.golang.org/grpc/credentials/credentials.go\r\nvendor/github.com/coreos/go-systemd/dbus/subscription.go\r\npkg/scheduler/scheduler_test.go\r\npkg/scheduler/util/utils.go\r\npkg/scheduler/algorithm/predicates/metadata.go\r\npkg/controller/job/job_controller.go\r\npkg/controller/replicaset/replica_set.go\r\n```",
        "createdAt" : "2019-07-11T15:58:38Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "03804821-8c21-47b5-ba5c-16d9a8087d31",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "> I found similar logic here in these places which do not need to call `CancelFunc`, and I still think it should not be part of the API.\r\n> \r\n> * https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/priorities/interpod_affinity.go#L194-L218\r\n> * https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/podautoscaler/horizontal.go#L760-L782\r\n> * https://github.com/kubernetes/kubernetes/blob/master/test/e2e/framework/util.go#L1563-L1596\r\n> * https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kube-aggregator/pkg/controllers/status/available_controller.go#L267-L298\r\n> \r\n\r\nCan't they pass nil if they don't want to pass a callback?\r\n\r\nKeeping it as error instead of interface sounds good, I guess the special cases that require something other than error could convert from error to their special type.",
        "createdAt" : "2019-07-11T16:05:04Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "5ecd6634-0a66-4dc6-b9f6-18aebe4b12f9",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "> Can't they pass nil if they don't want to pass a callback?\r\n\r\nSince it is not a typical pattern, it would be better to keep the API simple instead of adding support for exceptional cases. And call cancel function separately would work too.",
        "createdAt" : "2019-07-11T16:12:38Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "5d6b368f-674e-41cc-bf0a-b52d2d025597",
        "parentId" : "5e0716c9-8558-49f7-92f5-04d52228f203",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "Sorry, I am not sure what you mean by \"since it is not a typical pattern\". \r\n\r\nIf you mean it is not common that we pass a callback in general, then I guess we discussed that in the other PR and you seem to have agreed that it is a common pattern to pass callbacks, and I pointed that cancel is callback.\r\n\r\nIf you mean it is not common in our code base that we need to call cancel, then that is not true, you have four cases in this PR, I have one in my PR. Also, from the four cases you pointed out, one should be changed to use cancel, the other isn't in scope since it is not a parallel loop:\r\n\r\n> > * https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithm/priorities/interpod_affinity.go#L194-L218\r\n\r\nThis should be changed to use cancel.\r\n\r\n> > * https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/podautoscaler/horizontal.go#L760-L782\r\n\r\n\r\nThis is not a case that we need to cover, this isn't a loop executed in parallel.\r\n\r\n\r\nIf you are concerned about passing nil, we could have a new function that allows setting the callback:\r\n\r\n```\r\nfunc NewErrorRecorderWithCancel(bufferSize int, cancel context.CancelFunc) *ErrorRecorder\r\n```",
        "createdAt" : "2019-07-11T17:02:42Z",
        "updatedAt" : "2019-07-13T01:12:06Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fab1948a1be09f86f1d31d424e37a11d2a0c20a4",
    "line" : 104,
    "diffHunk" : "@@ -1,1 +495,499 @@\tif err := errCh.ReceiveError(); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn topologyPairsAffinityPodsMaps, topologyPairsAntiAffinityPodsMaps, nil"
  },
  {
    "id" : "e6f2627a-3d94-454b-b761-d03751003062",
    "prId" : 79774,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79774#pullrequestreview-259642991",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "afb3a975-282e-4862-b899-78c2a478747f",
        "parentId" : null,
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "@Huang-Wei is this on purpose? I noticed that we didn't call cancel when node not found.",
        "createdAt" : "2019-07-04T08:35:13Z",
        "updatedAt" : "2019-07-10T02:51:14Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "f2d030b2-e480-4017-84df-ad2a8385eeba",
        "parentId" : "afb3a975-282e-4862-b899-78c2a478747f",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "I dug around the code which calls this function and found out it is ok to call `cancel` here since the caller only concerns the first error returns.\r\n\r\n/ok-to-test\r\n/priority backlog\r\n/lgtm",
        "createdAt" : "2019-07-04T15:47:08Z",
        "updatedAt" : "2019-07-10T02:51:14Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "e817e8ae-f0fa-494e-b4fb-b9741c8f6a1c",
        "parentId" : "afb3a975-282e-4862-b899-78c2a478747f",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "> is this on purpose?\r\n\r\nNope. I think it's a missing part.",
        "createdAt" : "2019-07-09T17:12:47Z",
        "updatedAt" : "2019-07-10T02:51:14Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "c329d5117d0469ab46ba071d22b0956f1e2342b3",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +398,402 @@\t\tif node == nil {\n\t\t\tcatchError(fmt.Errorf(\"node %q not found\", allNodeNames[i]))\n\t\t\tcancel()\n\t\t\treturn\n\t\t}"
  },
  {
    "id" : "96e8665f-8e36-44fa-af49-75d6c58eaeba",
    "prId" : 79774,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79774#pullrequestreview-258109681",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46b4d379-1d90-45da-97eb-95c396af28de",
        "parentId" : null,
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "same here",
        "createdAt" : "2019-07-04T15:47:57Z",
        "updatedAt" : "2019-07-10T02:51:14Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c329d5117d0469ab46ba071d22b0956f1e2342b3",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +467,471 @@\t\tif node == nil {\n\t\t\tcatchError(fmt.Errorf(\"node %q not found\", allNodeNames[i]))\n\t\t\tcancel()\n\t\t\treturn\n\t\t}"
  },
  {
    "id" : "d829c0e5-4ab2-4f9a-971e-ece7b3b4ae11",
    "prId" : 79062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79062#pullrequestreview-264951538",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfdc13ca-0450-4fe2-9b0f-d48da8f378be",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "I would name it `nodeLabelsHaveSpreadConstraints`, since this is not actually a label selector.",
        "createdAt" : "2019-07-19T17:47:01Z",
        "updatedAt" : "2019-07-24T22:28:22Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "5e012a15-17f4-44bf-a10f-e227c43b3bdf",
        "parentId" : "dfdc13ca-0450-4fe2-9b0f-d48da8f378be",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "IMO `Have` doesn't sound correct.",
        "createdAt" : "2019-07-22T17:43:30Z",
        "updatedAt" : "2019-07-24T22:28:22Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "794847967c21cd50ef6bf8a69bc7d16e86027d05",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +321,325 @@\n// check if ALL topology keys in spread constraints are present in node labels\nfunc nodeLabelsMatchSpreadConstraints(nodeLabels map[string]string, constraints []v1.TopologySpreadConstraint) bool {\n\tfor _, constraint := range constraints {\n\t\tif _, ok := nodeLabels[constraint.TopologyKey]; !ok {"
  },
  {
    "id" : "3927a938-d288-46d5-b842-beac7fc94294",
    "prId" : 79062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79062#pullrequestreview-266636156",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9163e7ae-179a-4e90-a66c-967c0b1a8573",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Do we need to calculate `podSpreadMap.podToTopologyPairs` for `addedPod`? Alternatively, do we need to remove it during removePod?",
        "createdAt" : "2019-07-19T18:41:59Z",
        "updatedAt" : "2019-07-24T22:28:22Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "a02f818d-3f10-435d-a47b-19257ce83fdf",
        "parentId" : "9163e7ae-179a-4e90-a66c-967c0b1a8573",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "We should, to avoid potential inconsistency. And it's not expensive.",
        "createdAt" : "2019-07-22T17:41:36Z",
        "updatedAt" : "2019-07-24T22:28:22Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "400cd363-384d-46a5-94b4-ac44db625561",
        "parentId" : "9163e7ae-179a-4e90-a66c-967c0b1a8573",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Please add it to this PR. Unless I'm missing it?",
        "createdAt" : "2019-07-23T14:54:56Z",
        "updatedAt" : "2019-07-24T22:28:22Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "95589482-3b07-4824-9d74-6711098115d3",
        "parentId" : "9163e7ae-179a-4e90-a66c-967c0b1a8573",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "@Huang-Wei Do we need this for consistency?",
        "createdAt" : "2019-07-24T13:53:27Z",
        "updatedAt" : "2019-07-24T22:28:22Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "f8be94db-b75a-4bd8-b41c-f97c66ec8dd5",
        "parentId" : "9163e7ae-179a-4e90-a66c-967c0b1a8573",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "@alculquicondor `func (m *topologyPairsMaps) addTopologyPair` does it in pair. Is this your question?",
        "createdAt" : "2019-07-25T00:16:01Z",
        "updatedAt" : "2019-07-25T00:16:01Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "6e46580d-8a00-492d-b3c3-a131f5b096e4",
        "parentId" : "9163e7ae-179a-4e90-a66c-967c0b1a8573",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Yes, sorry I missed it.",
        "createdAt" : "2019-07-25T13:47:00Z",
        "updatedAt" : "2019-07-25T13:47:01Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "794847967c21cd50ef6bf8a69bc7d16e86027d05",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +414,418 @@\t}\n\t// no need to addTopologyPairWithoutPods b/c if a pair without pods must be present,\n\t// it should have already been created earlier in removePod() phase\n\n\t// In most cases, min match map doesn't need to be updated."
  },
  {
    "id" : "03c35a1c-b7be-4f32-8271-1a27825df21c",
    "prId" : 77760,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77760#pullrequestreview-259104062",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f1ae540-8eba-404b-898f-d05983fbc764",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "This struct does not look like it is defining a new data type, it is hard to reason what it represents. I recommend that you just add those fields directly to predicateMetadata struct.",
        "createdAt" : "2019-07-04T17:42:14Z",
        "updatedAt" : "2019-07-23T00:53:14Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "dd77ee52-b5e6-428a-93c7-b3db45ad9636",
        "parentId" : "3f1ae540-8eba-404b-898f-d05983fbc764",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "At this moment, I'd prefer to keep it as a standalone data structure because:\r\n\r\n1. From the name, we can easily know it's related and only related with `EvenPodsSpread` feature.\r\n2. Keep it standalone so as to make the code more testable.",
        "createdAt" : "2019-07-07T23:37:27Z",
        "updatedAt" : "2019-07-23T00:53:14Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "04bf6bf6-7f7b-4664-b4ce-a614218317fb",
        "parentId" : "3f1ae540-8eba-404b-898f-d05983fbc764",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "SG",
        "createdAt" : "2019-07-08T19:13:56Z",
        "updatedAt" : "2019-07-23T00:53:14Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "f822487f05313290140e08e508249e9970b5b5c3",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +72,76 @@// (1) minimum number of pods matched on the spread constraints.\n// (2) how existing pods match incoming pod on its spread constraints.\ntype topologyPairsPodSpreadMap struct {\n\t// This map is keyed with a topology key, and valued with minimum number\n\t// of pods matched on that topology domain."
  },
  {
    "id" : "e43c0fe3-835f-4deb-b47a-6fdd80331391",
    "prId" : 77760,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77760#pullrequestreview-265125060",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98c2e860-a4ab-4183-8104-e1cfcb0f603d",
        "parentId" : null,
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "nit: this comment should start with the function name.",
        "createdAt" : "2019-07-20T06:58:54Z",
        "updatedAt" : "2019-07-23T00:53:14Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "a3e14327-4167-4df8-ae36-e9854b55debd",
        "parentId" : "98c2e860-a4ab-4183-8104-e1cfcb0f603d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "It's usually tolerant for private functions.",
        "createdAt" : "2019-07-23T00:49:45Z",
        "updatedAt" : "2019-07-23T00:53:14Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "f822487f05313290140e08e508249e9970b5b5c3",
    "line" : 227,
    "diffHunk" : "@@ -1,1 +336,340 @@}\n\n// add a topology pair holder if needed\nfunc (m *topologyPairsMaps) addTopologyPairWithoutPods(pair topologyPair) {\n\tif m.topologyPairToPods[pair] == nil {"
  },
  {
    "id" : "df9562f6-22da-4b56-8b1c-76e9efb08cca",
    "prId" : 77760,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77760#pullrequestreview-265606023",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a341732a-5682-421e-83c5-7f3e376e1fc3",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "You may also want to add that since we restrict a toplogyKey to exist in a single hard constraint, using topolgyKey as the key in this map is good enough to identify which exact constraint this pod is counted against (because otherwise the key to the map should be some sort of an identifier that combines the topologyKey and the label selector)",
        "createdAt" : "2019-07-23T18:46:43Z",
        "updatedAt" : "2019-07-23T18:46:59Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "f822487f05313290140e08e508249e9970b5b5c3",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +253,257 @@\t\t\t\tif ok {\n\t\t\t\t\t// constraint.TopologyKey is already guaranteed to be present\n\t\t\t\t\tpair := topologyPair{key: constraint.TopologyKey, value: node.Labels[constraint.TopologyKey]}\n\t\t\t\t\tnodeTopologyMaps.addTopologyPair(pair, existingPod)\n\t\t\t\t}"
  },
  {
    "id" : "c6685a7c-d817-402e-9305-c42b73c579e0",
    "prId" : 77760,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77760#pullrequestreview-265760656",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fe65368-0c38-49dc-9b67-62573ce5dd54",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Is it possible that value of some topologyPairsPodSpreadMap.topologyKeyToMinPodsMap is\r\nmath.MaxInt32 at the end of this loop ?",
        "createdAt" : "2019-07-24T01:49:52Z",
        "updatedAt" : "2019-07-24T01:52:27Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "a62dc294-508f-4ffc-9539-cd2a2a705b5c",
        "parentId" : "1fe65368-0c38-49dc-9b67-62573ce5dd54",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Nope. The logic below ensures for each tp pair, they're valued with either empty podSet, or a concrete podSet:\r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/5993ec5a5a306de2b329ae7bfd182e8dddf3a8f3/pkg/scheduler/algorithm/predicates/metadata.go#L260-L272\r\n\r\nThen in the above loop, the default value (MaxInt32) will be compared with len(podSet), so they won't remain MaxInt32 at the end of the loop.",
        "createdAt" : "2019-07-24T02:07:22Z",
        "updatedAt" : "2019-07-24T02:07:22Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "f822487f05313290140e08e508249e9970b5b5c3",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +285,289 @@\t\ttopologyPairsPodSpreadMap.topologyKeyToMinPodsMap[constraint.TopologyKey] = math.MaxInt32\n\t}\n\tfor pair, podSet := range topologyPairsPodSpreadMap.topologyPairToPods {\n\t\t// TODO(Huang-Wei): short circuit unvisited portions of <topologyKey: any value>\n\t\t// if we already see 0 as min match of that topologyKey."
  },
  {
    "id" : "6522762e-5a25-4ecb-9804-29d0ebfa46f6",
    "prId" : 77760,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77760#pullrequestreview-265767391",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b04687d-4551-48e9-b181-256b91a88b8f",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "I wonder what type of short circuiting you were thinking about.\r\nWithout short circuiting, the following comparison is performed and we continue to the next pair:\r\n```\r\nl < topologyPairsPodSpreadMap.topologyKeyToMinPodsMap[pair.key]\r\n```",
        "createdAt" : "2019-07-24T02:40:37Z",
        "updatedAt" : "2019-07-24T02:40:37Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "f822487f05313290140e08e508249e9970b5b5c3",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +286,290 @@\t}\n\tfor pair, podSet := range topologyPairsPodSpreadMap.topologyPairToPods {\n\t\t// TODO(Huang-Wei): short circuit unvisited portions of <topologyKey: any value>\n\t\t// if we already see 0 as min match of that topologyKey.\n\t\tif l := int32(len(podSet)); l < topologyPairsPodSpreadMap.topologyKeyToMinPodsMap[pair.key] {"
  },
  {
    "id" : "4972a9fa-f84f-4d61-bb88-3910e0726d7b",
    "prId" : 76536,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76536#pullrequestreview-226952132",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db4c89f6-a5c6-41bf-86c6-885652204bc7",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "We must also ensure that `predicateMetadataProducers` map is not read/updated by other parallel threads. My quick look at the code didn't reveal any parallel thread that could read or update the map though.",
        "createdAt" : "2019-04-16T01:42:40Z",
        "updatedAt" : "2019-04-16T01:42:41Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "4038a5e3db9a29eaef469d80d4d121f66b42a5b4",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +105,109 @@// RegisterPredicateMetadataProducer registers a PredicateMetadataProducer.\nfunc RegisterPredicateMetadataProducer(predicateName string, precomp predicateMetadataProducer) {\n\tpredicateMetadataProducers[predicateName] = precomp\n}\n"
  },
  {
    "id" : "2f2a2ec1-d43d-4819-842e-e2df354a0e96",
    "prId" : 71978,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/71978#pullrequestreview-185925834",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ecc4292-f533-4421-940e-8bbd341ce8bd",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "This one confuses me every time I read it. It's not really in scope of this PR, but could you add a note to the comment that this type is stored in a global variable below and used to modify the return values of `PredicateMetadataProducer`?",
        "createdAt" : "2018-12-17T19:31:19Z",
        "updatedAt" : "2018-12-21T14:27:20Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "ca904f8f-bb96-41fe-b50f-08deae52caea",
        "parentId" : "8ecc4292-f533-4421-940e-8bbd341ce8bd",
        "authorId" : "89bff7d0-c420-41e1-9e5e-db63c4cccd93",
        "body" : "Done thanks",
        "createdAt" : "2018-12-18T06:48:57Z",
        "updatedAt" : "2018-12-21T14:27:20Z",
        "lastEditedBy" : "89bff7d0-c420-41e1-9e5e-db63c4cccd93",
        "tags" : [
        ]
      }
    ],
    "commit" : "b82a1d46003bf38f13cab864c0be09feefd27c4f",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +106,110 @@// predicateMetadataProducer function produces predicate metadata. It is stored in a global variable below\n// and used to modify the return values of PredicateMetadataProducer\ntype predicateMetadataProducer func(pm *predicateMetadata)\n\nvar predicateMetaProducerRegisterLock sync.Mutex"
  },
  {
    "id" : "db427e42-ea30-4023-8a69-2ee31efc5c2b",
    "prId" : 70602,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70602#pullrequestreview-171445994",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6da8d26-6409-4a43-900f-9f5eaf8bf925",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "I **_thought_** following logic would be more performant:\r\n\r\n```go\r\n\tallNodeNames := make([]string, len(nodeInfoMap))\r\n\tfor i, name := range nodeInfoMap {\r\n\t\tallNodeNames[i] = name\r\n\t}\r\n```\r\n\r\nSo I did a [test](https://play.golang.org/p/33bc1GOa1KV), but it turns it's even a little bit less performant...\r\n\r\nSo current logic is good to me. Thanks!",
        "createdAt" : "2018-11-02T22:42:03Z",
        "updatedAt" : "2018-11-02T22:42:04Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "76bd96ec-7654-4849-8133-58a7a23e7e3f",
        "parentId" : "a6da8d26-6409-4a43-900f-9f5eaf8bf925",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Thanks for checking. The biggest issue here is that in our scalability tests with 5000 nodes, these \"allNodeNames\" slices which exist in `getTPMapMatchingIncomingAffinityAntiAffinity`, `getTPMapMatchingExistingAntiAffinity`, and `CalculateInterPodAffinityPriority` allocate/release a tone of memory (about 12GB each) over the course of the test. The one here is doing it unnecessarily for pods that don't have any affinity rules. The other two are harder to avoid.",
        "createdAt" : "2018-11-02T23:21:49Z",
        "updatedAt" : "2018-11-02T23:22:59Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "e7bd54fa-c7a5-43b1-a0c3-14a6aa72d84b",
        "parentId" : "a6da8d26-6409-4a43-900f-9f5eaf8bf925",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "For getTPMapMatchingExistingAntiAffinity, it seems the assumption is that the number of entries of allNodeNames would be the same as the number of entries of nodeInfoMap when processNode runs.\r\n\r\nIs it possible to skip allNodeNames altogether ?\r\ne.g. \r\n```\r\n  processNode := func(i int) {\r\n    nodeInfo := nodeInfoMap[allNodeNames[i]]\r\n```\r\nInstead of getting nodeInfo from nodeInfoMap by node name, can an iterator of nodeInfoMap be used to skip the first i-1 entries ?\r\nThat way, allNodeNames wouldn't be needed.",
        "createdAt" : "2018-11-04T18:55:44Z",
        "updatedAt" : "2018-11-04T18:55:44Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "c676678d-128c-4fe3-996b-3cb59b32caf3",
        "parentId" : "a6da8d26-6409-4a43-900f-9f5eaf8bf925",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "@tedyu I exactly had the same question when I realized that these arrays which are used purely for iterating over nodeInfoMap allocate and release so much memory. I did a bit of looking, but I realized that iterating over maps in Go is not predictable. So, my finding is that it is not possible to go to the \"i\"th entry of a map.",
        "createdAt" : "2018-11-05T08:16:45Z",
        "updatedAt" : "2018-11-05T08:16:45Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a352b2b92e76532c6fcc2a27f60912112a7d556",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +414,418 @@\t}\n\n\tallNodeNames := make([]string, 0, len(nodeInfoMap))\n\tfor name := range nodeInfoMap {\n\t\tallNodeNames = append(allNodeNames, name)"
  },
  {
    "id" : "d0c7c89a-dfb2-4552-97d2-bab02f3b8feb",
    "prId" : 68173,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68173#pullrequestreview-152209099",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b992075e-af6d-45a4-9884-22c266a92764",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "Did not get time to go through all doc and comments :( \r\n\r\nBut according to the comments of `PodAntiAffinity`, it said \r\n\r\n> 2309     // If the anti-affinity requirements specified by this field are not met at\r\n2310     // scheduling time, the pod will not be scheduled onto the node.\r\n2311     // If the anti-affinity requirements specified by this field cease to be met\r\n2312     // at some point during pod execution (e.g. due to a pod label update), the\r\n2313     // system may or may not try to eventually evict the pod from its node.\r\n2314     // When there are multiple elements, the lists of nodes corresponding to each\r\n2315     // podAffinityTerm are intersected, i.e. all terms must be satisfied.\r\n2316     // +optional\r\n\r\nAnd how do we handle Affinity that Node did not have such label? I'm thinking that a `bool` (Yes or No) maybe not enough :)",
        "createdAt" : "2018-09-03T07:59:42Z",
        "updatedAt" : "2018-09-14T01:33:36Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "d1ccae10-72d2-49d0-8c0f-0ec11c873507",
        "parentId" : "b992075e-af6d-45a4-9884-22c266a92764",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "\"Node\" is a typo I guess... I suppose you meant \"pod\".\r\n\r\nIf there is no pod has labels matching the terms, function `podMatches{All|Any}AffinityTermProperties (targetPod, affinityProperties)` both returns false.\r\n\r\nThis is enough I think, because:\r\n> There are 2 phases to verify symmetry of PodAntiAffinity:\r\n> - verify labels of incoming pod not violates {anti}affinity of existing pods\r\n> - verify {anti}affinity of incoming pod not violates labels of existing pods \r\n\r\nIn other words, we need to evaluate combination of each phase: (can do early break for sure)\r\n- if it's Affinity case\r\n    - only and only if `true` + `true` means fit\r\n    - other combinations means no fit\r\n- if it's AntiAffinity case\r\n    - only and only if `false` + `false` means fit\r\n    - other combinations means no fit",
        "createdAt" : "2018-09-04T07:35:31Z",
        "updatedAt" : "2018-09-14T01:33:36Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "9f1dfad8-518d-4d01-853a-f97f88824c7e",
        "parentId" : "b992075e-af6d-45a4-9884-22c266a92764",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "I'd like to point out that @Huang-Wei did not change this function in this PR. `podMatchesAllAffinityTermProperties` is the same function that used to be named `podMatchesAffinityTermProperties`.\r\n\r\nThis function's docstring does not match its implementation. It specifically says it returns true if *any* property matches, but uses the function that checks *all*.\r\n\r\n@k82cn makes a good comment that this function doesn't seem to jibe with the definition of affinity/anti-affinity. I believe this is likely just due to confusing choice of function names and code organization. i.e. The logic is probably correct, but the names tell an incorrect story.\r\n\r\nOverall this change is a net benefit to code readability. Renaming that function made it clear that the logic and naming in this file could use improvement.",
        "createdAt" : "2018-09-04T19:11:43Z",
        "updatedAt" : "2018-09-14T01:33:36Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7490542156f6082176f7b85ad455e7470c37bd68",
    "line" : 217,
    "diffHunk" : "@@ -1,1 +506,510 @@\t\treturn false\n\t}\n\treturn podMatchesAllAffinityTermProperties(targetPod, affinityProperties)\n}\n"
  },
  {
    "id" : "7faada41-17d7-43e5-9188-8a6270147b92",
    "prId" : 68173,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68173#pullrequestreview-154879457",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd69407a-ba0a-4acc-8643-c280c720e976",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Looks like this function was renamed at some point without updating the function comment. Do you mind updating it?",
        "createdAt" : "2018-09-04T19:06:27Z",
        "updatedAt" : "2018-09-14T01:33:36Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "6e98cca0-0b9e-44ca-b1d3-52ef4a803089",
        "parentId" : "cd69407a-ba0a-4acc-8643-c280c720e976",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "done.",
        "createdAt" : "2018-09-12T23:16:36Z",
        "updatedAt" : "2018-09-14T01:33:36Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "7490542156f6082176f7b85ad455e7470c37bd68",
    "line" : 215,
    "diffHunk" : "@@ -1,1 +505,509 @@\t\tglog.Errorf(\"error in getting affinity properties of Pod %v\", pod.Name)\n\t\treturn false\n\t}\n\treturn podMatchesAllAffinityTermProperties(targetPod, affinityProperties)\n}"
  },
  {
    "id" : "4f33528e-9fb2-4fff-a3cd-c25e936f84c5",
    "prId" : 62211,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62211#pullrequestreview-111850275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "601ef26c-6f0a-4de4-82f6-c3eb03fba1f6",
        "parentId" : null,
        "authorId" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "body" : "I think you could combine this function and `targetPodMatchesAntiaffinity` by having one more field for affinity or antiaffinity terms.",
        "createdAt" : "2018-04-12T17:00:01Z",
        "updatedAt" : "2018-04-12T23:30:22Z",
        "lastEditedBy" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "tags" : [
        ]
      },
      {
        "id" : "7a14415b-0f8b-4f26-9f8c-c05ee8cb7bce",
        "parentId" : "601ef26c-6f0a-4de4-82f6-c3eb03fba1f6",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "We can, but the first half of the functions must be duplicated and more conditions checks must be added. I feel that would be less readable for not duplicating only several lines of code.",
        "createdAt" : "2018-04-12T19:04:14Z",
        "updatedAt" : "2018-04-12T23:30:22Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "0731e417-53ae-4384-947a-eb7e0d2a9650",
        "parentId" : "601ef26c-6f0a-4de4-82f6-c3eb03fba1f6",
        "authorId" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "body" : "SGTM",
        "createdAt" : "2018-04-13T01:08:53Z",
        "updatedAt" : "2018-04-13T01:08:53Z",
        "lastEditedBy" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3041698e521f60a65409a15dc2d6dd845a68a462",
    "line" : 264,
    "diffHunk" : "@@ -1,1 +403,407 @@// So, whether the targetPod actually matches or not needs further checks for a specific\n// node.\nfunc targetPodMatchesAffinityOfPod(pod, targetPod *v1.Pod) bool {\n\taffinity := pod.Spec.Affinity\n\tif affinity == nil || affinity.PodAffinity == nil {"
  },
  {
    "id" : "fd36d711-64fe-4ad4-ae56-fb5d1e7a647d",
    "prId" : 62211,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62211#pullrequestreview-111868932",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "75b01441-286e-4717-87f7-86c3a437f22a",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "please also include error message in error message :)",
        "createdAt" : "2018-04-13T03:10:53Z",
        "updatedAt" : "2018-04-13T03:10:53Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      }
    ],
    "commit" : "3041698e521f60a65409a15dc2d6dd845a68a462",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +120,124 @@\taffinityPods, antiAffinityPods, err := getPodsMatchingAffinity(pod, nodeNameToInfoMap)\n\tif err != nil {\n\t\tglog.Errorf(\"[predicate meta data generation] error finding pods that match affinity terms\")\n\t\treturn nil\n\t}"
  }
]
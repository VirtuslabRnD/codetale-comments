[
  {
    "id" : "0a3d2608-d09f-474b-9233-0bf3a4878853",
    "prId" : 89437,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89437#pullrequestreview-380581319",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2eb293a8-7be6-4243-82f0-291b949a9c15",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "I would just do this instead of the block below:\r\n\r\n```suggestion\r\n\t\tif err != nil || existingPodNode == nil {\r\n```",
        "createdAt" : "2020-03-24T18:22:51Z",
        "updatedAt" : "2020-03-24T18:58:05Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f41500dd71475e748e5d61ca92ae57a33805e92",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +114,118 @@\tprocessPod := func(existingPod *v1.Pod) error {\n\t\texistingPodNode, err := ipa.info.GetNodeInfo(existingPod.Spec.NodeName)\n\t\tif err != nil {\n\t\t\tif apierrors.IsNotFound(err) {\n\t\t\t\treturn nil"
  },
  {
    "id" : "d5be1921-162c-4428-a280-78c01d0b2d60",
    "prId" : 85959,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85959#pullrequestreview-328364622",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f53e27af-d2e0-42c4-825f-47df75c6c6bb",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "worth adding a comment indicating that this the representation of v1.WeightedPodAffinityTerm",
        "createdAt" : "2019-12-06T16:20:43Z",
        "updatedAt" : "2019-12-06T17:59:15Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "a65617f8-ec4c-40e7-89ce-875f5642b178",
        "parentId" : "f53e27af-d2e0-42c4-825f-47df75c6c6bb",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "done.",
        "createdAt" : "2019-12-06T17:59:23Z",
        "updatedAt" : "2019-12-06T17:59:24Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "53be26e4025dfb14b35b3fb1c90ddf67e5aadc53",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +47,51 @@\n// A \"processed\" representation of v1.WeightedAffinityTerm.\ntype weightedAffinityTerm struct {\n\tnamespaces  sets.String\n\tselector    labels.Selector"
  },
  {
    "id" : "7464c2fc-6d63-4983-baf5-a6fa5a1ce33e",
    "prId" : 84669,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84669#pullrequestreview-312253229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0299fcd2-d0ea-4d1d-b5cf-53ba07cd4cae",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "A nit: we can pass `Node` to processPod, so don't need to rely on `sharedLister`, hence the method `buildTopologyPairToScore` can eliminate the parameter `sharedLister`. ",
        "createdAt" : "2019-11-04T20:26:45Z",
        "updatedAt" : "2019-11-07T00:52:47Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "72dd8f3c-2c5e-4ecc-9003-12611903142f",
        "parentId" : "0299fcd2-d0ea-4d1d-b5cf-53ba07cd4cae",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "After #84824 merged, we could keep the sharedLister and remove allNodes from the arguments lists. :)",
        "createdAt" : "2019-11-06T08:14:30Z",
        "updatedAt" : "2019-11-07T00:52:47Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "652baf18601eecf42521a1361a8815576bc8eb55",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +176,180 @@\n\tprocessPod := func(existingPod *v1.Pod) error {\n\t\texistingPodNodeInfo, err := sharedLister.NodeInfos().Get(existingPod.Spec.NodeName)\n\t\tif err != nil {\n\t\t\tklog.Errorf(\"Node not found, %v\", existingPod.Spec.NodeName)"
  },
  {
    "id" : "9d1ae0af-f7ad-4c22-bf90-cbf819c7e633",
    "prId" : 82841,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82841#pullrequestreview-290125509",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1c664ee-c138-423c-b12a-efcbf867e67d",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "So we are saying:\r\nWe can't deduce which nodes could be counted, so create a counter for all of them. Please add this to the solution section of the PR description.\r\n\r\nNot related to this PR: have we done the same mistake for even pod spreading?",
        "createdAt" : "2019-09-18T18:32:06Z",
        "updatedAt" : "2019-09-19T17:52:13Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "f18eb32a-a1c4-489c-a482-729ac0383a7f",
        "parentId" : "a1c664ee-c138-423c-b12a-efcbf867e67d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "> We can't deduce which nodes could be counted, so create a counter for all of them.\r\n\r\nYes, and in the before, the overhead of using a map and initializing *int64 is too high.\r\n\r\n> have we done the same mistake for even pod spreading?\r\n\r\nEven pods spreading doesn't need to consider Symmetry, so it's fine.",
        "createdAt" : "2019-09-18T18:43:08Z",
        "updatedAt" : "2019-09-19T17:52:13Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c9312fa7e30352999346c0ec7d7ec12cc557ff3",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +105,109 @@\tpm := newPodAffinityPriorityMap(nodes)\n\tallNodeNames := make([]string, 0, len(nodeNameToInfo))\n\tfor name := range nodeNameToInfo {\n\t\tallNodeNames = append(allNodeNames, name)\n\t}"
  },
  {
    "id" : "0db53080-29b3-44ac-a03f-449281ed07dc",
    "prId" : 82841,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82841#pullrequestreview-290285306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "440b01d3-d573-4da2-8bbe-98691a4ede7e",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Please fix the comment.",
        "createdAt" : "2019-09-18T20:26:00Z",
        "updatedAt" : "2019-09-19T17:52:13Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "7e115248-57e0-41a2-bd65-32fd61012faf",
        "parentId" : "440b01d3-d573-4da2-8bbe-98691a4ede7e",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Updated.",
        "createdAt" : "2019-09-18T20:46:37Z",
        "updatedAt" : "2019-09-19T17:52:13Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "4a0ef272-9d54-4057-82a4-593c300f0dea",
        "parentId" : "440b01d3-d573-4da2-8bbe-98691a4ede7e",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "fix the comment in line 104 as well.",
        "createdAt" : "2019-09-19T01:45:18Z",
        "updatedAt" : "2019-09-19T17:52:13Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c9312fa7e30352999346c0ec7d7ec12cc557ff3",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +55,59 @@\tnodes []*v1.Node\n\t// counts store the so-far computed score for each node.\n\tcounts []int64\n}\n"
  },
  {
    "id" : "1c82112c-de06-4925-b32e-ca7ad2c44791",
    "prId" : 80588,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80588#pullrequestreview-266780546",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d17b2ad-4058-42b9-a6ed-3f7480ddeb6b",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "you can do \r\n\r\n```\r\nif err := pm.processTerms(terms, pod, existingPod, existingPodNode, 1); err != nil {\r\n    return err\r\n}\r\n```\r\nhere and all other places below.",
        "createdAt" : "2019-07-25T15:12:47Z",
        "updatedAt" : "2019-07-30T00:45:00Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "54ec4ce3-67c7-405a-ac43-9f288f9d74d2",
        "parentId" : "3d17b2ad-4058-42b9-a6ed-3f7480ddeb6b",
        "authorId" : "a650878f-0c10-41c7-b0fc-033031305d77",
        "body" : "Not sure which style we prefer. I have seen many places that the current pattern is used. But I will go ahead with you suggestion since I like this style too.",
        "createdAt" : "2019-07-25T17:40:11Z",
        "updatedAt" : "2019-07-30T00:45:00Z",
        "lastEditedBy" : "a650878f-0c10-41c7-b0fc-033031305d77",
        "tags" : [
        ]
      }
    ],
    "commit" : "9663c337475768f50d999c8f9ff58a0481b6a56e",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +146,150 @@\t\t\tif err := pm.processTerms(terms, pod, existingPod, existingPodNode, 1); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif hasAntiAffinityConstraints {"
  },
  {
    "id" : "7ba72d0c-ee86-4641-8608-ba979b3639f0",
    "prId" : 76973,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76973#pullrequestreview-230327829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0517eb2c-92dd-4eb6-bcef-98239524dad9",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "It looks to me that if `maxMinDiff` is zero, we can skip the for loop below altogether.",
        "createdAt" : "2019-04-24T18:47:05Z",
        "updatedAt" : "2019-04-24T19:02:18Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "b1f7601e-6f1e-4559-80fe-f4e4398150ae",
        "parentId" : "0517eb2c-92dd-4eb6-bcef-98239524dad9",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Thanks for the review!\r\n\r\nYes, that could be possible. I can investigate later to see whether current Priority reduce interface is fine with an empty []schedulerapi.HostPriorityList vs. mandatory entries with  `schedulerapi.HostPriority{Host: node.Name, Score: 0}` in the result set.",
        "createdAt" : "2019-04-24T20:05:24Z",
        "updatedAt" : "2019-04-24T20:05:24Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "492b970d73cfd53410685f78cf64cfa596b85f52",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +232,236 @@\t// calculate final priority score for each node\n\tresult := make(schedulerapi.HostPriorityList, 0, len(nodes))\n\tmaxMinDiff := maxCount - minCount\n\tfor _, node := range nodes {\n\t\tfScore := float64(0)"
  },
  {
    "id" : "e65fc3dd-63ac-42bb-aa9e-59e5354c8ff6",
    "prId" : 76243,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76243#pullrequestreview-224711552",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "563811f4-db24-4b78-b609-4036cb70577c",
        "parentId" : null,
        "authorId" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "body" : "I guess, we might have lost the float scores by now. I believe, we tried something similar in the past and it affected correctness. The one thing, I am curious about is - any difference between the scores computed, is there some difference between the scores computed with this patch/without this patch?(IIRC, last time the issue was related to too many nodes having same score).",
        "createdAt" : "2019-04-08T19:31:52Z",
        "updatedAt" : "2019-04-08T19:31:52Z",
        "lastEditedBy" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "tags" : [
        ]
      },
      {
        "id" : "5f98c404-db6e-4d30-b53b-b8e4b7a3ca3d",
        "parentId" : "563811f4-db24-4b78-b609-4036cb70577c",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "@ravisantoshgudimetla could you point me the issue #?\r\n\r\nThis PR introduced following changes related with fraction:\r\n\r\n- `weight` is always an integer, so new change that loads `weight` into `p.counts[node.Name]` (from float64 to int64) in an atomic way should be fine.\r\n- change from `float64(term.Weight*int32(multiplier)))` to `int64(term.Weight*int32(multiplier))` should be also fine as `multiplier` is of type `int`\r\n- `maxCount/minCount` are assigned from `p.counts[node.Name]`; should be good as well\r\n- the last one: change from `(pm.counts[node.Name] - minCount) / (maxCount - minCount)` to `float64(*pm.counts[node.Name]-minCount) / float64(maxCount-minCount)`; this doens't lose correctness either.",
        "createdAt" : "2019-04-08T20:18:30Z",
        "updatedAt" : "2019-04-08T20:18:30Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "7960ffcb-5949-400e-aaaa-8f27f670244e",
        "parentId" : "563811f4-db24-4b78-b609-4036cb70577c",
        "authorId" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "body" : "\r\nGot it, thanks for the explanation. I have some questions on the `term.Weight*int32(multiplier)` but I see that both of them are of the type int.",
        "createdAt" : "2019-04-10T00:16:27Z",
        "updatedAt" : "2019-04-10T00:16:27Z",
        "lastEditedBy" : "38ca4f80-c365-4775-8981-1e56b713b07b",
        "tags" : [
        ]
      }
    ],
    "commit" : "28730919a69d0a1518853fcc91ba54231919f7ed",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +228,232 @@\t\tfScore := float64(0)\n\t\tif (maxCount - minCount) > 0 {\n\t\t\tfScore = float64(schedulerapi.MaxPriority) * (float64(*pm.counts[node.Name]-minCount) / float64(maxCount-minCount))\n\t\t}\n\t\tresult = append(result, schedulerapi.HostPriority{Host: node.Name, Score: int(fScore)})"
  },
  {
    "id" : "6a4b1b0b-9049-4c3b-8022-68021e8eb9e1",
    "prId" : 76243,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/76243#pullrequestreview-224704987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3008119-be5c-43ef-975c-839e314b1c52",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "why does the value need to be an `int64` pointer, instead of just an `int64`?",
        "createdAt" : "2019-04-09T21:13:52Z",
        "updatedAt" : "2019-04-09T21:13:53Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "1e62f576-f18f-4754-81d3-2bcb62b49e1d",
        "parentId" : "f3008119-be5c-43ef-975c-839e314b1c52",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "It's because [atomic#AddInt64](https://golang.org/pkg/sync/atomic/#AddInt64) takes pointer as parameter.\r\n\r\nIf we go with `map[string]int64`, map value is not addressable (`&map[\"key\"]` is illegal); and alsoyou can't make `val := map[\"key\"]; ptr := &val` b/c that's another address.",
        "createdAt" : "2019-04-09T21:20:58Z",
        "updatedAt" : "2019-04-09T21:20:58Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "62d93513-84f1-45d5-b8ed-cde7306f4415",
        "parentId" : "f3008119-be5c-43ef-975c-839e314b1c52",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "That's right. In Go you cannot get a pointer to map entries as they may change during execution. ",
        "createdAt" : "2019-04-09T23:45:29Z",
        "updatedAt" : "2019-04-09T23:46:28Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "28730919a69d0a1518853fcc91ba54231919f7ed",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +65,69 @@\t// counts store the mapping from node name to so-far computed score of\n\t// the node.\n\tcounts map[string]*int64\n\t// The first error that we faced.\n\tfirstError error"
  },
  {
    "id" : "4087dbe6-f631-4265-b831-bfc56425dc32",
    "prId" : 70605,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/70605#pullrequestreview-172363876",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7812041-1057-45b2-89d7-ecf9da7da014",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "What other processes call this lock ?  Curious if this actually causes some issues or just an optimization ?",
        "createdAt" : "2018-11-04T09:56:05Z",
        "updatedAt" : "2018-11-04T09:56:05Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "89740bbd-6c7d-4b80-aeab-7e081c617ff2",
        "parentId" : "e7812041-1057-45b2-89d7-ecf9da7da014",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "All worker threads call this function. Holding the lock shorter can potentially improve performance. There is no change of logic here. This is only a performance optimization.",
        "createdAt" : "2018-11-05T08:22:34Z",
        "updatedAt" : "2018-11-05T08:22:34Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "6ea7fae4-1dd3-45ec-ac35-0ea814b0b1e6",
        "parentId" : "e7812041-1057-45b2-89d7-ecf9da7da014",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This helps with lock contention, though it increases the number of times we do \"lock+unlock\" potentially by 5000 times (so it may hurt performance potentially).",
        "createdAt" : "2018-11-07T07:27:13Z",
        "updatedAt" : "2018-11-07T07:27:19Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa8b5b431b2451b5670e0f89b8b159d60fb7a50b",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +97,101 @@\t\t\t\tp.Lock()\n\t\t\t\tp.counts[node.Name] += weight\n\t\t\t\tp.Unlock()\n\t\t\t}\n\t\t}"
  }
]
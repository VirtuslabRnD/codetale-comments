[
  {
    "id" : "3f4cd83b-ac3b-456a-a228-2696c151c438",
    "prId" : 73567,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73567#pullrequestreview-198446132",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fbc4588a-8595-4e35-b1fa-23546d658479",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "missing `moveRequestCycle` here ",
        "createdAt" : "2019-01-31T06:55:16Z",
        "updatedAt" : "2019-01-31T06:58:05Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "88f4a71e-4df0-4eb9-8f7d-bf21fca8fd79",
        "parentId" : "fbc4588a-8595-4e35-b1fa-23546d658479",
        "authorId" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "body" : "fixed, thanks!",
        "createdAt" : "2019-01-31T06:58:39Z",
        "updatedAt" : "2019-01-31T06:58:40Z",
        "lastEditedBy" : "e4e7c71f-23b5-4203-b65d-3f5f3c503b64",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc176598e4354766b24a2a9a744560db37c2070b",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +206,210 @@\t// schedulingCycle represents sequence number of scheduling cycle and is incremented\n\t// when a pod is popped.\n\tschedulingCycle int64\n\t// moveRequestCycle caches the sequence number of scheduling cycle when we\n\t// received a move request. Unscheduable pods in and before this scheduling"
  },
  {
    "id" : "ebed37c8-4c4f-4cdc-9d2f-9208a0f54a73",
    "prId" : 68700,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68700#pullrequestreview-159244284",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "713cceb5-5d5e-4727-9ff0-cea26677298e",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Not quite sure it's necessary to introduce another mutex to protect `closed` specifically.",
        "createdAt" : "2018-09-15T00:12:45Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "f589f380-30bb-472b-80ef-391967d322f0",
        "parentId" : "713cceb5-5d5e-4727-9ff0-cea26677298e",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "no, one mutex is enough to me :)",
        "createdAt" : "2018-09-26T02:03:14Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "53b81b98-71bd-4507-ad74-29789805453b",
        "parentId" : "713cceb5-5d5e-4727-9ff0-cea26677298e",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Sweet.",
        "createdAt" : "2018-09-27T00:11:30Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "be661fddb49087af113f03b106e827bec9bc4efe",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +196,200 @@\t// closed indicates that the queue is closed.\n\t// It is mainly used to let Pop() exit its control loop while waiting for an item.\n\tclosed bool\n}\n"
  },
  {
    "id" : "1d8a79bb-2fc1-45a3-ab48-d240d3f3ff7a",
    "prId" : 68700,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68700#pullrequestreview-159244158",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62a18a72-23d8-4776-b86a-bf2d80c7f257",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "I don't think this really warrants a const.",
        "createdAt" : "2018-09-25T19:19:41Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "b4a574e2-d71a-4885-9075-8a2c4a8e3614",
        "parentId" : "62a18a72-23d8-4776-b86a-bf2d80c7f257",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "maybe an error var is better, similar to `FIFOClosedError`.",
        "createdAt" : "2018-09-26T02:02:08Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "5ec5ecc9-ef48-497b-9dee-7a772ec635f2",
        "parentId" : "62a18a72-23d8-4776-b86a-bf2d80c7f257",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "In theory, yes, but we don't currently check the error anywhere. YAGNI.",
        "createdAt" : "2018-09-26T19:53:50Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "2a52f319-46f2-4f6b-9de2-2eeb404569da",
        "parentId" : "62a18a72-23d8-4776-b86a-bf2d80c7f257",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "let's make it a var.",
        "createdAt" : "2018-09-27T00:10:49Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "be661fddb49087af113f03b106e827bec9bc4efe",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +45,49 @@\nvar (\n\tqueueClosed = \"scheduling queue is closed\"\n)\n"
  },
  {
    "id" : "c0d9b45a-810c-4de3-8b6f-12c44d696f05",
    "prId" : 68700,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68700#pullrequestreview-159244173",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22fbf01e-8e66-4bb7-91db-cd2e66eef721",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Could you please add comments to `Pop()` and `Close()` in this interface that explain the blocking behavior?",
        "createdAt" : "2018-09-25T19:36:10Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "83799c54-7411-4a45-99f4-b3a3ae4a6508",
        "parentId" : "22fbf01e-8e66-4bb7-91db-cd2e66eef721",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "sure.",
        "createdAt" : "2018-09-27T00:10:54Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "be661fddb49087af113f03b106e827bec9bc4efe",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +67,71 @@\t// Close closes the SchedulingQueue so that the goroutine which is\n\t// waiting to pop items can exit gracefully.\n\tClose()\n}\n"
  },
  {
    "id" : "ea0d4595-8be5-4071-9071-8ef8e1ac3a51",
    "prId" : 68700,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/68700#pullrequestreview-159679824",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "Should also check queue is closed.",
        "createdAt" : "2018-09-26T02:01:17Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "56f4d886-7d08-4f6f-8748-27fe03ba41da",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Hmm, I doubt it. `p.activeQ.Pop()` should be consistent with `len(p.activeQ.data.queue) == 0`, right? As we have mutex protecting this.",
        "createdAt" : "2018-09-27T00:11:35Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "58e74c9b-a100-43c8-8110-114950b1b669",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "when `p.cond.Wait()` return , we need to recheck the status queue as this thread may not the first one to get the lock; so how about some other thread add more item before this thread get the lock?",
        "createdAt" : "2018-09-27T01:17:21Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "108cd531-70a8-4170-ab0f-83989c74acb8",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "This is a good point.\r\n\r\nI read some article saying that when `cond.Wait()` is called, the goroutine is suspended, but it's smart to not hold the lock. Instead, it tries to re-acquire the lock when it's awaken by a `Broadcast()` or `Signal()`.\r\n\r\nThe article is [here](https://kaviraj.me/understanding-condition-variable-in-go/), and it states like this:\r\n\r\n> It may look like that the goroutine waiting(rec.cond.Wait()) is holding the lock whole time(rec.Lock()), but its not, Internally cond.Wait() unlocks it and it **locks it again** only when it wakes up by other go routine.\r\n\r\nSo if this's true, when it's awaken again, it should try to acquire the lock first, and then check if its length is 0, then it's safe.\r\n\r\nBut I need to write some sample to verify above saying.\r\n",
        "createdAt" : "2018-09-27T02:19:52Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "7919371b-99d7-42a1-bce3-0ae3a0fa891e",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "> So if this's true, when it's awaken again, it should try to acquire the lock first\r\n\r\nWhen `wait()` return, it will get the lock again; but we do not know what was happened between `Broadcast`/`Signal` and `getting lock again`. That's why we use `for loop` to check `queue.len` again.\r\n\r\n> and then check if its length is 0, then it's safe.\r\n\r\nThat's what the `for loop` doing :) \r\n",
        "createdAt" : "2018-09-27T04:48:15Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "9a37fe3e-bf11-43aa-bc38-64cfa0eaf9b3",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "In this case, if queue is closed but there are still new items (added by other goroutines), then without checking if queue is closed, resting items will still be handled.\r\n\r\nSo @k82cn your preference is to check if queue is closed, and return immediately if it is? (as it's sort of wasting time handling those items.) ",
        "createdAt" : "2018-09-27T05:38:31Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "03f22377-c01d-4638-99b9-114ecfb3c458",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "> your preference is to check if queue is closed, and return immediately if it is?\r\n\r\nmaybe a `IsClosed` is better; so the code who uses `SchedulingQueue` can decide whether continue to handle the pending item or ignore them.",
        "createdAt" : "2018-09-27T06:43:51Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "ca8aaea7-3698-470a-ab17-b39b4e7b1a5a",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "External users are not able to use SchedulingQueue any more lol... As we recently move it to package `internal`.",
        "createdAt" : "2018-09-27T21:26:53Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "bad3fe64-dd2b-4ff8-94a9-9902bf79f41e",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "I rethink it a little bit: given that FIFO implementation (in client-go) \"drains\" the queue, and currently PriorityQueue behaves the same, I think we'd better keep them as is. Any objection? cc @misterikkit @bsalamat \r\n\r\n(we can't / won't change client-go code is also one major reason)\r\n",
        "createdAt" : "2018-09-27T21:29:36Z",
        "updatedAt" : "2018-09-27T21:33:16Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "be34b368-579e-4b9f-88cf-37fef2fbbb1f",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "> External users are not able to use SchedulingQueue any more lol... As we recently move it to package `internal`.\r\n\r\nAnything in `pkg/scheduler/...` is not considered external from the perspective of `pkg/scheduler/internal/...` \r\nhttps://golang.org/doc/go1.5\r\n\r\n> currently PriorityQueue behaves the same\r\n\r\nI like that the two implementations are consistent, and I'm fine with the existing behavior. Let's just make sure to document it as an official part of the `SchedulingQueue` API so that people in the future know what is intended.\r\n",
        "createdAt" : "2018-09-27T21:42:15Z",
        "updatedAt" : "2018-09-27T21:42:25Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "c014ef54-2efc-4529-9330-4d1ed843cc6f",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Is there a chance this could cause a busy loop during shutdown?",
        "createdAt" : "2018-09-27T21:44:10Z",
        "updatedAt" : "2018-09-27T21:44:18Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "23b0896b-fee6-42d9-8da7-f1673a59fb41",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Even there is, I think it's the same case as before. It doesn't make things worse.",
        "createdAt" : "2018-09-27T21:48:44Z",
        "updatedAt" : "2018-09-27T21:48:44Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "c7a9c329-9617-4c11-bbda-89aadcdf1ba8",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "One possible case I can think of is that master scheduler lost its leader role, and want to exit gracefully, and _maybe_ there happens to be a long queue.",
        "createdAt" : "2018-09-27T21:52:38Z",
        "updatedAt" : "2018-09-27T21:52:38Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "ac5138ee-8e66-4f93-92c8-0ff70b26c180",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "I'm not too worried about that case. If scheduler is shutting down, then it should exit the run loop after Pop returns. We also don't acquire leadership twice in the scheduler (by design). When we lose leadership, the scheduler exits and is restarted.",
        "createdAt" : "2018-09-27T22:03:21Z",
        "updatedAt" : "2018-09-27T22:03:21Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "31661452-080c-4d7e-bea8-44cd539d10d9",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Thanks for humoring me",
        "createdAt" : "2018-09-27T22:03:52Z",
        "updatedAt" : "2018-09-27T22:03:52Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "c9303ec2-9ea8-406d-8689-e67308f9405f",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "> when p.cond.Wait() return , we need to recheck the status queue as this thread may not the first one to get the lock; so how about some other thread add more item before this thread get the lock?\r\n\r\nWhat is the problem if another thread adds more items? We can still close the queue and shut down.",
        "createdAt" : "2018-09-27T23:24:07Z",
        "updatedAt" : "2018-09-27T23:24:07Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "c334f9ee-8ed9-4403-b1da-465e5502c2b5",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "There is no problem actually. Resting items will be handled even if queue is closed.",
        "createdAt" : "2018-09-27T23:28:27Z",
        "updatedAt" : "2018-09-27T23:28:27Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "2b448f07-a838-4cef-aa9c-228d77924a31",
        "parentId" : "ed83fb1b-f068-4f6f-9c78-131e00d58e2d",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Apologize the misleading words. I re-read the code, my previous statement is inaccurate. It should be \"Resting items will be handled one time at most if queue is closed.\"\r\n\r\nIt's because in Pop(), if there are other items enqueued and queue is closed, next item will be popped out. And in outer logic, wait.Until() will return gracefully as stopChan is closed.\r\n\r\nSo I think we're good at dealing with at most one more item.",
        "createdAt" : "2018-09-27T23:41:44Z",
        "updatedAt" : "2018-09-27T23:44:30Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "be661fddb49087af113f03b106e827bec9bc4efe",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +338,342 @@\t\tp.cond.Wait()\n\t}\n\tobj, err := p.activeQ.Pop()\n\tif err != nil {\n\t\treturn nil, err"
  }
]
[
  {
    "id" : "9299b38f-cb03-4fe7-afff-f7103f85c66e",
    "prId" : 4765,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e54d5538-f938-4f0d-a6dd-f695a1cb8790",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Nit: why not just return a FitError?\n",
        "createdAt" : "2015-02-26T21:26:45Z",
        "updatedAt" : "2015-02-26T21:26:45Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "33f6576f61d31faf4ef5713233a5a80ccfee8f14",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +98,102 @@// Filters the minions to find the ones that fit based on the given predicate functions\n// Each minion is passed through the predicate functions to determine if it is a fit\nfunc findNodesThatFit(pod api.Pod, podLister PodLister, predicates map[string]FitPredicate, nodes api.NodeList) (api.NodeList, FailedPredicateMap, error) {\n\tfiltered := []api.Node{}\n\tmachineToPods, err := MapPodsToMachines(podLister)"
  },
  {
    "id" : "2eadcf18-44a0-46ba-82fd-aea289fb532e",
    "prId" : 2505,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7e6f662-fafc-4a56-b4bf-c2e8377f4ea8",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "What was happening before here?\n",
        "createdAt" : "2014-12-01T17:24:15Z",
        "updatedAt" : "2014-12-08T22:47:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "09072b12-e5da-460c-82ad-7e6191389945",
        "parentId" : "b7e6f662-fafc-4a56-b4bf-c2e8377f4ea8",
        "authorId" : "4ae12efd-7e98-4c8b-9218-1ed35d1a2df1",
        "body" : "It was being caught towards the end of the function if no minions were found that could fit the predicates. I added this check here to validate that minions existed and were listed prior to running them through the predicates.\n",
        "createdAt" : "2014-12-01T17:33:46Z",
        "updatedAt" : "2014-12-08T22:47:09Z",
        "lastEditedBy" : "4ae12efd-7e98-4c8b-9218-1ed35d1a2df1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d17cebcd2a0bf676fe99dbfbaa1182720cb0adca",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +39,43 @@\t\treturn \"\", err\n\t}\n\tif len(minions.Items) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no minions available to schedule pods\")\n\t}"
  },
  {
    "id" : "840d1542-ade0-4a44-8e6b-1ff457d08c9a",
    "prId" : 2505,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "883c42cf-85c6-4dc9-a7dd-f56d1332809e",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Why do you reverse sort and then forward sort?\n",
        "createdAt" : "2014-12-05T02:49:06Z",
        "updatedAt" : "2014-12-08T22:47:09Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "182c32f5-8aef-4ccf-9a07-5553d8448d35",
        "parentId" : "883c42cf-85c6-4dc9-a7dd-f56d1332809e",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "http://golang.org/pkg/sort/#Reverse\n",
        "createdAt" : "2014-12-05T05:44:46Z",
        "updatedAt" : "2014-12-08T22:47:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "1f8d763a-f050-4658-812d-ba1f8d6d7323",
        "parentId" : "883c42cf-85c6-4dc9-a7dd-f56d1332809e",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Ah, thanks, I had read that but not carefully enough.\n",
        "createdAt" : "2014-12-05T06:09:53Z",
        "updatedAt" : "2014-12-08T22:47:09Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "d17cebcd2a0bf676fe99dbfbaa1182720cb0adca",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +65,69 @@\t\treturn \"\", fmt.Errorf(\"empty priorityList\")\n\t}\n\tsort.Sort(sort.Reverse(priorityList))\n\n\thosts := getBestHosts(priorityList)"
  },
  {
    "id" : "563d8fed-e049-4bd8-84d3-b110e259c80f",
    "prId" : 1420,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c22b2397-3792-4281-8dee-94ca8076ad44",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Seems like this should be a \"while\" loop.\n",
        "createdAt" : "2014-09-24T23:05:13Z",
        "updatedAt" : "2014-09-25T17:49:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "dc2de199-bfac-4b6a-9d12-c23257d85bfd",
        "parentId" : "c22b2397-3792-4281-8dee-94ca8076ad44",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "if only go believed in such a thing...\n\nI could do for &lt;condition&gt; {  ... }\n\nbut I'm not sure what condition you are suggesting.\n",
        "createdAt" : "2014-09-24T23:21:53Z",
        "updatedAt" : "2014-09-25T17:49:43Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "be78e138-0f4b-42fe-93b6-39a41760a1a6",
        "parentId" : "c22b2397-3792-4281-8dee-94ca8076ad44",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "getMinHosts assumes a sorted list. You could take advantage of that by breaking out of the loop when hostEntry.score != list[0].score, which would be the moral equivalent of a while loop.\n\nAnyway, this wasn't important. I was just commenting while skimming the PR.\n",
        "createdAt" : "2014-09-24T23:31:59Z",
        "updatedAt" : "2014-09-25T17:49:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "a62803f0-7402-43e4-a4eb-fd168a825761",
        "parentId" : "c22b2397-3792-4281-8dee-94ca8076ad44",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2014-09-25T03:54:46Z",
        "updatedAt" : "2014-09-25T17:49:43Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "0cf8f2811279c6323ff700d317860c3ec0ca1e63",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +92,96 @@\tresult := []string{}\n\tfor _, hostEntry := range list {\n\t\tif hostEntry.score == list[0].score {\n\t\t\tresult = append(result, hostEntry.host)\n\t\t} else {"
  },
  {
    "id" : "3e6044d6-c273-4f4c-836d-5aa977a1a668",
    "prId" : 1420,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f0146a05-ca3e-46ff-9d18-7058c46bf9e8",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "FWIW, if/when we add constraints (#367), we'll want to be able to filter nodes by label selector.\n",
        "createdAt" : "2014-09-24T23:37:45Z",
        "updatedAt" : "2014-09-25T17:49:43Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "0cf8f2811279c6323ff700d317860c3ec0ca1e63",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +35,39 @@\nfunc (g *genericScheduler) Schedule(pod api.Pod, minionLister MinionLister) (string, error) {\n\tminions, err := minionLister.List()\n\tif err != nil {\n\t\treturn \"\", err"
  }
]
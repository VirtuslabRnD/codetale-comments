[
  {
    "id" : "46b9a68f-7c20-45db-a8ce-47d534c30de5",
    "prId" : 92940,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92940#pullrequestreview-446610593",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfb56372-2293-4567-bd46-d1e51ee01155",
        "parentId" : null,
        "authorId" : "1fde46ca-8fae-4b82-9978-f266fdae6ffe",
        "body" : "This line might need to be updated as well?\r\n\r\n@L466\r\n```\r\n\t// Pod will remain waiting pod for the minimum duration returned by the permit plugins.\r\n```",
        "createdAt" : "2020-07-10T09:48:14Z",
        "updatedAt" : "2020-08-31T22:52:21Z",
        "lastEditedBy" : "1fde46ca-8fae-4b82-9978-f266fdae6ffe",
        "tags" : [
        ]
      },
      {
        "id" : "946fe253-58ed-425f-919c-3b69e6317e0e",
        "parentId" : "bfb56372-2293-4567-bd46-d1e51ee01155",
        "authorId" : "98e767be-1d9e-41bb-ae64-c1a4a183c8c0",
        "body" : "Changed as suggested. Thanks.",
        "createdAt" : "2020-07-10T18:28:05Z",
        "updatedAt" : "2020-08-31T22:52:21Z",
        "lastEditedBy" : "98e767be-1d9e-41bb-ae64-c1a4a183c8c0",
        "tags" : [
        ]
      }
    ],
    "commit" : "f6f9bf3e76765aa2e16e61de837b1f016a02a120",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +458,462 @@\tRunReservePluginsUnreserve(ctx context.Context, state *CycleState, pod *v1.Pod, nodeName string)\n\n\t// RunPermitPlugins runs the set of configured Permit plugins. If any of these\n\t// plugins returns a status other than \"Success\" or \"Wait\", it does not continue\n\t// running the remaining plugins and returns an error. Otherwise, if any of the"
  },
  {
    "id" : "4e358290-b472-4398-bb67-0dbbd311d298",
    "prId" : 92391,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92391#pullrequestreview-438527421",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00be4b3d-2f59-4c1f-9122-1e803a1c3eae",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Instead of \"The Unreserve method implementation must be idempotent.\" To be more explicit, let's say: \"Note that Unreserve might be called even if Reserve for the same plugin was not.\"",
        "createdAt" : "2020-06-26T18:12:45Z",
        "updatedAt" : "2020-06-26T20:41:39Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "52f2124e-0dc0-4929-89f7-5ad34ec9e8fb",
        "parentId" : "00be4b3d-2f59-4c1f-9122-1e803a1c3eae",
        "authorId" : "521b6fc2-4b36-4594-8b5b-9d1e5bcc8759",
        "body" : "I think it makes sense to include both statements -- I've added a line to say that.",
        "createdAt" : "2020-06-26T18:59:05Z",
        "updatedAt" : "2020-06-26T20:41:39Z",
        "lastEditedBy" : "521b6fc2-4b36-4594-8b5b-9d1e5bcc8759",
        "tags" : [
        ]
      }
    ],
    "commit" : "1b223b861a3f1eba214b9a609de04235ec70fe0f",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +338,342 @@\tReserve(ctx context.Context, state *CycleState, p *v1.Pod, nodeName string) *Status\n\t// Unreserve is called by the scheduling framework when a reserved pod was\n\t// rejected, an error occurred during reservation of subsequent plugins, or\n\t// in a later phase. The Unreserve method implementation must be idempotent\n\t// and may be called by the scheduler even if the corresponding Reserve"
  },
  {
    "id" : "d27e72b5-2f4a-4461-8eeb-7ccaf7dddd7e",
    "prId" : 92200,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92200#pullrequestreview-432518595",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12413a0f-6e22-41fb-a3bb-beb42263c117",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "nit: `an error ocurred during reservation of subsequent plugins` doesn't apply in this PR.",
        "createdAt" : "2020-06-17T15:25:16Z",
        "updatedAt" : "2020-06-24T21:11:11Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "ec83143342817f3d6c1a993261adb66010031d34",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +337,341 @@\tReserve(ctx context.Context, state *CycleState, p *v1.Pod, nodeName string) *Status\n\t// Unreserve is called by the scheduling framework when a reserved pod was\n\t// rejected, an error occurred during reservation of subsequent plugins, or\n\t// in a later phase. The Unreserve method implementation must be idempotent.\n\tUnreserve(ctx context.Context, state *CycleState, p *v1.Pod, nodeName string)"
  },
  {
    "id" : "467b567a-3454-4e23-9230-99505532e46a",
    "prId" : 90711,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/90711#pullrequestreview-418789412",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99de1cb0-5710-4de4-b58b-094b301ec108",
        "parentId" : null,
        "authorId" : "60cf1937-b446-4873-9cbc-7c2ea3ae0a27",
        "body" : "Can the `Framework` interface extend this interface?  \r\n\r\nAnd can we plan to expose `Score` related runner thorough this interface??  As I mentioned [here](https://github.com/kubernetes/kubernetes/issues/90025#issuecomment-613781984), although I think no one has been convinced yet unfortunately, I would like to make `preemptHandle` provide `Score` related runners.  \r\n\r\n`preemptHandle`  also provides extenders that have `Prioritize` extenders.  So, I think we better to expose `Score` related runner though the interface for uniformity. \r\n \r\nIf not,  how about renaming this with `FilterPluginsRunner` or similar?\r\n\r\nWDYT??",
        "createdAt" : "2020-05-13T08:39:03Z",
        "updatedAt" : "2020-05-26T17:01:52Z",
        "lastEditedBy" : "60cf1937-b446-4873-9cbc-7c2ea3ae0a27",
        "tags" : [
        ]
      },
      {
        "id" : "4940ae3f-c2bc-4517-8136-f703f2af6bc8",
        "parentId" : "99de1cb0-5710-4de4-b58b-094b301ec108",
        "authorId" : "89bff7d0-c420-41e1-9e5e-db63c4cccd93",
        "body" : "> preemptHandle also provides extenders that have Prioritize extenders.\r\n\r\nðŸ¤” I think the preemptHandle will just use the function `ProcessPreemption`.\r\n\r\n> And can we plan to expose Score related runner thorough this interface?? As I mentioned here, although I think no one has been convinced yet unfortunately, I would like let preemptHandle provide Score related runners.\r\n\r\nI am not sure if we need `Score` in `Preempt`. And it is worried that the preemption phase will take more time, resulting in the overall scheduling performance degradation. And also if we do that, how to deal with the origin strategies in `pickOneNodeForPreemption` and the result of `Score` pluginsï¼Ÿ @everpeace ",
        "createdAt" : "2020-05-13T09:11:51Z",
        "updatedAt" : "2020-05-26T17:01:52Z",
        "lastEditedBy" : "89bff7d0-c420-41e1-9e5e-db63c4cccd93",
        "tags" : [
        ]
      },
      {
        "id" : "c28da1dd-efc8-41b2-93cb-0b27f8e801cf",
        "parentId" : "99de1cb0-5710-4de4-b58b-094b301ec108",
        "authorId" : "60cf1937-b446-4873-9cbc-7c2ea3ae0a27",
        "body" : ">  I think the preemptHandle will just use the function ProcessPreemption.\r\n\r\nOh, really? I expected that `preemptHandle` will be exposed to the `PreemptionExtention` which I expect to be implemented in `PostFilter` plugin.  So, I supposed that preemption plugins implemented by users would be able to call extenders' methods freely.\r\n\r\n> And it is worried that the preemption phase will take more time, resulting in the overall scheduling performance degradation. \r\n\r\nEven if we exposed `Score` related runners though this interface,  default `PreemptionExtention` won't call these runners in it, right?  So, I'm not sure why we should worry about performance degradation because of it.  I think we would need enough interface for implementers to implement a flexible preemption extension point.  I also think we should warn implementers that calling `Score` runners will affect scheduler performance, though.\r\n\r\n> I am not sure if we need Score in Preempt\r\n\r\nLet me try to explain my motivation again (sorry for my poor explanation ðŸ™‡ ).  For example, assume some profile is configured with score functions below:\r\n\r\n- `A` and `B` which comes from built-in\r\n- `X` and `Y` which comes from implemented by some OSS \r\n- extender `E` having `Prioritize` function\r\n- `S` and `T` which is implemented by self-developed plugins\r\n\r\nAnd given preemptor pod `p` and if your preemption plugin found\r\n\r\n- node `N1` can be schedulable upon preempting  victim `v1`, `v2` and `v3` \r\n  - let `P(N1)` be a set of pods _currently scheduled_ in `N1` (which includes victims)\r\n- node `N2` can be schedulable upon preempting victim `w1` and `w2`  \r\n  - let `P(N2)` be a set of pods _currently scheduled_ in `N2` (which includes victims)\r\n\r\nThen, I feel that it would be natural that the preemption plugin wants to compare\r\n\r\n- normalized `NodeScore(N1)` with pod set `P(N1) - {v1, v2, v3} + p` and \r\n- normalized `NodeScore(N2)` with pod set `P(N2) - {w1, w2} + p`\r\n\r\nbecause the normalized scores by configured score functions (`A, B, X, Y, E, S, and T` in this example) define the most preferred node to schedule preemptor pod `p`, right?\r\n\r\nSo, it would be so useful for preemption plugins to be able to access`Score` runners that can easily calculate the score values by configured score functions.  If not, the plugin needs to call all the configured score functions by itself.  I think it would be very messy.  Moreover, calling `X, Y` cannot be done when those functions are package-private....\r\n\r\nAlso, I think `Score` functions for single node `N` would be useful to identify the nice victim set for the node.  I suppose that some plugin would want to find a set of victim pods `V` such that `V` can maximize `NodeScore(N) with P(N) - V + p`.  I know this computation is very expensive.  But I picked it just as a possible use case.\r\n\r\n> how to deal with the origin strategies in pickOneNodeForPreemption and the result of Score plugins?\r\n\r\nsorry, I'm not sure what your point really would be.  If extension implementers wanted to use the function, I don't disagree to expose this function through `preemptHandle`.  It would be not difficult because `pickOneNodeForPreemption` is now a stateless function.   I think the plugin can use the `Score` plugin results before calling `pickOneNodeForPreemption`.\r\n",
        "createdAt" : "2020-05-13T12:58:50Z",
        "updatedAt" : "2020-05-26T17:01:52Z",
        "lastEditedBy" : "60cf1937-b446-4873-9cbc-7c2ea3ae0a27",
        "tags" : [
        ]
      },
      {
        "id" : "8d671e0d-0f31-49f5-945b-ec774fe67a08",
        "parentId" : "99de1cb0-5710-4de4-b58b-094b301ec108",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "I can see @everpeace 's point. Adding `RunScorePlugins` into `preemptHanlde` can give out-of-tree plugins more flexibility to implement their preemption plugins, without reinventing existing Score algorithms. And default preemption plugin don't need to use it.",
        "createdAt" : "2020-05-19T23:52:31Z",
        "updatedAt" : "2020-05-26T17:01:52Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "adef9e54-00e9-4a49-a2ec-51361a9aace5",
        "parentId" : "99de1cb0-5710-4de4-b58b-094b301ec108",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "@everpeace I updated the logic to use the private `f framework` to back `PluginsRunner` (instead of defining individual runXYZ methods), so that it'd be convenient for you to adopt RunFilterXYZ method by just introducing those methods to `PluginsRunner`.",
        "createdAt" : "2020-05-26T03:51:50Z",
        "updatedAt" : "2020-05-26T17:01:52Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "681b0499-a0a3-4bd1-b148-b9d3ef408c27",
        "parentId" : "99de1cb0-5710-4de4-b58b-094b301ec108",
        "authorId" : "60cf1937-b446-4873-9cbc-7c2ea3ae0a27",
        "body" : "Thanks! LGTM!",
        "createdAt" : "2020-05-27T01:10:15Z",
        "updatedAt" : "2020-05-27T01:10:15Z",
        "lastEditedBy" : "60cf1937-b446-4873-9cbc-7c2ea3ae0a27",
        "tags" : [
        ]
      }
    ],
    "commit" : "59eff29d22588995a7733dc244df76ff20d488d4",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +519,523 @@// This is used by preemption PostFilter plugins when evaluating the feasibility of\n// scheduling the pod on nodes when certain running pods get evicted.\ntype PluginsRunner interface {\n\t// RunFilterPlugins runs the set of configured filter plugins for pod on the given node.\n\tRunFilterPlugins(context.Context, *CycleState, *v1.Pod, *NodeInfo) PluginToStatus"
  },
  {
    "id" : "da8a051f-4577-4df9-b4e8-acf62d780c47",
    "prId" : 88199,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88199#pullrequestreview-360013434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9fd6b39-c188-4ffe-bd3d-03d556fbbffb",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "```suggestion\r\n\t// WaitOnPermit blocks if the pod is in the waiting pod map. It unblocks when the pod gets rejected/allowed or the timeout period expires, in which case Unschedulable is returned.\r\n```",
        "createdAt" : "2020-02-18T00:36:18Z",
        "updatedAt" : "2020-02-18T18:04:35Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "d221d82eaf3756a759530bdd332af9ba755151dd",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +474,478 @@\tRunPermitPlugins(ctx context.Context, state *CycleState, pod *v1.Pod, nodeName string) *Status\n\n\t// WaitOnPermit will block, if the pod is a waiting pod, until the waiting pod is rejected or allowed.\n\tWaitOnPermit(ctx context.Context, pod *v1.Pod) *Status\n"
  },
  {
    "id" : "bc23840d-dfe6-462e-bb8d-7c3efa0652ed",
    "prId" : 86963,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86963#pullrequestreview-340103732",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd2504cd-cc19-423b-a5ba-37ab8c4dd4ad",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "comments missing.\r\n\r\nWe should clarify the intent. We only seemed concerned about Filter status for now. Is that enough?",
        "createdAt" : "2020-01-08T18:44:53Z",
        "updatedAt" : "2020-01-08T21:45:01Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "cdcbcc3e-f468-47b8-92b0-a83b14d24d99",
        "parentId" : "dd2504cd-cc19-423b-a5ba-37ab8c4dd4ad",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "added comments.",
        "createdAt" : "2020-01-08T19:48:55Z",
        "updatedAt" : "2020-01-08T21:45:01Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3c7a4c82315e7270401027f6d823426fff48ccc",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +162,166 @@// Merge merges the statuses in the map into one. The resulting status code have the following\n// precedence: Error, UnschedulableAndUnresolvable, Unschedulable.\nfunc (p PluginToStatus) Merge() *Status {\n\tif len(p) == 0 {\n\t\treturn nil"
  },
  {
    "id" : "1467a576-4dce-4769-b706-35903489fb67",
    "prId" : 86963,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86963#pullrequestreview-340111606",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f64ff05-d2e9-49a3-980c-81fe1e4ceba8",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "what about defining a \"precedence\" array or map. Then simply take the status with higher precedence. It seems easier to read too.",
        "createdAt" : "2020-01-08T18:48:36Z",
        "updatedAt" : "2020-01-08T21:45:01Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "e4b917a0-3b8b-4bf5-bfee-e1680e827abd",
        "parentId" : "8f64ff05-d2e9-49a3-980c-81fe1e4ceba8",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "I am not sure it is necessary, the order is clear in the last block.",
        "createdAt" : "2020-01-08T20:03:01Z",
        "updatedAt" : "2020-01-08T21:45:02Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3c7a4c82315e7270401027f6d823426fff48ccc",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +167,171 @@\t}\n\n\tfinalStatus := NewStatus(Success)\n\tvar hasError, hasUnschedulableAndUnresolvable, hasUnschedulable bool\n\tfor _, s := range p {"
  },
  {
    "id" : "548629bf-8f94-4076-abd5-be4d28db1a05",
    "prId" : 86963,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86963#pullrequestreview-340218724",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f051dc0c-6c5c-4692-8a4b-21eb1d13b82e",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "@losipiuk here is the updated function signature. PluginToStatus is a ```map[string]*Status```",
        "createdAt" : "2020-01-08T23:52:35Z",
        "updatedAt" : "2020-01-08T23:52:50Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3c7a4c82315e7270401027f6d823426fff48ccc",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +428,432 @@\t// removed from it to evaluate the possibility of preempting them to\n\t// schedule the target pod.\n\tRunFilterPlugins(ctx context.Context, state *CycleState, pod *v1.Pod, nodeInfo *schedulernodeinfo.NodeInfo) PluginToStatus\n\n\t// RunPreFilterExtensionAddPod calls the AddPod interface for the set of configured"
  },
  {
    "id" : "40a4e8ea-3091-4cfc-af53-ecb155a96e3a",
    "prId" : 83756,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83756#pullrequestreview-304194139",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc520ad1-0d3c-420f-9014-fca35bd7c8ae",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "can you update the comment to say that \"if this is the last remaining plugin to allow, then a success signal is delivered to unblock the pod\"",
        "createdAt" : "2019-10-18T14:44:40Z",
        "updatedAt" : "2019-10-19T08:22:54Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "155d8fcd-cd09-449c-ba4f-2fda674b96a6",
        "parentId" : "bc520ad1-0d3c-420f-9014-fca35bd7c8ae",
        "authorId" : "df8dc16d-08c7-457c-8593-619395912000",
        "body" : "Updated. PTAL",
        "createdAt" : "2019-10-19T03:51:06Z",
        "updatedAt" : "2019-10-19T08:22:54Z",
        "lastEditedBy" : "df8dc16d-08c7-457c-8593-619395912000",
        "tags" : [
        ]
      }
    ],
    "commit" : "38b7668bb3ef15c945d25dd84d7fd740e3163b2f",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +156,160 @@\t// If this is the last remaining plugin to allow, then a success signal is delivered\n\t// to unblock the pod.\n\t// Returns true if the allow signal was successfully dealt with, false otherwise.\n\tAllow(pluginName string) bool\n\t// Reject declares the waiting pod unschedulable. Returns true if the reject signal"
  },
  {
    "id" : "18dda136-3b1a-42e0-967d-e00dab2c1e4b",
    "prId" : 83674,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83674#pullrequestreview-300135424",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31d5c1d8-5566-42ca-b091-b571b239e89d",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "can you please update the comment for PodInfo at line 155, not sure what \"cell\" means. Can you please indicate that all those members lnes 159-165 are for instrumentation.\r\n\r\n",
        "createdAt" : "2019-10-10T13:02:57Z",
        "updatedAt" : "2019-10-10T20:59:05Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "4969c11e-2dbf-4c53-910b-812cc52a6e5e",
        "parentId" : "31d5c1d8-5566-42ca-b091-b571b239e89d",
        "authorId" : "a650878f-0c10-41c7-b0fc-033031305d77",
        "body" : "Done.",
        "createdAt" : "2019-10-10T14:58:13Z",
        "updatedAt" : "2019-10-10T20:59:05Z",
        "lastEditedBy" : "a650878f-0c10-41c7-b0fc-033031305d77",
        "tags" : [
        ]
      }
    ],
    "commit" : "085852160a65f123f3697cf5968add822a91a8dd",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +160,164 @@\t// The time pod added to the scheduling queue.\n\tTimestamp time.Time\n\t// Number of schedule attempts before successfully scheduled.\n\t// It's used to record the # attempts metric.\n\tAttempts int"
  },
  {
    "id" : "a76a4f58-ac0c-4dd6-9bd5-287c76b2e372",
    "prId" : 83042,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83042#pullrequestreview-292829363",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07e0ef6a-9769-4d35-b721-b940162ea381",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Document that implementations can return `nil` and what the semantics of it are.",
        "createdAt" : "2019-09-24T12:51:50Z",
        "updatedAt" : "2019-09-26T02:19:15Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "b7b4d926-94ec-420c-9816-1b15b3ac5146",
        "parentId" : "07e0ef6a-9769-4d35-b721-b940162ea381",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "all plugins can return nil, and its semantics is Success.",
        "createdAt" : "2019-09-24T13:02:10Z",
        "updatedAt" : "2019-09-26T02:19:15Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "b303c178-454f-44f4-b817-3d64b6dcd8cf",
        "parentId" : "07e0ef6a-9769-4d35-b721-b940162ea381",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "We could document as below, what do you think?\r\n\r\n```go\r\nThis function is optional, and you could implement it as a noop by simply return nil\r\n```",
        "createdAt" : "2019-09-24T14:19:49Z",
        "updatedAt" : "2019-09-26T02:19:15Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "321ad525-3940-48c4-bda1-05fbe2cd8e95",
        "parentId" : "07e0ef6a-9769-4d35-b721-b940162ea381",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "It takes me some seconds to figure out what \"noop\" is... And then I realized it's \"no-op\", so prefer to reword to \"no-op\".",
        "createdAt" : "2019-09-24T16:37:12Z",
        "updatedAt" : "2019-09-26T02:19:15Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "25044d44-e217-4dca-9287-3d081eb12457",
        "parentId" : "07e0ef6a-9769-4d35-b721-b940162ea381",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "> It takes me some seconds to figure out what \"noop\" is... And then I realized it's \"no-op\", so prefer to reword to \"no-op\".\r\n\r\nSorry for the confusion, I'll make the update.",
        "createdAt" : "2019-09-25T04:42:41Z",
        "updatedAt" : "2019-09-26T02:19:15Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "c3b31323-2a3f-436e-a665-ed0f1aca33ca",
        "parentId" : "07e0ef6a-9769-4d35-b721-b940162ea381",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "done",
        "createdAt" : "2019-09-25T05:01:17Z",
        "updatedAt" : "2019-09-26T02:19:15Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "314ec4e5041ffd6dd65a7d20b8890b6961ad3f70",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +242,246 @@\t// NormalizeScore is called for all node scores produced by the same plugin's \"Score\"\n\t// method. A successful run of NormalizeScore will update the scores list and return\n\t// a success status.\n\t//\n\t// NOTE: This function is optional, and you could implement it as a no-op by simply"
  },
  {
    "id" : "55ce7ce0-4644-4a65-8a00-77c6618a67db",
    "prId" : 82034,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82034#pullrequestreview-280808117",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e771df54-3bce-454b-bdc4-a3557c325ea2",
        "parentId" : null,
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "Unless this PR will be merged into 1.16, it would be better to append `UnschedulableAndUnresolvable` to the last position since we use `iota` here. But it is ok if we decide to break it as we are in the alpha stage.",
        "createdAt" : "2019-08-28T09:45:28Z",
        "updatedAt" : "2019-08-28T14:11:06Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "28002b25-6061-4ce2-81bd-e3264f80d6a3",
        "parentId" : "e771df54-3bce-454b-bdc4-a3557c325ea2",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "It should be in 1.16",
        "createdAt" : "2019-08-28T12:57:33Z",
        "updatedAt" : "2019-08-28T14:11:06Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c1f8a8c4e75a9600906890dfced380449266116",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +59,63 @@\t// The accompanying status message should explain why the pod is unschedulable.\n\tUnschedulable\n\t// UnschedulableAndUnresolvable is used when a (pre-)filter plugin finds a pod unschedulable and\n\t// preemption would not change anything. Plugins should return Unschedulable if it is possible\n\t// that the pod can get scheduled with preemption."
  },
  {
    "id" : "f2c77ca7-c0f3-468e-b688-7a41f6d5b9f8",
    "prId" : 80901,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80901#pullrequestreview-273319554",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5b91faf-35be-4b16-82d3-2c3fb6c91a9b",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Wouldn't it be better to use a map from node names to node score (`map[string]int`) instead of `NodeScoreList`? With the current data structure, finding the score of a node requires iterating over a NodeScoreList.",
        "createdAt" : "2019-08-09T01:04:13Z",
        "updatedAt" : "2019-08-09T01:04:46Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "8409717a-ec5b-483d-9a9f-8f1e1292134d",
        "parentId" : "d5b91faf-35be-4b16-82d3-2c3fb6c91a9b",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "> Wouldn't it be better to use a map from node names to node score (`map[string]int`) instead of `NodeScoreList`? With the current data structure, finding the score of a node requires iterating over a NodeScoreList.\r\n\r\nI don't have a preference here\r\n\r\n> I recalled that in the [API convention](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#lists-of-named-subobjects-preferred-over-maps) documents, kubernetes prefer the named array to map. I could go with the second option if it is the convention we must follow here, but I prefer the first for now. What do you think of this?",
        "createdAt" : "2019-08-09T01:12:06Z",
        "updatedAt" : "2019-08-09T01:12:07Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "1c44eac2-ee6e-49fe-831b-dfc472275bdb",
        "parentId" : "d5b91faf-35be-4b16-82d3-2c3fb6c91a9b",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "We have to think carefully about this question: \"Do we need to find score of a particular node in our code?\" If the answer is no, we should definitely go with the current List instead of a map. Lists are faster to access compared to maps if we don't need to search for something.",
        "createdAt" : "2019-08-09T01:17:17Z",
        "updatedAt" : "2019-08-09T01:17:17Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "9260fb73-e25e-4a81-8230-070c1cffcd2b",
        "parentId" : "d5b91faf-35be-4b16-82d3-2c3fb6c91a9b",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "> We have to think carefully about this question: \"Do we need to find score of a particular node in our code?\"\r\n\r\n+1\r\n\r\n> If the answer is no, we should definitely go with the current List instead of a map. Lists are faster to access compared to maps if we don't need to search for something.\r\n\r\nFor the implementation of InterPodAffinity and EvenPodSpread, we don't need to find the score of a particular node in NormalizeScore, and we only use node name in the named array (or map) to find score from the internal data structure.",
        "createdAt" : "2019-08-09T01:24:03Z",
        "updatedAt" : "2019-08-09T01:27:22Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "682c9298-ecb6-47d5-b2b7-7d72e472b796",
        "parentId" : "d5b91faf-35be-4b16-82d3-2c3fb6c91a9b",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "Unless we have a strong reason to use map (which I doubt we will), my recommendation is to use a list.",
        "createdAt" : "2019-08-09T19:22:50Z",
        "updatedAt" : "2019-08-09T19:23:26Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa5f9fda52d0171e45682254e0d37b16f58ae6fc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +32,36 @@\n// NodeScoreList declares a list of nodes and their scores.\ntype NodeScoreList []NodeScore\n\n// NodeScore is a struct with node name and score."
  },
  {
    "id" : "a2bd05f1-cc97-43f5-9de1-aff9abaf0e8c",
    "prId" : 80383,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80383#pullrequestreview-266904983",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6bb3be93-4360-4ab1-8740-b3d8d40b928c",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "Since we have tight coupling between score and normalize, I think we should treat this as a special type of Score plugin.\r\n\r\nI suggest we remove the explicit NormalizeScore list from the [plugins struct](https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/apis/config/types.go). A ScoreWithNormalizePlugin can be added in the Score PluginSet.\r\n\r\nFor each entry in the Score PluginSet, the framework initialization code will basically first make sure that it implements the Score interface and error out if it does not. Next it checks if it also implements the ScoreWithNormalizePlugin interface, if it does, then we add it to the internal normalize plugins list, if not, then we just do nothing.",
        "createdAt" : "2019-07-25T14:57:54Z",
        "updatedAt" : "2019-07-31T00:02:33Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "0e4d0d1d-393e-4e42-9856-37fe57be25d9",
        "parentId" : "6bb3be93-4360-4ab1-8740-b3d8d40b928c",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "This approach is fine with me. Compared to the current approach, this has the limitation of not being able to disable \"Normalize Score\" plugins independently of Score plugins, but I doubt if users really need to disable \"Normalize\" only and leave \"Score\" in place.",
        "createdAt" : "2019-07-25T21:53:09Z",
        "updatedAt" : "2019-07-31T00:02:33Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "34373662d3d66bf4bed60384140a5a9c473adcdc",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +174,178 @@// plugins that also need to normalize the node scoring results produced by the same\n// plugin's \"Score\" method.\ntype ScoreWithNormalizePlugin interface {\n\tScorePlugin\n\t// NormalizeScore is called for all node scores produced by the same plugin's \"Score\""
  },
  {
    "id" : "4883c9a0-91e8-4a2c-9810-3f3483b952c2",
    "prId" : 78513,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78513#pullrequestreview-288468434",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65e2709a-70aa-4f1b-b54f-9bd4b7b320c1",
        "parentId" : null,
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "`RunBindPlugins` should one day return an error if all bind plugins 'Skip' the pod, but this is fine for now that we want to run the default bind function if none of the bind plugins process the pod. My hope is that the current bind function will one day be a (default) plugin.",
        "createdAt" : "2019-06-19T21:57:13Z",
        "updatedAt" : "2019-06-20T07:57:03Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "f87d5195-994f-4711-93ce-0eedf67f9282",
        "parentId" : "65e2709a-70aa-4f1b-b54f-9bd4b7b320c1",
        "authorId" : "38428f84-e217-4cb8-8916-cc4e674102d6",
        "body" : "Maybe we can do it in a following PR.",
        "createdAt" : "2019-06-20T09:22:51Z",
        "updatedAt" : "2019-06-20T09:22:51Z",
        "lastEditedBy" : "38428f84-e217-4cb8-8916-cc4e674102d6",
        "tags" : [
        ]
      },
      {
        "id" : "2771de02-96fd-4ea0-9553-3e97832c5de2",
        "parentId" : "65e2709a-70aa-4f1b-b54f-9bd4b7b320c1",
        "authorId" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "body" : "I opened an issue https://github.com/kubernetes/kubernetes/issues/79215 to track this and I could raise a PR after this get merged.",
        "createdAt" : "2019-06-20T09:38:09Z",
        "updatedAt" : "2019-06-20T09:38:41Z",
        "lastEditedBy" : "9829b6c0-e54c-401b-8d97-73e5aa4e83c1",
        "tags" : [
        ]
      },
      {
        "id" : "cc85640e-d711-4aec-a521-1e8fc128095b",
        "parentId" : "65e2709a-70aa-4f1b-b54f-9bd4b7b320c1",
        "authorId" : "74808d33-32a9-4db9-8265-aadfe78d94ab",
        "body" : "> `RunBindPlugins` should one day return an error if all bind plugins 'Skip' the pod, but this is fine for now that we want to run the default bind function if none of the bind plugins process the pod. My hope is that the current bind function will one day be a (default) plugin.\r\n\r\n This is a great idea",
        "createdAt" : "2019-09-16T08:13:25Z",
        "updatedAt" : "2019-09-16T08:13:25Z",
        "lastEditedBy" : "74808d33-32a9-4db9-8265-aadfe78d94ab",
        "tags" : [
        ]
      }
    ],
    "commit" : "b339c0a8bf75ff246440fbd84a3cf93b1f4418bd",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +249,253 @@\t// whether or not to handle the given Pod. If a bind plugin chooses to skip the\n\t// binding, it should return code=4(\"skip\") status. Otherwise, it should return \"Error\"\n\t// or \"Success\". If none of the plugins handled binding, RunBindPlugins returns\n\t// code=4(\"skip\") status.\n\tRunBindPlugins(pc *PluginContext, pod *v1.Pod, nodeName string) *Status"
  },
  {
    "id" : "bc951c80-f7a3-4f2e-b239-1be09efcf204",
    "prId" : 78477,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78477#pullrequestreview-257226892",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b6d90d8-72e2-4193-b046-c0249fb601b0",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "update the comment to explicitly say that a filter plugin should return success to declare that the node fits, or unschedulable to indicate that the node does not fit. Other statuses are considered internal errors.",
        "createdAt" : "2019-07-02T17:41:57Z",
        "updatedAt" : "2019-07-17T07:31:13Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "88a0d9f9-1d3f-4d58-9875-894e17e8a890",
        "parentId" : "8b6d90d8-72e2-4193-b046-c0249fb601b0",
        "authorId" : "ba6240e3-678e-479a-b2f3-a1b796de7259",
        "body" : "Addressed.",
        "createdAt" : "2019-07-03T01:52:04Z",
        "updatedAt" : "2019-07-17T07:31:13Z",
        "lastEditedBy" : "ba6240e3-678e-479a-b2f3-a1b796de7259",
        "tags" : [
        ]
      }
    ],
    "commit" : "7f9dd949e01189709b7ec7955204e04378aa64cb",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +157,161 @@\t// the given node fits the pod. If Filter doesn't return \"Success\",\n\t// please refer scheduler/algorithm/predicates/error.go\n\t// to set error message.\n\tFilter(pc *PluginContext, pod *v1.Pod, nodeName string) *Status\n}"
  },
  {
    "id" : "f4fae42d-f68b-4bb0-acf9-9ef65b022491",
    "prId" : 75848,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75848#pullrequestreview-221378082",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ee81895-9347-4d59-95d1-37fe00845469",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "I looked for `PermitPlugins` for a while (which was demoed in last week's sig meeting)... Seems it hasn't been added in this PR?",
        "createdAt" : "2019-03-31T08:20:33Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "1e4b488c-b228-4b2e-b287-ab16681295e8",
        "parentId" : "0ee81895-9347-4d59-95d1-37fe00845469",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "No, permit plugins are not added yet. Intel folks have implemented it in their own PoC.",
        "createdAt" : "2019-04-01T23:05:19Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "83828bcb2df27f3111837226ce87258d76533090",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +140,144 @@\t// remains unchanged in the binding phase of scheduling.\n\tNodeInfoSnapshot() *internalcache.NodeInfoSnapshot\n}"
  },
  {
    "id" : "fb4bae19-a4c9-4bc7-9631-7f466d6280b7",
    "prId" : 75848,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75848#pullrequestreview-225845702",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bdc5d0d-5552-4172-a146-bc3e60fe4d95",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "I *really* don't understand the error handling semantics of this interface. What is the difference between failure and error? I assume that the intention is for a prebind plugin to cause us to either retry, or mark the pod as unschedulable. If that's so, I don't think this interface captures that intention clearly.",
        "createdAt" : "2019-04-11T00:09:53Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "5ea3f1a0-2fd8-4480-a1a9-8e100c995103",
        "parentId" : "8bdc5d0d-5552-4172-a146-bc3e60fe4d95",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "I tried to explain in the comment that a failure indicates that an unexpected error has happened. When failure is false and error is populated, it means that the plugin has run successfully and has determined that the pod should not be bound.",
        "createdAt" : "2019-04-11T23:59:42Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "83828bcb2df27f3111837226ce87258d76533090",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +109,113 @@type PrebindPlugin interface {\n\tPlugin\n\t// Prebind is called before binding a pod. All prebind plugins must return\n\t// success or the pod will be rejected and won't be sent for binding.\n\tPrebind(pc *PluginContext, p *v1.Pod, nodeName string) *Status"
  },
  {
    "id" : "3fcba187-bddf-4ce4-b56b-83650eddc51f",
    "prId" : 75848,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75848#pullrequestreview-231907731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b198ad77-634e-4cfb-bc03-8f269285b9c5",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "Can we add to this, \"The accompanying status message should explain why the pod is unschedulable\"?",
        "createdAt" : "2019-04-26T20:37:31Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "a74e5a21-62de-4526-943b-ffb00c56fd14",
        "parentId" : "b198ad77-634e-4cfb-bc03-8f269285b9c5",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "done",
        "createdAt" : "2019-04-29T21:21:06Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "83828bcb2df27f3111837226ce87258d76533090",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +36,40 @@\t// Error is used for internal plugin errors, unexpected input, etc.\n\tError Code = 1\n\t// Unschedulable is used when a plugin finds a pod unschedulable.\n\t// The accompanying status message should explain why the pod is unschedulable.\n\tUnschedulable Code = 2"
  },
  {
    "id" : "f6413545-7338-4215-9d86-2708bcca6248",
    "prId" : 75848,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75848#pullrequestreview-231346851",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7bf09aa2-0d28-4d5c-8217-a30a54be0494",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "maybe add a nil check and return success? Then we could switch on s.Code()",
        "createdAt" : "2019-04-26T20:50:21Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      }
    ],
    "commit" : "83828bcb2df27f3111837226ce87258d76533090",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@\t\treturn Success\n\t}\n\treturn s.code\n}\n"
  },
  {
    "id" : "04b61a5f-e7d9-46e9-bd38-d6bcc9ae1654",
    "prId" : 75848,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75848#pullrequestreview-231907731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81e58691-c8b0-40ca-9f39-70a32c7ff5f5",
        "parentId" : null,
        "authorId" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "body" : "I am happy with this. I think that we may want to add an actual `error` member so that we can wrap real error values and not just strings, but we don't have to worry about that today.",
        "createdAt" : "2019-04-26T20:51:52Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "5f2c1de8-4266-42c0-b343-ba247af3578f",
        "tags" : [
        ]
      },
      {
        "id" : "c6f9bf1f-5cc7-48a0-9d78-4a6d5141917d",
        "parentId" : "81e58691-c8b0-40ca-9f39-70a32c7ff5f5",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "yes, we can do so when needed",
        "createdAt" : "2019-04-29T21:22:39Z",
        "updatedAt" : "2019-04-29T23:41:08Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "83828bcb2df27f3111837226ce87258d76533090",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +45,49 @@// explain why.\n// NOTE: A nil Status is also considered as Success.\ntype Status struct {\n\tcode    Code\n\tmessage string"
  }
]
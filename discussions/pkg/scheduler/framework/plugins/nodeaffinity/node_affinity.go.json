[
  {
    "id" : "af22a2fa-a0a3-488a-8fac-2445bfeb790a",
    "prId" : 99213,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99213#pullrequestreview-596688928",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a3a4afa-a7c1-47bf-a0f5-292171bf9a9b",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "add a comment:\r\n\r\n```\r\nUsing LazyErrorNodeSelector for backwards compatibility of parsing errors\r\n```",
        "createdAt" : "2021-02-23T18:57:18Z",
        "updatedAt" : "2021-02-25T00:22:32Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "4fb8e343c01acd1b6489054daf773cbdeaa4d072",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +259,263 @@\t\tpod.Spec.Affinity.NodeAffinity != nil &&\n\t\tpod.Spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution != nil {\n\t\taffinity = nodeaffinity.NewLazyErrorNodeSelector(pod.Spec.Affinity.NodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution)\n\t}\n\treturn &preFilterState{requiredNodeSelector: selector, requiredNodeAffinity: affinity}"
  },
  {
    "id" : "caf890dc-aac7-46cc-870e-cd14b6ee08dd",
    "prId" : 96223,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96223#pullrequestreview-528301697",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a090b0a8-38dc-4d58-bb3e-9b9b44ba02e3",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "There might be users of KubeSchedulerConfig that have `disabled: [\"*\"]` for PreScore. Those users would start seeing failures without them doing changes. That's not desirable for a beta API.\r\n\r\nMake it so that, if prescore state is not found, it gets calculated here. Of course, avoid code duplication and add a test.",
        "createdAt" : "2020-11-11T15:55:19Z",
        "updatedAt" : "2020-11-26T03:20:05Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b38078de1c655221b16dfd8f953b628ea7abe93",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +122,126 @@\n\ts, err := getPreScoreState(state)\n\tif err != nil {\n\t\t// fallback to calculate preferredNodeAffinity here when PreScore is disabled\n\t\tpreferredNodeAffinity, err := getPodPreferredNodeAffinity(pod)"
  },
  {
    "id" : "1f16c786-0cbd-4d65-939a-5cbcffac93fe",
    "prId" : 96202,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96202#pullrequestreview-525294987",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dba39709-39dc-497e-bd00-708083125e6f",
        "parentId" : null,
        "authorId" : "7ec1dfea-3d2a-4eea-8e24-34a7547407f9",
        "body" : "If the pod specified a same prefered affinity with default one, then that will be double count. For example, the default one is 'in zoneA with weight=1', the pod specified one is 'in zoneA with weight=1 and in zoneB with wieght=2'. In the end, actually zoneA and zoneB have the same weight. That changed the original intent for the user. But this is indeed the `AND` behavior as the design, just thinking about whether this makes sense for the user. Although I see the major use-case for this feature is required affinity, so I may over thing about this.\r\n\r\n",
        "createdAt" : "2020-11-06T02:45:48Z",
        "updatedAt" : "2020-11-09T20:19:36Z",
        "lastEditedBy" : "7ec1dfea-3d2a-4eea-8e24-34a7547407f9",
        "tags" : [
        ]
      },
      {
        "id" : "de8888da-602f-4e9b-890a-68bc025a3c7f",
        "parentId" : "dba39709-39dc-497e-bd00-708083125e6f",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "You are correct, and I think that is working as intended.\r\n\r\nHowever, in \"AddedAffinity\", you would probably use a label that Pods usually don't care about. I'll try to put some thoughts in kubernetes/website#24914",
        "createdAt" : "2020-11-06T16:12:47Z",
        "updatedAt" : "2020-11-09T20:19:37Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ce145787af031e2f6a735d558530f6813cbfdd0",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +91,95 @@\tif pl.addedPrefSchedTerms != nil {\n\t\tcount += pl.addedPrefSchedTerms.Score(node)\n\t}\n\t// A nil element of PreferredDuringSchedulingIgnoredDuringExecution matches no objects.\n\t// An element of PreferredDuringSchedulingIgnoredDuringExecution that refers to an"
  },
  {
    "id" : "c2a5d56f-a77d-4e3d-865d-9ec2cbcede52",
    "prId" : 96202,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96202#pullrequestreview-526716439",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd406558-5e65-4a7d-acbb-686a7b238106",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Nit: is it more efficient to do a \"smart merge\" on addedAffinity and user-specified ones? so that we only run \"match logic\" once. For example, \"foo in [bar]\" and  \"foo in [bar]\" gets de-duplicated to \"foo in [bar]\"; while \"foo in [bar]\" and  \"foo in [baz]\" gets merged to one entry: \"foo in [bar, baz]\".",
        "createdAt" : "2020-11-09T20:35:44Z",
        "updatedAt" : "2020-11-09T20:36:36Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "cb83d13d-27bc-4364-ae9f-5b779dd316f7",
        "parentId" : "dd406558-5e65-4a7d-acbb-686a7b238106",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "I don't think it's worth.\r\nSee my documentation PR https://github.com/kubernetes/website/pull/24914/files#diff-ba98b126fe5dd6bf0570b39d4928eb9143d1f2ed60fbaf9fa2051810acc2e8a6R192",
        "createdAt" : "2020-11-09T21:09:56Z",
        "updatedAt" : "2020-11-09T21:09:57Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "73f80289-ee06-40e3-911a-d535d18fa691",
        "parentId" : "dd406558-5e65-4a7d-acbb-686a7b238106",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "SG.",
        "createdAt" : "2020-11-09T22:46:44Z",
        "updatedAt" : "2020-11-09T22:46:44Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ce145787af031e2f6a735d558530f6813cbfdd0",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +69,73 @@\t\treturn framework.NewStatus(framework.UnschedulableAndUnresolvable, ErrReasonPod)\n\t}\n\treturn nil\n}\n"
  },
  {
    "id" : "02d8d2ed-402e-42c4-8637-f14816ef8dfe",
    "prId" : 96126,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96126#pullrequestreview-522605023",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bf9df28-816d-41b8-a6d0-669ce4bafc09",
        "parentId" : null,
        "authorId" : "0e2b7889-1224-444e-a36d-475f9edd0703",
        "body" : "Does this still compute it for all nodes? Maybe I am missing where the computed affinity is stored, or that will be added in another PR, just curious",
        "createdAt" : "2020-11-03T14:43:15Z",
        "updatedAt" : "2020-11-03T15:21:48Z",
        "lastEditedBy" : "0e2b7889-1224-444e-a36d-475f9edd0703",
        "tags" : [
        ]
      },
      {
        "id" : "4370643c-fe15-4b15-bd93-89eb64364a4b",
        "parentId" : "8bf9df28-816d-41b8-a6d0-669ce4bafc09",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Correct. For that, I would need to implement PreFilter, which is out of the scope for this PR. But I might leave that for 1.21. The priority is implementing #95738, for which parsing happens during plugin instantiation.",
        "createdAt" : "2020-11-03T15:08:48Z",
        "updatedAt" : "2020-11-03T15:21:48Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "913893f4-b21e-42a8-9b99-e997ce373898",
        "parentId" : "8bf9df28-816d-41b8-a6d0-669ce4bafc09",
        "authorId" : "0e2b7889-1224-444e-a36d-475f9edd0703",
        "body" : "Sounds good, just wanted to make sure I understood thanks",
        "createdAt" : "2020-11-03T15:11:47Z",
        "updatedAt" : "2020-11-03T15:21:48Z",
        "lastEditedBy" : "0e2b7889-1224-444e-a36d-475f9edd0703",
        "tags" : [
        ]
      },
      {
        "id" : "fc2987ff-53f5-4dfd-9a44-8448b0ca4bb7",
        "parentId" : "8bf9df28-816d-41b8-a6d0-669ce4bafc09",
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "I created an issue and restored the TODO",
        "createdAt" : "2020-11-03T15:21:52Z",
        "updatedAt" : "2020-11-03T15:21:52Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      }
    ],
    "commit" : "d572249d3056b06877dff30c8ddbe30e75d3d353",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +81,85 @@\tif affinity != nil && affinity.NodeAffinity != nil && affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution != nil {\n\t\t// TODO(#96164): Do this in PreScore to avoid computing it for all nodes.\n\t\tpreferredNodeAffinity, err := nodeaffinity.NewPreferredSchedulingTerms(affinity.NodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution)\n\t\tif err != nil {\n\t\t\treturn 0, framework.AsStatus(err)"
  },
  {
    "id" : "0592859a-2a1e-48e8-9620-f108ca66e0b3",
    "prId" : 87091,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87091#pullrequestreview-341502376",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "046e14dd-7d27-4b8f-aea8-dbf19b6d1887",
        "parentId" : null,
        "authorId" : "41c25afd-5561-4611-9b3a-7df68582aa10",
        "body" : "Should we rename to `ErrReasonSelectorNotMatch`",
        "createdAt" : "2020-01-11T03:59:32Z",
        "updatedAt" : "2020-01-13T18:02:49Z",
        "lastEditedBy" : "41c25afd-5561-4611-9b3a-7df68582aa10",
        "tags" : [
        ]
      },
      {
        "id" : "2cd66340-3404-4a15-84e1-ab3a31098e60",
        "parentId" : "046e14dd-7d27-4b8f-aea8-dbf19b6d1887",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "package name is enough to identify the context, externally this looks like: ```nodeaffinithy.ErrReason```",
        "createdAt" : "2020-01-11T04:01:38Z",
        "updatedAt" : "2020-01-13T18:02:49Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb66e807cd317254e5c7bf134186ddbfba757ef4",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +43,47 @@\n\t// ErrReason for node affinity/selector not matching.\n\tErrReason = \"node(s) didn't match node selector\"\n)\n"
  }
]
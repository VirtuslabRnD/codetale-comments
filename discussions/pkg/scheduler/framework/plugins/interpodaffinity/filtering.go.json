[
  {
    "id" : "28184630-ab36-4c1f-b96c-9153927cd10c",
    "prId" : 98446,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98446#pullrequestreview-584706107",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5917c094-ec1d-483f-9fd7-3d18bd3220b8",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "`// No need to deep copy Pod details because they don't change.`\r\n\r\nBtw, podInfo would go away with #97813, right?",
        "createdAt" : "2021-02-05T18:28:25Z",
        "updatedAt" : "2021-03-04T12:30:39Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "081a76ca-f0a1-4e78-9a80-91ef2ec43908",
        "parentId" : "5917c094-ec1d-483f-9fd7-3d18bd3220b8",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "No, it will continue to exist.",
        "createdAt" : "2021-02-05T21:10:45Z",
        "updatedAt" : "2021-03-04T12:30:39Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7fef196b60856420ce3f0470acd1093ab1d9b5f",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +69,73 @@\tcopy.antiAffinityCounts = s.antiAffinityCounts.clone()\n\tcopy.existingAntiAffinityCounts = s.existingAntiAffinityCounts.clone()\n\t// No need to deep copy the podInfo because it shouldn't change.\n\tcopy.podInfo = s.podInfo\n\tcopy.namespaceLabels = s.namespaceLabels"
  },
  {
    "id" : "df7d0e02-430d-46a2-ae0e-08a5e651313c",
    "prId" : 98446,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98446#pullrequestreview-591563420",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac261313-441b-4011-a49d-dfc0c07cab13",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "Explain why `nsLabels` can be nil and how it's handled",
        "createdAt" : "2021-02-16T18:36:43Z",
        "updatedAt" : "2021-03-04T12:30:39Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "3f406904-cceb-4335-8e04-9f7ec12d0d3d",
        "parentId" : "ac261313-441b-4011-a49d-dfc0c07cab13",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "This is not relevant here, nothing special about `nsLabels` handling with regards to it being nil or not. I added a comment in the place where we consciously pass nil because we don't need to explicitly look the labels up.",
        "createdAt" : "2021-02-16T19:41:12Z",
        "updatedAt" : "2021-03-04T12:30:39Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7fef196b60856420ce3f0470acd1093ab1d9b5f",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +130,134 @@\n// updates the topologyToMatchedTermCount map with the specified value\n// for each anti-affinity term matched the target pod.\nfunc (m topologyToMatchedTermCount) updateWithAntiAffinityTerms(terms []framework.AffinityTerm, pod *v1.Pod, nsLabels labels.Set, node *v1.Node, value int64, enableNamespaceSelector bool) {\n\t// Check anti-affinity terms."
  },
  {
    "id" : "6fe4802f-0dbd-4a29-b9cf-ce533552dfa1",
    "prId" : 97599,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97599#pullrequestreview-560888911",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a557e22f-07ff-4959-b6f4-49545f360a37",
        "parentId" : null,
        "authorId" : "1fde46ca-8fae-4b82-9978-f266fdae6ffe",
        "body" : "Just thinking out loud, all those comment is outdated, those should be \"InterPodAffinity\" instead of legacy \"MatchInterPodAffinity\".",
        "createdAt" : "2021-01-04T09:36:49Z",
        "updatedAt" : "2021-01-18T16:53:14Z",
        "lastEditedBy" : "1fde46ca-8fae-4b82-9978-f266fdae6ffe",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4418c1402188947cac992de96c04e44ad639997",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +36,40 @@\t// ErrReasonExistingAntiAffinityRulesNotMatch is used for ExistingPodsAntiAffinityRulesNotMatch predicate error.\n\tErrReasonExistingAntiAffinityRulesNotMatch = \"node(s) didn't satisfy existing pods anti-affinity rules\"\n\t// ErrReasonAffinityNotMatch is used for MatchInterPodAffinity predicate error.\n\tErrReasonAffinityNotMatch = \"node(s) didn't match pod affinity/anti-affinity rules\"\n\t// ErrReasonAffinityRulesNotMatch is used for PodAffinityRulesNotMatch predicate error."
  },
  {
    "id" : "fef24579-0f77-402a-8113-75455e0794b9",
    "prId" : 91168,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91168#pullrequestreview-413092705",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "193e005b-74c3-4847-be42-b77c56284bc0",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "this one just got moved, nothing new.",
        "createdAt" : "2020-05-16T17:08:39Z",
        "updatedAt" : "2020-05-18T19:15:31Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d2c05408dbc435f76175e4bfc3eb4fa4201fb70",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +161,165 @@}\n\n// getMatchingAntiAffinityTopologyPairs calculates the following for \"existingPod\" on given node:\n// (1) Whether it has PodAntiAffinity\n// (2) Whether ANY AffinityTerm matches the incoming pod"
  },
  {
    "id" : "f91abdc0-b4d0-4d9c-8ffd-56b60378186c",
    "prId" : 91168,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91168#pullrequestreview-413870789",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b77a93f-2883-4590-87d9-ea9ca0678276",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "I'd prefer to refactor the whole function to return early when there is a simple negative path:\r\n\r\n```go\r\nfunc satisfiesPodsAffinity(state *preFilterState, nodeInfo *framework.NodeInfo) bool {\r\n\tpodsExist := true\r\n\tfor _, term := range state.podInfo.RequiredAffinityTerms {\r\n\t\ttopologyValue, ok := nodeInfo.Node().Labels[term.TopologyKey]\r\n\t\tif !ok {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tpair := topologyPair{key: term.TopologyKey, value: topologyValue}\r\n\t\tif state.topologyToMatchedAffinityTerms[pair] <= 0 {\r\n\t\t\tpodsExist = false\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\r\n\tif podsExist {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// This pod may be the first pod in a series that have affinity to themselves. In order\r\n\t// to not leave such pods in pending state forever, we check that if no other pod\r\n\t// in the cluster matches the namespace and selector of this pod, the pod matches\r\n\t// its own terms, and the node has all the requested topologies, then we allow the pod\r\n\t// to pass the affinity check.\r\n\tpodInfo := state.podInfo\r\n\tif len(state.topologyToMatchedAffinityTerms) == 0 && podMatchesAllAffinityTerms(podInfo.Pod, podInfo.RequiredAffinityTerms) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n```",
        "createdAt" : "2020-05-18T03:46:17Z",
        "updatedAt" : "2020-05-18T19:15:31Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "46d7a025-df18-43d1-ad61-cac4b0f67e3f",
        "parentId" : "8b77a93f-2883-4590-87d9-ea9ca0678276",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "there should be one or two affinity terms and so exiting early is not really beneficial and makes the code more complicated, I prefer simplicity in this case.",
        "createdAt" : "2020-05-18T15:04:40Z",
        "updatedAt" : "2020-05-18T19:15:31Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "b1f8b62a-cdf6-461f-b8f0-5256f64176dc",
        "parentId" : "8b77a93f-2883-4590-87d9-ea9ca0678276",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Or, we can just eliminate the variable `toposExist`  - directly return false in L367, and the logic afterwards would be only checking `podsExist`.",
        "createdAt" : "2020-05-18T17:40:50Z",
        "updatedAt" : "2020-05-18T19:15:31Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "82c67dba-c62b-48f4-85f6-f276535a6a18",
        "parentId" : "8b77a93f-2883-4590-87d9-ea9ca0678276",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "done. ",
        "createdAt" : "2020-05-18T19:15:31Z",
        "updatedAt" : "2020-05-18T19:15:32Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d2c05408dbc435f76175e4bfc3eb4fa4201fb70",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +361,365 @@func satisfyPodAffinity(state *preFilterState, nodeInfo *framework.NodeInfo) bool {\n\tpodsExist := true\n\tfor _, term := range state.podInfo.RequiredAffinityTerms {\n\t\tif topologyValue, ok := nodeInfo.Node().Labels[term.TopologyKey]; ok {\n\t\t\ttp := topologyPair{key: term.TopologyKey, value: topologyValue}"
  },
  {
    "id" : "1294a2fc-d942-42d9-877e-20bed0e28c70",
    "prId" : 91168,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91168#pullrequestreview-413865734",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1bac731-fbd8-4074-b680-d53b342fac13",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "s/Pods/Pod/ to be consistent with others?",
        "createdAt" : "2020-05-18T17:31:13Z",
        "updatedAt" : "2020-05-18T19:15:31Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "ede7ccd9-5b6f-406f-a0ae-613fc443e1f4",
        "parentId" : "d1bac731-fbd8-4074-b680-d53b342fac13",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "this one should stay because we are checking existing pods (multiple pods), in the other two we are checking the incoming pod (single pod).",
        "createdAt" : "2020-05-18T19:08:22Z",
        "updatedAt" : "2020-05-18T19:15:31Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d2c05408dbc435f76175e4bfc3eb4fa4201fb70",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +331,335 @@// Checks if scheduling the pod onto this node would break any anti-affinity\n// terms indicated by the existing pods.\nfunc satisfyExistingPodsAntiAffinity(state *preFilterState, nodeInfo *framework.NodeInfo) bool {\n\tif len(state.topologyToMatchedExistingAntiAffinityTerms) > 0 {\n\t\t// Iterate over topology pairs to get any of the pods being affected by"
  },
  {
    "id" : "781bed81-ecbe-4659-92a9-8b2ce0196fb8",
    "prId" : 91062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91062#pullrequestreview-411504980",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a85230db-0808-4e93-9730-ee50bb8fa6c8",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "would something fail if we just returned nil? just to avoid unnecessary allocations.",
        "createdAt" : "2020-05-13T19:14:36Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "ddd90377-1e37-4587-b243-55ced23e4696",
        "parentId" : "a85230db-0808-4e93-9730-ee50bb8fa6c8",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "there are more than few map access in the file, needs to be verified, I don't trust the unit tests to cover all cases.",
        "createdAt" : "2020-05-13T20:07:52Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "e83916a1-9211-473e-b1f1-e2a1a4cf6a6c",
        "parentId" : "a85230db-0808-4e93-9730-ee50bb8fa6c8",
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "It'd safe to keep the map instantiated, as some places directly access it without check if it's nil.",
        "createdAt" : "2020-05-14T07:12:46Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e0211c72de097b931296f5a08c6a94945548312",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +200,204 @@\ttopologyPairsAffinityPodsMap := make(topologyToMatchedTermCount)\n\ttopologyToMatchedExistingAntiAffinityTerms := make(topologyToMatchedTermCount)\n\tif len(podInfo.RequiredAffinityTerms) == 0 && len(podInfo.RequiredAntiAffinityTerms) == 0 {\n\t\treturn topologyPairsAffinityPodsMap, topologyToMatchedExistingAntiAffinityTerms\n\t}"
  },
  {
    "id" : "a226627e-134f-4fb2-b3bd-d8f3c81bdde1",
    "prId" : 91062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91062#pullrequestreview-411248097",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8ed23ec-d313-4981-a875-56f32f42198f",
        "parentId" : null,
        "authorId" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "body" : "For a follow up: Perhaps we could store something in QueuedPodInfo? This way processed terms are stored across scheduling attempts. And this is something we could also add to Spreading plugin.",
        "createdAt" : "2020-05-13T19:19:04Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "31fbce73-ef64-43f8-9faa-047479d8fc32",
        "tags" : [
        ]
      },
      {
        "id" : "bdfe4dcc-5f58-4f81-896f-d1c5460c1e01",
        "parentId" : "c8ed23ec-d313-4981-a875-56f32f42198f",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "We can embed PodInfo in QueuedPodInfo, not sure how much improvement this will bring though.",
        "createdAt" : "2020-05-13T19:51:55Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e0211c72de097b931296f5a08c6a94945548312",
    "line" : 270,
    "diffHunk" : "@@ -1,1 +254,258 @@\t}\n\n\tpodInfo := framework.NewPodInfo(pod)\n\n\t// existingPodAntiAffinityMap will be used later for efficient check on existing pods' anti-affinity"
  },
  {
    "id" : "b6f6b269-5b69-484e-ad3e-6adbbd83fea4",
    "prId" : 91062,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91062#pullrequestreview-411848542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f187e115-717a-4784-9b44-9d71486f687b",
        "parentId" : null,
        "authorId" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "body" : "Add a TODO to remove `podToSchedule` from the interface signature? ",
        "createdAt" : "2020-05-14T07:01:09Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "06cbf859-1cac-4be7-80e6-3b34dcff1812",
        "tags" : [
        ]
      },
      {
        "id" : "e9bf7607-87b0-4d4d-a075-1f53f6cf1d32",
        "parentId" : "f187e115-717a-4784-9b44-9d71486f687b",
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "we can't because it is not a standard that every plugin will store the pod in their CycleState.",
        "createdAt" : "2020-05-14T14:15:13Z",
        "updatedAt" : "2020-05-14T14:31:05Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e0211c72de097b931296f5a08c6a94945548312",
    "line" : 300,
    "diffHunk" : "@@ -1,1 +285,289 @@\t\treturn framework.NewStatus(framework.Error, err.Error())\n\t}\n\tstate.updateWithPod(podToAdd, nodeInfo.Node(), 1)\n\treturn nil\n}"
  },
  {
    "id" : "0aa6d79b-6d24-4c47-8b7f-98ed458268af",
    "prId" : 86836,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/86836#pullrequestreview-339669215",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8631a204-84f6-45ed-9d76-34cf03bc4338",
        "parentId" : null,
        "authorId" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "body" : "please add a comment documenting the two flags the function returns.",
        "createdAt" : "2020-01-07T18:04:03Z",
        "updatedAt" : "2020-01-08T06:38:12Z",
        "lastEditedBy" : "570b631b-84a0-4888-a815-ca0e7934e412",
        "tags" : [
        ]
      },
      {
        "id" : "aa1a2d3f-17ae-4f84-9920-cd59f8acd9af",
        "parentId" : "8631a204-84f6-45ed-9d76-34cf03bc4338",
        "authorId" : "41c25afd-5561-4611-9b3a-7df68582aa10",
        "body" : "added.",
        "createdAt" : "2020-01-08T06:39:52Z",
        "updatedAt" : "2020-01-08T06:39:52Z",
        "lastEditedBy" : "41c25afd-5561-4611-9b3a-7df68582aa10",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1053e4835f262837ef7c4f437aa27ca4136f56a",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +542,546 @@// This function returns two boolean flags. The first boolean flag indicates whether the pod matches affinity rules\n// or not. The second boolean flag indicates if the pod matches anti-affinity rules.\nfunc (pl *InterPodAffinity) satisfiesPodsAffinityAntiAffinity(pod *v1.Pod,\n\tstate *preFilterState, nodeInfo *nodeinfo.NodeInfo,\n\taffinity *v1.Affinity) (bool, bool, error) {"
  }
]
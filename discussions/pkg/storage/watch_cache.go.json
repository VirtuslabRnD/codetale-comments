[
  {
    "id" : "009900a2-10ed-4fc0-bb86-81499bcae31e",
    "prId" : 35218,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35218#pullrequestreview-5214467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "046d3ab4-de2c-45d9-b57c-cef6e95cd68f",
        "parentId" : null,
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "please add comment, that w.Unlock() needs to be called after this function.\n",
        "createdAt" : "2016-10-21T08:05:48Z",
        "updatedAt" : "2016-10-21T08:09:34Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "b37f4160-f8f6-4fe5-a563-dd9aac626939",
        "parentId" : "046d3ab4-de2c-45d9-b57c-cef6e95cd68f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done\n",
        "createdAt" : "2016-10-21T08:09:41Z",
        "updatedAt" : "2016-10-21T08:09:41Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "93c008f8a4f6c592994e199e8d7c1b721b3379fc",
    "line" : null,
    "diffHunk" : "@@ -1,1 +249,253 @@// NOTE: This function acquired lock and doesn't release it.\n// You HAVE TO explicitly call w.RUnlock() after this function.\nfunc (w *watchCache) waitUntilFreshAndBlock(resourceVersion uint64, trace *util.Trace) error {\n\tstartTime := w.clock.Now()\n\tgo func() {"
  },
  {
    "id" : "efa43e94-9d7c-4250-ab6b-bde40be16efb",
    "prId" : 13910,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Does this list go out to hit etcd? I guess it doesn't matter since this feature can't be used safely anyway, but if it doesn't go out to hit etcd there's no guarantee the combined state returned by the list would be a complete/correct one as of any particular resource version.\n",
        "createdAt" : "2015-09-15T17:30:31Z",
        "updatedAt" : "2015-09-15T17:30:31Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "1646e04e-c996-4d73-894e-db40df527256",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I believe that the List() will work against the current state in the backing cache.Store and not hit etcd.\n",
        "createdAt" : "2015-09-15T18:16:46Z",
        "updatedAt" : "2015-09-15T18:16:46Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "524f0e29-c1d2-445c-a7a9-f732ca0de621",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Wait, why is this feature not safe?  The original implementation was safe -\nwe called etcd to do a list, then watched from the list timestamp.  How is\nthe new version less able to deliver safety?\n\nOn Tue, Sep 15, 2015 at 1:30 PM, Daniel Smith notifications@github.com\nwrote:\n\n> In pkg/storage/watch_cache.go\n> https://github.com/kubernetes/kubernetes/pull/13910#discussion_r39539558\n> :\n> \n> > @@ -250,6 +250,20 @@ func (w *watchCache) GetAllEventsSinceThreadUnsafe(resourceVersion uint64) ([]wa\n> >     if size > 0 {\n> >         oldest = w.cache[w.startIndex%w.capacity].resourceVersion\n> >     }\n> > -   if resourceVersion == 0 {\n> > -       // resourceVersion = 0 means that we don't require any specific starting point\n> > -       // and we would like to start watching from ~now.\n> > -       // However, to keep backward compatibility, we additionally need to return the\n> > -       // current state and only then start watching from that point.\n> > -       //\n> > -       // TODO: In v2 api, we should stop returning the current state - #13969.\n> > -       allItems := w.store.List()\n> \n> Does this list go out to hit etcd? I guess it doesn't matter since this\n> feature can't be used safely anyway, but if it doesn't go out to hit etcd\n> there's no guarantee the combined state returned by the list would be a\n> complete/correct one as of any particular resource version.\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13910/files#r39539558.\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-09-15T20:20:30Z",
        "updatedAt" : "2015-09-15T20:20:30Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ddb99f91-b8d0-482a-a26a-832a434327bc",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Right, I have the same question. I can tell @lavalamp doesn't like this method, but I haven't heard a concrete reason an internal list followed by watch of the list's resourceVersion is unsafe\n",
        "createdAt" : "2015-09-15T20:22:44Z",
        "updatedAt" : "2015-09-15T20:23:21Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9b7c6238-a19b-41a4-b1d7-ca66d58aaf7a",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I suspect he is referring to a potential race between the backing cache.Store and the watch cache.  So if the current items are enumerated from the cache.store, and a watch is initiated, its possible that in the time between that a change in etcd was missed.  I think to fix that you would need to know the resource version of the most recent item for when `w.store.List()` returned its value.\n",
        "createdAt" : "2015-09-15T20:35:07Z",
        "updatedAt" : "2015-09-15T20:35:07Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "c23ce51c-5133-4f3e-9af3-b266bfb54aa1",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "So before the watch cache was in place, it could have been safe (since we have a resourceVersion on the List we got from etcd)?\n",
        "createdAt" : "2015-09-15T21:12:45Z",
        "updatedAt" : "2015-09-15T21:12:45Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6d630ef2-7c4d-41d7-821f-8959877e147a",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I say it's not \"safe\" because at no point in time can the client be certain it has a complete or correct list. I get that for many uses this safety isn't important.\n",
        "createdAt" : "2015-09-15T21:48:31Z",
        "updatedAt" : "2015-09-15T21:48:31Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "c82bc0ac-be5d-416b-91d4-15dc5870d865",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "It is safe (due to how it is implemented).\nBasically, the backing store contains a correct state at some point in time. The way it is implemented is that the cacher is locking watchCache, gets the state from that point in time (using list on the backing store) and starts watch from exactly that point. Every new watch event delivered to the backing store will be propagated to that watcher,\nSo there is no risk that some event will not be delivered.\n",
        "createdAt" : "2015-09-16T06:32:06Z",
        "updatedAt" : "2015-09-16T06:32:06Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "389cc152-6737-4981-b63f-1ec443c1e7e2",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "> I say it's not \"safe\" because at no point in time can the client be certain it has a complete or correct list. I get that for many uses this safety isn't important.\n\nI don't understand it btw. It is guaranteed that this list is a correct list from some point in time (as long as we don't have multi-object transactions, which is true for now).\n",
        "createdAt" : "2015-09-16T06:53:25Z",
        "updatedAt" : "2015-09-16T06:53:32Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "5c0aad66-8750-4446-adf3-54655a3c45de",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@wojtek-t  thank you for the clarification.\n",
        "createdAt" : "2015-09-16T18:02:01Z",
        "updatedAt" : "2015-09-16T18:02:01Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "33c34d22-4828-45b4-8e6f-82f7808534f1",
        "parentId" : "f83104c9-01ae-4771-a282-a646dcb831d6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Oh, I see! Yes, this sounds correct. In theory, etcd would provide the same\nlist at some resourceVersion. Thanks for explaining.\n\nOn Tue, Sep 15, 2015 at 11:32 PM, Wojciech Tyczynski <\nnotifications@github.com> wrote:\n\n> In pkg/storage/watch_cache.go\n> https://github.com/kubernetes/kubernetes/pull/13910#discussion_r39597444\n> :\n> \n> > @@ -250,6 +250,20 @@ func (w *watchCache) GetAllEventsSinceThreadUnsafe(resourceVersion uint64) ([]wa\n> >     if size > 0 {\n> >         oldest = w.cache[w.startIndex%w.capacity].resourceVersion\n> >     }\n> > -   if resourceVersion == 0 {\n> > -       // resourceVersion = 0 means that we don't require any specific starting point\n> > -       // and we would like to start watching from ~now.\n> > -       // However, to keep backward compatibility, we additionally need to return the\n> > -       // current state and only then start watching from that point.\n> > -       //\n> > -       // TODO: In v2 api, we should stop returning the current state - #13969.\n> > -       allItems := w.store.List()\n> \n> It is safe (due to how it is implemented).\n> Basically, the backing store contains a correct state at some point in\n> time. The way it is implemented is that the cacher is locking watchCache,\n> gets the state from that point in time (using list on the backing store)\n> and starts watch from exactly that point. Every new watch event delivered\n> to the backing store will be propagated to that watcher,\n> So there is no risk that some event will not be delivered.\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13910/files#r39597444.\n",
        "createdAt" : "2015-09-16T21:30:11Z",
        "updatedAt" : "2015-09-16T21:30:11Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "12eaf67acceb0bcd49527667dc154b8c670752ea",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +258,262 @@\t\t//\n\t\t// TODO: In v2 api, we should stop returning the current state - #13969.\n\t\tallItems := w.store.List()\n\t\tresult := make([]watchCacheEvent, len(allItems))\n\t\tfor i, item := range allItems {"
  }
]
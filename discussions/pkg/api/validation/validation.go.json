[
  {
    "id" : "d6fe08c6-a7fc-4e4d-9f8a-7b78c32c3587",
    "prId" : 51761,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51761#pullrequestreview-60119135",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "534ea942-ce9d-4c07-98a4-68482a671e4e",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "```go\r\nif oldNode.Spec.ProviderID == \"\"\r\n```",
        "createdAt" : "2017-09-01T12:22:35Z",
        "updatedAt" : "2017-09-01T12:22:35Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "032a6d944191f0b76e54a0d099cb29883de4e276",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +3440,3444 @@\n\t// Allow controller manager updating provider ID when not set\n\tif len(oldNode.Spec.ProviderID) == 0 {\n\t\toldNode.Spec.ProviderID = node.Spec.ProviderID\n\t} else {"
  },
  {
    "id" : "a550e681-5847-425c-92ff-2847e192ff1e",
    "prId" : 51761,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51761#pullrequestreview-60229432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc051db6-65dd-450e-877c-be6875a8ed5e",
        "parentId" : null,
        "authorId" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "body" : "Can we add the new ProviderID to the error to make this easier to debug?",
        "createdAt" : "2017-09-01T18:37:57Z",
        "updatedAt" : "2017-09-01T18:37:57Z",
        "lastEditedBy" : "7aca96c2-45d7-4567-99be-0323d7556c55",
        "tags" : [
        ]
      },
      {
        "id" : "4528e76d-e921-4c68-8810-319f51b01b77",
        "parentId" : "bc051db6-65dd-450e-877c-be6875a8ed5e",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We don't usually do that for Forbidden errors because ... I forget why.  If we want to do that, we should add a field to the error struct and do it all over.",
        "createdAt" : "2017-09-01T20:00:03Z",
        "updatedAt" : "2017-09-01T20:00:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "032a6d944191f0b76e54a0d099cb29883de4e276",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +3444,3448 @@\t} else {\n\t\tif oldNode.Spec.ProviderID != node.Spec.ProviderID {\n\t\t\tallErrs = append(allErrs, field.Forbidden(field.NewPath(\"spec\", \"providerID\"), \"node updates may not change providerID except from \\\"\\\" to valid\"))\n\t\t}\n\t}"
  },
  {
    "id" : "26ef6cbe-f00d-4ccc-881d-44710923a0de",
    "prId" : 51240,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51240#pullrequestreview-74313662",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e534761-f96c-43c3-9421-743dda26e99b",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This now allows linux users to specify a non-absolute path.  What happens when a linux user says `\"C:\"` for this field?\r\n\r\nAnd where are the tests for this?  No test == no merge.\r\n\r\nCome on folks.  We need to do better than this.  I don't have bandwidth to review every PR, but I shouldn't have to.  Every time I randomly sample and I find things like this, I fear for the project.  You HAVE TO consider the wider implications of EVERY change.  We're well past the days where such changes could be made cavalierly.\r\n\r\nI don't know what the solution is, but I need a solution and a test ASAP or I will roll this back. \r\n\r\nMaybe we can redefine this field to always be at the root directory if the path is not absolute, and just remove this validation entirely?  What bad things would happen?\r\n\r\n@saad-ali @kubernetes/sig-storage-api-reviews ",
        "createdAt" : "2017-11-02T04:05:01Z",
        "updatedAt" : "2017-11-02T04:11:40Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "918bd235-aa37-464e-8b6c-743bb6a29d8b",
        "parentId" : "8e534761-f96c-43c3-9421-743dda26e99b",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "The correct approach is to use the `path/filepath` `isAbs` function:\r\n\r\nhttps://golang.org/pkg/path/filepath/#IsAbs\r\n\r\nSee:\r\n\r\nhttps://github.com/golang/go/issues/1483\r\n\r\nFor details.",
        "createdAt" : "2017-11-02T13:29:12Z",
        "updatedAt" : "2017-11-02T13:29:12Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "eb551c35-5edf-40f3-888f-9f6a4446985b",
        "parentId" : "8e534761-f96c-43c3-9421-743dda26e99b",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "PR with the fix is here:\r\n\r\nhttps://github.com/kubernetes/kubernetes/pull/54995",
        "createdAt" : "2017-11-02T13:45:20Z",
        "updatedAt" : "2017-11-02T13:45:20Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "5e98225a-6d4c-4ebc-822f-1088aa1ce871",
        "parentId" : "8e534761-f96c-43c3-9421-743dda26e99b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This presumes that the server on which the validation runs is the same OS as the server on which the pod will run.  That is certainly not guaranteed.  will comment there.",
        "createdAt" : "2017-11-02T16:12:55Z",
        "updatedAt" : "2017-11-02T16:12:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "8f740324-4248-4839-80e7-20410eee4e49",
        "parentId" : "8e534761-f96c-43c3-9421-743dda26e99b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Apologies if this came off harshly.  What I hoped to convey was that a) we're in a place now where changes such as this have subtle and non-local implications that we HAVE to work through; and b) PRs without tests need to be the rare exception case.  We owe it to our users and each other to raise the quality level on every PR.",
        "createdAt" : "2017-11-02T17:29:10Z",
        "updatedAt" : "2017-11-02T17:29:10Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "01ff80c5-2e59-476c-a642-b14a81a2a016",
        "parentId" : "8e534761-f96c-43c3-9421-743dda26e99b",
        "authorId" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "body" : "Hi @thockin, sorry I should add tests for this PR, here is the new test PR: https://github.com/kubernetes/kubernetes/pull/55137\r\n\r\nThe main difficulty for this fix is:  **validation would not only run on agent node, it also runs on master node, while from the master, it did not know whether the mount path is for linux or windows agent node.**  (For windows based k8s cluster, the master node is a linux server and agent is windows server)\r\n\r\nThe absolute path validation was introduced from `v1.8` and it did not consider the condition for windows node, see: https://github.com/kubernetes/kubernetes/commit/8d86bd1c644fec011e2cb48414d66a7dbc3f7f1d\r\n\r\n@brendanburns ",
        "createdAt" : "2017-11-06T03:49:22Z",
        "updatedAt" : "2017-11-06T13:41:42Z",
        "lastEditedBy" : "e0218e0a-9e55-43f5-8929-04673eea9015",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d4e049ea136c600ff7b4d285dff45022f79f3c7",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1863,1867 @@\t\t\t// also allow windows absolute path\n\t\t\tp := mnt.MountPath\n\t\t\tif len(p) < 2 || ((p[0] < 'A' || p[0] > 'Z') && (p[0] < 'a' || p[0] > 'z')) || p[1] != ':' {\n\t\t\t\tallErrs = append(allErrs, field.Invalid(idxPath.Child(\"mountPath\"), mnt.MountPath, \"must be an absolute path\"))\n\t\t\t}"
  },
  {
    "id" : "7a9647d8-b0bd-4992-9c4f-f21c52960f38",
    "prId" : 50859,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/50859#pullrequestreview-57265080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "parentId" : null,
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "Do we want to validate the HugePage size? i.e. 2Mi and 1Gi are valid and others not.",
        "createdAt" : "2017-08-18T04:51:39Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      },
      {
        "id" : "134184c5-d39a-4b04-8db8-3785568d4df6",
        "parentId" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "That means, what if users configure `hugepages-3Mi` ?",
        "createdAt" : "2017-08-18T04:52:43Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      },
      {
        "id" : "cfef32b0-79c3-468b-bd57-0ca6ad8f79b3",
        "parentId" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@xiangpengzhao - that is a good question.\r\n\r\nthere are a variety of large page sizes depending on the architecture, so i was hoping to avoid an explicit enumeration of them or awareness in the api server.  this is an alpha feature, but my long term expectation is that operators would configure the `ResourceQuota` system to make consumption of hugepages denied by default per something like https://github.com/kubernetes/kubernetes/pull/36765 , and they would then grant explicit quota for the page sizes supported in their fleet of machines.  WDYT?",
        "createdAt" : "2017-08-18T14:42:14Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "8757798c-8230-4df2-892c-f0d6e45ac3ab",
        "parentId" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "SGTM. I like this idea. Thanks for explanation!\r\n\r\nAnother concern, I have a use case that users want to have the privilege to adjust their hugepages usage, or even the node hugepages capacity dynamically. Yes this will cause complication and seems like not reasonable enough. Any thoughts?",
        "createdAt" : "2017-08-18T15:40:26Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      },
      {
        "id" : "bf40064f-7562-4b9b-818e-8221321a777b",
        "parentId" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "They want to release the unused hugepages to be \"normal\" memory so that these memory can be used by other process on the node.",
        "createdAt" : "2017-08-18T15:43:05Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      },
      {
        "id" : "c5649812-0e3c-413b-9646-f1014dff097e",
        "parentId" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@xiangpengzhao - that is out of scope for alpha.  its possible you could run a controller that observed pods pending due to lack of hugepages capacity across cluster, and run a pod to allocate them on a particular node in response.  there are pros/cons with that especially with gigantic page sizes.  i had a pod that did something like that here: https://github.com/derekwaynecarr/hugepages/tree/master/allocator",
        "createdAt" : "2017-08-18T17:24:16Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "c55639f7-b9ec-47bf-828b-88d515cc7c2e",
        "parentId" : "cb1de915-2fa0-4793-8337-48099ee406fd",
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "@derekwaynecarr Cool! Thanks, Derek!",
        "createdAt" : "2017-08-18T17:37:25Z",
        "updatedAt" : "2017-09-05T14:34:41Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      }
    ],
    "commit" : "38d5dee67776733045463a8a35fb2058db49eb3b",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +2457,2461 @@\t\t\tresourceSet := toContainerResourcesSet(&pod.Spec.Containers[i])\n\t\t\tfor resourceStr := range resourceSet {\n\t\t\t\tif v1helper.IsHugePageResourceName(v1.ResourceName(resourceStr)) {\n\t\t\t\t\thugePageResources.Insert(resourceStr)\n\t\t\t\t}"
  },
  {
    "id" : "e2a46de7-e542-42d2-bb55-af8e8e5ea5ba",
    "prId" : 49727,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/49727#pullrequestreview-60155264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e8d38f5-7438-463b-ad9b-c6bd1abd3a80",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I don't think your feature gate has to protect conditions.  Conditions are something any controller can set.  You can remove this check.",
        "createdAt" : "2017-08-31T22:15:44Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "24c7d837-97d6-4695-8b41-119808f73900",
        "parentId" : "2e8d38f5-7438-463b-ad9b-c6bd1abd3a80",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Keep the test if it's valid though.",
        "createdAt" : "2017-08-31T22:16:02Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "eb12ab2e-1e09-4499-89c5-9c56131f4a2d",
        "parentId" : "2e8d38f5-7438-463b-ad9b-c6bd1abd3a80",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the conditions field is new to this feature... it's a tad odd to add it and unconditionally enable it with only one current use",
        "createdAt" : "2017-09-01T14:39:18Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b6cedb94-079f-4224-baec-836135519632",
        "parentId" : "2e8d38f5-7438-463b-ad9b-c6bd1abd3a80",
        "authorId" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "body" : "yeah, I have left this check in place for now. ",
        "createdAt" : "2017-09-01T14:42:38Z",
        "updatedAt" : "2017-09-04T07:08:19Z",
        "lastEditedBy" : "d3e684d7-edd2-4290-a8bf-e8b698c97338",
        "tags" : [
        ]
      }
    ],
    "commit" : "84029c2c1a798bab26781c0219186b278ad69af7",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1633,1637 @@\t\tallErrs = append(allErrs, field.Required(field.NewPath(\"Spec\", \"accessModes\"), \"\"))\n\t}\n\tif !utilfeature.DefaultFeatureGate.Enabled(features.ExpandPersistentVolumes) && len(newPvc.Status.Conditions) > 0 {\n\t\tconditionPath := field.NewPath(\"status\", \"conditions\")\n\t\tallErrs = append(allErrs, field.Forbidden(conditionPath, \"invalid field\"))"
  },
  {
    "id" : "8041d8c5-61c2-40ae-adf8-908f8f39d061",
    "prId" : 48815,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48815#pullrequestreview-49693318",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d28ee72-d945-4ef8-b64d-453b4243d0cf",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "what happens today if you use a non-absolute path? is it relative to the container root?",
        "createdAt" : "2017-07-13T06:14:47Z",
        "updatedAt" : "2017-07-13T06:14:47Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "295eb2b9-a2b7-4701-b3f0-3a6f83fd4c0b",
        "parentId" : "6d28ee72-d945-4ef8-b64d-453b4243d0cf",
        "authorId" : "3c1422a0-6358-4857-8f56-961979171514",
        "body" : "@sttts From [the Docker Official Doc](https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume),\r\n\r\n> The `container-dir` must always be an **absolute path** such as /src/docs.\r\n\r\nSo the container cannot be started up if you use a non-absolute path for `mnt.MountPath`, just as what was reported in #48749.\r\n\r\n",
        "createdAt" : "2017-07-13T06:57:21Z",
        "updatedAt" : "2017-07-13T06:57:21Z",
        "lastEditedBy" : "3c1422a0-6358-4857-8f56-961979171514",
        "tags" : [
        ]
      },
      {
        "id" : "11929912-22a0-4f39-9e0e-d66d9b8a9d08",
        "parentId" : "6d28ee72-d945-4ef8-b64d-453b4243d0cf",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Ic. I was worried that we disallow something in the API that used to work.\r\n\r\n/cc @derekwaynecarr sounds reasonable. ptal.",
        "createdAt" : "2017-07-13T07:00:42Z",
        "updatedAt" : "2017-07-13T07:00:42Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "8d86bd1c644fec011e2cb48414d66a7dbc3f7f1d",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1761,1765 @@\t\t\tallErrs = append(allErrs, field.Invalid(idxPath.Child(\"mountPath\"), mnt.MountPath, \"must be unique\"))\n\t\t}\n\t\tif !path.IsAbs(mnt.MountPath) {\n\t\t\tallErrs = append(allErrs, field.Invalid(idxPath.Child(\"mountPath\"), mnt.MountPath, \"must be an absolute path\"))\n\t\t}"
  },
  {
    "id" : "75df3387-4aa2-4587-826b-f5fe76c3fdda",
    "prId" : 48789,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48789#pullrequestreview-57238801",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "what are the format restrictions on InitiatorName?",
        "createdAt" : "2017-08-10T14:08:35Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "cdf29751-9f41-4185-9324-432d2548760f",
        "parentId" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "@liggitt @rootfs \r\nIIRC, the InitiatorName should follow IQN (iSCSI Qualified Name) format or EUI (Extended Unique Identifier) format to connect to iSCSI target properly.\r\nex.\r\n```\r\ncat /etc/iscsi/initiatorname.iscsi\r\nInitiatorName=iqn.1994-05.com.redhat:185ce16b55ad\r\n```\r\n\r\nBut from my quick check, it seems that iscsiadm accepts any kind of initiatorname like below. Then iSCSI connection will fail if the initiatorname doesn't align specific format as mentioned above. \r\nSince iscsiadm doesn't validate initiatorname, I think we can skip validation in Kubernetes.\r\nAlso we don't validate \"IQN\" which is already in ISCSIVolumeSource struct.\r\nAny thought?\r\n\r\n```\r\nroot# sudo iscsiadm -m iface -I stable -o update -n iface.initiatorname -v a\r\nstable updated.\r\nroot# sudo iscsiadm -m iface -I stable | grep iface.initiatorname\r\niface.initiatorname = a\r\nroot# sudo iscsiadm -m iface -I stable -o update -n iface.initiatorname -v $\r\nstable updated.\r\nroot# sudo iscsiadm -m iface -I stable | grep iface.initiatorname\r\niface.initiatorname = $\r\nroot# sudo iscsiadm -m iface -I stable -o update -n iface.initiatorname -v @\r\nstable updated.\r\nroot# sudo iscsiadm -m iface -I stable | grep iface.initiatorname\r\niface.initiatorname = @\r\nroot# sudo iscsiadm -m iface -I stable -o update -n iface.initiatorname -v !\r\nstable updated.\r\nroot# sudo iscsiadm -m iface -I stable | grep iface.initiatorname\r\niface.initiatorname = !\r\n```",
        "createdAt" : "2017-08-10T15:25:35Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "965fb7d5-b1d5-49b6-bd1b-487ee1aeb912",
        "parentId" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "passing unbounded data through to native exec calls run as root always makes me squeamish... I wasn't sure how well the iscsiadm tool handled malicious data",
        "createdAt" : "2017-08-10T15:47:52Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "77b0a27b-b1a8-47d1-b160-6f15727e53cf",
        "parentId" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "@liggitt\r\nI understand your concern especially from security perspective.\r\nIn order to validate initiatorname, we should research what kind of values should be accepted to avoid degradation.\r\n\r\n@rootfs \r\nAny consideration?",
        "createdAt" : "2017-08-10T16:33:09Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      },
      {
        "id" : "074a54f0-645f-4b92-bbad-29c1b1b0bb6c",
        "parentId" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "```\r\nInitiators and targets MUST support the receipt of iSCSI names of up\r\n   to the maximum length of 223 bytes.\r\n```\r\nper https://www.ietf.org/rfc/rfc3720.txt",
        "createdAt" : "2017-08-10T17:02:57Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      },
      {
        "id" : "d5808460-baf9-4490-8708-1c3b877f07dc",
        "parentId" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "just banning `&`, `;`, `*`, `$`, and `|` helps a little if that is possible...",
        "createdAt" : "2017-08-16T17:15:36Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "f1c6ebcf-7bcf-44af-b9d9-c5f213a99c08",
        "parentId" : "dd2c32fc-025e-4773-b629-bfbd005e31f4",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "Validation for both \"IQN\"  and \"InitiatorName\" in the ISCSIVolumeSource were added.\r\nAs for iSCSI, we accept three type of prefixes, \"iqn\", \"eui\" and \"naa\".\r\nThey are supported by tagetcli. \r\n\r\nSee man targetcli.\r\n```\r\niSCSI supports multiple WWN formats: iqn, naa, and eui. Other fabrics support single formats only.\r\n```\r\n\r\nThese are reference of the implementation.\r\n- iqn/eui\r\nhttps://www.ietf.org/rfc/rfc3721.txt\r\n\r\n```\r\niqn\r\niqn.2000-02.edu.example.cs:users.oaks:proto.target4\r\niqn.1995-11.com.example.ssp:customers.4567.disks.107\r\n\r\nType  EUI-64 identifier\r\neui.02004567A425678D\r\n```\r\n\r\n- naa\r\nhttps://tools.ietf.org/html/rfc3980#ref-FC-FS\r\n\r\n```\r\nType  64bit NAA identifier (ASCII-encoded hexadecimal)\r\nnaa.52004567BA64678D\r\n\r\nType  128 bit NAA identifier (ASCII-encoded hexadecimal)\r\nnaa.62004567BA64678D0123456789ABCDEF\r\n```\r\n\r\n- python-rtslib-2.1.fb57-5.el7.noarch\r\n```\r\ndef normalize_wwn(wwn_types, wwn):\r\n    '''\r\n    Take a WWN as given by the user and convert it to a standard text\r\n    representation.\r\n\r\n    Returns (normalized_wwn, wwn_type), or exception if invalid wwn.\r\n    '''\r\n    wwn_test = {\r\n    'free': lambda wwn: True,\r\n    'iqn': lambda wwn: \\\r\n        re.match(\"iqn\\.[0-9]{4}-[0-1][0-9]\\..*\\..*\", wwn) \\\r\n        and not re.search(' ', wwn) \\\r\n        and not re.search('_', wwn),\r\n    'naa': lambda wwn: re.match(\"naa\\.[125][0-9a-fA-F]{15}$\", wwn),\r\n    'eui': lambda wwn: re.match(\"eui\\.[0-9a-f]{16}$\", wwn),\r\n    'ib': lambda wwn: re.match(\"ib\\.[0-9a-f]{32}$\", wwn),\r\n    'unit_serial': lambda wwn: \\\r\n        re.match(\"[0-9A-Fa-f]{8}(-[0-9A-Fa-f]{4}){3}-[0-9A-Fa-f]{12}$\", wwn),\r\n    }\r\n```",
        "createdAt" : "2017-08-18T15:45:46Z",
        "updatedAt" : "2017-08-21T16:37:43Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0d4664a27781d73180cd2f63b2b516a8a0e2558",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +448,452 @@\t\t\tnumVolumes++\n\t\t\tallErrs = append(allErrs, validateISCSIVolumeSource(source.ISCSI, fldPath.Child(\"iscsi\"))...)\n\t\t}\n\t\tif source.ISCSI.InitiatorName != nil && len(volName+\":\"+source.ISCSI.TargetPortal) > 64 {\n\t\t\ttooLongErr := \"Total length of <volume name>:<iscsi.targetPortal> must be under 64 characters if iscsi.initiatorName is specified.\""
  },
  {
    "id" : "bcfca662-cf82-4e63-b45e-020048e1b0cc",
    "prId" : 48789,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48789#pullrequestreview-57855722",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87e8b216-ca22-4348-90f3-6727d1a920ce",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "nit: easier to read as a switch:\r\n\r\n```go\r\nswitch {\r\n  case len(iscsi.IQN) == 0:\r\n    allErrs = append(allErrs, field.Required(fldPath.Child(\"iqn\"), \"\"))\r\n\r\n  case strings.HasPrefix(iscsi.IQN, \"iqn\"):\r\n    if !iscsiInitiatorIqnRegex.MatchString(iscsi.IQN) {\r\n      allErrs = append(allErrs, field.Invalid(fldPath.Child(\"iqn\"), iscsi.IQN, \"must be valid format\"))\r\n    }\r\n\r\n  case strings.HasPrefix(iscsi.IQN, \"eui\"):\r\n    if !iscsiInitiatorEuiRegex.MatchString(iscsi.IQN) {\r\n      allErrs = append(allErrs, field.Invalid(fldPath.Child(\"iqn\"), iscsi.IQN, \"must be valid format\"))\r\n    }\r\n\r\n  case strings.HasPrefix(iscsi.IQN, \"naa\"):\r\n    if !iscsiInitiatorNaaRegex.MatchString(iscsi.IQN) {\r\n      allErrs = append(allErrs, field.Invalid(fldPath.Child(\"iqn\"), iscsi.IQN, \"must be valid format\"))\r\n    }\r\n\r\n  default:\r\n    allErrs = append(allErrs, field.Invalid(fldPath.Child(\"iqn\"), iscsi.IQN, \"must be valid format\"))\r\n}\r\n```",
        "createdAt" : "2017-08-22T17:38:06Z",
        "updatedAt" : "2017-08-22T17:38:06Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0d4664a27781d73180cd2f63b2b516a8a0e2558",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +643,647 @@\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"targetPortal\"), \"\"))\n\t}\n\tif len(iscsi.IQN) == 0 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"iqn\"), \"\"))\n\t} else {"
  },
  {
    "id" : "f703abb4-09f5-41ae-940e-6b9222b3c772",
    "prId" : 48741,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48741#pullrequestreview-49250104",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42ad65f9-4793-4057-a7ed-2f88a15c8fe4",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I'd appreciate an unit test for this.",
        "createdAt" : "2017-07-11T08:33:39Z",
        "updatedAt" : "2017-08-10T14:43:13Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "4407d348-01e6-4053-883b-1aea13b7c5a9",
        "parentId" : "42ad65f9-4793-4057-a7ed-2f88a15c8fe4",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "done",
        "createdAt" : "2017-07-11T16:14:51Z",
        "updatedAt" : "2017-08-10T14:43:13Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "422ce036e7ac2965c00f2d9d6557968ae42dd34d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +649,653 @@func validateFCVolumeSource(fc *api.FCVolumeSource, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif len(fc.TargetWWNs) < 1 && len(fc.WWIDs) < 1 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"targetWWNs\"), \"must specify either targetWWNs or wwids, but not both\"))\n\t}"
  },
  {
    "id" : "f62becc9-cc43-4a75-ad08-19e5f036d975",
    "prId" : 48741,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48741#pullrequestreview-49250132",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59871eb0-2e6e-451e-92e9-bc3992b31188",
        "parentId" : null,
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I'd appreciate an unit test for this.",
        "createdAt" : "2017-07-11T08:33:46Z",
        "updatedAt" : "2017-08-10T14:43:13Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "0b61be8a-2b06-4bd9-a0d2-567673d5467d",
        "parentId" : "59871eb0-2e6e-451e-92e9-bc3992b31188",
        "authorId" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "body" : "done",
        "createdAt" : "2017-07-11T16:14:56Z",
        "updatedAt" : "2017-08-10T14:43:13Z",
        "lastEditedBy" : "967a712d-9784-41d4-920d-42eaba99fb24",
        "tags" : [
        ]
      }
    ],
    "commit" : "422ce036e7ac2965c00f2d9d6557968ae42dd34d",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +653,657 @@\t}\n\n\tif len(fc.TargetWWNs) != 0 && len(fc.WWIDs) != 0 {\n\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"targetWWNs\"), fc.TargetWWNs, \"targetWWNs and wwids can not be specified simultaneously\"))\n\t}"
  },
  {
    "id" : "d8d6e39c-d27a-438a-b39d-84faa426a1c6",
    "prId" : 47660,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47660#pullrequestreview-56106185",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8c3d235-77e5-46ae-9783-692bf60a7909",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "error if secretNamespace is non-nil and empty... nil means use the PVC namespace, non-nil means use the specified namespace",
        "createdAt" : "2017-08-10T13:19:26Z",
        "updatedAt" : "2017-08-24T14:53:08Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2751528c-141e-459f-8f30-a17c1d56702b",
        "parentId" : "f8c3d235-77e5-46ae-9783-692bf60a7909",
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "added",
        "createdAt" : "2017-08-14T15:05:17Z",
        "updatedAt" : "2017-08-24T14:53:08Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a38cf1b1bd6bf1459d3f87edf1e6a044398c68e",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1101,1105 @@func validateAzureFilePV(azure *api.AzureFilePersistentVolumeSource, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif azure.SecretName == \"\" {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"secretName\"), \"\"))\n\t}"
  },
  {
    "id" : "abae7907-4867-40c6-96da-29567272391e",
    "prId" : 47290,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47290#pullrequestreview-43465287",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d529754-a1e7-4810-bae6-95f23c4e8666",
        "parentId" : null,
        "authorId" : "3c1422a0-6358-4857-8f56-961979171514",
        "body" : "The function should be uppercase, as being called in other package.",
        "createdAt" : "2017-06-12T02:03:23Z",
        "updatedAt" : "2017-06-16T20:52:52Z",
        "lastEditedBy" : "3c1422a0-6358-4857-8f56-961979171514",
        "tags" : [
        ]
      },
      {
        "id" : "9d02a245-a859-4d43-af00-4341e64b7100",
        "parentId" : "3d529754-a1e7-4810-bae6-95f23c4e8666",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I don't think it is, there is a similar method in the volume package that is getting called",
        "createdAt" : "2017-06-12T15:03:08Z",
        "updatedAt" : "2017-06-16T20:52:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "48b3fb84abdc0fee12299eed262da287d48110de",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +971,975 @@// This assumes the OS of the apiserver and the nodes are the same. The same check should be done\n// on the node to ensure there are no backsteps.\nfunc validatePathNoBacksteps(targetPath string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tparts := strings.Split(filepath.ToSlash(targetPath), \"/\")"
  },
  {
    "id" : "d90aa633-b67d-4735-b49e-ee5f43ed5dc2",
    "prId" : 47284,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47284#pullrequestreview-43342635",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38db385b-6029-4b8d-9cf5-b7b2b7ed8540",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This should just be `map[intstr.IntOrString]bool` for obviousness reasons. or `struct{}` instead of bool.",
        "createdAt" : "2017-06-10T22:25:12Z",
        "updatedAt" : "2017-06-12T03:24:05Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "49768669-6272-4cda-90fb-4ed56dd8a6d8",
        "parentId" : "38db385b-6029-4b8d-9cf5-b7b2b7ed8540",
        "authorId" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "body" : "We should also respect protocol, so I still use ServicePort here.",
        "createdAt" : "2017-06-12T03:31:05Z",
        "updatedAt" : "2017-06-12T03:31:26Z",
        "lastEditedBy" : "a09f2d48-fec0-4c0d-bd81-6de7378a6ebf",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce54d9072bd637db5441a9c7b92c8d0eb0511629",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +2868,2872 @@\t// Check for duplicate TargetPort\n\tportsPath = specPath.Child(\"ports\")\n\ttargetPorts := make(map[api.ServicePort]bool)\n\tfor i, port := range service.Spec.Ports {\n\t\tif (port.TargetPort.Type == intstr.Int && port.TargetPort.IntVal == 0) || (port.TargetPort.Type == intstr.String && port.TargetPort.StrVal == \"\") {"
  },
  {
    "id" : "ce3ede96-f2b4-4287-a87d-d6515c8dd66f",
    "prId" : 47236,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/47236#pullrequestreview-44693855",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed421594-849d-4c41-ad25-a42fd64e7e75",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "return early",
        "createdAt" : "2017-06-17T05:41:03Z",
        "updatedAt" : "2017-06-17T06:37:52Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa23ed53c2f285b2f7c74e8344d29008580a9e86",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +1133,1137 @@\tallErrs := field.ErrorList{}\n\tif ls.Path == \"\" {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"path\"), \"\"))\n\t\treturn allErrs\n\t}"
  },
  {
    "id" : "39ec6f58-a2c2-4beb-bcde-4c535f920fe3",
    "prId" : 46711,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46711#pullrequestreview-41685744",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5379856-6210-4e78-a7ec-153a0feaeae6",
        "parentId" : null,
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "What's the range of valid pod `.spec.ActiveDeadlineSeconds`? `0 - MaxInt32` or `1 - MaxInt32`?",
        "createdAt" : "2017-05-31T21:34:59Z",
        "updatedAt" : "2017-05-31T22:10:18Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "662497d8-5678-4dc2-b218-d30deb156e0d",
        "parentId" : "f5379856-6210-4e78-a7ec-153a0feaeae6",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "0 is allowed on update of  pod to mean \"kill it now\".\r\n\r\non create its 1-MaxInt32",
        "createdAt" : "2017-05-31T22:33:13Z",
        "updatedAt" : "2017-05-31T22:33:13Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "fb8c3600-d221-486f-af4d-e650d278ebb2",
        "parentId" : "f5379856-6210-4e78-a7ec-153a0feaeae6",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "@derekwaynecarr , can we just update `InclusiveRangeError` to use `int64`?",
        "createdAt" : "2017-06-01T23:05:34Z",
        "updatedAt" : "2017-06-01T23:05:34Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "8f193e59-c0d6-4b2b-b1ce-bbc3d54d89b2",
        "parentId" : "f5379856-6210-4e78-a7ec-153a0feaeae6",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "no, int64 values cannot be reliably represented in JSON",
        "createdAt" : "2017-06-02T03:06:50Z",
        "updatedAt" : "2017-06-02T03:06:50Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "5b1426e2-ec8d-45c6-91e5-2b8f2850cad0",
        "parentId" : "f5379856-6210-4e78-a7ec-153a0feaeae6",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "`InclusiveRangeError` is an internal error message builder which will return string. I think it's not related with JSON. Refer to #46807 for detail :).",
        "createdAt" : "2017-06-02T03:34:18Z",
        "updatedAt" : "2017-06-02T03:34:18Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "81899ea1-45d2-4cc9-9be1-2d7eacdafd56",
        "parentId" : "f5379856-6210-4e78-a7ec-153a0feaeae6",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "ah, misread... I thought you wanted the valid range expanded to int64",
        "createdAt" : "2017-06-02T03:36:17Z",
        "updatedAt" : "2017-06-02T03:36:17Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "6207e19fb82037523c6b6f3a050088cee2e2d607",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +2193,2197 @@\t\tvalue := *spec.ActiveDeadlineSeconds\n\t\tif value < 1 || value > math.MaxInt32 {\n\t\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"activeDeadlineSeconds\"), value, validation.InclusiveRangeError(1, math.MaxInt32)))\n\t\t}\n\t}"
  },
  {
    "id" : "2fe56e16-5338-455f-a187-cb52766e926a",
    "prId" : 46640,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46640#pullrequestreview-41618059",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cb55649-681b-4ff7-9a56-1124ec18b6bc",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "InclusiveRange takes `int` as input parameter, i thought passing math.MaxUint32 would overflow. But it seems only the cross build arm compiler catches it.",
        "createdAt" : "2017-06-01T19:43:02Z",
        "updatedAt" : "2017-06-01T19:43:02Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "aad55495-612f-42a4-9563-ae6f55fddcc8",
        "parentId" : "9cb55649-681b-4ff7-9a56-1124ec18b6bc",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Oh, maybe it's because int is int64 on common platforms.",
        "createdAt" : "2017-06-01T19:46:15Z",
        "updatedAt" : "2017-06-01T19:46:15Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "2132139a-b034-464d-9f3b-6cb4d50faa70",
        "parentId" : "9cb55649-681b-4ff7-9a56-1124ec18b6bc",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Can we just change the upperbound to MaxInt32?",
        "createdAt" : "2017-06-01T19:49:09Z",
        "updatedAt" : "2017-06-01T19:49:09Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "9d412210e9babf6c7181ee0708c8cd3a8da234e2",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +2194,2198 @@\t\t\tvalue := *spec.ActiveDeadlineSeconds\n\t\t\tif value < 1 || value > math.MaxUint32 {\n\t\t\t\tallErrs = append(allErrs, field.Invalid(fldPath.Child(\"activeDeadlineSeconds\"), value, validation.InclusiveRangeError(1, math.MaxUint32)))\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "da4d39cc-9652-4441-b44c-d9e9d453c1ce",
    "prId" : 46444,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46444#pullrequestreview-59973940",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7961b330-4d60-4927-b556-176e1b70ef89",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "The api changes guideline for alpha fields also suggestss clearing the field before persisting to the storage. https://github.com/kubernetes/community/blob/master/contributors/devel/api_changes.md#alpha-field-in-existing-api-version\r\n\r\nNot sure if it's needed but it's worth checking out.",
        "createdAt" : "2017-08-31T18:10:44Z",
        "updatedAt" : "2017-09-01T19:39:42Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "b424d757-28c5-4a28-b0c5-ba6ca0b0bdf0",
        "parentId" : "7961b330-4d60-4927-b556-176e1b70ef89",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "I did not find any feature gate checks in `pkg/registry/core`. Is really required?",
        "createdAt" : "2017-08-31T19:41:39Z",
        "updatedAt" : "2017-09-01T19:39:42Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "9db67b77-465e-49f5-b284-0ddb18a06084",
        "parentId" : "7961b330-4d60-4927-b556-176e1b70ef89",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "there is discussion about clearing alpha fields in https://github.com/kubernetes/kubernetes/pull/50924. I'll wait for result and fix mountPropagation field when necessary.",
        "createdAt" : "2017-08-31T20:00:44Z",
        "updatedAt" : "2017-09-01T19:39:42Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      }
    ],
    "commit" : "03b753daad55b492bfc71d17b0c3109d404ee8e3",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1030,1034 @@// validateMountPropagation verifies that MountPropagation field is valid and\n// allowed for given container.\nfunc validateMountPropagation(mountPropagation *api.MountPropagationMode, container *api.Container, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n"
  },
  {
    "id" : "f2c1bbf7-75f4-4b54-9a19-bb65daa8e80c",
    "prId" : 46444,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46444#pullrequestreview-60271513",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee964a5a-cf59-4667-820b-83ea9dd5199c",
        "parentId" : null,
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "why no err returned about nil",
        "createdAt" : "2017-09-01T01:45:19Z",
        "updatedAt" : "2017-09-01T19:39:42Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      },
      {
        "id" : "21314c1a-a8e4-4e05-a3ec-9a10574bb7b4",
        "parentId" : "ee964a5a-cf59-4667-820b-83ea9dd5199c",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "See the comment two lines below. Some `PodPreset` test was failing on it as it validated a PodSpec with no containers.",
        "createdAt" : "2017-09-01T08:53:33Z",
        "updatedAt" : "2017-09-01T19:39:42Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "b5422933-e9cc-48e6-9713-691e77ccb7f6",
        "parentId" : "ee964a5a-cf59-4667-820b-83ea9dd5199c",
        "authorId" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "body" : "... some PodPreset test was failing on it as it validated **VolumeMounts** with no containers.\r\n",
        "createdAt" : "2017-09-01T09:02:46Z",
        "updatedAt" : "2017-09-01T19:39:42Z",
        "lastEditedBy" : "8b64e744-955d-4523-a3b7-60fae9df0857",
        "tags" : [
        ]
      },
      {
        "id" : "94afd00f-3474-467e-9f4c-16352ba474d8",
        "parentId" : "ee964a5a-cf59-4667-820b-83ea9dd5199c",
        "authorId" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "body" : "If container is previously  validated,  I do not think this `if container == nil `  make  sense",
        "createdAt" : "2017-09-02T08:30:20Z",
        "updatedAt" : "2017-09-02T08:30:49Z",
        "lastEditedBy" : "c29e1906-5f0b-4d7b-af8b-d664805e8c8e",
        "tags" : [
        ]
      }
    ],
    "commit" : "03b753daad55b492bfc71d17b0c3109d404ee8e3",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1046,1050 @@\t}\n\n\tif container == nil {\n\t\t// The container is not available yet, e.g. during validation of\n\t\t// PodPreset. Stop validation now, Pod validation will refuse final"
  },
  {
    "id" : "1fc67a7d-81b8-4bd7-b98e-cdf134ba8b05",
    "prId" : 45610,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45610#pullrequestreview-44165130",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15f890a5-b931-4a80-839b-4c307967cb79",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "both fields should be prevented from being populated if the priority feature gate is not on... we don't want latent data allowed in, then acted on in a later release when the feature is enabled",
        "createdAt" : "2017-06-14T13:10:57Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "37dddf2a-d4d5-4a3c-a4ba-b3dec214c0e4",
        "parentId" : "15f890a5-b931-4a80-839b-4c307967cb79",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Added the feature gate for PriorityClassName. Admission controller (a subsequent PR) will prevent users from setting `Priority` regardless. `Priority` is set only be the admission controller.",
        "createdAt" : "2017-06-14T21:47:22Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "0137b129-1d2d-4bd5-b40b-12418eef90f2",
        "parentId" : "15f890a5-b931-4a80-839b-4c307967cb79",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : " The rest handler cannot depend on the admission plug-in being present, and by the time the object reaches validation and rest handling, there is no way to know whether the field was set by a user or an admission plug-in ",
        "createdAt" : "2017-06-14T21:54:51Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3e14239c-fd22-47fc-874d-dd7e6b734e38",
        "parentId" : "15f890a5-b931-4a80-839b-4c307967cb79",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "Makes sense. I added a check for preventing `Priority` from being set if the feature is not enabled. ",
        "createdAt" : "2017-06-14T22:27:26Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      }
    ],
    "commit" : "403b30f6e9619366072b1cb5b302e9ebc240d095",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +2301,2305 @@\t}\n\n\tif len(spec.PriorityClassName) > 0 {\n\t\tif !utilfeature.DefaultFeatureGate.Enabled(features.PodPriority) {\n\t\t\tallErrs = append(allErrs, field.Forbidden(fldPath.Child(\"priorityClassName\"), \"Pod priority is disabled by feature-gate\"))"
  },
  {
    "id" : "106032e7-6c8d-4790-9039-bf92410dfd93",
    "prId" : 45610,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45610#pullrequestreview-45118517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ecb7b8b-2c7f-474a-bbbf-32d53ca120c2",
        "parentId" : null,
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "personally, I'd like the following if/else:\r\n\r\n```\r\nif utilfeature.DefaultFeatureGate.Enabled(features.PodPriority) {\r\n  ...\r\n} else {\r\n  ...\r\n}\r\n```",
        "createdAt" : "2017-06-17T01:23:42Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      },
      {
        "id" : "aa3f9880-4714-4039-9353-a9bbcb83644e",
        "parentId" : "0ecb7b8b-2c7f-474a-bbbf-32d53ca120c2",
        "authorId" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "body" : "in my version of the code, the feature gate is not checked when priority class is not specified. Also, the condition \"if len(spec.PriorityClassName) > 0\" should be repeated in both if and else blocks of your version.",
        "createdAt" : "2017-06-19T19:20:37Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "15fb535e-c5be-47ce-a304-1cb5da5aca90",
        "tags" : [
        ]
      },
      {
        "id" : "1760565f-0f83-4a65-aa2e-80d716434e12",
        "parentId" : "0ecb7b8b-2c7f-474a-bbbf-32d53ca120c2",
        "authorId" : "72156db3-c40b-4455-9838-c12c0c606019",
        "body" : "yes; my version is for sometimes removing this feature gate (just remove the `else` block is OK); both are ok to me :).",
        "createdAt" : "2017-06-20T12:27:46Z",
        "updatedAt" : "2017-06-26T22:07:33Z",
        "lastEditedBy" : "72156db3-c40b-4455-9838-c12c0c606019",
        "tags" : [
        ]
      }
    ],
    "commit" : "403b30f6e9619366072b1cb5b302e9ebc240d095",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +2302,2306 @@\n\tif len(spec.PriorityClassName) > 0 {\n\t\tif !utilfeature.DefaultFeatureGate.Enabled(features.PodPriority) {\n\t\t\tallErrs = append(allErrs, field.Forbidden(fldPath.Child(\"priorityClassName\"), \"Pod priority is disabled by feature-gate\"))\n\t\t} else {"
  },
  {
    "id" : "084c5c2f-2b6e-4ed2-8cb6-7fe3f6e0c980",
    "prId" : 44785,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44785#pullrequestreview-38794968",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6e24425-7bb0-4351-ab87-0378b4dfe425",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "How about validating Pod Spec resources?",
        "createdAt" : "2017-05-09T21:45:00Z",
        "updatedAt" : "2017-05-31T20:06:56Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "2d93ddc6-4bc8-4a97-9e78-49a1cc60583e",
        "parentId" : "a6e24425-7bb0-4351-ab87-0378b4dfe425",
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "add validation for ResourceRequirements which will be called by validateContainer",
        "createdAt" : "2017-05-17T21:36:12Z",
        "updatedAt" : "2017-05-31T20:06:56Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      }
    ],
    "commit" : "695f7be697b4137875e2fc93c39b06ab2784fa2f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +398,402 @@\t\tnumVolumes++\n\t\tif !utilfeature.DefaultFeatureGate.Enabled(features.LocalStorageCapacityIsolation) {\n\t\t\tunsetSizeLimit := resource.Quantity{}\n\t\t\tif unsetSizeLimit.Cmp(source.EmptyDir.SizeLimit) != 0 {\n\t\t\t\tallErrs = append(allErrs, field.Forbidden(fldPath.Child(\"emptyDir\").Child(\"sizeLimit\"), \"SizeLimit field disabled by feature-gate for EmptyDir volumes\"))"
  },
  {
    "id" : "260f6ce3-21f8-4f3a-8cc5-f3c6957da937",
    "prId" : 42156,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42156#pullrequestreview-42605619",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99855fb5-e947-49ab-992f-b994ffa84fa7",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "when validating a PV storageos volume source, need to make sure that the secret name and namespace are both specified, or neither is specified, right?",
        "createdAt" : "2017-06-07T13:41:28Z",
        "updatedAt" : "2017-06-09T12:33:33Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e2503e71fa51ae08fbbc90cc94e7d293709528e",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1125,1129 @@}\n\nfunc validateStorageOSVolumeSource(storageos *api.StorageOSVolumeSource, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif len(storageos.VolumeName) == 0 {"
  },
  {
    "id" : "67b365d4-3e4e-4a1e-8182-db2bcb60fede",
    "prId" : 41818,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41818#pullrequestreview-23588060",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1b89fe38-ddd6-4a61-9db3-485921020442",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "I would say \"modified or deleted\" but you can fix in a followup PR\r\n",
        "createdAt" : "2017-02-23T21:12:51Z",
        "updatedAt" : "2017-02-23T21:12:51Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9d95b44265bc043c6cb8493a61e696029efccca",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1863,1867 @@\t\t}\n\t\tif !found {\n\t\t\tallErrs = append(allErrs, field.Forbidden(fldPath, \"existing toleration can not be modified except its tolerationSeconds\"))\n\t\t\treturn allErrs\n\t\t}"
  },
  {
    "id" : "7351ab86-e2a6-42b9-a9b2-3bdef0f3db5d",
    "prId" : 41162,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41162#pullrequestreview-37736244",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79099b72-0f67-4865-ac40-ba974143a59d",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Not sure if it is relevant. \r\nIs it allowed to use healthcheck node port with Global?\r\nIs it allowed to mixa usage of beta annotation and fields? (I think annotaion is preempting, so we do not care? )",
        "createdAt" : "2017-05-12T00:47:52Z",
        "updatedAt" : "2017-05-12T17:59:12Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "70479e13-e69c-4fd9-9dc8-e0e37cb57aa1",
        "parentId" : "79099b72-0f67-4865-ac40-ba974143a59d",
        "authorId" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "body" : "> Is it allowed to use healthcheck node port with Global?\r\n\r\nNope, we disallow this case in ValidateServiceExternalTrafficFieldsCombination().\r\n\r\n> Is it allowed to mixa usage of beta annotation and fields? (I think annotaion is preempting, so we do not care? )\r\n\r\nNope, we disallow this case in validateServiceExternalTrafficAPIVersion().\r\n\r\nSorry for the mess, but I have to separate the validation into multiple pieces because they are called in different phases --- especially ValidateServiceExternalTrafficFieldsCombination() needs to be called after defaulting and resetting ESIPP fields :(",
        "createdAt" : "2017-05-12T01:15:41Z",
        "updatedAt" : "2017-05-12T17:59:12Z",
        "lastEditedBy" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "tags" : [
        ]
      }
    ],
    "commit" : "12b6c2b8792f375460c94f59c9bffe39895df37f",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +2789,2793 @@// validateServiceExternalTrafficFieldsValue validates ExternalTraffic related annotations\n// have legal value.\nfunc validateServiceExternalTrafficFieldsValue(service *api.Service) field.ErrorList {\n\tallErrs := field.ErrorList{}\n"
  },
  {
    "id" : "91b96753-8244-4428-860b-a07e98eaed13",
    "prId" : 40216,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40216#pullrequestreview-17743027",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9540a8bd-ea03-4900-8fcf-9e647d923ceb",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "This is really ugly and generally wrong.  Not new in this pull but the link here should be snipped.  This is an admission choice, not a general validation choice.",
        "createdAt" : "2017-01-20T15:10:13Z",
        "updatedAt" : "2017-01-24T19:56:12Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "f9451f16-306e-4ed7-9956-ac48be3a23a9",
        "parentId" : "9540a8bd-ea03-4900-8fcf-9e647d923ceb",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Will add a TODO. Didn't look at the meaning of the gates.",
        "createdAt" : "2017-01-20T19:10:32Z",
        "updatedAt" : "2017-01-24T19:56:12Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b8e9381284d29f0a14e524a5fb8a845b03ebb5f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2066,2070 @@\t\t}\n\t\t// TODO: this belongs to admission, not general pod validation:\n\t\tif !utilfeature.DefaultFeatureGate.Enabled(features.AppArmor) {\n\t\t\tallErrs = append(allErrs, field.Forbidden(fldPath.Key(k), \"AppArmor is disabled by feature-gate\"))\n\t\t\tcontinue"
  },
  {
    "id" : "79bb25ff-d125-4e2b-b890-70d7231fd12d",
    "prId" : 40216,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/40216#pullrequestreview-17917134",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13f5d89a-b544-4fa5-8515-c37bb5eac82c",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "@timstclair ^^",
        "createdAt" : "2017-01-23T13:01:06Z",
        "updatedAt" : "2017-01-24T19:56:12Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b8e9381284d29f0a14e524a5fb8a845b03ebb5f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2065,2069 @@\t\t\tcontinue\n\t\t}\n\t\t// TODO: this belongs to admission, not general pod validation:\n\t\tif !utilfeature.DefaultFeatureGate.Enabled(features.AppArmor) {\n\t\t\tallErrs = append(allErrs, field.Forbidden(fldPath.Key(k), \"AppArmor is disabled by feature-gate\"))"
  },
  {
    "id" : "7228e5f2-ce00-46d6-9e94-bbaa75385312",
    "prId" : 38957,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38957#pullrequestreview-22973617",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Do we also need to add validation for Tolerations update?\r\n",
        "createdAt" : "2017-02-20T08:35:13Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "77957a03-aee5-4cbf-83fc-585aac9c7326",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "My understanding is that tolerations should not be allowed to be modified during pod updates. ",
        "createdAt" : "2017-02-20T14:58:28Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "f08cf421-ea18-4bf3-ac4f-b2cb8c502a55",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "FYI: managers code can handle toleration updates.\r\n\r\nFrom usability perspective I'd say it should be possible to add Toleration, e.g. when operator is adding new taint to the cluster, and want to keep some of the Pods running.",
        "createdAt" : "2017-02-20T15:06:21Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "d3c0b85c-e01c-4ef1-99aa-f7503f2447b4",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "tolerations are part of pod spec, so are immutable.",
        "createdAt" : "2017-02-20T15:06:39Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a96f62d1-3999-4bea-a782-6ba9a12bf394",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Spec immutability is a thing only for Pods, right? Is there any part of system that depends on that? Kubelet?",
        "createdAt" : "2017-02-20T15:08:40Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "d8eecc79-7d26-4e15-befe-78b148e82577",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "currently, admission is used on pod creation to verify the node selector and toleration uses are authorized. taints/tolerations are one tool to keep user pods off of infrastructure nodes. allowing mutation means revisiting existing admission plugins (in and out of tree) and reauthorizing pod specs on update.",
        "createdAt" : "2017-02-20T15:09:41Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f2493443-9dfa-4c95-bd22-fe9693903be9",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Plus IIUC we're planning to allow changing Pod resource requests at some point which will get rid of this assumption. I guess it's better to do it sooner rather than later.",
        "createdAt" : "2017-02-20T15:09:52Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "99de8e6e-7847-45ed-8044-b9fa05fab6a3",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "OK, but that doesn't follow from the fact that Tolerations are in the Spec;)",
        "createdAt" : "2017-02-20T18:38:55Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      },
      {
        "id" : "415e4740-bfb2-4c13-94ce-e2b742b4db04",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> that doesn't follow from the fact that Tolerations are in the Spec;)\r\n\r\npod spec has been immutable since 1.0 with exactly two exceptions: images and activeDeadlineSeconds:\r\n\r\n```\r\n\tif !apiequality.Semantic.DeepEqual(mungedPod.Spec, oldPod.Spec) {\r\n\t\t//TODO: Pinpoint the specific field that causes the invalid error after we have strategic merge diff\r\n\t\tallErrs = append(allErrs, field.Forbidden(specPath, \"pod updates may not change fields other than `containers[*].image` or `spec.activeDeadlineSeconds`\"))\r\n\t}\r\n```",
        "createdAt" : "2017-02-20T18:46:37Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2ef27d9d-5c69-4eae-94fa-e00b4f6354c7",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "@liggitt I think we need to bite the bullet and change all the admission controllers to accommodate it. I think it's not possible for Kubernetes or a cluster admin to roll out new taints in a non-disruptive way if we don't allow updates to tolerations on existing pods.\r\n\r\nFor example, say a new Kubelet release introduce a new \"node problem\" NoExecute taint, and by default pods should tolerate it for 5 minutes. We can add an admission controller to add the default toleration, but the admin also needs to update the pods that are pending and running at the time they upgrade the Kubelet, otherwise if any of their nodes get the taint then the pods that were pending or running at the time of the upgrade (and are now running) will be evicted immediately, which is not what they want. \r\n\r\nAnother example would be, you convert your cluster from shared to partitioned by team by introducing NoSchedule taints to all of the nodes. If you do this, all of the pods that are pending at the time you add the taints will remain pending forever (since none of them tolerate the dedicated node taints). What you want is to update the pending pods to tolerate the taint corresponding to their dedicated node group.\r\n\r\nIf you think it is not possible to update the security assumptions of the admission controllers and other infrastructure in time for 1.6, we could say toleration update is rejected in 1.6 and then allowed in 1.7 (which would be considered a backward-compatible change IMO). But this feature is much less useful without it, so I don't see how we can avoid allowing toleration update either now or very soon.\r\n",
        "createdAt" : "2017-02-20T20:55:29Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "17e161de-2a0e-4e40-ad30-2078b86b63f1",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@davidopp --can we separate the problem and ask if the pod spec should allow mutation to any toleration, or if we should allow for example only new tolerations to be added to an existing pod spec.",
        "createdAt" : "2017-02-20T21:29:05Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "0749cf79-80ac-4e7d-8ce6-f5c0b8f230d3",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@davidopp - i think we can evaluate mutating tolerations on pod spec post 1.6?",
        "createdAt" : "2017-02-20T21:33:38Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "6ee1fe77-037a-45ad-a818-a925399fb9d8",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "@derekwaynecarr Yes - I think saying you can add a toleration but not change an existing one is very reasonable (both for this PR and long-term). @liggitt would it be OK for us to do that in this PR?",
        "createdAt" : "2017-02-20T21:47:45Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "85c90c45-0fff-4747-89df-2cc93ca4c4ea",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> @liggitt would it be OK for us to do that in this PR?\r\n\r\nAdding tolerations is no different than mutating them, security-wise (preventing user-specified tolerations is a key way to keep user pods off nodes). I'd prefer to defer the discussion about pod-spec mutation to after 1.6",
        "createdAt" : "2017-02-20T21:51:14Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "5f40e84a-ce04-4d6f-a558-cdf98fd8d126",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "@davidopp -- i am not sure my thought was well-reasoned.  i was more trying to see if the problem space can be reduced.  the use-case of adding to an existing pod spec, and those specs getting out of date with replica sets still felt skewed.",
        "createdAt" : "2017-02-20T21:51:56Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "3ebb2124-5ba8-42b6-9760-6d087cb1f17c",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "How about we say that adding/modifying tolerations is an \"alpha feature\" that is disabled by default, so that people who are OK with it can enable it? I realize that makes this PR more complicated than either \"allow it\" or \"don't allow it\" but I am worried about the usability implications of not having any way for people to handle the scenarios I described.",
        "createdAt" : "2017-02-20T21:56:01Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "e2892830-2fa0-41bc-9abe-1793c12d2f36",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "(I do think we should make it a \"real\" feature in 1.7, but at least it would be available to those who want it in 1.6)",
        "createdAt" : "2017-02-20T21:56:30Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "db9cdc73-0d24-4c08-a0d8-a5e45c46bf51",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "mutable pod specs is a pretty fundamental shift. I would maintain the status quo for this PR and propose allowing mutation separately. ",
        "createdAt" : "2017-02-20T22:04:37Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "bfca80c0-bf84-4c93-bff0-9d1aed6a1d38",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "But you said PodSpec is already mutable (for two fields). :)\r\n\r\nDo you disagree that handling the scenarios I describe need some kind of ability to update tolerations on existing pods?\r\n\r\nI'm trying to understand if your objection is \"we have too much stuff that relies on this assumption right now and not enough time to fix it\" or \"adding tolerations can never be safe.\" If the latter, we should understand the issues before moving taints/tolerations feature to beta, as the feature really relies on being able to add tolerations to existing pods.\r\n",
        "createdAt" : "2017-02-20T22:08:30Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "af3d1bc3-67d7-4e32-a9a8-52c177c14f0e",
        "parentId" : "6fda1315-cd1c-4914-84b8-feff40c67076",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "There are lots of fields in the pod spec that fall into the category of \"my pod could keep running even though the world has changed if I could just tweak this one aspect\". I think it's a slippery slope to make manual fixup of existing pods to adapt to a changing cluster a goal, but if there's broad agreement (including @kubernetes/api-approvers) that's what we want to do, I'll defer",
        "createdAt" : "2017-02-21T14:50:30Z",
        "updatedAt" : "2017-02-22T14:28:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "b679e13c91470f2de4dde03dd8cc2936189a63e1",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +2904,2908 @@\toldNode.Status = node.Status\n\n\t// update taints\n\tif len(node.Spec.Taints) > 0 {\n\t\tallErrs = append(allErrs, validateNodeTaints(node.Spec.Taints, fldPath.Child(\"taints\"))...)"
  },
  {
    "id" : "dc3ebf61-c4cf-433e-aaf1-dea1cf0f7013",
    "prId" : 36133,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36133#pullrequestreview-7124008",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b149bfbf-5c58-4ba6-a89e-897442ad8cfb",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "This code is duplicated, perhaps extract out as a single function?\n",
        "createdAt" : "2016-11-03T23:11:53Z",
        "updatedAt" : "2016-11-08T17:58:19Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "c1f7530d-65ec-4873-873d-30c106eeee12",
        "parentId" : "b149bfbf-5c58-4ba6-a89e-897442ad8cfb",
        "authorId" : "5d1f7040-18ac-4dc2-aadb-f39c5601803e",
        "body" : "It's not 100% duplicated though... one is using fldPath and the other is using specPath. And I am trying to be consistent with the context code. \nMaybe a separate commit just for code-cleanup to shorten all the duplicated code in this block would be a better solution?\n",
        "createdAt" : "2016-11-03T23:25:34Z",
        "updatedAt" : "2016-11-08T17:58:20Z",
        "lastEditedBy" : "5d1f7040-18ac-4dc2-aadb-f39c5601803e",
        "tags" : [
        ]
      }
    ],
    "commit" : "20b9fc6905b11b8b59656f934371c4211192ccfb",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +1176,1180 @@\t\t}\n\t}\n\tif pv.Spec.PhotonPersistentDisk != nil {\n\t\tif numVolumes > 0 {\n\t\t\tallErrs = append(allErrs, field.Forbidden(specPath.Child(\"photonPersistentDisk\"), \"may not specify more than 1 volume type\"))"
  },
  {
    "id" : "63058fa4-d653-4e3d-a0fe-7a530f20cb54",
    "prId" : 30599,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db4c6b27-c619-471c-a2fe-a41d7291bd1e",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Godoc on this.\n",
        "createdAt" : "2016-08-16T22:18:48Z",
        "updatedAt" : "2016-08-19T18:31:19Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "3db4de02-5eb1-4ea0-a134-6bd6f4c40736",
        "parentId" : "db4c6b27-c619-471c-a2fe-a41d7291bd1e",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "Done\n",
        "createdAt" : "2016-08-16T22:55:41Z",
        "updatedAt" : "2016-08-19T18:31:19Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "88fdb96bfb175fa242c1b6e43ee55466842741f0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +103,107 @@\n// ValidateDNS1123Subdomain validates that a name is a proper DNS subdomain.\nfunc ValidateDNS1123Subdomain(value string, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tfor _, msg := range validation.IsDNS1123Subdomain(value) {"
  },
  {
    "id" : "a1b03a77-651d-4c1a-acb2-e15b5e6091f8",
    "prId" : 30599,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed7de8d9-6cfa-40cf-81c9-f94879fea3ec",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Is it allowed to have type ExternalName but an empty ExternalName?\n",
        "createdAt" : "2016-08-16T22:19:42Z",
        "updatedAt" : "2016-08-19T18:31:19Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ea790578-f343-42a9-8ba6-271d62239379",
        "parentId" : "ed7de8d9-6cfa-40cf-81c9-f94879fea3ec",
        "authorId" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "body" : "That was a question I had. I added  an error for empty names.\n",
        "createdAt" : "2016-08-16T22:56:54Z",
        "updatedAt" : "2016-08-19T18:31:19Z",
        "lastEditedBy" : "11725e10-43c9-4a8c-96d0-5118a3e67a6a",
        "tags" : [
        ]
      }
    ],
    "commit" : "88fdb96bfb175fa242c1b6e43ee55466842741f0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2227,2231 @@\t\t\tallErrs = append(allErrs, field.Invalid(specPath.Child(\"clusterIP\"), service.Spec.ClusterIP, \"must be empty for ExternalName services\"))\n\t\t}\n\t\tif len(service.Spec.ExternalName) > 0 {\n\t\t\tallErrs = append(allErrs, ValidateDNS1123Subdomain(service.Spec.ExternalName, specPath.Child(\"externalName\"))...)\n\t\t} else {"
  },
  {
    "id" : "54c8596d-a8c2-4961-a9a0-3ba997dcb053",
    "prId" : 29836,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "830cb1c9-44f4-4188-8f0e-22702154e184",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "no validation of CachingMode?  It's documented as an enum-string...\n",
        "createdAt" : "2016-08-02T05:54:21Z",
        "updatedAt" : "2016-08-23T13:23:19Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "dea4b0226d859a1b86a81163c86ec61cffc1b952",
    "line" : null,
    "diffHunk" : "@@ -1,1 +960,964 @@\t\tallErrs = append(allErrs, field.NotSupported(fldPath.Child(\"cachingMode\"), *azure.CachingMode, supportedCachingModes.List()))\n\t}\n\treturn allErrs\n}\n"
  },
  {
    "id" : "a32b642f-8ca2-45cc-a100-3ca06bf6b9e3",
    "prId" : 29034,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b967dbc7-345b-49f3-ac9d-18899cf2887f",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "update comment to include `initContainers[*].image`. @smarterclayton, I assume initContainers image fields are supposed to be updateable as well?\n\nedit: confirmed with @smarterclayton out of band\n",
        "createdAt" : "2016-07-19T21:20:16Z",
        "updatedAt" : "2016-07-19T21:31:25Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "02baa44948f6b2c8145784c01481c4a02628d868",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1987,1991 @@\n\t// validate updateable fields:\n\t// 1.  containers[*].image\n\t// 2.  initContainers[*].image\n\t// 3.  spec.activeDeadlineSeconds"
  },
  {
    "id" : "d6ffaf49-f4e7-4454-ad23-ad0478f2c44d",
    "prId" : 28690,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd0cd18a-3ff7-43ee-8331-0e3e5b325806",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "You don't need to deep copy here - see ValidatePetSetUpdate() for a slightly cleaner way to do this (easier to read and verify is correct).\n",
        "createdAt" : "2016-07-08T21:15:26Z",
        "updatedAt" : "2016-07-11T15:51:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "bccce17d-3be7-4c7f-a90e-bcbb11764117",
        "parentId" : "cd0cd18a-3ff7-43ee-8331-0e3e5b325806",
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "I looked at PetSet and I understand what you're suggesting, but that got me wondering if I even need to do that.  Fact is, the only change allowed is volumeName from empty string to something. \n\nI removed the clone, added a comment about volumeName, and simply set back to \"\" when done.\n",
        "createdAt" : "2016-07-08T22:08:49Z",
        "updatedAt" : "2016-07-11T15:51:26Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ddb8470b992ec3ff4b4c36818d7d6b5cff0aa6c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1025,1029 @@\t// PVController needs to update PVC.Spec w/ VolumeName.\n\t// Claims are immutable in order to enforce quota, range limits, etc. without gaming the system.\n\tif len(oldPvc.Spec.VolumeName) == 0 {\n\t\t// volumeName changes are allowed once.\n\t\t// Reset back to empty string after equality check"
  },
  {
    "id" : "2ffd5606-20d3-4605-a791-220e087700e1",
    "prId" : 28690,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4032a0e8-4e0f-4981-9e2c-4910b524e9c5",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "curiously this change results in an behavior that a no-op (identical) UPDATE operation succeeds if volumeName == \"\", but fails in any other case.\n\nPerhaps we should be checking for no-op updates at a higher-level, so per-type code can know that SOMETHING is changing.\n",
        "createdAt" : "2016-07-10T22:04:16Z",
        "updatedAt" : "2016-07-11T15:51:26Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "81286af5-4139-4162-b6d2-2708cda2c12b",
        "parentId" : "4032a0e8-4e0f-4981-9e2c-4910b524e9c5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "@smarterclayton ^^\n",
        "createdAt" : "2016-07-10T22:04:27Z",
        "updatedAt" : "2016-07-11T15:51:26Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3d179bea-a285-404c-b9e5-4324dcd0ce62",
        "parentId" : "4032a0e8-4e0f-4981-9e2c-4910b524e9c5",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We definitely check at the lower level (storage will no-op a CAS on etcd where source and target are the same).  I can buy that we should have better info in the strategy to make that decision.\n\nI think all no-op changes (for now) should be allowed down through validation, so as Tim notes the PR should treat a no-op as success regardless of value (I think you were going to do that based on the comment below, but just double checking).\n",
        "createdAt" : "2016-07-10T23:07:34Z",
        "updatedAt" : "2016-07-11T15:51:26Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ddb8470b992ec3ff4b4c36818d7d6b5cff0aa6c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1028,1032 @@\t\t// volumeName changes are allowed once.\n\t\t// Reset back to empty string after equality check\n\t\toldPvc.Spec.VolumeName = newPvc.Spec.VolumeName\n\t\tdefer func() { oldPvc.Spec.VolumeName = \"\" }()\n\t}"
  },
  {
    "id" : "47c134c8-7aa7-4afd-b595-a74b5c52d4a5",
    "prId" : 27180,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c0764d0-9603-4948-ba58-174250aad48a",
        "parentId" : null,
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "nit: `s/fldPath/fieldPath`, in this case the full name looks better\n",
        "createdAt" : "2016-08-19T12:40:24Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      },
      {
        "id" : "2b7a63ea-88ba-4942-8d8c-0455e7f4854e",
        "parentId" : "0c0764d0-9603-4948-ba58-174250aad48a",
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "ha, used all over the place\n",
        "createdAt" : "2016-08-19T12:51:17Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      },
      {
        "id" : "74ab9383-2ea0-4946-9514-bd281a32c937",
        "parentId" : "0c0764d0-9603-4948-ba58-174250aad48a",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "yes :)\n",
        "createdAt" : "2016-08-19T12:57:34Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "03d7e33034af425e4ea7da76641d6451abfd501e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2169,2173 @@}\n\nfunc validateSysctls(sysctls []api.Sysctl, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tfor i, s := range sysctls {"
  },
  {
    "id" : "22ff439b-12d3-42e7-a92c-b07dac360271",
    "prId" : 27180,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04b57679-09f5-4295-9623-581d11db651e",
        "parentId" : null,
        "authorId" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "body" : "exported symbol => godoc\n",
        "createdAt" : "2016-08-19T12:53:28Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "c63e1ceb-64bd-4726-b8ef-e647d73dae0c",
        "tags" : [
        ]
      }
    ],
    "commit" : "03d7e33034af425e4ea7da76641d6451abfd501e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2162,2166 @@// IsValidSysctlName checks that the given string is a valid sysctl name,\n// i.e. matches SysctlFmt.\nfunc IsValidSysctlName(name string) bool {\n\tif len(name) > SysctlMaxLength {\n\t\treturn false"
  },
  {
    "id" : "a3b4bae3-d304-4286-a81a-beb928468316",
    "prId" : 27180,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "510f6b7d-851b-4954-9561-d0f3a3ff3731",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Consider using pkg/util/sets.String and its various helper methods?\n",
        "createdAt" : "2016-08-24T15:06:23Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "c493bde7-be25-42da-a306-fd03c79db27b",
        "parentId" : "510f6b7d-851b-4954-9561-d0f3a3ff3731",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Then we have to extract the names first. Gives us two loops as well. Or\nanother helper. Will take a look.\n\nOn Wed, Aug 24, 2016 at 5:07 PM, Andy Goldstein notifications@github.com\nwrote:\n\n> In pkg/api/validation/validation.go\n> https://github.com/kubernetes/kubernetes/pull/27180#discussion_r76074722\n> :\n> \n> > @@ -3517,3 +3530,17 @@ func isValidHostnamesMap(serializedPodHostNames string) bool {\n> >     }\n> >     return true\n> >  }\n> > +\n> > +func sysctlIntersection(a []api.Sysctl, b []api.Sysctl) []api.Sysctl {\n> > -   lookup := make(map[string]struct{}, len(a))\n> \n> Consider using pkg/util/sets.String and its various helper methods?\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/27180/files/ac007642cb78b954bdfb27cdac0da7634cb02b04..00d7068d939c4fbc40da44209908e0832792dcee#r76074722,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAskCzRongxKx22ismihaO2MecRYATitks5qjF4ogaJpZM4Iy3_n\n> .\n",
        "createdAt" : "2016-08-24T15:09:09Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "5d85baed-5d81-4a2e-baa6-5783473ff846",
        "parentId" : "510f6b7d-851b-4954-9561-d0f3a3ff3731",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "This line frightens me: https://github.com/sttts/kubernetes/blob/836ac6e4037c2ff0c9994ced9526b6a18a451486/vendor/github.com/heketi/heketi/pkg/utils/stringset.go#L40-L40\n\n`O(n*n*log(n))`\n",
        "createdAt" : "2016-08-24T19:06:24Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "03d7e33034af425e4ea7da76641d6451abfd501e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3530,3534 @@\nfunc sysctlIntersection(a []api.Sysctl, b []api.Sysctl) []string {\n\tlookup := make(map[string]struct{}, len(a))\n\tresult := []string{}\n\tfor i := range a {"
  },
  {
    "id" : "87ca958e-7dc2-4e4e-ad3a-720a4296742f",
    "prId" : 27180,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03b55e33-b218-4566-a78e-185ba57a148b",
        "parentId" : null,
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "I think you dont have to store whole sysctl into result if you are just using their name in the validation, see my other comment above.\n",
        "createdAt" : "2016-08-24T15:57:52Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "223f0bfe-fbe8-4803-8289-9950000f922e",
        "parentId" : "03b55e33-b218-4566-a78e-185ba57a148b",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "True, fixing.\n",
        "createdAt" : "2016-08-24T19:01:56Z",
        "updatedAt" : "2016-08-25T11:22:38Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "03d7e33034af425e4ea7da76641d6451abfd501e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3541,3545 @@\t}\n\treturn result\n}"
  },
  {
    "id" : "6ce883d0-4a28-48ce-8e9f-5db231a27d6a",
    "prId" : 25567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "05da845b-4f24-43fc-a902-88c08e593316",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "why does it need to be a `*bool` instead of a `bool`?\n",
        "createdAt" : "2016-05-26T16:28:18Z",
        "updatedAt" : "2016-05-31T18:21:14Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a784ca6f-3b0b-4229-be30-2e32baaa10c5",
        "parentId" : "05da845b-4f24-43fc-a902-88c08e593316",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "@bgrant0607 wanted it this way.\n",
        "createdAt" : "2016-05-26T16:39:38Z",
        "updatedAt" : "2016-05-31T18:21:14Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "778b1df717215f0e0a03a83b467be7f7d0e02367",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +164,168 @@\tfor _, ref := range ownerReferences {\n\t\tallErrs = append(allErrs, validateOwnerReference(ref, fldPath)...)\n\t\tif ref.Controller != nil && *ref.Controller {\n\t\t\tif controllerName != \"\" {\n\t\t\t\tallErrs = append(allErrs, field.Invalid(fldPath, ownerReferences,"
  },
  {
    "id" : "fd267cbc-a60e-4d8f-86c1-09b23f175fe2",
    "prId" : 24977,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8996a373-6300-41cf-aa30-4f9a576031d7",
        "parentId" : null,
        "authorId" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "body" : "validate this is in form of `hostname:port` \n",
        "createdAt" : "2016-05-03T23:08:14Z",
        "updatedAt" : "2016-08-18T15:14:11Z",
        "lastEditedBy" : "a7f673a6-4b23-4df6-aa10-f123fa9dcd5f",
        "tags" : [
        ]
      }
    ],
    "commit" : "eed42380f98439c0776431bc1bd949f530099c62",
    "line" : null,
    "diffHunk" : "@@ -1,1 +743,747 @@func validateQuobyteVolumeSource(quobyte *api.QuobyteVolumeSource, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tif len(quobyte.Registry) == 0 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"registry\"), \"must be a host:port pair or multiple pairs seperated by commas\"))\n\t} else {"
  },
  {
    "id" : "f3d04415-b93e-4978-b986-cc37c00aa00c",
    "prId" : 24836,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ad61389-08f3-4543-9cc5-14b62802dc4b",
        "parentId" : null,
        "authorId" : "b9cd3bbd-5e27-418d-850f-9875159d4e01",
        "body" : "should we also add `quantity.Cmp(requrestQuantity) > 1`? Because so far we only support /dev/nvidia0\n",
        "createdAt" : "2016-05-11T07:40:07Z",
        "updatedAt" : "2016-05-11T07:40:07Z",
        "lastEditedBy" : "b9cd3bbd-5e27-418d-850f-9875159d4e01",
        "tags" : [
        ]
      },
      {
        "id" : "ea9d2c05-12a6-433f-8a98-184380f26f80",
        "parentId" : "5ad61389-08f3-4543-9cc5-14b62802dc4b",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I don't think this is necessary.  We would not, for example, validate that your ram is smaller than the largest ram machine.\n",
        "createdAt" : "2016-05-11T22:48:11Z",
        "updatedAt" : "2016-05-11T22:48:11Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "362c763fca4c7c6c148532c6f4e68422899b5297",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +2479,2483 @@\t\t\tif resourceName == api.ResourceNvidiaGPU {\n\t\t\t\tallErrs = append(allErrs, field.Invalid(reqPath, requestQuantity.String(), \"cannot be set\"))\n\t\t\t} else if quantity.Cmp(requestQuantity) < 0 {\n\t\t\t\tallErrs = append(allErrs, field.Invalid(fldPath, quantity.String(), \"must be greater than or equal to request\"))\n\t\t\t}"
  },
  {
    "id" : "1b7bf662-4b22-4678-ae4e-003e13dd5160",
    "prId" : 24179,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "341e3ea9-8bce-4944-92c0-74c033b6c4a6",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "I would just reference the constant inline instead of making it a parameter to this method.\n",
        "createdAt" : "2016-05-23T18:57:33Z",
        "updatedAt" : "2016-05-24T16:24:57Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "16ec226e-3be2-40e2-8428-80e9a3a6f774",
        "parentId" : "341e3ea9-8bce-4944-92c0-74c033b6c4a6",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "But thats how it is done for other pod level resources like metadata.name etc.\n",
        "createdAt" : "2016-05-23T19:03:20Z",
        "updatedAt" : "2016-05-24T16:24:57Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "0bd5cdc8-6cf6-486e-9a4b-2db7e7c8bad6",
        "parentId" : "341e3ea9-8bce-4944-92c0-74c033b6c4a6",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "accepted, OK to leave as is.\n",
        "createdAt" : "2016-05-23T19:22:15Z",
        "updatedAt" : "2016-05-24T16:24:57Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "1931931494518d5b60f61435a77fa39189546c00",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1123,1127 @@\t} else if len(fs.Resource) == 0 {\n\t\tallErrs = append(allErrs, field.Required(fldPath.Child(\"resource\"), \"\"))\n\t} else if !expressions.Has(fs.Resource) {\n\t\tallErrs = append(allErrs, field.NotSupported(fldPath.Child(\"resource\"), fs.Resource, expressions.List()))\n\t}"
  },
  {
    "id" : "ee42cdab-1280-4744-98fc-bde9b5e1ad46",
    "prId" : 23928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40f94ad2-a229-4bb2-bb7a-9aca6e241edd",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "we need to make sure we have a kind and name (and version, I guess)\n",
        "createdAt" : "2016-04-25T21:14:45Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "acd5ce4a-f53f-4cbe-9e98-3c76f9421a13",
        "parentId" : "40f94ad2-a229-4bb2-bb7a-9aca6e241edd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Will do.\n",
        "createdAt" : "2016-04-25T21:32:11Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "5328ff1c-5100-4890-85d2-5e49510ad4d3",
        "parentId" : "40f94ad2-a229-4bb2-bb7a-9aca6e241edd",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "who is responsible for making sure the owner reference is even a group/version/kind that exists in the system? if bogus values are given, what will the garbage collector do?\n",
        "createdAt" : "2016-04-26T04:30:58Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "b10e2915-9b94-4b89-9e80-22bf6b33b64d",
        "parentId" : "40f94ad2-a229-4bb2-bb7a-9aca6e241edd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "I plan to let the garbage collector to compare the reference with the discovery results, and ignore the reference if the resource doesn't exist in the system.\n",
        "createdAt" : "2016-04-26T04:35:16Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "ff2c12de-abd4-4c9a-97e2-99b944454212",
        "parentId" : "40f94ad2-a229-4bb2-bb7a-9aca6e241edd",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Bogus values should be the same as the owner having been deleted, IMO.\n",
        "createdAt" : "2016-04-26T16:54:47Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8ea9f120-2431-4e2a-898e-eae35f74207d",
        "parentId" : "40f94ad2-a229-4bb2-bb7a-9aca6e241edd",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "In offline chat with lavalamp, we decided that **GC should ignore bogus ownerReference**, because in the following two situations, we don't want GC to delete an object: 1. the cluster stops supporting an old version of a resource, we don't want GC to delete objects that have ownerReferences pointing to an object of the old version. 2. if user accidentally misspell an ownerReference, we don't want GC to delete the object.\n",
        "createdAt" : "2016-04-26T18:39:34Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "4562a26d3449eec8481214d198e904a3883d5c5f",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +155,159 @@func validateOwnerReference(ownerReference api.OwnerReference, fldPath *field.Path) field.ErrorList {\n\tallErrs := field.ErrorList{}\n\tgvk := unversioned.FromAPIVersionAndKind(ownerReference.APIVersion, ownerReference.Kind)\n\t// gvk.Group is empty for the legacy group.\n\tif len(gvk.Version) == 0 {"
  },
  {
    "id" : "c4bf740c-1f33-4e94-abb8-5664b771ae82",
    "prId" : 23928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "A TODO might be helpful here... I wouldn't expect this to be immutable once we figure out the update/authorization approach. In particular, we'd likely want to be able to update to set a uid of a parent (if it isn't known at create time), or to add a new owner reference (in case we're using this for rotation scenarios)\n",
        "createdAt" : "2016-04-25T21:17:03Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7357995a-84c1-4c3c-bca3-a3a794e71149",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "It's validating finalizers cannot be updated, not ownerReferences.\n\nIIRC, in last sig meeting we were discussing making finalizers a subresource, so that we can enforce difference admission policy for /mainResource/finalizers and /mainResource.\n",
        "createdAt" : "2016-04-25T21:31:15Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "04342236-d2a2-4632-9e8f-0bb3ac18f180",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "ah, misread. in that case, I'd expect owner references to not be updateable until we figure out the update/authorization approach.\n",
        "createdAt" : "2016-04-26T04:34:16Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "698b5fb9-4ca3-4358-999c-8e02fee92696",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "IMO we don't need to treat ownerReferences specially. If a user has the right to update an object, he can corrupt the object in various ways, which aren't any better than getting the object deleted by the GC.\n",
        "createdAt" : "2016-04-26T21:23:52Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "92109b6a-ab6e-4258-9b74-e71fcbfb1b66",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "corruption != deletion, especially when the system will cascade deletion across multiple objects.\n",
        "createdAt" : "2016-04-26T21:29:58Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3401eefd-13b4-41df-93d9-0d36acd10890",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "For example, there's no real way to corrupt a namespace resource. I would be shocked to give someone update access in order to label a namespace and find that they could effectively delete it and all the resources contained in it. \n",
        "createdAt" : "2016-04-26T21:37:49Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6abfb593-6425-4107-b97a-624d02f0198c",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@liggitt prepare to be shocked: you can set deletionTimestamp with an update, and the namespace is then deleted by the namespace controller. I hope you're not relying on that behavior.\n",
        "createdAt" : "2016-04-26T21:56:32Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "824058d6-4e2f-49f6-a664-c1e3809270cb",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "And I don't think that should be fixed by adding validation. I think if you want to allow targeted actions like label editing, you need a special subresource or some such that permits only that.\n\n(Don't construe that as me agreeing that label editing is generally safe, I don't agree with that!)\n",
        "createdAt" : "2016-04-26T21:59:47Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "58c0ca67-e419-43b3-83f3-44823b816d05",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "The cascading escalation surface area is significant.  The power to update foo gives me the power to delete not only foo, but I'm escalated to delete everything depending on foo.\n\nI don't think most people expect that as a side effect of update powers.\n\nAlso, the fact that the API behaves in a way that defies @liggitt's expectation may be an indication that it isn't obeying the principle of least surprise.\n",
        "createdAt" : "2016-04-26T22:06:18Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "63b60529-c279-493a-9980-940da0082f4b",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think we have a fundamental disagreement about the power rating of update and delete. I think that update is strictly more powerful than delete, and therefore it's not surprising at all that update permission allows deletes; you guys seem to think the opposite? Is there prior art here? I'm not sure how you're going to convince me that power to update should not include power to delete.\n\nCascading deletions could be an issue only if the attacker also could add references willy-nilly. But that means the attacker already had control over those resources in the first place.\n",
        "createdAt" : "2016-04-26T22:11:43Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "3e51ed94-df43-4fdc-9b78-76bfe469ad0d",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Filed #24828\n",
        "createdAt" : "2016-04-26T22:28:43Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8ed5f962-ec09-4bc0-93f4-ea2072d5ff49",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I think that update is strictly more powerful than delete, and therefore it's not surprising at all that update permission allows deletes; you guys seem to think the opposite? Is there prior art here? I'm not sure how you're going to convince me that power to update should not include power to delete.\n\nI see the different permissions as different without a clear covers relationship amongst all of them.  Bearing in mind that our current API objects only represent a few enumerated cases, not the full set of all possible ones I see this:\n1. List - covers Watch (repeated List) and Get.\n2. Create - does not cover anything.  The power to create implies the power to set any \"set-once\" fields that are immutable after creation.  It also results in quota charges.\n3. Patch - does not cover anything.  The power to Patch does not imply the power to Create (patch can't change immutable fields and can't charge quota).  The power to Patch does not imply the power to Get (patch can blindly set fields, `kubectl annotate` as a for instance.)\n4. Delete - does not cover anything.  The power to Delete doesn't imply that you Get (or List or Watch) the thing you're deleting (maybe its a timed-based secret deletion taking a batch list and shouldn't ever be allowed to see a secret).  It doesn't imply Create (can't set immutable fields) or Patch or Update (can't change the meaning of the resource.)\n5. Update - covers Get (not List or Watch) and Patch.  Update is per-item and requires a resourceVersion, so to make use of Update, you had the original object at some point in time.  Update does not cover Create because it can't set immutable fields or charge quota.  Update does not cover Delete since it doesn't replenish quota and (given immutable fields) doesn't necessarily imply the power to destroy data.\n",
        "createdAt" : "2016-04-26T23:28:51Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "6bdf1b8e-1843-4d6f-84a1-7ebd003d7204",
        "parentId" : "3d0dc8b3-8bda-4a0c-888d-c5f3b865b85a",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I agree with @deads2k @liggitt , the ability to set `DeletionTimestamp` on a Namespace UPDATE is a bug inconsistent with original design.\n",
        "createdAt" : "2016-04-27T15:08:29Z",
        "updatedAt" : "2016-05-05T04:55:07Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "4562a26d3449eec8481214d198e904a3883d5c5f",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +415,419 @@\tallErrs = append(allErrs, ValidateImmutableField(newMeta.UID, oldMeta.UID, fldPath.Child(\"uid\"))...)\n\tallErrs = append(allErrs, ValidateImmutableField(newMeta.CreationTimestamp, oldMeta.CreationTimestamp, fldPath.Child(\"creationTimestamp\"))...)\n\tallErrs = append(allErrs, ValidateImmutableField(newMeta.Finalizers, oldMeta.Finalizers, fldPath.Child(\"finalizers\"))...)\n\n\tallErrs = append(allErrs, ValidateLabels(newMeta.Labels, fldPath.Child(\"labels\"))...)"
  },
  {
    "id" : "09f5da3b-8f46-4561-af6a-a85eae6fd398",
    "prId" : 23567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6791c7bb-3255-4012-acb3-df94bec6f9ca",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "also stdin, tty, stdinonce? though I suppose it would be nice to have a -it that dropped you into an init container so you can eg: write out nginx.conf before nginx starts\n",
        "createdAt" : "2016-04-08T20:41:06Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "64da0ff1-dad8-455b-bf69-19523d18a528",
        "parentId" : "6791c7bb-3255-4012-acb3-df94bec6f9ca",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Originally was going to remove, decided that we could tolerate them being\nattachable.\n\nOn Fri, Apr 8, 2016 at 4:41 PM, Prashanth B notifications@github.com\nwrote:\n\n> In pkg/api/validation/validation.go\n> https://github.com/kubernetes/kubernetes/pull/23567#discussion_r59086228\n> :\n> \n> > -   for i, ctr := range containers {\n> > -       idxPath := fldPath.Index(i)\n> > -       if allNames.Has(ctr.Name) {\n> > -           allErrs = append(allErrs, field.Duplicate(idxPath.Child(\"name\"), ctr.Name))\n> > -       }\n> > -       if len(ctr.Name) > 0 {\n> > -           allNames.Insert(ctr.Name)\n> > -       }\n> > -       if ctr.Lifecycle != nil {\n> > -           allErrs = append(allErrs, field.Invalid(idxPath.Child(\"lifecycle\"), ctr.Lifecycle, \"must not be set for init containers\"))\n> > -       }\n> > -       if ctr.LivenessProbe != nil {\n> > -           allErrs = append(allErrs, field.Invalid(idxPath.Child(\"livenessProbe\"), ctr.LivenessProbe, \"must not be set for init containers\"))\n> > -       }\n> > -       if ctr.ReadinessProbe != nil {\n> > -           allErrs = append(allErrs, field.Invalid(idxPath.Child(\"readinessProbe\"), ctr.ReadinessProbe, \"must not be set for init containers\"))\n> \n> also stdin, tty, stdinonce? though I suppose it would be nice to have a\n> -it that dropped you into an init container so you can eg: write out\n> nginx.conf before nginx starts\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23567/files/53b5dd4d022c2b97f02e40d07c81600fc249b5ae..c75dc6a7e701f3e4484e6545658cf85711a2d6d7#r59086228\n",
        "createdAt" : "2016-04-13T00:45:38Z",
        "updatedAt" : "2016-05-17T04:30:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a53330700ac39ee61109c748fe665cf38581a5d",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +1352,1356 @@\t\t}\n\t\tif ctr.ReadinessProbe != nil {\n\t\t\tallErrs = append(allErrs, field.Invalid(idxPath.Child(\"readinessProbe\"), ctr.ReadinessProbe, \"must not be set for init containers\"))\n\t\t}\n\t}"
  },
  {
    "id" : "4e02001b-446e-4e9d-a9b7-85b32fccb1a4",
    "prId" : 22766,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f976a12-6886-4ec2-b0ba-3f71245bd3ab",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "use strings.Contains?\n",
        "createdAt" : "2016-03-10T16:39:23Z",
        "updatedAt" : "2016-03-10T16:39:23Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "3d5ea73b-fc7b-492f-8698-8997f20fca9a",
        "parentId" : "1f976a12-6886-4ec2-b0ba-3f71245bd3ab",
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Or do you really want exactly 1 slash?\n",
        "createdAt" : "2016-03-10T16:39:46Z",
        "updatedAt" : "2016-03-10T16:39:46Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "1e34937e-5abe-4236-aadf-9ea94d4d9955",
        "parentId" : "1f976a12-6886-4ec2-b0ba-3f71245bd3ab",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "It seems that in the function IsQualifiedName and also as per this document:\nhttps://github.com/kubernetes/kubernetes/blob/master/docs/design/resources.md \nonly one slash is expected to be a qualified name.\n",
        "createdAt" : "2016-03-10T16:46:43Z",
        "updatedAt" : "2016-03-10T16:46:43Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "b47062a8-a7e0-4962-8100-127b54101d8e",
        "parentId" : "1f976a12-6886-4ec2-b0ba-3f71245bd3ab",
        "authorId" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "body" : "With more than one slash, IsQualifiedName fails.\n",
        "createdAt" : "2016-03-10T16:47:38Z",
        "updatedAt" : "2016-03-10T16:47:38Z",
        "lastEditedBy" : "6252ac4b-6b9e-4dee-8931-ca3b934d52fc",
        "tags" : [
        ]
      },
      {
        "id" : "020d31ed-5ac1-46f0-8e18-d39ce6dac6ac",
        "parentId" : "1f976a12-6886-4ec2-b0ba-3f71245bd3ab",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "yes, i am biased to stay consistent, so this lgtm.\n",
        "createdAt" : "2016-03-10T19:52:52Z",
        "updatedAt" : "2016-03-10T19:52:52Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "427774306cfffc816b8ff9eebbd79142f5c3e55f",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +2042,2046 @@\t}\n\n\tif len(strings.Split(value, \"/\")) == 1 {\n\t\tif !api.IsStandardLimitRangeType(value) {\n\t\t\treturn append(allErrs, field.Invalid(fldPath, value, \"must be a standard limit type or fully qualified\"))"
  },
  {
    "id" : "fd85082c-f212-4d9a-87ac-dc4b51e8c07e",
    "prId" : 20688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9dfa37a-77b1-4856-a1d9-a321671bc9da",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Also need validation for the endpoints annotation\n",
        "createdAt" : "2016-03-02T01:44:18Z",
        "updatedAt" : "2016-03-04T21:32:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3c00aadd5da91288cca856dabbefbc9f261be69",
    "line" : null,
    "diffHunk" : "@@ -1,1 +133,137 @@\n\treturn allErrs\n}\n\nfunc ValidateEndpointsSpecificAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {"
  },
  {
    "id" : "f0e16374-8da4-47c5-9e40-274f022647e5",
    "prId" : 20688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c80e7f1b-2085-4132-a53e-f8ea27d6ab52",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "What is going on here - do you have a different version of goimports or something?\n",
        "createdAt" : "2016-03-03T05:13:39Z",
        "updatedAt" : "2016-03-04T21:32:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5df8a9de-b8c8-4ef6-a6d9-4785149fe656",
        "parentId" : "c80e7f1b-2085-4132-a53e-f8ea27d6ab52",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "fixed it..(not pushed)\n",
        "createdAt" : "2016-03-03T22:20:13Z",
        "updatedAt" : "2016-03-04T21:32:45Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3c00aadd5da91288cca856dabbefbc9f261be69",
    "line" : null,
    "diffHunk" : "@@ -1,1 +20,24 @@\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"os\""
  },
  {
    "id" : "74a39ea7-0b31-46bd-8405-0ece85a924d9",
    "prId" : 20688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b2d43d02-7a0a-4e83-a139-bb88651b1fd5",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "don't you need to call this from ValidatePod(), too ?\n",
        "createdAt" : "2016-03-04T20:18:59Z",
        "updatedAt" : "2016-03-04T21:32:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "02bad75b-d423-45fe-839b-97cd63937763",
        "parentId" : "b2d43d02-7a0a-4e83-a139-bb88651b1fd5",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "I had fixed this already. Can you take a look at the push I did 10 seconds\nago ?\n\nOn Fri, Mar 4, 2016 at 12:19 PM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/api/validation/validation.go\n> https://github.com/kubernetes/kubernetes/pull/20688#discussion_r55083329\n> :\n> \n> > @@ -1875,6 +1900,7 @@ func ValidatePodTemplateSpec(spec *api.PodTemplateSpec, fldPath *field.Path) fie\n> >     allErrs := field.ErrorList{}\n> >     allErrs = append(allErrs, ValidateLabels(spec.Labels, fldPath.Child(\"labels\"))...)\n> >     allErrs = append(allErrs, ValidateAnnotations(spec.Annotations, fldPath.Child(\"annotations\"))...)\n> > -   allErrs = append(allErrs, ValidatePodSpecificAnnotations(spec.Annotations, fldPath.Child(\"annotations\"))...)\n> \n> don't you need to call this from ValidatePod(), too ?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20688/files#r55083329.\n",
        "createdAt" : "2016-03-04T20:20:02Z",
        "updatedAt" : "2016-03-04T21:32:45Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      },
      {
        "id" : "905de0a3-7320-40e4-a3d8-71985c473f99",
        "parentId" : "b2d43d02-7a0a-4e83-a139-bb88651b1fd5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "LG\n",
        "createdAt" : "2016-03-04T20:23:05Z",
        "updatedAt" : "2016-03-04T21:32:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3c00aadd5da91288cca856dabbefbc9f261be69",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +1913,1917 @@\tallErrs = append(allErrs, ValidateLabels(spec.Labels, fldPath.Child(\"labels\"))...)\n\tallErrs = append(allErrs, ValidateAnnotations(spec.Annotations, fldPath.Child(\"annotations\"))...)\n\tallErrs = append(allErrs, ValidatePodSpecificAnnotations(spec.Annotations, fldPath.Child(\"annotations\"))...)\n\tallErrs = append(allErrs, ValidatePodSpec(&spec.Spec, fldPath.Child(\"spec\"))...)\n\treturn allErrs"
  },
  {
    "id" : "05e90f10-48ba-4819-bb05-fea2ad7cecb4",
    "prId" : 19909,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "do we limit number of keys?  what if they send us 10k keys?\n",
        "createdAt" : "2016-01-21T06:26:09Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "19ffab98-aee4-4dd7-9876-61b54049a592",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "this applies to anything we key in this way\n",
        "createdAt" : "2016-01-21T06:26:24Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "55672ad0-e612-46d6-99ca-e8385931f73b",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin We do, the max length is 253 and there's a unit test for it.\n",
        "createdAt" : "2016-01-21T19:38:41Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "03408012-3a4a-483f-98db-4e5f716bbdad",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin Sorry, answered the wrong question  -- number of keys isn't covered.  The same issue exists for secrets -- can I do them both in a follow-up?\n",
        "createdAt" : "2016-01-21T19:48:09Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "9b1c8c2a-4556-4cf5-87fb-07551520fb84",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin I'm wondering if we need to count the size as keys and data, since the size limit of 1MB comes in part from the limit of what is recommended to go into an etcd record.\n\ncc @smarterclayton \n",
        "createdAt" : "2016-01-21T19:55:22Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "ed0e59e7-3050-483a-8a51-a4398d9d3dc5",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We should count both keys and data towards the total, yes.\n\nOn Thu, Jan 21, 2016 at 2:55 PM, Paul Morie notifications@github.com\nwrote:\n\n> In pkg/api/validation/validation.go\n> https://github.com/kubernetes/kubernetes/pull/19909#discussion_r50453918\n> :\n> \n> > +func ValidateConfigMapName(name string, prefix bool) (bool, string) {\n> > -   return NameIsDNSSubdomain(name, prefix)\n> >   +}\n> >   +\n> >   +// ValidateConfigMap tests whether required fields in the ConfigMap are set.\n> >   +func ValidateConfigMap(cfg *api.ConfigMap) field.ErrorList {\n> > -   allErrs := field.ErrorList{}\n> > -   allErrs = append(allErrs, ValidateObjectMeta(&cfg.ObjectMeta, true, ValidateConfigMapName, field.NewPath(\"metadata\"))...)\n> >   +\n> > -   totalSize := 0\n> >   +\n> > -   for key, value := range cfg.Data {\n> > -       if !IsSecretKey(key) {\n> > -           allErrs = append(allErrs, field.Invalid(field.NewPath(\"data\").Key(key), key, fmt.Sprintf(\"must have at most %d characters and match regex %s\", validation.DNS1123SubdomainMaxLength, SecretKeyFmt)))\n> > -       }\n> > -       totalSize += len(value)\n> \n> @thockin https://github.com/thockin I'm wondering if we need to count\n> the size as keys and data, since the size limit of 1MB comes in part from\n> the limit of what is recommended to go into an etcd record.\n> \n> cc @smarterclayton https://github.com/smarterclayton\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/19909/files#r50453918.\n",
        "createdAt" : "2016-01-21T19:58:24Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "721bbce6-2362-45fe-9536-75c3d6627c87",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We can count keys + data, but that alone is insufficient to not bump our heads on etcd.  The rest of the object's JSON has some size, too.  And maybe one day etcd will grow limits.\n\nI think it's best to say \"max 1000 keys, max key size is 256B. max total size of keys and data is 1MB\"\n",
        "createdAt" : "2016-01-22T00:48:35Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "0f7d203c-c04d-4140-8ff8-4ed08ece1e0b",
        "parentId" : "1e258ec0-3586-40df-81cf-8fa901893040",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'm OK with a followup.  #19969 at you\n",
        "createdAt" : "2016-01-22T00:53:16Z",
        "updatedAt" : "2016-01-29T05:22:32Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "defd1d05440e81b06e51803d1f846400ae458cf3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2006,2010 @@\t\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"data\").Key(key), key, fmt.Sprintf(\"must have at most %d characters and match regex %s\", validation.DNS1123SubdomainMaxLength, SecretKeyFmt)))\n\t\t}\n\t\ttotalSize += len(value)\n\t}\n\tif totalSize > api.MaxSecretSize {"
  },
  {
    "id" : "a60fd1cf-1dc6-477b-bb58-c519c9d32d82",
    "prId" : 19758,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f722f00a-d067-4f40-9ae2-0d6f1dd29fb9",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "is there a difference between this and `if annotations[api.AffinityAnnotationKey] > 0` ?\nIs one better than the other?\n",
        "createdAt" : "2016-01-30T07:29:09Z",
        "updatedAt" : "2016-02-04T01:53:44Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "0a2b9171-45d1-4980-b3eb-be483d61fb99",
        "parentId" : "f722f00a-d067-4f40-9ae2-0d6f1dd29fb9",
        "authorId" : "70ba63ce-18c5-43f6-a9fb-1acd33329390",
        "body" : "Do you mean `if len(annotations[api.AffinityAnnotationKey]) > 0`?\nI guess there's no difference, just in different way.\n",
        "createdAt" : "2016-01-30T08:07:23Z",
        "updatedAt" : "2016-02-04T01:53:44Z",
        "lastEditedBy" : "70ba63ce-18c5-43f6-a9fb-1acd33329390",
        "tags" : [
        ]
      },
      {
        "id" : "a721f495-1dfc-401c-896d-dd7c8a9f3a40",
        "parentId" : "f722f00a-d067-4f40-9ae2-0d6f1dd29fb9",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Yeah, but never mind, what you have is fine (and I see you did it the same way in GetAffinityFromPodAnnotations()). So no need to change anything.\n",
        "createdAt" : "2016-01-30T08:12:56Z",
        "updatedAt" : "2016-02-04T01:53:44Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "c8c82c1d8f8e143f9b571a731d7ff11d5101de20",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +99,103 @@\t}\n\n\tif annotations[api.AffinityAnnotationKey] != \"\" {\n\t\tallErrs = append(allErrs, ValidateAffinityInPodAnnotations(annotations, fldPath)...)\n\t}"
  },
  {
    "id" : "8a5fdfd6-3721-42f0-ae0f-1278c4e1415f",
    "prId" : 19716,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ebcc6c64-a01a-4bd3-976f-993e5f16423c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Should we fold in the size-checking into this PR or followup?\n",
        "createdAt" : "2016-01-21T17:05:50Z",
        "updatedAt" : "2016-01-28T22:17:38Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "020ea9c6-5589-48ba-b0bb-6eb6469538fa",
        "parentId" : "ebcc6c64-a01a-4bd3-976f-993e5f16423c",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Follow-up, this is enough on its own.\n",
        "createdAt" : "2016-01-21T21:43:22Z",
        "updatedAt" : "2016-01-28T22:17:38Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2d1a20178329355c81a1e9c04c5f1715eb32f65",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +2004,2008 @@\t\t\tallErrs = append(allErrs, field.Invalid(field.NewPath(\"data\").Key(key), key, fmt.Sprintf(\"must have at most %d characters and match regex %s\", validation.DNS1123SubdomainMaxLength, SecretKeyFmt)))\n\t\t}\n\t}\n\n\treturn allErrs"
  },
  {
    "id" : "21cf237f-74c4-492c-be4a-993822a8a745",
    "prId" : 15850,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16ac2666-7d2d-4ed6-8c34-22ebd094ca4d",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Since this can only return a single error, please have it just return `error` not `errs.ValidationErrorList`\n",
        "createdAt" : "2015-10-20T17:26:22Z",
        "updatedAt" : "2015-10-23T06:28:28Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "b1ca31db-6722-4cdd-afd7-a9613c606f95",
        "parentId" : "16ac2666-7d2d-4ed6-8c34-22ebd094ca4d",
        "authorId" : "fa03ed6a-9d2a-44b6-8438-e21ee4a2ce4d",
        "body" : "@brendandburns \nFrom my perspective, returning `errs.ValidationErrorList` is a better choice, just as `ValidatePositiveField` and `ValidatePositiveQuantity` do. Those three validation functions can indeed only return a single error, but there are lots of other validation functions such as `ValidateLabelName` will return a list of error, keep all validation functions consistently return `errs.ValidationErrorList｀could make all invocation statements consistent.\n",
        "createdAt" : "2015-10-21T03:33:55Z",
        "updatedAt" : "2015-10-23T06:28:28Z",
        "lastEditedBy" : "fa03ed6a-9d2a-44b6-8438-e21ee4a2ce4d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce384e62edd58bb8bbcddea76cd647ae91f7fe32",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +236,240 @@}\n\nfunc ValidateImmutableField(old, new interface{}, fieldName string) errs.ValidationErrorList {\n\tallErrs := errs.ValidationErrorList{}\n\tif !api.Semantic.DeepEqual(old, new) {"
  },
  {
    "id" : "b15bc247-df45-43f2-a8c1-ed61e07b666a",
    "prId" : 15533,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b52c364-cfae-4600-a017-8af86be52367",
        "parentId" : null,
        "authorId" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "body" : "Can this be rolled into the previous check for \"..\"?  One check for the same thing should be sufficient.\n",
        "createdAt" : "2015-10-27T13:32:08Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "727fc82d-d969-41a4-a614-7fefce94f9a6",
        "tags" : [
        ]
      }
    ],
    "commit" : "70a9c0bf56c5efd20c7e3d623cd236f08cfd72f8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +443,447 @@\tif len(gitRepo.Repository) == 0 {\n\t\tallErrs = append(allErrs, validation.NewRequiredError(\"repository\"))\n\t}\n\n\tpathErrs := validateVolumeSourcePath(gitRepo.Directory, \"directory\")"
  },
  {
    "id" : "21d4e3b7-6ba6-41ed-a57b-e142ff359782",
    "prId" : 15533,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dddee2a0-c4cd-47dd-8e69-7932e4f4478e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Do we want os-varient things used in API validation?\n",
        "createdAt" : "2015-11-28T02:32:07Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "63493839-2766-43b0-8736-3f60c31d794e",
        "parentId" : "dddee2a0-c4cd-47dd-8e69-7932e4f4478e",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "But it's validating a path on the server, which is os-varient I think.\n",
        "createdAt" : "2015-11-28T03:14:46Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      },
      {
        "id" : "051e843c-a338-4fa4-97da-22113665c6ed",
        "parentId" : "dddee2a0-c4cd-47dd-8e69-7932e4f4478e",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "The API validation shouldn't depend on which OS the API is running on, especially since the node's OS is the one that would be affected by this path\n",
        "createdAt" : "2015-11-28T03:18:35Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3166df62-5e93-4523-a7c5-885e385283a2",
        "parentId" : "dddee2a0-c4cd-47dd-8e69-7932e4f4478e",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "Yeah, I can see we should use the real `os.PathSeparator` here, but may I leave it to another issue? Maybe a TODO here?\n",
        "createdAt" : "2015-11-28T03:50:22Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "70a9c0bf56c5efd20c7e3d623cd236f08cfd72f8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +590,594 @@\t}\n\t// TODO assume OS of api server & nodes are the same for now\n\titems := strings.Split(targetPath, string(os.PathSeparator))\n\n\tfor _, item := range items {"
  },
  {
    "id" : "ab2ab7e4-4bb2-450f-9717-fa056f552d20",
    "prId" : 15533,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e608cf61-166b-40aa-ad73-5a331cb2889e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Why no \"..\" prefix?\n",
        "createdAt" : "2015-11-28T02:34:08Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6b4e5dc9-253d-4128-9905-b7ea2dac0c17",
        "parentId" : "e608cf61-166b-40aa-ad73-5a331cb2889e",
        "authorId" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "body" : "It's required by downward api, so I followed this 'rule', does that make sense? Or should be removed?\n",
        "createdAt" : "2015-11-28T03:10:01Z",
        "updatedAt" : "2015-12-01T16:21:11Z",
        "lastEditedBy" : "7dd504ec-7e63-45b3-98f8-6eb1c683e9c2",
        "tags" : [
        ]
      }
    ],
    "commit" : "70a9c0bf56c5efd20c7e3d623cd236f08cfd72f8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +597,601 @@\t\t}\n\t}\n\tif strings.HasPrefix(items[0], \"..\") && len(items[0]) > 2 {\n\t\tallErrs = append(allErrs, validation.NewInvalidError(field, targetPath, \"must not start with \\\"..\\\"\"))\n\t}"
  },
  {
    "id" : "a95b74a6-17be-4736-805b-b53ac1549d02",
    "prId" : 15491,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c99fba4-f0e7-4808-a24b-acd304f5e3d1",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "s/ip IP/\n",
        "createdAt" : "2015-10-14T22:18:12Z",
        "updatedAt" : "2015-10-14T22:18:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "eae56c3b2d0b90c7a3b3bf91f693a6a4573f1257",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +2010,2014 @@\t\t\t}\n\t\t\tif isIP := (net.ParseIP(ingress.Hostname) != nil); isIP {\n\t\t\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"ingress.hostname\", ingress.Hostname, \"must be a DNS name, not ip address\"))\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "b15fab8f-e811-4643-994a-bd4bcd16442f",
    "prId" : 15191,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "931f7e56-480b-4532-9fd4-f90179c69ca2",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@lavalamp comments added. And I increase the scope of the `if` to enclose other code that repairs the update request.\n",
        "createdAt" : "2015-10-13T21:35:57Z",
        "updatedAt" : "2015-10-13T23:29:58Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "7c20f5c0-bf53-43ff-9d33-32a71b0db00b",
        "parentId" : "931f7e56-480b-4532-9fd4-f90179c69ca2",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Huh, I didn't realize deletion time stamp did the same thing.\n",
        "createdAt" : "2015-10-13T21:56:22Z",
        "updatedAt" : "2015-10-13T23:29:58Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "be0754750f7dac811bc8375714a043deae6709c0",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +284,288 @@\t// in the event it is left empty, set it, to allow clients more flexibility\n\t// TODO: remove the following code that repairs the update request when we retire the clients that modify the immutable fields.\n\t// Please do not copy this pattern elsewhere; validation functions should not be modifying the objects they are passed!\n\tif RepairMalformedUpdates {\n\t\tif len(new.UID) == 0 {"
  },
  {
    "id" : "178dfcc1-7823-47f7-8897-f511c97e1e59",
    "prId" : 15191,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c96bbea4-b1e8-41ed-83f8-c88da70d3788",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This check seems wrong. (what if new is nil but not old?) Can you file an issue?\n",
        "createdAt" : "2015-10-13T21:58:49Z",
        "updatedAt" : "2015-10-13T23:29:58Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8f7adff6-5e6b-4bcc-adb9-7eff683c58cc",
        "parentId" : "c96bbea4-b1e8-41ed-83f8-c88da70d3788",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "that's handled by the repair in above. I'll leave a comment here so we don't forget when we delete the repair.\n",
        "createdAt" : "2015-10-13T23:24:43Z",
        "updatedAt" : "2015-10-13T23:29:58Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "be0754750f7dac811bc8375714a043deae6709c0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +305,309 @@\n\t// TODO: needs to check if new==nil && old !=nil after the repair logic is removed.\n\tif new.DeletionGracePeriodSeconds != nil && old.DeletionGracePeriodSeconds != nil && *new.DeletionGracePeriodSeconds != *old.DeletionGracePeriodSeconds {\n\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"deletionGracePeriodSeconds\", new.DeletionGracePeriodSeconds, \"field is immutable; may only be changed via deletion\"))\n\t}"
  },
  {
    "id" : "66de4b25-7f3c-4166-8374-68344ed62f42",
    "prId" : 15191,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a830dea0-39d2-47a0-9e7c-d1ad418664c4",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "added a todo here\n",
        "createdAt" : "2015-10-13T23:31:05Z",
        "updatedAt" : "2015-10-13T23:31:05Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "be0754750f7dac811bc8375714a043deae6709c0",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +304,308 @@\t}\n\n\t// TODO: needs to check if new==nil && old !=nil after the repair logic is removed.\n\tif new.DeletionGracePeriodSeconds != nil && old.DeletionGracePeriodSeconds != nil && *new.DeletionGracePeriodSeconds != *old.DeletionGracePeriodSeconds {\n\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"deletionGracePeriodSeconds\", new.DeletionGracePeriodSeconds, \"field is immutable; may only be changed via deletion\"))"
  },
  {
    "id" : "4ff96903-81c3-4abe-b041-0b733ca99a64",
    "prId" : 13853,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5836d087-a0cd-4ce4-b4ef-dd3744d31bc6",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "If Kubernetes itself is not consuming these secret types in any way, then we shouldn't validate them in the apiserver.\n",
        "createdAt" : "2015-10-19T19:57:47Z",
        "updatedAt" : "2016-01-26T13:34:47Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ed04e4b8-1ac7-409a-b0c9-9c911e2aabfb",
        "parentId" : "5836d087-a0cd-4ce4-b4ef-dd3744d31bc6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "For ssh-privatekey, \"privatekey\" is a common identifier used by SSH config,\nthat's the only reason.\n\nOn Mon, Oct 19, 2015 at 3:58 PM, Brian Grant notifications@github.com\nwrote:\n\n> In pkg/api/validation/validation.go\n> https://github.com/kubernetes/kubernetes/pull/13853#discussion_r42417980\n> :\n> \n> > @@ -1603,6 +1603,21 @@ func ValidateSecret(secret *api.Secret) errs.ValidationErrorList {\n> >         if err := json.Unmarshal(dockercfgBytes, &map[string]interface{}{}); err != nil {\n> >             allErrs = append(allErrs, errs.NewFieldInvalid(fmt.Sprintf(\"data[%s]\", api.DockerConfigKey), \"<secret contents redacted>\", err.Error()))\n> >         }\n> > -   case api.SecretTypeBasicAuth:\n> \n> If Kubernetes itself is not consuming these secret types in any way, then\n> we shouldn't validate them in the apiserver.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13853/files#r42417980.\n",
        "createdAt" : "2015-10-19T20:08:40Z",
        "updatedAt" : "2016-01-26T13:34:47Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "5927ad81be974384c4b2313970b11bad18b86765",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1951,1955 @@\t\t\tallErrs = append(allErrs, field.Invalid(dataPath.Key(api.DockerConfigJsonKey), \"<secret contents redacted>\", err.Error()))\n\t\t}\n\tcase api.SecretTypeBasicAuth:\n\t\t_, usernameFieldExists := secret.Data[api.BasicAuthUsernameKey]\n\t\t_, passwordFieldExists := secret.Data[api.BasicAuthPasswordKey]"
  },
  {
    "id" : "e94ca595-eeea-4cc5-b53e-90dc4a22d317",
    "prId" : 13688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "799852e1-a275-427c-8006-fe5f0577054a",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "nit: consider making a named map type\n",
        "createdAt" : "2015-09-09T18:37:31Z",
        "updatedAt" : "2015-09-09T19:52:51Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea919f6d1e716a350d8db9530193574a05370aa6",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1443,1447 @@\n\t\tkeys := util.StringSet{}\n\t\tmin := map[string]resource.Quantity{}\n\t\tmax := map[string]resource.Quantity{}\n\t\tdefaults := map[string]resource.Quantity{}"
  },
  {
    "id" : "fb18726d-5457-43a8-9d69-0da47ae868d4",
    "prId" : 12599,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "328d64ad-0bfc-4698-a639-515fdcf6e1df",
        "parentId" : null,
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "nit: Could collapse the `else if` into one line. But no big deal\n",
        "createdAt" : "2015-09-18T23:30:38Z",
        "updatedAt" : "2015-09-18T23:30:38Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed9a1bbd3a9b689f4953deb6308d631314edf3f4",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +447,451 @@\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"lun\"))\n\t} else {\n\t\tif *fc.Lun < 0 || *fc.Lun > 255 {\n\t\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"lun\", fc.Lun, \"\"))\n\t\t}"
  },
  {
    "id" : "bf1ab27c-a501-47a4-a9aa-c9a00c9835bc",
    "prId" : 12035,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9786f9d-34a5-4b6a-9431-3a4a43788833",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "limits is a map, not an array/list, so it would be resources.limits.%s.\n",
        "createdAt" : "2015-08-06T00:08:27Z",
        "updatedAt" : "2015-08-06T02:02:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "b923b599-d184-4bf1-ab1b-5fd41eb1c1e4",
        "parentId" : "d9786f9d-34a5-4b6a-9431-3a4a43788833",
        "authorId" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "body" : "Maybe this should be a separate PR, because we use map[%s] instead of map.%s across validation/validation.go (for annotations, for limits in other places, for secret data, etc). I'm not changing this otherwise the formatting will be inconsistent with the rest of the file. But if you think I should change it in these 2 instances, I will! :)\n",
        "createdAt" : "2015-08-06T01:42:15Z",
        "updatedAt" : "2015-08-06T02:02:38Z",
        "lastEditedBy" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef1e576810e0a7d4173a152183c6be5239f2e757",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1507,1511 @@\t\t\t}\n\t\t\tif limitValue < requestValue {\n\t\t\t\tallErrs = append(allErrs, errs.NewFieldInvalid(fmt.Sprintf(\"resources.limits[%s]\", resourceName), quantity.String(), \"limit cannot be smaller than request\"))\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "08f7c86b-33be-4128-b8b2-2e258405d4d2",
    "prId" : 12035,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2378307-4c62-415b-9b8f-fa7bc05710e7",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "limits is a map, not an array/list, so it would be resources.limits.%s.\n",
        "createdAt" : "2015-08-06T00:08:44Z",
        "updatedAt" : "2015-08-06T02:02:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "368dd782-11da-4f95-bc55-28154caeedf5",
        "parentId" : "d2378307-4c62-415b-9b8f-fa7bc05710e7",
        "authorId" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "body" : "As above!\n",
        "createdAt" : "2015-08-06T01:42:24Z",
        "updatedAt" : "2015-08-06T02:02:38Z",
        "lastEditedBy" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "tags" : [
        ]
      },
      {
        "id" : "3f99042f-1ac4-467c-a219-9163ad8a3f53",
        "parentId" : "d2378307-4c62-415b-9b8f-fa7bc05710e7",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : ":-(. Consistency is more important than correctness. I'll make a note of this elsewhere.\n",
        "createdAt" : "2015-08-06T01:58:28Z",
        "updatedAt" : "2015-08-06T02:02:38Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "ef1e576810e0a7d4173a152183c6be5239f2e757",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1491,1495 @@\tfor resourceName, quantity := range requirements.Limits {\n\t\t// Validate resource name.\n\t\tallErrs = append(allErrs, validateResourceName(resourceName.String(), fmt.Sprintf(\"resources.limits[%s]\", resourceName))...)\n\t\tif api.IsStandardResourceName(resourceName.String()) {\n\t\t\tallErrs = append(allErrs, validateBasicResource(quantity).Prefix(fmt.Sprintf(\"Resource %s: \", resourceName))...)"
  },
  {
    "id" : "2b281959-3da1-4cae-887b-455412e767c2",
    "prId" : 11801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "128b979e-0494-4374-b384-2ab2227af172",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We discussed not allowing updates of any part of the template other than the nodeSelector (and maybe labels) for now.\n",
        "createdAt" : "2015-08-05T07:45:10Z",
        "updatedAt" : "2015-08-06T20:15:46Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "26a2980c-a7c9-442b-b228-1d8ff2f5373b",
        "parentId" : "128b979e-0494-4374-b384-2ab2227af172",
        "authorId" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "body" : "Oh yeah, I'll change this and submit tomorrow.\n",
        "createdAt" : "2015-08-05T07:59:44Z",
        "updatedAt" : "2015-08-06T20:15:46Z",
        "lastEditedBy" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "tags" : [
        ]
      },
      {
        "id" : "76d2e9b2-7f69-4207-badc-937c03ca1197",
        "parentId" : "128b979e-0494-4374-b384-2ab2227af172",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Thanks. It could be done similarly to ValidatePodUpdate:\nhttps://github.com/GoogleCloudPlatform/kubernetes/blob/master/pkg/api/validation/validation.go#L992\n",
        "createdAt" : "2015-08-05T17:09:25Z",
        "updatedAt" : "2015-08-06T20:15:46Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "14a488e1-18b2-4225-b004-6cb969398854",
        "parentId" : "128b979e-0494-4374-b384-2ab2227af172",
        "authorId" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "body" : "Can I allow users to update ObjectMeta for the template? Right now we don't throw validation errors if users update ObjectMeta for an rc's pod template.\n",
        "createdAt" : "2015-08-05T19:19:41Z",
        "updatedAt" : "2015-08-06T20:15:46Z",
        "lastEditedBy" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "tags" : [
        ]
      },
      {
        "id" : "5353252b-c351-49ed-b1ce-a56f338b9e5c",
        "parentId" : "128b979e-0494-4374-b384-2ab2227af172",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Users can update object meta - the validation though should be only the\n\"create\" validation (not the meta update validation) because this is a\ntemplate for a new item.\n\nOn Wed, Aug 5, 2015 at 3:19 PM, Ananya Kumar notifications@github.com\nwrote:\n\n> In pkg/api/validation/validation.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/11801#discussion_r36342763\n> :\n> \n> > -   return allErrs\n> >   +}\n> >   +\n> >   +// ValidateDaemon tests if required fields in the daemon are set.\n> >   +func ValidateDaemon(controller *api.Daemon) errs.ValidationErrorList {\n> > -   allErrs := errs.ValidationErrorList{}\n> > -   allErrs = append(allErrs, ValidateObjectMeta(&controller.ObjectMeta, true, ValidateReplicationControllerName).Prefix(\"metadata\")...)\n> > -   allErrs = append(allErrs, ValidateDaemonSpec(&controller.Spec).Prefix(\"spec\")...)\n> > -   return allErrs\n> >   +}\n> >   +\n> >   +// ValidateDaemonUpdate tests if required fields in the daemon are set.\n> >   +func ValidateDaemonUpdate(oldController, controller *api.Daemon) errs.ValidationErrorList {\n> > -   allErrs := errs.ValidationErrorList{}\n> > -   allErrs = append(allErrs, ValidateObjectMetaUpdate(&controller.ObjectMeta, &oldController.ObjectMeta).Prefix(\"metadata\")...)\n> > -   allErrs = append(allErrs, ValidateDaemonSpec(&controller.Spec).Prefix(\"spec\")...)\n> \n> Can I allow users to update ObjectMeta for the template? Right now we\n> don't throw validation errors if users update ObjectMeta for an rc's pod\n> template.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/11801/files#r36342763\n> .\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-08-05T19:43:23Z",
        "updatedAt" : "2015-08-06T20:15:46Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "9141ed66-5450-4cd4-a62b-7bc81d64c683",
        "parentId" : "128b979e-0494-4374-b384-2ab2227af172",
        "authorId" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "body" : "Added ValidateDaemonTemplateUpdate for this (and new test cases to validation_test)\n",
        "createdAt" : "2015-08-05T22:48:06Z",
        "updatedAt" : "2015-08-06T20:15:46Z",
        "lastEditedBy" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9b85652aed6d1061c04c951770f4844afbedb3e",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +1246,1250 @@\tallErrs := errs.ValidationErrorList{}\n\tallErrs = append(allErrs, ValidateObjectMetaUpdate(&controller.ObjectMeta, &oldController.ObjectMeta).Prefix(\"metadata\")...)\n\tallErrs = append(allErrs, ValidateDaemonSpec(&controller.Spec).Prefix(\"spec\")...)\n\tallErrs = append(allErrs, ValidateDaemonTemplateUpdate(oldController.Spec.Template, controller.Spec.Template).Prefix(\"spec.template\")...)\n\treturn allErrs"
  },
  {
    "id" : "346d1f5b-13d4-49b7-9a74-bfbe134c8f61",
    "prId" : 11781,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c91aa56c-d526-4dae-b68a-fcf9b145a709",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We're going to need to figure out how to validate that the resource paths are unique, but it doesn't have to be in this PR.\n",
        "createdAt" : "2015-08-07T03:48:49Z",
        "updatedAt" : "2015-08-13T16:25:15Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "edb89314-8f2d-46dd-8c53-c1d11fcb568e",
        "parentId" : "c91aa56c-d526-4dae-b68a-fcf9b145a709",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Actually, if we stored the resources at corresponding paths in etcd, we could.\n",
        "createdAt" : "2015-08-07T03:49:48Z",
        "updatedAt" : "2015-08-13T16:25:15Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "7d29d7d7-8240-42f1-8b8f-18d22e57ddb5",
        "parentId" : "c91aa56c-d526-4dae-b68a-fcf9b145a709",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Right, since the `metadata.name` of the resource specifies a unique path, and we use the `metadata.name` as most of the key in etcd, we will get write conflicts if they're not.  \n",
        "createdAt" : "2015-08-07T20:38:03Z",
        "updatedAt" : "2015-08-13T16:25:15Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "1055eed9b6829347a568eceea51f3662ea6862a6",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1813,1817 @@\t\tversion := &obj.Versions[ix]\n\t\tif len(version.Name) == 0 {\n\t\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"name\", version, \"name can not be empty\"))\n\t\t}\n\t\tif versions.Has(version.Name) {"
  },
  {
    "id" : "cbcb3a2d-12b4-4f23-bf2d-7871fac75da1",
    "prId" : 10974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60d77c1c-e7cf-4b68-b035-15e93f457094",
        "parentId" : null,
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Shouldn't you also do this check if type=NodePort?\n",
        "createdAt" : "2015-07-09T21:37:33Z",
        "updatedAt" : "2015-07-10T21:36:10Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "28b868c3-90ba-45ec-a1b4-b4ba9393d6fd",
        "parentId" : "60d77c1c-e7cf-4b68-b035-15e93f457094",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Ah, only if they're using host port, not node port. Nevermind\n",
        "createdAt" : "2015-07-09T21:38:17Z",
        "updatedAt" : "2015-07-10T21:36:10Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "cf25fc5c-67e0-4b6c-bd9d-269ca3863b72",
        "parentId" : "60d77c1c-e7cf-4b68-b035-15e93f457094",
        "authorId" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "body" : "Preventing someone from explicitly choosing nodeport=10250 is orthogonal if we aren't already doing it\n",
        "createdAt" : "2015-07-09T21:39:51Z",
        "updatedAt" : "2015-07-10T21:36:10Z",
        "lastEditedBy" : "7766e039-aa4c-4476-9091-5cc8763fa8d6",
        "tags" : [
        ]
      },
      {
        "id" : "36064937-06d1-4ade-a200-3245c31a3eed",
        "parentId" : "60d77c1c-e7cf-4b68-b035-15e93f457094",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "That will just fail when we try to open the node port, and we'll see an error.  The trouble with the firewall is that it will silently expose the kubelet to the external internet.\n",
        "createdAt" : "2015-07-09T23:06:53Z",
        "updatedAt" : "2015-07-10T21:36:10Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8f02e54721f4f22abb38c1056dcb620282839d3",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1040,1044 @@\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"spec.ports\"))\n\t}\n\tif service.Spec.Type == api.ServiceTypeLoadBalancer {\n\t\tfor ix := range service.Spec.Ports {\n\t\t\tport := &service.Spec.Ports[ix]"
  },
  {
    "id" : "414e3dc7-97fd-43fa-b4b1-2fb040bfd7cd",
    "prId" : 9965,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99001240-e8d6-40c8-af03-640cc93a76a2",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "this works, but it might be cleaner to follow this pattern:\n\n```\nvar supportedGetActionSchemes = util.NewStringSet(string(api.URISchemeHTTP), string(api.URISchemeHTTPS))\n...\nif !supportedGetActionSchemes.Has(string(http.Scheme)) {\n  allErrors = append(allErrors, errs.NewFieldInvalid(\"scheme\", http.Scheme, fmt.Sprintf(\"must be one of %v\", supportedGetActionSchemes.List())))\n}\n```\n",
        "createdAt" : "2015-06-25T18:10:02Z",
        "updatedAt" : "2015-06-25T20:59:38Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "3008ff6150c6b04c4e566786ff518caf60d7766c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +766,770 @@\tif !supportedSchemes.Has(string(http.Scheme)) {\n\t\tallErrors = append(allErrors, errs.NewFieldInvalid(\"scheme\", http.Scheme, fmt.Sprintf(\"must be one of %v\", supportedSchemes.List())))\n\t}\n\treturn allErrors\n}"
  },
  {
    "id" : "9308e893-ea76-405f-b2a2-31e359b3a65a",
    "prId" : 9387,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b98c8711-ea8a-42d8-b7a9-2a366223f73a",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "`new` is a keyword.   `newer`?\n",
        "createdAt" : "2015-06-09T13:28:23Z",
        "updatedAt" : "2015-06-09T13:28:23Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "d14e434d-8f9d-42b5-bd6b-f165657ef7b2",
        "parentId" : "b98c8711-ea8a-42d8-b7a9-2a366223f73a",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "SGTM\n",
        "createdAt" : "2015-06-09T13:48:10Z",
        "updatedAt" : "2015-06-09T13:48:10Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa892b71431c5de46676499cb9a4e601f63d418b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +240,244 @@\n// ValidateObjectMetaUpdate validates an object's metadata when updated\nfunc ValidateObjectMetaUpdate(new, old *api.ObjectMeta) errs.ValidationErrorList {\n\tallErrs := errs.ValidationErrorList{}\n"
  },
  {
    "id" : "8e5f090d-03c9-4ff8-8cea-02cb8adf39c4",
    "prId" : 8641,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6eb11d8e-bbb8-481d-a632-75995cbb8df9",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "DeletionTimestamp can be nil.\n",
        "createdAt" : "2015-06-01T20:03:54Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "d3627517-9ff0-48b8-967d-6e888082d3df",
        "parentId" : "6eb11d8e-bbb8-481d-a632-75995cbb8df9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We define IsZero for *util.Time so that we don't need the nil check (a nil util.Time is zero)\n\n----- Original Message -----\n\n> > @@ -252,6 +252,10 @@ func ValidateObjectMetaUpdate(old, meta\n> > *api.ObjectMeta) errs.ValidationErrorLis\n> >     } else {\n> >         meta.CreationTimestamp = old.CreationTimestamp\n> >     }\n> > -   // an object can never remove a deletion timestamp\n> > -   if !old.DeletionTimestamp.IsZero() {\n> \n> DeletionTimestamp can be nil.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8641/files#r31464084\n",
        "createdAt" : "2015-06-01T20:12:37Z",
        "updatedAt" : "2015-06-01T23:24:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "f12a68cd60ccfe2f0926386df771805c0993d783",
    "line" : null,
    "diffHunk" : "@@ -1,1 +254,258 @@\t}\n\t// an object can never remove a deletion timestamp or clear/change grace period seconds\n\tif !old.DeletionTimestamp.IsZero() {\n\t\tmeta.DeletionTimestamp = old.DeletionTimestamp\n\t}"
  },
  {
    "id" : "30a2dae3-452f-452b-9256-f7f75cf1f283",
    "prId" : 7974,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abda3e9f-acc8-4c86-8854-28930d7491e9",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "What are the secret keys used for? File names in secret volumes? Do they really need to have different validation rules than labels, annotations, and resources?\n\nNote that we just tightened label rules.\n\ncc @thockin \n",
        "createdAt" : "2015-05-13T22:45:07Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "951f6da4-d8f5-4304-b15f-dc9b70395dac",
        "parentId" : "abda3e9f-acc8-4c86-8854-28930d7491e9",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I see why you want leading dot for .dockercfg, since we're generating file names from the keys.\n\nShould we be imposing filename-based character restrictions instead?\n\n@pmorie \n",
        "createdAt" : "2015-05-13T23:01:28Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "0e8e76ff-9adf-4687-a7c5-70c183c1f27f",
        "parentId" : "abda3e9f-acc8-4c86-8854-28930d7491e9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "+1 for filename-based restrictions\n",
        "createdAt" : "2015-05-13T23:17:50Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "257e8f61-15f9-4fdc-9a52-58b661dcf49d",
        "parentId" : "abda3e9f-acc8-4c86-8854-28930d7491e9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Including forcing lower case...\n",
        "createdAt" : "2015-05-13T23:48:25Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "3b3bc3bb-5f7c-4408-a247-1d635f0745d9",
        "parentId" : "abda3e9f-acc8-4c86-8854-28930d7491e9",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "There's certainly a more descriptive format to enforce than dns subdomains.  We went with DNS subdomains instead of defining a new format during the implementation because we assumed that a dns subdomain was a strict subset of the eventual format to use.  I'll make an issue to sort this out.\n",
        "createdAt" : "2015-05-14T04:31:47Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "c5afdee3-0180-443b-94ce-0bd465262b54",
        "parentId" : "abda3e9f-acc8-4c86-8854-28930d7491e9",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Created #8236 \n",
        "createdAt" : "2015-05-14T04:35:21Z",
        "updatedAt" : "2015-05-19T16:41:15Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "72c0709f18cbeff1efef3c2bd601db5f1e117509",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1282,1286 @@// IsSecretKey tests for a string that conforms to the definition of a\n// subdomain in DNS (RFC 1123), except that a leading dot is allowed\nfunc IsSecretKey(value string) bool {\n\treturn len(value) <= util.DNS1123SubdomainMaxLength && secretKeyRegexp.MatchString(value)\n}"
  },
  {
    "id" : "2060842a-331b-4440-a804-44a26834d945",
    "prId" : 7419,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d75bdab6-c061-494d-8401-fcc0e8eab5cc",
        "parentId" : null,
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Can't this just be replaced with a TODO to add future validations based on types?\n",
        "createdAt" : "2015-04-28T19:05:25Z",
        "updatedAt" : "2015-04-28T19:05:25Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "a8992822-d3bc-437a-8c51-a01a5ef0772e",
        "parentId" : "d75bdab6-c061-494d-8401-fcc0e8eab5cc",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "cut me a tiny bit of slack... I'm trying to keep the service accounts PR balanced on top of this commit :) (which does add validation of the ServiceAccountToken secret type)\n",
        "createdAt" : "2015-04-28T19:06:48Z",
        "updatedAt" : "2015-04-28T19:07:36Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6f71bed4-5a02-479f-a9b4-0f1fa9d27082",
        "parentId" : "d75bdab6-c061-494d-8401-fcc0e8eab5cc",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : ";)\n",
        "createdAt" : "2015-04-28T19:23:56Z",
        "updatedAt" : "2015-04-28T19:23:56Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "b8e27504-287b-45c6-8283-d01022a18418",
        "parentId" : "d75bdab6-c061-494d-8401-fcc0e8eab5cc",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "Ah, my bad, I had forgotten about the ServiceAccountToken type\n",
        "createdAt" : "2015-04-28T19:28:15Z",
        "updatedAt" : "2015-04-28T19:28:15Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac67fff1cf994e5ee5aaae99aece5eaa9b78893e",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1243,1247 @@\t}\n\n\tswitch secret.Type {\n\tcase api.SecretTypeOpaque, \"\":\n\t\t// no-op"
  },
  {
    "id" : "497d37e7-48f6-44b5-a614-b778946954ed",
    "prId" : 7131,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81eda4d3-e556-4db9-9174-76a87a7d2b96",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "you really want a field name here - can you pass that down into this function?\n",
        "createdAt" : "2015-04-21T20:22:36Z",
        "updatedAt" : "2015-04-21T20:36:08Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "be830bac-14db-4272-8a3e-6c61c9906279",
        "parentId" : "81eda4d3-e556-4db9-9174-76a87a7d2b96",
        "authorId" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "body" : "The field name is already added at the callsite through Prefix().\n",
        "createdAt" : "2015-04-21T20:24:29Z",
        "updatedAt" : "2015-04-21T20:36:08Z",
        "lastEditedBy" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "tags" : [
        ]
      },
      {
        "id" : "66d362ca-4360-4a15-983c-728887edb7c7",
        "parentId" : "81eda4d3-e556-4db9-9174-76a87a7d2b96",
        "authorId" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "body" : "Updated all other fields.\n",
        "createdAt" : "2015-04-21T20:54:02Z",
        "updatedAt" : "2015-04-21T20:54:02Z",
        "lastEditedBy" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "bfb4b7280d8231963290c4e9b77c0a55b2445284",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1162,1166 @@func validateBasicResource(quantity resource.Quantity) errs.ValidationErrorList {\n\tif quantity.Value() < 0 {\n\t\treturn errs.ValidationErrorList{errs.NewFieldInvalid(\"\", quantity.Value(), \"must be a valid resource quantity\")}\n\t}\n\treturn errs.ValidationErrorList{}"
  },
  {
    "id" : "ac8fa07c-3d00-491e-b295-fee135cbbaa1",
    "prId" : 7101,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb1573f1-92cc-4e10-b32d-3ec8ae424ff9",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Add check for the token element in data?\n",
        "createdAt" : "2015-05-06T14:00:41Z",
        "updatedAt" : "2015-05-11T21:34:20Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "ecbcee82-caec-44ef-827b-22b7ae932b9e",
        "parentId" : "bb1573f1-92cc-4e10-b32d-3ec8ae424ff9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "right now, the token controller will:\n1. create new ServiceAccountToken secrets with the token data filled in\n2. add token data to ServiceAccountToken secrets that are missing it, to enable creation of new tokens\n\nrequiring token data in validation would prevent number 2\n",
        "createdAt" : "2015-05-06T14:11:37Z",
        "updatedAt" : "2015-05-11T21:34:20Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "92bd58ede6b03a4cc98639ccafdbc4796da9dccb",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1267,1271 @@\n\tswitch secret.Type {\n\tcase api.SecretTypeServiceAccountToken:\n\t\t// Only require Annotations[kubernetes.io/service-account.name]\n\t\t// Additional fields (like Annotations[kubernetes.io/service-account.uid] and Data[token]) might be contributed later by a controller loop"
  },
  {
    "id" : "b090f4b1-eb5d-43fb-9c61-a29afa5009b4",
    "prId" : 6739,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccd7bb65-0c89-49bf-a80f-9e0b5b3faa23",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "At what point do we validate these are legitimate values?\n",
        "createdAt" : "2015-04-21T22:32:45Z",
        "updatedAt" : "2015-04-27T18:42:58Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "f0b9c99a-e208-4f6c-843d-74146a070b5d",
        "parentId" : "ccd7bb65-0c89-49bf-a80f-9e0b5b3faa23",
        "authorId" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "body" : "@thockin At this point, that happens in the kubelet.  I don't think that's great.  Let me think on this a bit more.\n",
        "createdAt" : "2015-04-21T23:41:53Z",
        "updatedAt" : "2015-04-27T18:42:58Z",
        "lastEditedBy" : "498aade9-b8f0-4e29-8055-89afa6f5fcc8",
        "tags" : [
        ]
      },
      {
        "id" : "8b78e80f-14c7-4f62-b4f0-bb67c04b317d",
        "parentId" : "ccd7bb65-0c89-49bf-a80f-9e0b5b3faa23",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Seems totally feasible to validate them in apiserver even if expanded by Kubelet.\n",
        "createdAt" : "2015-04-23T01:29:44Z",
        "updatedAt" : "2015-04-27T18:42:58Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "1fc624f7-3d78-44d5-8f61-241b52b7d81b",
        "parentId" : "ccd7bb65-0c89-49bf-a80f-9e0b5b3faa23",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "> On Apr 22, 2015, at 9:30 PM, Brian Grant notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > -   numSources := 0\n> >   +\n> > -   switch {\n> > -   case ev.Source.PodField != nil:\n> > -       numSources++\n> > -       allErrs = append(allErrs, validateObjectFieldSelector(ev.Source.PodField).Prefix(\"podField\")...)\n> > -   }\n> >   +\n> > -   if ev.Value != \"\" && numSources != 0 {\n> > -       allErrs = append(allErrs, errs.NewFieldInvalid(\"\", \"\", \"sources cannot be specified when value is not empty\"))\n> > -   }\n> >   +\n> > -   return allErrs\n> >   +}\n> >   +\n> >   +func validateObjectFieldSelector(fs *api.ObjectFieldSelector) errs.ValidationErrorList {\n> >   Seems totally feasible to validate them in apiserver even if expanded by Kubelet.\n> \n> So if an network plugin was running on the nodes and could offer downward API to pods (not saying I have a concrete scenario in mind), the apiserver would need to know about the full shape of the downward API object the network plugin exposes?  Just trying to clarify what we mean by validation.\n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-04-23T02:41:17Z",
        "updatedAt" : "2015-04-27T18:42:58Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ae2ada99-0607-4e37-9a7b-330ce1a59c93",
        "parentId" : "ccd7bb65-0c89-49bf-a80f-9e0b5b3faa23",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "The user would prefer to get errors as early as possible. The plugin wouldn't have to be compiled into the apiserver or kubectl in order to enable that; we could use swagger.\n",
        "createdAt" : "2015-04-23T02:50:56Z",
        "updatedAt" : "2015-04-27T18:42:58Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d30f09ebfac6476eed12a040b3da2ca44882062",
    "line" : null,
    "diffHunk" : "@@ -1,1 +589,593 @@var validFieldPathExpressions = util.NewStringSet(\"metadata.name\", \"metadata.namespace\")\n\nfunc validateObjectFieldSelector(fs *api.ObjectFieldSelector) errs.ValidationErrorList {\n\tallErrs := errs.ValidationErrorList{}\n"
  },
  {
    "id" : "0742c418-71ff-43f6-9f60-6ae95f60652a",
    "prId" : 5929,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a38c649-4ae4-470b-9d7b-564190e49bbb",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Is `0 bytes` of memory valid?\n",
        "createdAt" : "2015-03-25T17:05:02Z",
        "updatedAt" : "2015-03-25T22:00:42Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "49ff04765b80befc8deb914d955b274797bfb0c4",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +916,920 @@\t\tif val, ok := node.Spec.Capacity[api.ResourceMemory]; !ok {\n\t\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"spec.Capacity[memory]\"))\n\t\t} else if val.Value() < 0 {\n\t\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"spec.Capacity[memory]\", val, \"memory capacity cannot be negative\"))\n\t\t}"
  },
  {
    "id" : "fe44c95d-f49f-461f-8f5d-b7666bf9c768",
    "prId" : 5929,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b2263d7-7767-429b-80f9-894939f49947",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Same here. Is `0 cores` valid?\n",
        "createdAt" : "2015-03-25T17:05:28Z",
        "updatedAt" : "2015-03-25T22:00:42Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "49ff04765b80befc8deb914d955b274797bfb0c4",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +921,925 @@\t\tif val, ok := node.Spec.Capacity[api.ResourceCPU]; !ok {\n\t\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"spec.Capacity[cpu]\"))\n\t\t} else if val.Value() < 0 {\n\t\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"spec.Capacity[cpu]\", val, \"cpu capacity cannot be negative\"))\n\t\t}"
  },
  {
    "id" : "697e38f0-9fc8-4436-9eb6-c0f3c7a64195",
    "prId" : 5609,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c67298b-050e-4893-bc22-15ef424da376",
        "parentId" : null,
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "information on what kind of field required here? \"containers\"?\n",
        "createdAt" : "2015-03-18T21:00:13Z",
        "updatedAt" : "2015-03-19T11:34:30Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "05de86a2-d0e8-46b4-b935-c8ed6ba94d8e",
        "parentId" : "9c67298b-050e-4893-bc22-15ef424da376",
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "This is not needed, because all errors returned from this method will be prefixed with \"containers\" so the error will be like:\n\n[spec.template.spec.containers: required value]\n\n(prefix may vary depending on where the PodSpec is used)\n",
        "createdAt" : "2015-03-19T08:25:22Z",
        "updatedAt" : "2015-03-19T11:34:30Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f89f91b7bd364afdf2992dfd507882c94ddb5a57",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +538,542 @@\n\tif len(containers) == 0 {\n\t\treturn append(allErrs, errs.NewFieldRequired(\"\"))\n\t}\n"
  },
  {
    "id" : "9f0b42e9-f1ee-4a5b-846b-b55df99d34fa",
    "prId" : 5185,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9a2142b-c956-47e0-a3a0-bbb498379c80",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "In what cases would we expect it to be changed to something different, as opposed to just being empty?\n",
        "createdAt" : "2015-03-09T18:24:51Z",
        "updatedAt" : "2015-03-09T18:24:51Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "7994f7cf-a8f9-48b3-99c1-b29f82368a23",
        "parentId" : "a9a2142b-c956-47e0-a3a0-bbb498379c80",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Probably none.  I don't have the right \"reset this value before ValidateUpdate is invoked\" so the validator does the reset.\n\nI suppose if no one ever set a creation timestamp (very old clusters), on an update having _a_ value set is better than no value.\n",
        "createdAt" : "2015-03-09T18:37:29Z",
        "updatedAt" : "2015-03-09T18:37:29Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "8291bc51-fff7-4e29-bd45-af9c35a8d62c",
        "parentId" : "a9a2142b-c956-47e0-a3a0-bbb498379c80",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I will remove all of this reset code when I implement BeforeUpdate()\n",
        "createdAt" : "2015-03-09T18:37:45Z",
        "updatedAt" : "2015-03-09T18:37:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "d016f478e092211349ae40718bfe2791c790fc09",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +220,224 @@\t\tmeta.UID = old.UID\n\t}\n\t// ignore changes to timestamp\n\tif old.CreationTimestamp.IsZero() {\n\t\told.CreationTimestamp = meta.CreationTimestamp"
  },
  {
    "id" : "a7ba096b-073e-455a-adc0-0ea5c5385d7b",
    "prId" : 5185,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1fbbdc1-7f7b-41ba-8c96-0d2c5b350be7",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "This should be `else if meta.CreationTimestamp.IsZero()`\n",
        "createdAt" : "2015-03-09T20:27:33Z",
        "updatedAt" : "2015-03-09T20:27:33Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "3467739a-f16e-41d2-a8e9-8e821fb3fa54",
        "parentId" : "b1fbbdc1-7f7b-41ba-8c96-0d2c5b350be7",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "meta has to have the same creation timestamp as the new one, otherwise the latter check fails.  The problem here is both are set, and are different.  This is just about ensuring that \"meta\" (what we are going to write) is correctly set to _something_.  If old.CreationTimestamp is zero, it seems strictly better to have it set to something (vs remaining empty)\n",
        "createdAt" : "2015-03-09T20:37:29Z",
        "updatedAt" : "2015-03-09T20:37:29Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "d016f478e092211349ae40718bfe2791c790fc09",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +223,227 @@\tif old.CreationTimestamp.IsZero() {\n\t\told.CreationTimestamp = meta.CreationTimestamp\n\t} else {\n\t\tmeta.CreationTimestamp = old.CreationTimestamp\n\t}"
  },
  {
    "id" : "5560a8bf-c056-4279-9139-8483428b4c7b",
    "prId" : 4779,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4056994-11ce-4391-bb60-7a12115bf809",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "In what situation would we allow changes? Pods don't get rescheduled, and I'm thinking that the cleanest way to deal with rejection from Kubelet is to consider the pod dead.\n",
        "createdAt" : "2015-02-27T04:09:40Z",
        "updatedAt" : "2015-03-02T03:35:22Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "598a715b-da35-4645-a1a2-72f9250bc41e",
        "parentId" : "f4056994-11ce-4391-bb60-7a12115bf809",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "If we ever wanted to allow scheduler to mutate status instead of binding, but no other reason.  I'll remove the todo\n\n> On Feb 26, 2015, at 11:09 PM, Brian Grant notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > @@ -647,6 +647,23 @@ func ValidatePodUpdate(newPod, oldPod *api.Pod) errs.ValidationErrorList {\n> >     return allErrs\n> >  }\n> > \n> > +// ValidatePodStatusUpdate tests to see if the update is legal for an end user to make. newPod is updated with fields\n> > +// that cannot be changed.\n> > +func ValidatePodStatusUpdate(newPod, oldPod *api.Pod) errs.ValidationErrorList {\n> > -   allErrs := errs.ValidationErrorList{}\n> >   +\n> > -   allErrs = append(allErrs, ValidateObjectMetaUpdate(&oldPod.ObjectMeta, &newPod.ObjectMeta).Prefix(\"metadata\")...)\n> >   +\n> > -   // TODO: allow change when bindings are properly decoupled from pods\n> >   In what situation would we allow changes? Pods don't get rescheduled, and I'm thinking that the cleanest way to deal with rejection from Kubelet is to consider the pod dead.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-02-27T04:12:09Z",
        "updatedAt" : "2015-03-02T03:35:22Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "76a1e434-e585-457e-92bd-31cfb37ba007",
        "parentId" : "f4056994-11ce-4391-bb60-7a12115bf809",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I'm also thinking we should get rid of host in Status, and just set the one in Spec -- the scheduler is a finalizer.\n",
        "createdAt" : "2015-02-27T04:12:35Z",
        "updatedAt" : "2015-03-02T03:35:22Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "a7a0d00b-0b90-4e3b-b46d-5ebf115511de",
        "parentId" : "f4056994-11ce-4391-bb60-7a12115bf809",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "So would end users be able to set it?\n\n> On Feb 26, 2015, at 11:12 PM, Brian Grant notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > @@ -647,6 +647,23 @@ func ValidatePodUpdate(newPod, oldPod *api.Pod) errs.ValidationErrorList {\n> >     return allErrs\n> >  }\n> > \n> > +// ValidatePodStatusUpdate tests to see if the update is legal for an end user to make. newPod is updated with fields\n> > +// that cannot be changed.\n> > +func ValidatePodStatusUpdate(newPod, oldPod *api.Pod) errs.ValidationErrorList {\n> > -   allErrs := errs.ValidationErrorList{}\n> >   +\n> > -   allErrs = append(allErrs, ValidateObjectMetaUpdate(&oldPod.ObjectMeta, &newPod.ObjectMeta).Prefix(\"metadata\")...)\n> >   +\n> > -   // TODO: allow change when bindings are properly decoupled from pods\n> >   I'm also thinking we should get rid of host in Status, and just set the one in Spec -- the scheduler is a finalizer.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-03-02T18:51:23Z",
        "updatedAt" : "2015-03-02T18:51:23Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "2ad2fc5c-8433-4f47-b2c9-a54639469017",
        "parentId" : "f4056994-11ce-4391-bb60-7a12115bf809",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Never mind, binding sets it.  I keep forgetting....\n\n> On Feb 26, 2015, at 11:12 PM, Brian Grant notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > @@ -647,6 +647,23 @@ func ValidatePodUpdate(newPod, oldPod *api.Pod) errs.ValidationErrorList {\n> >     return allErrs\n> >  }\n> > \n> > +// ValidatePodStatusUpdate tests to see if the update is legal for an end user to make. newPod is updated with fields\n> > +// that cannot be changed.\n> > +func ValidatePodStatusUpdate(newPod, oldPod *api.Pod) errs.ValidationErrorList {\n> > -   allErrs := errs.ValidationErrorList{}\n> >   +\n> > -   allErrs = append(allErrs, ValidateObjectMetaUpdate(&oldPod.ObjectMeta, &newPod.ObjectMeta).Prefix(\"metadata\")...)\n> >   +\n> > -   // TODO: allow change when bindings are properly decoupled from pods\n> >   I'm also thinking we should get rid of host in Status, and just set the one in Spec -- the scheduler is a finalizer.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-03-02T18:51:35Z",
        "updatedAt" : "2015-03-02T18:51:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d290089ae97098e10c0afe83ff4d1cf987a5f06",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +655,659 @@\tallErrs = append(allErrs, ValidateObjectMetaUpdate(&oldPod.ObjectMeta, &newPod.ObjectMeta).Prefix(\"metadata\")...)\n\n\t// TODO: allow change when bindings are properly decoupled from pods\n\tif newPod.Status.Host != oldPod.Status.Host {\n\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"status.host\", newPod.Status.Host, \"pod host cannot be changed directly\"))"
  },
  {
    "id" : "eb7022cc-b3ff-46b5-87c5-814c755890db",
    "prId" : 4601,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e820b91-9bca-4d9d-8c40-d54310ec7ea5",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Presumably it has to be an absolute path? If so, validate with IsAbs()?\n",
        "createdAt" : "2015-03-18T06:21:42Z",
        "updatedAt" : "2015-03-19T17:38:12Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a45e37d17de3a6de690dba98675c16ccb93a892",
    "line" : null,
    "diffHunk" : "@@ -1,1 +351,355 @@\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"server\"))\n\t}\n\tif nfs.Path == \"\" {\n\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"path\"))\n\t}"
  },
  {
    "id" : "61bcfb1c-5111-4d6e-ab8d-6cb9f43619ef",
    "prId" : 4514,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc07cca3-abe1-4a4a-b24d-425ca899d7b7",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "validate keys as being valid filenames?\nAre subdirs possible, and are they expressed as a slash in the name?  IF so, how is a slash in the name escaped, if at all?\n",
        "createdAt" : "2015-02-18T17:39:16Z",
        "updatedAt" : "2015-02-18T17:39:16Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "fb001ada21710c87fc0af1cd18c8798303ea000a",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +856,860 @@\tfor _, value := range secret.Data {\n\t\ttotalSize += len(value)\n\t}\n\tif totalSize > api.MaxSecretSize {\n\t\tallErrs = append(allErrs, errs.NewFieldForbidden(\"data\", \"Maximum secret size exceeded\"))"
  },
  {
    "id" : "f43290fd-b33e-404f-b94d-d6dd7fa691c5",
    "prId" : 4451,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fda5830-6b1a-45f4-8d69-d40eebf8946f",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Need to use Prefix on these to assign \"livenessProbe\" and \"readinessProbe\"\n",
        "createdAt" : "2015-02-15T17:48:28Z",
        "updatedAt" : "2015-02-17T06:16:59Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "56ce0585-b6cc-488d-bc0e-fa17eb1ea618",
        "parentId" : "9fda5830-6b1a-45f4-8d69-d40eebf8946f",
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "Done.\n",
        "createdAt" : "2015-02-15T18:44:34Z",
        "updatedAt" : "2015-02-17T06:16:59Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7df9b9d37cd8aa524b0e1adc8055082816facfb",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +481,485 @@\t\tif ctr.Lifecycle != nil {\n\t\t\tcErrs = append(cErrs, validateLifecycle(ctr.Lifecycle).Prefix(\"lifecycle\")...)\n\t\t}\n\t\tcErrs = append(cErrs, validateProbe(ctr.LivenessProbe).Prefix(\"livenessProbe\")...)\n\t\tcErrs = append(cErrs, validateProbe(ctr.ReadinessProbe).Prefix(\"readinessProbe\")...)"
  },
  {
    "id" : "a2b47f63-a02f-4c8c-bf5a-6f6ee2ab8d1c",
    "prId" : 4419,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b6ecc7d-1f43-436e-81b4-7f937b90ed42",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "This was just a bug?\n",
        "createdAt" : "2015-02-13T17:27:39Z",
        "updatedAt" : "2015-02-13T18:11:48Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "16b693c8-5c21-423b-a296-3e62fa80943d",
        "parentId" : "0b6ecc7d-1f43-436e-81b4-7f937b90ed42",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "This probably could be moved into 4248 - it's still correct, but 4248 is where the reset really needs to happen.\n",
        "createdAt" : "2015-02-13T17:35:05Z",
        "updatedAt" : "2015-02-13T18:11:48Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "d9b33b46-a960-475c-8ab3-ae4ae5e3ed97",
        "parentId" : "0b6ecc7d-1f43-436e-81b4-7f937b90ed42",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Please do.\n",
        "createdAt" : "2015-02-13T17:54:08Z",
        "updatedAt" : "2015-02-13T18:11:48Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "42d42e89-fc06-4ec8-947b-6bd8de0d40ab",
        "parentId" : "0b6ecc7d-1f43-436e-81b4-7f937b90ed42",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Nevermind.\n",
        "createdAt" : "2015-02-13T18:48:37Z",
        "updatedAt" : "2015-02-13T18:48:37Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "8440310ea0d11ad2e3f8e21c98bae08dc3ee3e13",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +586,590 @@\t}\n\n\tnewPod.Status = oldPod.Status\n\treturn allErrs\n}"
  },
  {
    "id" : "ab8737ba-4bb9-4dee-9e75-1b1c7d1f8535",
    "prId" : 3854,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e6273ec-6580-4015-adf6-6b515f193dea",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is a good way to prove that we are not depending on mutating changes, but it is pessimal for performance - it will make a copy  of every object.  I think we should stick with pointers.\n",
        "createdAt" : "2015-01-30T00:30:48Z",
        "updatedAt" : "2015-02-03T08:58:13Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "737e8c22-9a61-4794-9a97-e0df176371e4",
        "parentId" : "7e6273ec-6580-4015-adf6-6b515f193dea",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Our encoding / decoding / conversion is an order of magnitude worse (we do 2000 allocations per decode, and actually encode 3 times).  A few copies we can probably let slide...\n\n> On Jan 29, 2015, at 7:31 PM, Tim Hockin notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > @@ -38,8 +38,7 @@ func validateVolumes(volumes []api.Volume) (util.StringSet, errs.ValidationError\n> >     allErrs := errs.ValidationErrorList{}\n> > \n> > ```\n> > allNames := util.StringSet{}\n> > ```\n> > -   for i := range volumes {\n> > -       vol := &volumes[i] // so we can set default values\n> > -   for i, vol := range volumes {\n> >   This is a good way to prove that we are not depending on mutating changes, but it is pessimal for performance - it will make a copy of every object. I think we should stick with pointers.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-01-30T01:43:49Z",
        "updatedAt" : "2015-02-03T08:58:13Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "716ba8d4-063d-48f4-a35f-bf250133eeaf",
        "parentId" : "7e6273ec-6580-4015-adf6-6b515f193dea",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Why pessimize when we don't really have to? I leave it to Yu-Ju - if it is a pain to convert back, skip it for now..\n",
        "createdAt" : "2015-02-03T04:42:37Z",
        "updatedAt" : "2015-02-03T08:58:13Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a72addaeb301da2a8f8fbcb226991d62dbb012f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +190,194 @@\n\tallNames := util.StringSet{}\n\tfor i, vol := range volumes {\n\t\tel := validateSource(&vol.Source).Prefix(\"source\")\n\t\tif len(vol.Name) == 0 {"
  },
  {
    "id" : "37b1bfdb-6b0e-46ef-86da-8ed9684b0091",
    "prId" : 3789,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d78c0946-495e-4b51-a91f-f7b039738460",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I don't find muhc value in these functions, vs directly passing nameIsDNSSubdomain at the call-site.  Is there some evolutionary plan that justifies these?\n",
        "createdAt" : "2015-02-02T05:58:10Z",
        "updatedAt" : "2015-02-02T19:48:57Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c386bfb0-fdeb-4edf-bdc5-afd4647d99a3",
        "parentId" : "d78c0946-495e-4b51-a91f-f7b039738460",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "They're called by the generation code explicitly when we generate names, so that we can separately validate name changes from validating the whole pod.\n",
        "createdAt" : "2015-02-02T17:43:57Z",
        "updatedAt" : "2015-02-02T19:48:57Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "98f604dc-5b47-4c46-b55b-5eb024251fab",
        "parentId" : "d78c0946-495e-4b51-a91f-f7b039738460",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "See replication_controller.go line 67\n",
        "createdAt" : "2015-02-02T17:46:27Z",
        "updatedAt" : "2015-02-02T19:48:57Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "5d982e5c-b2bb-4ce5-8045-974deca2fc05",
        "parentId" : "d78c0946-495e-4b51-a91f-f7b039738460",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "That justifies pod name - none of the others.  It's minor, it's just noise without a reason.\n",
        "createdAt" : "2015-02-02T23:50:30Z",
        "updatedAt" : "2015-02-02T23:50:30Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "da50cecd-58e6-46e9-83e5-d6f8031261ed",
        "parentId" : "d78c0946-495e-4b51-a91f-f7b039738460",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Just today I made up a \"use case\" and used these in OpenShift out of spite - we are doing generation of replication controllers for each deployment so we sanity check the replication controller name validation prior to submitting it to the api, and we started generating services and I was letting the service name validation guide whether we made up a name, or used one that corresponded to the docker image's name we generated an app from.  Having them separate was truly useful.\n\n> On Feb 2, 2015, at 6:50 PM, Tim Hockin notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > +// name will have a value appended to it.\n> > +type ValidateNameFunc func(name string, prefix bool) (bool, string)\n> > +\n> > +// maskTrailingDash replaces the final character of a string with a subdomain safe\n> > +// value if is a dash.\n> > +func maskTrailingDash(name string) string {\n> > -   if strings.HasSuffix(name, \"-\") {\n> > -       return name[:len(name)-2] + \"a\"\n> > -   }\n> > -   return name\n> >   +}\n> >   +\n> >   +// ValidatePodName can be used to check whether the given pod name is valid.\n> >   +// Prefix indicates this name will be used as part of generation, in which case\n> >   +// trailing dashes are allowed.\n> >   +func ValidatePodName(name string, prefix bool) (bool, string) {\n> >   That justifies pod name - none of the others. It's minor, it's just noise without a reason.\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-02-06T02:18:17Z",
        "updatedAt" : "2015-02-06T02:18:17Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "1588970ec429df804708e8f00b66e4b94ba70723",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +70,74 @@// Prefix indicates this name will be used as part of generation, in which case\n// trailing dashes are allowed.\nfunc ValidatePodName(name string, prefix bool) (bool, string) {\n\treturn nameIsDNSSubdomain(name, prefix)\n}"
  },
  {
    "id" : "11ca2d8a-b23b-4caa-abe3-46441e9db32f",
    "prId" : 3751,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f3b5c55-1194-4ade-ae45-e77c833076e6",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "In #3057 I asked whether we want these objects to be namespaced, or to be un-namespaced, but referring to namespaces.\n",
        "createdAt" : "2015-01-26T19:40:48Z",
        "updatedAt" : "2015-01-27T21:55:19Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "2f36cd57-1eaf-42b9-85ef-71410a220113",
        "parentId" : "7f3b5c55-1194-4ade-ae45-e77c833076e6",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I replied in #3057 that I think it stays namespaced.\n\nI think a `ClusterLimitRange` could be non-namespaced, and the admission control plug-in to enforce that is super simple, since it only has to pull 1 of these.  A `CluserLimitRange` would take precedence over what is presented in this PR and the actors that can define it are obviously different.\n\nPrefer this PR stay limited to I want to enforce limits at the namesapce scope.\n",
        "createdAt" : "2015-01-26T21:00:43Z",
        "updatedAt" : "2015-01-27T21:55:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "b19a8a61a86e0ffefb9d94fb39a54d92e134bfbf",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +653,657 @@\t\tallErrs = append(allErrs, errs.NewFieldRequired(\"namespace\", limitRange.Namespace))\n\t} else if !util.IsDNSSubdomain(limitRange.Namespace) {\n\t\tallErrs = append(allErrs, errs.NewFieldInvalid(\"namespace\", limitRange.Namespace, \"\"))\n\t}\n\t// ensure resource names are properly qualified per docs/resources.md"
  },
  {
    "id" : "80d217be-568f-45c0-bf6f-397f9e251561",
    "prId" : 3751,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb1c6efc-89aa-4de5-8af9-65801568110b",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Do you need to reject resource names other than cpu or ram, given that your implementation silently ignores other resource types?\n",
        "createdAt" : "2015-01-26T21:13:22Z",
        "updatedAt" : "2015-01-27T21:55:19Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "b54852db-d26c-449b-ac73-205f7809841e",
        "parentId" : "eb1c6efc-89aa-4de5-8af9-65801568110b",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "For validation, no.\n\nI want to be able to do the following downstream:\n\n```\n{\n  \"id\": \"limits\",\n  \"kind\": \"LimitRange\",\n  \"apiVersion\": \"v1beta1\",\n  \"spec\": {\n    \"limits\": [\n    {\n      \"type\": \"Pod\",\n      \"max\": {\n        \"memory\": \"1073741824\",\n        \"cpu\": \"2\",\n      },\n      \"min\": {\n        \"memory\": \"1048576\",\n        \"cpu\": \"0.25\"\n      }\n    },\n    {\n      \"type\": \"openshift.com/ShinyThing\",\n      \"max\": {\n        \"openshift.com/ShinyThingProperty\": \"5\",\n    },\n    ],\n  }\n}\n```\n\nAnd enforcement of \"openshift.com/ShinyThing\" would happen in a separate LimitRange admission control plug-in for OpenShift, but from CLI, I would have a single resource to view my min/max constraints.\n",
        "createdAt" : "2015-01-26T21:20:42Z",
        "updatedAt" : "2015-01-27T21:55:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "e1c24697-277c-4ab6-bde4-8ac2a83fc0fd",
        "parentId" : "eb1c6efc-89aa-4de5-8af9-65801568110b",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I see.  But, if someone is not aware of the OpenShiftLimitRange plugin, and they are just using LimitRange plugin, and they create a LimitRange object with some other resource type, then won't they be confused that nothing happens?  Or should they just RTFM?\n",
        "createdAt" : "2015-01-27T00:25:49Z",
        "updatedAt" : "2015-01-27T21:55:19Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "9ba0b225-7f68-46b9-9c9c-0c2ab92353c7",
        "parentId" : "eb1c6efc-89aa-4de5-8af9-65801568110b",
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "Yep - RTFM \n\n> On Jan 26, 2015, at 7:26 PM, Eric Tune notifications@github.com wrote:\n> \n> In pkg/api/validation/validation.go:\n> \n> > -       allErrs = append(allErrs, errs.NewFieldInvalid(\"name\", limitRange.Name, \"\"))\n> > -   }\n> > -   if len(limitRange.Namespace) == 0 {\n> > -       allErrs = append(allErrs, errs.NewFieldRequired(\"namespace\", limitRange.Namespace))\n> > -   } else if !util.IsDNSSubdomain(limitRange.Namespace) {\n> > -       allErrs = append(allErrs, errs.NewFieldInvalid(\"namespace\", limitRange.Namespace, \"\"))\n> > -   }\n> > -   // ensure resource names are properly qualified per docs/resources.md\n> > -   for i := range limitRange.Spec.Limits {\n> > -       limit := limitRange.Spec.Limits[i]\n> > -       for k := range limit.Max {\n> > -           allErrs = append(allErrs, ValidateResourceName(string(k))...)\n> > -       }\n> > -       for k := range limit.Min {\n> > -           allErrs = append(allErrs, ValidateResourceName(string(k))...)\n> > -       }\n> >   I see. But, if someone is not aware of the OpenShiftLimitRange plugin, and they are just using LimitRange plugin, and they create a LimitRange object with some other resource type, then won't they be confused that nothing happens? Or should they just RTFM?\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-01-27T02:02:40Z",
        "updatedAt" : "2015-01-27T21:55:19Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      }
    ],
    "commit" : "b19a8a61a86e0ffefb9d94fb39a54d92e134bfbf",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +663,667 @@\t\tfor k := range limit.Min {\n\t\t\tallErrs = append(allErrs, ValidateResourceName(string(k))...)\n\t\t}\n\t}\n\treturn allErrs"
  },
  {
    "id" : "4813dbda-ff67-4c14-bb65-ac7fad21f51c",
    "prId" : 3587,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58e01d6d-a162-43a6-9ca7-39da64421bdc",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "cleaner as switch() with default being the error?\n",
        "createdAt" : "2015-01-18T04:29:44Z",
        "updatedAt" : "2015-01-20T19:54:34Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "a98eb924-ef80-455e-b875-ade4a0ad37a8",
        "parentId" : "58e01d6d-a162-43a6-9ca7-39da64421bdc",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "poking this comment\n",
        "createdAt" : "2015-01-21T01:13:29Z",
        "updatedAt" : "2015-01-21T01:13:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ac7d6973-93f4-4456-a4f1-3d75779d977d",
        "parentId" : "58e01d6d-a162-43a6-9ca7-39da64421bdc",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "Ahh, missed this one. Will update this. \n",
        "createdAt" : "2015-01-21T01:15:09Z",
        "updatedAt" : "2015-01-21T01:15:09Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      }
    ],
    "commit" : "92ff4cd2b1ff18d0d958f074e46e47e134cf7cb8",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +281,285 @@\t\t}\n\t}\n\tif ctr.ImagePullPolicy != api.PullAlways &&\n\t\tctr.ImagePullPolicy != api.PullIfNotPresent &&\n\t\tctr.ImagePullPolicy != api.PullNever {"
  },
  {
    "id" : "0f8e514c-d3fd-420b-8667-9f5fcd9b3481",
    "prId" : 2893,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52eed8a5-64ef-41f8-8c9e-6ebd3f19b29f",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "Why won't DeepEqual() return false if Spec.Capacity is different?\n",
        "createdAt" : "2014-12-12T21:19:58Z",
        "updatedAt" : "2014-12-18T05:50:42Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "57811f4d-3fe7-4464-a1b0-034ce38e38b5",
        "parentId" : "52eed8a5-64ef-41f8-8c9e-6ebd3f19b29f",
        "authorId" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "body" : "DeepDqual() will return false if Spec.Capacity is different, that's why it's overwrite oldMinion to allow updating capacity.\n",
        "createdAt" : "2014-12-13T00:38:25Z",
        "updatedAt" : "2014-12-18T05:50:42Z",
        "lastEditedBy" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "tags" : [
        ]
      },
      {
        "id" : "0daec7c9-b6c5-4165-a3e5-ad555c7df627",
        "parentId" : "52eed8a5-64ef-41f8-8c9e-6ebd3f19b29f",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Yep, as Deyuan says, we overwrite oldMinion to allow capacity updating.\n",
        "createdAt" : "2014-12-15T18:19:38Z",
        "updatedAt" : "2014-12-18T05:50:42Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf0b41535fed9128645c124fdf45fa0ae8419367",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +577,581 @@\toldMinion.Spec.Capacity = minion.Spec.Capacity\n\n\tif !reflect.DeepEqual(oldMinion, minion) {\n\t\tglog.V(4).Infof(\"Update failed validation %#v vs %#v\", oldMinion, minion)\n\t\tallErrs = append(allErrs, fmt.Errorf(\"update contains more than labels or capacity changes\"))"
  },
  {
    "id" : "64521336-220f-4a05-aa75-81eec459d745",
    "prId" : 2224,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bdc6018c-ffd8-49f0-9048-3b0f8a401db1",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "// TODO: Move this default setting out of the validation function once there's a home for it.\n",
        "createdAt" : "2014-12-24T00:49:47Z",
        "updatedAt" : "2014-12-29T17:18:18Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "13a89de1-b109-40fb-a9b0-9908dd1e513a",
        "parentId" : "bdc6018c-ffd8-49f0-9048-3b0f8a401db1",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "so noted\n",
        "createdAt" : "2014-12-24T01:05:03Z",
        "updatedAt" : "2014-12-29T17:18:18Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "32a59477a5a39647bd6519446a393fb02c9bf95e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +357,361 @@\tcase \"\":\n\t\t// TODO: move this out to standard defaulting logic, when that is ready.\n\t\t*dnsPolicy = api.DNSClusterFirst // Default value.\n\tcase api.DNSClusterFirst, api.DNSDefault:\n\t\tbreak"
  },
  {
    "id" : "3c268750-5147-41b3-b6e7-1340ae07349e",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "288e4e2c-3eee-4d6d-b252-3bd63b083f76",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@brendandburns, reviewers: how did this get in. We shot this down in https://github.com/GoogleCloudPlatform/kubernetes/pull/1264#discussion_r17396033; no cluster-wide constraint should be checked by validation! No RPCs or things that look like RPCs should be performed by validation!\n",
        "createdAt" : "2014-11-18T22:57:45Z",
        "updatedAt" : "2014-11-18T22:57:45Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "95a9c69d-2f24-49dd-8159-280b8a9531f9",
        "parentId" : "288e4e2c-3eee-4d6d-b252-3bd63b083f76",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Filed #2457\n",
        "createdAt" : "2014-11-18T23:02:01Z",
        "updatedAt" : "2014-11-18T23:02:01Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "f556f2f82f198bfd5c30704a000c183e8101c7c8",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +388,392 @@\n// ValidateService tests if required fields in the service are set.\nfunc ValidateService(service *api.Service, lister ServiceLister, ctx api.Context) errs.ValidationErrorList {\n\tallErrs := errs.ValidationErrorList{}\n\tif len(service.Name) == 0 {"
  },
  {
    "id" : "4fbf2ad7-94df-4038-a22d-bb8da8537d58",
    "prId" : 1830,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b3b0b01-598e-45f6-9ddc-b74957ebe02c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "How about Annotations?\n",
        "createdAt" : "2014-10-23T16:30:08Z",
        "updatedAt" : "2014-10-24T20:04:15Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "e2365b1f963d9b86ebda50e34b5ebfec20328a27",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +405,409 @@\t}\n\tallErrs = append(allErrs, validateLabels(service.Labels)...)\n\tallErrs = append(allErrs, validateLabels(service.Selector)...)\n\treturn allErrs\n}"
  }
]
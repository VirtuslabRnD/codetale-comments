[
  {
    "id" : "d5fa767b-6f85-492e-940f-1c9f0536ac0c",
    "prId" : 67622,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/67622#pullrequestreview-150409402",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "657d98d9-5256-4d30-9e0e-86c298ae64cc",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "@thockin since ports for headless service dont make sense, are we at some point also going to throw validation errors ? Its not backward compatible i guess but if there is a way to deprecate and eventually not allow that, it will be helpful",
        "createdAt" : "2018-08-29T05:48:13Z",
        "updatedAt" : "2018-08-29T05:48:13Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      }
    ],
    "commit" : "06b785ca5286c08592d50b4c0a4fe5b63e5040d6",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +41,45 @@\t\tif len(subsets[i].Ports) == 0 {\n\t\t\t// Don't discard endpoints with no ports defined, use a sentinel.\n\t\t\tmapAddressesByPort(&subsets[i], api.EndpointPort{Port: -1}, allAddrs, portToAddrReadyMap)\n\t\t} else {\n\t\t\tfor _, port := range subsets[i].Ports {"
  },
  {
    "id" : "350ef787-7926-45e7-a665-47b25b084d2f",
    "prId" : 24362,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3027e9f0-5435-4542-b2ee-e7139545ee69",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Also TODO the HostRecord struct\n",
        "createdAt" : "2016-04-27T05:50:53Z",
        "updatedAt" : "2016-04-28T17:57:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "0642e228-fdad-4085-b595-7d74acd145be",
        "parentId" : "3027e9f0-5435-4542-b2ee-e7139545ee69",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "Done.\n",
        "createdAt" : "2016-04-27T17:56:13Z",
        "updatedAt" : "2016-04-28T17:57:24Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a3ed48808185ec410a7450796da790790e1d3bd",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +30,34 @@\nconst (\n\t// TODO: to be deleted after v1.3 is released\n\t// Its value is the json representation of map[string(IP)][HostRecord]\n\t// example: '{\"10.245.1.6\":{\"HostName\":\"my-webserver\"}}'"
  },
  {
    "id" : "b86ba6c4-fd09-4cd2-bece-4fdf3c51f3ae",
    "prId" : 13778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2069dca9-8398-4242-b176-c1743e9e9ae1",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "it feels like there is a lot of code duplication here with what is in subsets[i].Addresses, would be good if we could somehow make something common.\n",
        "createdAt" : "2015-09-11T18:18:10Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "9d6e3563-d7cb-4366-8d53-91bd80467d83",
        "parentId" : "2069dca9-8398-4242-b176-c1743e9e9ae1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Ok\n",
        "createdAt" : "2015-09-11T18:33:44Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "72b9818c-6449-40fc-949e-45982bfdf327",
        "parentId" : "2069dca9-8398-4242-b176-c1743e9e9ae1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Removed duplication, also added comment that NotReady trumps Ready if we\nsee the same address twice.\n\nOn Fri, Sep 11, 2015 at 2:18 PM, Derek Carr notifications@github.com\nwrote:\n\n> In pkg/api/endpoints/util.go\n> https://github.com/kubernetes/kubernetes/pull/13778#discussion_r39300442\n> :\n> \n> > @@ -64,12 +65,37 @@ func RepackSubsets(subsets []api.EndpointSubset) []api.EndpointSubset {\n> >                 }\n> >                 portsToAddrs[*epp].Insert(allAddrs[ak])\n> >             }\n> > -           for k := range subsets[i].NotReadyAddresses {\n> \n> it feels like there is a lot of code duplication here with what is in\n> subsets[i].Addresses, would be good if we could somehow make something\n> common.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13778/files#r39300442.\n\n## \n\nClayton Coleman | Lead Engineer, OpenShift\n",
        "createdAt" : "2015-09-11T20:47:22Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf2decce817e00ec8646811c4a755797f450811e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +43,47 @@\t\t\t\tmapAddressByPort(&subsets[i].Addresses[k], port, true, allAddrs, portToAddrReadyMap)\n\t\t\t}\n\t\t\tfor k := range subsets[i].NotReadyAddresses {\n\t\t\t\tmapAddressByPort(&subsets[i].NotReadyAddresses[k], port, false, allAddrs, portToAddrReadyMap)\n\t\t\t}"
  },
  {
    "id" : "13195e37-f65a-4056-90b1-037ffcd803b7",
    "prId" : 13778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "be19fe99-2e89-461d-a2c7-c2265217b658",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It's unique ports here, but when we divvy by subsets we allocate by unique\nhost ready status.  But this we originally Tims code and I may be missing a\ncase that could be simplfied\n\nOn Sep 15, 2015, at 10:28 PM, Abhi Shah notifications@github.com wrote:\n\nIn pkg/api/endpoints/util.go\nhttps://github.com/kubernetes/kubernetes/pull/13778#discussion_r39588390:\n\n>   }\n> \n>   // Finally, sort it.\n>   return SortSubsets(final)\n>  }\n> \n> -type addressSet map[*api.EndpointAddress]struct{}\n> +// The sets of hosts must be de-duped, using IP+UID as the key.\n> +type addressKey struct {\n\nI think we should just get rid of addressKey and use the endpointAddress as\nthe key itself.\nWe are inconsistent in the code here. we use addressKey in the map, but not\nduring hash generation of the address set.\nWe should be consistent.\n\n—\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/13778/files#r39588390.\n",
        "createdAt" : "2015-09-16T02:46:33Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "2040e4a5-1cea-435c-b031-8a7435a2767c",
        "parentId" : "be19fe99-2e89-461d-a2c7-c2265217b658",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "So this is a question for Tim - Tim, why do we want to preserve duplicate IPs that come from different target refs?  That's what addressKey provides\n",
        "createdAt" : "2015-09-16T19:11:52Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a17f3102-d1b0-474a-a6f5-9f5551a93831",
        "parentId" : "be19fe99-2e89-461d-a2c7-c2265217b658",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "i think it probably covers the case where docker subnet is the same on different nodes.\n",
        "createdAt" : "2015-09-16T22:02:22Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      },
      {
        "id" : "caea5d91-3237-4193-97c6-d66deab3945d",
        "parentId" : "be19fe99-2e89-461d-a2c7-c2265217b658",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Mesos.  Their IPs end up being the node's IP, but the pods are different.\n\nOn Wed, Sep 16, 2015 at 12:12 PM, Clayton Coleman notifications@github.com\nwrote:\n\n> In pkg/api/endpoints/util.go\n> https://github.com/kubernetes/kubernetes/pull/13778#discussion_r39672451\n> :\n> \n> > ```\n> > }\n> > \n> > // Finally, sort it.\n> > return SortSubsets(final)\n> > ```\n> > \n> >  }\n> > \n> > -type addressSet map[*api.EndpointAddress]struct{}\n> > +// The sets of hosts must be de-duped, using IP+UID as the key.\n> > +type addressKey struct {\n> \n> So this is a question for Tim - Tim, why do we want to preserve duplicate\n> IPs that come from different target refs? That's what addressKey provides\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/13778/files#r39672451.\n",
        "createdAt" : "2015-09-16T23:15:13Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d29fd89c-7b60-4277-b941-bac5c94262a7",
        "parentId" : "be19fe99-2e89-461d-a2c7-c2265217b658",
        "authorId" : "ef33f76a-ca59-4720-94a5-47e86994ee8d",
        "body" : "What @thockin said. On Mesos, Pod address is not a unique identifier (at least until IP per task is supported). address + port should be unique tho. There were a bunch of e2e tests we fixed recently that made this assumption too. \n",
        "createdAt" : "2015-09-17T03:06:00Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "ef33f76a-ca59-4720-94a5-47e86994ee8d",
        "tags" : [
        ]
      },
      {
        "id" : "943d4377-6134-4e18-99d8-04e0412aec56",
        "parentId" : "be19fe99-2e89-461d-a2c7-c2265217b658",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Ok, added very explicit comment\n\nOn Sep 16, 2015, at 11:06 PM, Karl Isenberg notifications@github.com\nwrote:\n\nIn pkg/api/endpoints/util.go\nhttps://github.com/kubernetes/kubernetes/pull/13778#discussion_r39708189:\n\n>   }\n> \n>   // Finally, sort it.\n>   return SortSubsets(final)\n>  }\n> \n> -type addressSet map[*api.EndpointAddress]struct{}\n> +// The sets of hosts must be de-duped, using IP+UID as the key.\n> +type addressKey struct {\n\nWhat @thockin https://github.com/thockin said. On Mesos, Pod address is\nnot a unique identifier (at least until IP per task is supported). address\n- port should be unique tho. There were a bunch of e2e tests we fixed\n  recently that made this assumption too.\n\n—\nReply to this email directly or view it on GitHub\nhttps://github.com/kubernetes/kubernetes/pull/13778/files#r39708189.\n",
        "createdAt" : "2015-09-17T03:52:58Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf2decce817e00ec8646811c4a755797f450811e",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +81,85 @@\n// The sets of hosts must be de-duped, using IP+UID as the key.\ntype addressKey struct {\n\tip  string\n\tuid types.UID"
  },
  {
    "id" : "69d13a94-1a60-4850-b6b8-6f0df369d2fa",
    "prId" : 13778,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72b08998-376f-4a6c-b17e-6631e3938c9d",
        "parentId" : null,
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "// RepackSubsets takes a slice of EndpointSubset objects, expands it to the full\n// representation, and then repacks that into the canonical layout.  This\n// ensures that code which operates on these objects can rely on the common\n// form for things like comparison.  The result is a newly allocated slice.\nfunc RepackSubsets(subsets []api.EndpointSubset) []api.EndpointSubset {\n    // First map each unique port definition to the sets of hosts that\n    // offer it.\n    allAddrs := map[addressKey]*api.EndpointAddress{}\n    portToAddrReadyMap := map[api.EndpointPort]addressReadyMap{}\n    for i := range subsets {\n        for j := range subsets[i].Ports {\n            epp := subsets[i].Ports[j]\n            for k := range subsets[i].Addresses {\n                joinAddress(&subsets[i].Addresses[k], epp, true, allAddrs, portToAddrReadyMap)\n            }\n            for k := range subsets[i].NotReadyAddresses {\n                joinAddress(&subsets[i].NotReadyAddresses[k], epp, false, allAddrs, portToAddrReadyMap)\n            }\n        }\n    }\n\n```\n// Next, map the sets of hosts to the sets of ports they offer.\n// Go does not allow maps or slices as keys to maps, so we have\n// to synthesize an artificial key and do a sort of 2-part\n// associative entity.\ntype keyString string\nkeyToAddrReadyMap := map[keyString]addressReadyMap{}\naddrReadyMapKeyToPorts := map[keyString][]api.EndpointPort{}\nfor epp, addrReadyMap := range portToAddrReadyMap {\n    addrReadyMapKey := keyString(hashAddresses(addrReadyMap))\n    keyToAddrReadyMap[addrReadyMapKey] = addrReadyMap\n    addrReadyMapKeyToPorts[addrReadyMapKey] = append(addrReadyMapKeyToPorts[addrReadyMapKey], epp)\n}\n\n// Next, build the N-to-M association the API wants.\nfinal := []api.EndpointSubset{}\nfor addrReadyMapKey, ports := range addrReadyMapKeyToPorts {\n    var addrs, notReadyAddrs []api.EndpointAddress\n    for address, addrReady := range keyToAddrReadyMap[addrReadyMapKey] {\n        if addrReady {\n            addrs = append(addrs, *address)\n        } else {\n            notReadyAddrs = append(notReadyAddrs, *address)\n        }\n    }\n    final = append(final, api.EndpointSubset{Addresses: addrs, NotReadyAddresses: notReadyAddrs, Ports: ports})\n}\n\n// Finally, sort it.\nreturn SortSubsets(final)\n```\n\n}\n",
        "createdAt" : "2015-09-16T22:37:18Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      },
      {
        "id" : "30e78558-afaa-4156-b151-77945b335b72",
        "parentId" : "72b08998-376f-4a6c-b17e-6631e3938c9d",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "I have re-written the function with better variable names.\ncan you use this ?\n",
        "createdAt" : "2015-09-16T22:38:21Z",
        "updatedAt" : "2015-09-17T13:40:25Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf2decce817e00ec8646811c4a755797f450811e",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +33,37 @@// ensures that code which operates on these objects can rely on the common\n// form for things like comparison.  The result is a newly allocated slice.\nfunc RepackSubsets(subsets []api.EndpointSubset) []api.EndpointSubset {\n\t// First map each unique port definition to the sets of hosts that\n\t// offer it."
  },
  {
    "id" : "5e2016c4-06fa-4d34-91d6-7c9e20bf4a1f",
    "prId" : 10390,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a2c4782-cab0-49e6-bf3e-d27fa04f4901",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This needs unit tests to demonstrate the expected behavior and ensure it stays working.\n",
        "createdAt" : "2015-06-27T03:50:10Z",
        "updatedAt" : "2015-08-07T06:35:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "7f9ab8a0-e3ef-404e-b2f5-f29c6793563f",
        "parentId" : "7a2c4782-cab0-49e6-bf3e-d27fa04f4901",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Of course this needs proper test cases. Will add them.\n",
        "createdAt" : "2015-06-27T10:02:52Z",
        "updatedAt" : "2015-08-07T06:35:29Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "d38fe097-1d44-4ad8-85e0-20d3629ba605",
        "parentId" : "7a2c4782-cab0-49e6-bf3e-d27fa04f4901",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Added a number of unit test cases with uids.\n",
        "createdAt" : "2015-06-29T10:29:37Z",
        "updatedAt" : "2015-08-07T06:35:29Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "79e54c26793495be7f8b63888ce1192e9fe270b4",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +36,40 @@\t// First map each unique port definition to the sets of hosts that\n\t// offer it.  The sets of hosts must be de-duped, using IP+UID as the key.\n\ttype addressKey struct {\n\t\tip  string\n\t\tuid types.UID"
  },
  {
    "id" : "acde2504-14da-4491-b4b0-07484227ff22",
    "prId" : 5939,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Go question: Why not loop over the values instead of the keys?\n",
        "createdAt" : "2015-03-27T04:35:21Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "e6a009df-96ff-423a-a834-fb805fa3f552",
        "parentId" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "authorId" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "body" : "I think this is to avoid copying. The `range` construct has copy semantics.\n",
        "createdAt" : "2015-03-27T04:48:44Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "tags" : [
        ]
      },
      {
        "id" : "a1cb374b-3283-44d8-aa65-04bcee16e05f",
        "parentId" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Looping over values causes copies.  Basically, any time there's a map or\nslice where the value is anything but a primitive type you incur totally\npointless copies.  Go just encourages you to piss away your performance.\n\nI asked them about this once and they simply said, \"yeah, just iterate\nslices in the C style, with a pointer to the current element\".  So that's\nthe pattern I follow everywhere except test code where it doesn't matter.\n\nIn short `map[anything]struct` and `for x, y := range slice` are traps.\n\nOn Thu, Mar 26, 2015 at 9:35 PM, Brian Grant notifications@github.com\nwrote:\n\n> In pkg/api/endpoints/util.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5939#discussion_r27275581\n> :\n> \n> > +)\n> > +\n> > +// RepackSubsets takes a slice of EndpointSubset objects, expands it to the full\n> > +// representation, and then repacks that into the canonical layout.  This\n> > +// ensures that code which operates on these objects can rely on the common\n> > +// form for things like comparison.  The result is a newly allocated slice.\n> > +func RepackSubsets(subsets []api.EndpointSubset) []api.EndpointSubset {\n> > -   // First map each unique port definition to the sets of hosts that\n> > -   // offer it.  The sets of hosts must be de-duped, using IP as the key.\n> > -   type ipString string\n> > -   allAddrs := map[ipString]*api.EndpointAddress{}\n> > -   portsToAddrs := map[api.EndpointPort]addressSet{}\n> > -   for i := range subsets {\n> > -       for j := range subsets[i].Ports {\n> > -           epp := &subsets[i].Ports[j]\n> > -           for k := range subsets[i].Addresses {\n> \n> Go question: Why not loop over the values instead of the keys?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5939/files#r27275581\n> .\n",
        "createdAt" : "2015-03-27T04:52:52Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "eaea49d9-eeb5-4d2a-9dd0-93931b7dfc8b",
        "parentId" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "authorId" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "body" : "Where is `for (const auto& kv` when you need it? Although you need `for (auto& kv`.\n",
        "createdAt" : "2015-03-27T05:00:24Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "9d07de69-76c2-43bd-9590-55d9aded200d",
        "tags" : [
        ]
      },
      {
        "id" : "f2bff0d3-6551-434e-a6e4-b603330fe745",
        "parentId" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "srsly, go need to offer iterate by ref.\n\nOn Thu, Mar 26, 2015 at 10:00 PM, Satnam Singh notifications@github.com\nwrote:\n\n> In pkg/api/endpoints/util.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5939#discussion_r27276121\n> :\n> \n> > +)\n> > +\n> > +// RepackSubsets takes a slice of EndpointSubset objects, expands it to the full\n> > +// representation, and then repacks that into the canonical layout.  This\n> > +// ensures that code which operates on these objects can rely on the common\n> > +// form for things like comparison.  The result is a newly allocated slice.\n> > +func RepackSubsets(subsets []api.EndpointSubset) []api.EndpointSubset {\n> > -   // First map each unique port definition to the sets of hosts that\n> > -   // offer it.  The sets of hosts must be de-duped, using IP as the key.\n> > -   type ipString string\n> > -   allAddrs := map[ipString]*api.EndpointAddress{}\n> > -   portsToAddrs := map[api.EndpointPort]addressSet{}\n> > -   for i := range subsets {\n> > -       for j := range subsets[i].Ports {\n> > -           epp := &subsets[i].Ports[j]\n> > -           for k := range subsets[i].Addresses {\n> \n> Where is for (const auto& kv when you need it.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5939/files#r27276121\n> .\n",
        "createdAt" : "2015-03-27T05:02:49Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ec539174-a92d-4ca5-8f93-91c4c6d25e15",
        "parentId" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Ok, but I'll point out that the code a few lines below goes out of its way to copy every value.\n",
        "createdAt" : "2015-03-27T06:13:12Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "7c911e1f-a1a1-41ef-9845-fc661fb71c18",
        "parentId" : "d06af0d1-103e-4f70-8f52-a07ffc66ebee",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Go logic - the copy that is made on each loop has the same address, so I would need to make TWO copies in order to save one.\n",
        "createdAt" : "2015-03-27T18:29:09Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ae203825b3b28c45ac7d23f3d107c66df9dad7c",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@\t\tfor j := range subsets[i].Ports {\n\t\t\tepp := &subsets[i].Ports[j]\n\t\t\tfor k := range subsets[i].Addresses {\n\t\t\t\tepa := &subsets[i].Addresses[k]\n\t\t\t\tipstr := ipString(epa.IP)"
  },
  {
    "id" : "126b11ef-4e52-4ff3-b08c-9b2ba69481c7",
    "prId" : 5939,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f783c31e-8747-43d3-88c1-dc24781ce76c",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Is this really better than DeepCopy?\n",
        "createdAt" : "2015-03-27T05:05:14Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "8412cc3b-eab8-452e-a79b-705328f23610",
        "parentId" : "f783c31e-8747-43d3-88c1-dc24781ce76c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "What is DeepCopy?  I find no such anything in our tree or in go's libs.\nSadly, this is just something go does not handle well.  No such thing as a\ncopy-ctor\n\nOn Thu, Mar 26, 2015 at 10:05 PM, Brian Grant notifications@github.com\nwrote:\n\n> In pkg/api/endpoints/util.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5939#discussion_r27276206\n> :\n> \n> > -   type ipString string\n> > -   allAddrs := map[ipString]*api.EndpointAddress{}\n> > -   portsToAddrs := map[api.EndpointPort]addressSet{}\n> > -   for i := range subsets {\n> > -       for j := range subsets[i].Ports {\n> > -           epp := &subsets[i].Ports[j]\n> > -           for k := range subsets[i].Addresses {\n> > -               epa := &subsets[i].Addresses[k]\n> > -               ipstr := ipString(epa.IP)\n> > -               // Accumulate the most \"complete\" address we can.\n> > -               if allAddrs[ipstr] == nil {\n> > -                   // Make a copy so we don't write to the\n> > -                   // input args of this function.\n> > -                   p := &api.EndpointAddress{}\n> > -                   *p = *epa\n> > -                   allAddrs[ipstr] = p\n> \n> Is this really better than DeepCopy?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5939/files#r27276206\n> .\n",
        "createdAt" : "2015-03-27T05:08:53Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "858c5734-63dc-4ca3-ba71-7cb8ab57c382",
        "parentId" : "f783c31e-8747-43d3-88c1-dc24781ce76c",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Sorry, nevermind. I thought I'd seen one, but it's not part of the standard library.\n",
        "createdAt" : "2015-03-27T06:07:50Z",
        "updatedAt" : "2015-03-27T19:36:49Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ae203825b3b28c45ac7d23f3d107c66df9dad7c",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +50,54 @@\t\t\t\t\tp := &api.EndpointAddress{}\n\t\t\t\t\t*p = *epa\n\t\t\t\t\tallAddrs[ipstr] = p\n\t\t\t\t} else if allAddrs[ipstr].TargetRef == nil {\n\t\t\t\t\tallAddrs[ipstr].TargetRef = epa.TargetRef"
  }
]
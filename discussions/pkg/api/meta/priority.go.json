[
  {
    "id" : "449fe534-8bf5-4a6c-b500-2c6aa452f639",
    "prId" : 28512,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98a7e950-65f4-45a4-a0e2-5bf559a690e6",
        "parentId" : null,
        "authorId" : "ffc157a5-b8d0-4a06-b942-f8e5150e4215",
        "body" : "small detail but this could be moved to before the `if` when you declare the var\n",
        "createdAt" : "2016-07-07T00:24:05Z",
        "updatedAt" : "2016-07-14T01:19:11Z",
        "lastEditedBy" : "ffc157a5-b8d0-4a06-b942-f8e5150e4215",
        "tags" : [
        ]
      },
      {
        "id" : "e0998218-8a59-4035-8303-7a70be79825c",
        "parentId" : "98a7e950-65f4-45a4-a0e2-5bf559a690e6",
        "authorId" : "ffc157a5-b8d0-4a06-b942-f8e5150e4215",
        "body" : "actually you could even remove the `if/else` and set the initial value of priorities to `m.KindPriority` like:\n\n``` go\npriorities := m.KindPriority\nfor _, version := range versions {\n    gv, err := unversioned.ParseGroupVersion(version)\n    if err != nil {\n        return nil, err\n    }\n    priorities = append(priorities, gv.WithKind(AnyKind))\n}\n```\n\nwhich simplifies a bit of this logic and makes it easier to read\n",
        "createdAt" : "2016-07-07T00:27:18Z",
        "updatedAt" : "2016-07-14T01:19:11Z",
        "lastEditedBy" : "ffc157a5-b8d0-4a06-b942-f8e5150e4215",
        "tags" : [
        ]
      },
      {
        "id" : "4bff7628-42a3-40a3-89f1-0696ecca02cf",
        "parentId" : "98a7e950-65f4-45a4-a0e2-5bf559a690e6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Simplified it with an initializer, but version priorities need to go before the innate priorities.\n",
        "createdAt" : "2016-07-12T05:01:28Z",
        "updatedAt" : "2016-07-14T01:19:11Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "c077bac34153c89c42517fdff1f389b3b5effd31",
    "line" : null,
    "diffHunk" : "@@ -1,1 +162,166 @@\tpriorities := m.KindPriority\n\tif len(versions) > 0 {\n\t\tpriorities = make([]unversioned.GroupVersionKind, 0, len(m.KindPriority)+len(versions))\n\t\tfor _, version := range versions {\n\t\t\tgv, err := unversioned.ParseGroupVersion(version)"
  },
  {
    "id" : "65a38d63-5155-4595-aac1-34bb03e9bb55",
    "prId" : 28512,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "46d3e98d-9285-4f1d-a56e-817f386dd83e",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Should be able to return early with one match here, right?\n",
        "createdAt" : "2016-07-13T13:40:01Z",
        "updatedAt" : "2016-07-14T01:19:11Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "a174a226-2f06-433f-9ac7-cc91a0faee49",
        "parentId" : "46d3e98d-9285-4f1d-a56e-817f386dd83e",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah, does it make the method less readable or more?\n",
        "createdAt" : "2016-07-13T14:23:33Z",
        "updatedAt" : "2016-07-14T01:19:11Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "18d84f85-a8e3-41c6-8abb-2050076cfc23",
        "parentId" : "46d3e98d-9285-4f1d-a56e-817f386dd83e",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Yeah, does it make the method less readable or more?\n\nI like it better, but I won't require it.\n",
        "createdAt" : "2016-07-13T17:04:35Z",
        "updatedAt" : "2016-07-14T01:19:11Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "c077bac34153c89c42517fdff1f389b3b5effd31",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +157,161 @@\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// any versions the user provides take priority"
  },
  {
    "id" : "7f565d0a-7214-4546-95fa-a382b21c8eec",
    "prId" : 21272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Perhaps we should add to the comment that users should put the more specific patterns before the more generic patterns, otherwise the more specific patterns won't be effective.\nFor example, if in general I prefer group A over group B, but for a specific resource R, I prefer group B over group A, I need to make sure the pattern for R is before the general pattern in this list.\n",
        "createdAt" : "2016-02-17T19:43:43Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "c5cde73f-1015-4a72-930d-df03f52e59af",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Perhaps we should add to the comment that users should put the more specific patterns before the more generic patterns\n\nI'm not sure that's right.  They need higher priority ones first, but less specificity does make sense in some cases.  For instance, if your example had A, B, and C, but in the case of resource R, I want A/R, C/R, B/R, then I still logically want A (less specific) to come first.\n",
        "createdAt" : "2016-02-17T19:46:38Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "2990fb9a-8c5a-4aa6-85f8-da1811238c77",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "You are right, I need to narrow down my statement.\nAnyway, do you think it will be a burden to reason about the rules? Just thinking out loud, perhaps we can split the rules to two sets, one set for resource-specific rules, and the other set for non-resource-specific rules, and the former set of rules always takes precedence. This might make the reasoning of rules easier. And for the efficiency, we can make the resource-specific set a map. Overall, the matching process will converge quicker than the current design. This might be an overkill, I just want to explore alternative designs.\n",
        "createdAt" : "2016-02-17T21:32:56Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "4656a06c-0365-474e-b6d8-db96c39a6122",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I don't know that I would start by trying to split these into classes.  I think I would probably expose the patterns in some sort of user config.  Then build the `PriorityRESTMapper` with their choices first and the order from the discover doc (including preferred versions first followed by all versions) second.\n\nThat way the users only end up focusing on their special cases instead of messing with everything.\n",
        "createdAt" : "2016-02-17T21:53:50Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "9efdae68-86d3-4b1d-9b24-eda5205b8576",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "So we don't allow user to specify general rules (like favor Group B over Group A) in user config? I think we should allow it.\n",
        "createdAt" : "2016-02-18T00:25:15Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "bba69abf-2f0d-4b3f-8eb6-7de3880cca38",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "> I'm not sure that's right. They need higher priority ones first, but less specificity does make sense in some cases. For instance, if your example had A, B, and C, but in the case of resource R, I want A/R, C/R, B/R, then I still logically want A (less specific) to come first.\n\nReflecting on the comment above, I think we need the following 2 rules:\n1. if user specifies a special case for a resource, he needs to specify the patterns for all the possible groups. In the example used in the comment above, user needs to specify 3 patterns: A/R, C/R, B/R, (instead of only C/R, B/R);\n2. more specific rules need to come first in the list. So in the example above, the merged rules will be (A/R, C/R, B/R, A, B, C)\n\nWithout rule 1, you will have ambiguity when merging user config with discover doc.\n",
        "createdAt" : "2016-02-18T00:36:57Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "6d555ffa-418d-4d1a-ac60-0b71cc4f15a5",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I should have qualified that users can specify whatever patterns they like.  As long as we append discovery information after user information, I think we'll always end up with expected behavior.\n",
        "createdAt" : "2016-02-18T01:17:01Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "07809aca-d7a1-49f9-a8a3-08dd3418da84",
        "parentId" : "5281accf-22ce-4f54-87a3-4cb0a3e8f11f",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Thanks for the clarification. My point is if the server default order is A, B, C, and the order user wants is A/R, C/R, B/R, then the user needs to specify A/R, C/R, B/R, or A, C/R, B/R, rather than C/R, B/R alone and hoping the merger will get it right. This doesn't appear obvious to me. Anyway, this is a digression, I'll bring this up when we reach there.\n",
        "createdAt" : "2016-02-18T04:53:47Z",
        "updatedAt" : "2016-02-25T12:35:27Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf6234d219894916b9a67cc3a85e894c690d93d9",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +40,44 @@\t// A pattern with no matches is skipped.  A pattern with more than one match uses its\n\t// matches as the list to continue matching against.\n\tResourcePriority []unversioned.GroupVersionResource\n\n\t// KindPriority is a list of priority patterns to apply to matching kinds."
  }
]
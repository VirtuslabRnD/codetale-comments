[
  {
    "id" : "f42aacfc-2c0d-43fd-a1a8-13a2ae214285",
    "prId" : 27567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d68ebff-b221-4e34-ba99-ead618c0318b",
        "parentId" : null,
        "authorId" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "body" : "what kind of error this function might return?\n",
        "createdAt" : "2016-06-20T22:49:01Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "44594ff0-8fbc-44a7-84f9-654ffd54270f",
        "tags" : [
        ]
      },
      {
        "id" : "3770d353-4af0-4016-a725-748c60c98853",
        "parentId" : "9d68ebff-b221-4e34-ba99-ead618c0318b",
        "authorId" : "8e448017-7838-493d-a424-33cada0da657",
        "body" : "This is generated code. No need to review.\n",
        "createdAt" : "2016-06-21T00:55:17Z",
        "updatedAt" : "2016-06-21T01:20:41Z",
        "lastEditedBy" : "8e448017-7838-493d-a424-33cada0da657",
        "tags" : [
        ]
      }
    ],
    "commit" : "e716ddc771be0b4314590ca924547ab74b2ff684",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +230,234 @@}\n\nfunc DeepCopy_api_AttachedVolume(in AttachedVolume, out *AttachedVolume, c *conversion.Cloner) error {\n\tout.Name = in.Name\n\tout.DevicePath = in.DevicePath"
  },
  {
    "id" : "56609067-f8b6-4432-92e2-4813d6e07807",
    "prId" : 22985,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e039f94f-1f37-4cf6-b5e5-e24e5ba56f66",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "I'm not an api-server expert, but can't you just block copy *annotations?  Do we need deep full type-checking on every copy operation?  Seems expensive.  \n",
        "createdAt" : "2016-03-15T16:09:09Z",
        "updatedAt" : "2016-05-06T07:34:41Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "82ba4f077e01bf5be20cfd9cbe74949f8eea611d",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +204,208 @@\t\tout.NodeAffinity = nil\n\t}\n\tif in.PodAffinity != nil {\n\t\tin, out := in.PodAffinity, &out.PodAffinity\n\t\t*out = new(PodAffinity)"
  },
  {
    "id" : "e378ad99-c39f-454b-b5d2-6611fd27e144",
    "prId" : 22985,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31e565f2-4e2f-4e9f-8844-632e78ca8b72",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "I believe much of these repetitive cases can be done generically on objects vs. explicit invocation.  But that's more of a \"we can reduce this code significantly\", perhaps as a TODO.  \n",
        "createdAt" : "2016-04-27T13:41:30Z",
        "updatedAt" : "2016-05-06T07:34:41Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "82ba4f077e01bf5be20cfd9cbe74949f8eea611d",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +2002,2006 @@\t\tin, out := in.PreferredDuringSchedulingIgnoredDuringExecution, &out.PreferredDuringSchedulingIgnoredDuringExecution\n\t\t*out = make([]WeightedPodAffinityTerm, len(in))\n\t\tfor i := range in {\n\t\t\tif err := DeepCopy_api_WeightedPodAffinityTerm(in[i], &(*out)[i], c); err != nil {\n\t\t\t\treturn err"
  }
]
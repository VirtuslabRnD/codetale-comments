[
  {
    "id" : "96ad2b2b-08c9-428a-8e1a-b5e0f2978b17",
    "prId" : 8269,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Why is this one error promoted to a variable but no others?\n",
        "createdAt" : "2015-05-14T20:10:00Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d769474f-afb0-46ad-a935-e3f1029ad648",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "It was our only typed error (error we logged, vs propagating up from iptables).\n\n----- Original Message -----\n\n> > @@ -319,38 +319,43 @@ type Proxier struct {\n> >     hostIP        net.IP\n> >  }\n> > \n> > +var (\n> > -   ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> \n> Why is this one error promoted to a variable but no others?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269/files#r30357599\n",
        "createdAt" : "2015-05-14T20:12:31Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "64962f13-b839-430a-8d2c-4b821a3986b5",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Who is \"we\" ?\n- glog.Errorf(\"Failed to select a host interface: %v\", err)\n- glog.Errorf(\"Failed to initialize iptables: %v\", err)\n- glog.Errorf(\"Failed to flush iptables: %v\", err)\n\nWhy is this one more important?  does someone need to test whether an error they receive is the \"not on localhost\" error?  Who/where?\n",
        "createdAt" : "2015-05-14T20:16:21Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d0237c5b-e9dc-4d54-ae09-db56d8d5fc2e",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We was \"the proxier\".  I wanted to check on ErrProxyOnLocalhost since it's doing argument validation and we want to give a very specific message to users.  ProxyLocked I wanted to test on.  Initialize and test on were generic errors - yeah it failed, we can't start the proxy because of some arbitrary iptables craziness.\n\nBasically the difference between http 422 and 404 - 422 means something very specific, 404 could mean anything.  The ProxyOnLocalhost was validation, the others were \"we can't start because of :shrug:\")\n",
        "createdAt" : "2015-05-14T20:22:23Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a34ce24f-504e-4d9c-8ffb-ddd2d68fc895",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "But nobody uses this yet...\n",
        "createdAt" : "2015-05-14T20:25:24Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "18e12d47-c597-4ed8-b7a5-4195a2479ce9",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "OpenShift wants to.\n\n----- Original Message -----\n\n> > @@ -319,38 +319,43 @@ type Proxier struct {\n> >     hostIP        net.IP\n> >  }\n> > \n> > +var (\n> > -   ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> \n> But nobody uses this yet...\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269/files#r30358947\n",
        "createdAt" : "2015-05-14T20:41:11Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "0b578263-1405-401c-8c7b-a27b70fcf481",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Shouldn't you pre-validate that, then, rather than surfacing it from the depths of the app?  It's a pretty specific error to catch, you might as well check it yourself.\n",
        "createdAt" : "2015-05-15T06:35:12Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cb8cc2bb-e9d1-4530-82b6-fd5fe166dcc0",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "So then we have to expose a method to check it.  Any everyone has to check it the same way.  And everyone needs a consistent message.  Seems like you're arguing against people returning known error types from functions?  If I set up a TLS config and get back a TLS typed error (this is invalid) isn't that reasonable?\n\n----- Original Message -----\n\n> > @@ -319,38 +319,43 @@ type Proxier struct {\n> >     hostIP        net.IP\n> >  }\n> > \n> > +var (\n> > -   ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> \n> Shouldn't you pre-validate that, then, rather than surfacing it from the\n> depths of the app?  It's a pretty specific error to catch, you might as well\n> check it yourself.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269/files#r30387927\n",
        "createdAt" : "2015-05-15T14:32:19Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6d12249d-b193-47b8-9f98-86e73cbb61c7",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Typed errors are fine (though it's not my favorite aspect of Go, whatevs).\nMy point was to grok why some errors matter more than others.\n\nOn Fri, May 15, 2015 at 7:32 AM, Clayton Coleman notifications@github.com\nwrote:\n\n> In pkg/proxy/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269#discussion_r30412964\n> :\n> \n> > @@ -319,38 +319,43 @@ type Proxier struct {\n> >     hostIP        net.IP\n> >  }\n> > \n> > +var (\n> > -   ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> \n> So then we have to expose a method to check it. Any everyone has to check\n> it the same way. And everyone needs a consistent message. Seems like you're\n> arguing against people returning known error types from functions? If I set\n> up a TLS config and get back a TLS typed error (this is invalid) isn't that\n> reasonable?\n> … <#14d57fde9d752fa5_>\n> ----- Original Message -----\n> \n> > @@ -319,38 +319,43 @@ type Proxier struct { > hostIP net.IP > } > >\n> > +var ( > + ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> > Shouldn't you pre-validate that, then, rather than surfacing it from the\n> > depths of the app? It's a pretty specific error to catch, you might as well\n> > check it yourself. --- Reply to this email directly or view it on GitHub:\n> > https://github.com/GoogleCloudPlatform/kubernetes/pull/8269/files#r30387927\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269/files#r30412964\n> .\n",
        "createdAt" : "2015-05-15T16:05:25Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "15d08ec8-84de-477b-a2b9-9bdc11bd6abf",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Will add comments to the intended use (every consumer of NewProxier having the same validation error).\n\n> On May 15, 2015, at 12:05 PM, Tim Hockin notifications@github.com wrote:\n> \n> In pkg/proxy/proxier.go:\n> \n> > @@ -319,38 +319,43 @@ type Proxier struct {\n> >     hostIP        net.IP\n> >  }\n> > \n> > +var (\n> > -   ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> >   Typed errors are fine (though it's not my favorite aspect of Go, whatevs). My point was to grok why some errors matter more than others.\n> >   …\n> >   —\n> >   Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-05-15T16:28:39Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "032d0d65-4c34-4930-bb23-e78778b095e8",
        "parentId" : "144615c8-4eef-45d5-b333-f99bea43fdb0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "it's OK.  I get it, I just wanted to probe you for what distinguishes.\nThis is LGTM\n\nOn Fri, May 15, 2015 at 9:29 AM, Clayton Coleman notifications@github.com\nwrote:\n\n> In pkg/proxy/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269#discussion_r30423449\n> :\n> \n> > @@ -319,38 +319,43 @@ type Proxier struct {\n> >     hostIP        net.IP\n> >  }\n> > \n> > +var (\n> > -   ErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n> \n> Will add comments to the intended use (every consumer of NewProxier having\n> the same validation error).\n> … <#14d5868689f8dd5c_>\n>  On May 15, 2015, at 12:05 PM, Tim Hockin notifications@github.com\n> wrote: In pkg/proxy/proxier.go: > @@ -319,38 +319,43 @@ type Proxier struct\n> { > hostIP net.IP > } > > +var ( > + ErrProxyOnLocalhost =\n> fmt.Errorf(\"cannot proxy on localhost\") Typed errors are fine (though it's\n> not my favorite aspect of Go, whatevs). My point was to grok why some\n> errors matter more than others. … — Reply to this email directly or view it\n> on GitHub.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/8269/files#r30423449\n> .\n",
        "createdAt" : "2015-05-15T16:31:34Z",
        "updatedAt" : "2015-05-15T17:50:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "de36967c7e79812ba6f00f6cf90a38e191028e9f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +324,328 @@\t// the loopback address. May be checked for by callers of NewProxier to know whether\n\t// the caller provided invalid input.\n\tErrProxyOnLocalhost = fmt.Errorf(\"cannot proxy on localhost\")\n)\n"
  },
  {
    "id" : "367ad0fa-50c4-4d8b-87d1-e96c28e3a44f",
    "prId" : 5400,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2928a8f4-39d8-447b-8539-eb6ab106b6de",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This should not be a public symbol - createProxier() or newProxierInternal() please\n",
        "createdAt" : "2015-03-15T21:58:52Z",
        "updatedAt" : "2015-03-15T21:58:52Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "54031d26-5620-4c58-a376-70c47f08521b",
        "parentId" : "2928a8f4-39d8-447b-8539-eb6ab106b6de",
        "authorId" : "955a1a53-be89-4d06-9d67-c02d55287906",
        "body" : "@thockin fixed it as part of #5497\n",
        "createdAt" : "2015-03-16T06:44:02Z",
        "updatedAt" : "2015-03-16T06:44:02Z",
        "lastEditedBy" : "955a1a53-be89-4d06-9d67-c02d55287906",
        "tags" : [
        ]
      }
    ],
    "commit" : "269ad3216f85268c47d82494a4eec004021938b0",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +329,333 @@}\n\nfunc CreateProxier(loadBalancer LoadBalancer, listenIP net.IP, iptables iptables.Interface, hostIP net.IP) *Proxier {\n\tglog.Infof(\"Initializing iptables\")\n\t// Clean up old messes.  Ignore erors."
  },
  {
    "id" : "cd37846b-df8e-4364-94ae-ce08daa2cbc8",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e2d8b25-72eb-4b3b-933b-beaf522f98c0",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Need to test for `!= \"\"` also, I think...\n",
        "createdAt" : "2014-12-18T18:25:16Z",
        "updatedAt" : "2014-12-18T23:46:34Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "b605d739-2ae6-4f23-9ed2-7d0efe9fe550",
        "parentId" : "1e2d8b25-72eb-4b3b-933b-beaf522f98c0",
        "authorId" : "bb0813b4-3730-423f-9f69-f2e03bcc818f",
        "body" : "At this point it shouldn't be blank, if the value is not specified when the service is created I set it to none, but let take another look to see if could ever be \"\" when it gets here.\n",
        "createdAt" : "2014-12-18T18:45:33Z",
        "updatedAt" : "2014-12-18T23:46:34Z",
        "lastEditedBy" : "bb0813b4-3730-423f-9f69-f2e03bcc818f",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4e94efe1623df1af72ef9baf02e6f009e948af4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +365,369 @@func (proxier *Proxier) cleanupStaleStickySessions() {\n\tfor name, info := range proxier.serviceMap {\n\t\tif info.sessionAffinityType != api.AffinityTypeNone {\n\t\t\tproxier.loadBalancer.CleanupStaleStickySessions(name)\n\t\t}"
  },
  {
    "id" : "3b4a27c9-1e68-4b00-91c5-af4f4956c8ff",
    "prId" : 2281,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ec91e38-ded6-41b4-8e44-c7a41f348dee",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I'm really sorry, I should have noticed this before-- can you either make this an []int, or put the x*time.Second up here? It sort of breaks the Duration concept to multiply a duration by a duration, like what happens down on line 89.\n",
        "createdAt" : "2014-11-13T01:09:23Z",
        "updatedAt" : "2014-11-13T01:09:23Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "cd3f0f6a-b9fa-4ce7-9f56-73661e197748",
        "parentId" : "0ec91e38-ded6-41b4-8e44-c7a41f348dee",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "It won't let you do that with an int type variable without a cast, Go must\nbe doing something magical for 1*time.Second.\n\nSo the options are:\n\nDuration[] { 1_time.Second, 2_time.Second, ...}\n\nOr\n\ntime.Duration(timeout)*time.Second\n\nBoth of which are worse in my opinion.\n\nBrendan\n\nIn pkg/proxy/proxier.go:\n\n> @@ -56,8 +56,8 @@ func (si *serviceInfo) setActive(val bool) bool {\n>   return tmp\n>  }\n> \n> -// How long we wait for a connection to a backend.\n> -const endpointDialTimeout = 5 \\* time.Second\n> +// How long we wait for a connection to a backend in seconds\n> +var endpointDialTimeout = []time.Duration{1, 2, 4, 8}\n\nI'm really sorry, I should have noticed this before-- can you either make\nthis an []int, or put the x*time.Second up here? It sort of breaks the\nDuration concept to multiply a duration by a duration, like what happens\ndown on line 89.\n\n—\nReply to this email directly or view it on GitHub\nhttps://github.com/GoogleCloudPlatform/kubernetes/pull/2281/files#r20266395\n.\n",
        "createdAt" : "2014-11-13T02:09:30Z",
        "updatedAt" : "2014-11-13T02:09:30Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "92645328-9256-41f7-8bed-5c71c65c99b7",
        "parentId" : "0ec91e38-ded6-41b4-8e44-c7a41f348dee",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "ah, right, it works because constants are untyped.\n\n_sigh_ I'd prefer Duration[] { 1_time.Second, 2_time.Second, ...} but I guess I won't make you change it.\n",
        "createdAt" : "2014-11-13T02:13:41Z",
        "updatedAt" : "2014-11-13T02:13:41Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b5029c67330b64cad03e5e1493269b1f4bc9cb5",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +58,62 @@\n// How long we wait for a connection to a backend in seconds\nvar endpointDialTimeout = []time.Duration{1, 2, 4, 8}\n\n// Abstraction over TCP/UDP sockets which are proxied."
  },
  {
    "id" : "22005fa5-e084-488f-b174-36c3231ac215",
    "prId" : 1402,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd8c6ec9-24a2-4ca4-8f42-965a6fce1d31",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Why %q? Isn't that a character?\n",
        "createdAt" : "2014-10-05T06:19:19Z",
        "updatedAt" : "2014-10-16T15:37:00Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "06ab9dd5-5f91-4e40-96ba-1494d2458de6",
        "parentId" : "cd8c6ec9-24a2-4ca4-8f42-965a6fce1d31",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "%q is a quoted string.  I found it easier to read logs if I consistently quoted the service names.\n",
        "createdAt" : "2014-10-06T16:02:45Z",
        "updatedAt" : "2014-10-16T15:37:00Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c4bd552730fb2a4ca6d5c85230aed4f37734e7e",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +96,100 @@\t\t\tcontinue\n\t\t}\n\t\tglog.V(3).Infof(\"Mapped service %q to endpoint %s\", service, endpoint)\n\t\t// TODO: This could spin up a new goroutine to make the outbound connection,\n\t\t// and keep accepting inbound traffic."
  },
  {
    "id" : "eadcf1b6-1984-41cd-8dc6-85217ae724ee",
    "prId" : 1402,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92d264b8-cbd2-438d-9ff2-6b147ff2f1f6",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Again, why %q?\n",
        "createdAt" : "2014-10-05T06:20:09Z",
        "updatedAt" : "2014-10-16T15:37:00Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "9d1bf142-c359-4df7-ba42-8d73b757d60c",
        "parentId" : "92d264b8-cbd2-438d-9ff2-6b147ff2f1f6",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Same.  I could pull this into its own PR, if it helps this bigger change go through\n",
        "createdAt" : "2014-10-06T16:03:29Z",
        "updatedAt" : "2014-10-16T15:37:00Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c4bd552730fb2a4ca6d5c85230aed4f37734e7e",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +215,219 @@\t\t\treturn nil, err\n\t\t}\n\t\tglog.V(3).Infof(\"Mapped service %q to endpoint %s\", service, endpoint)\n\t\tsvrConn, err = net.DialTimeout(\"udp\", endpoint, endpointDialTimeout)\n\t\tif err != nil {"
  },
  {
    "id" : "6ae7cbaf-e294-4ff3-a06f-f3317426a7f0",
    "prId" : 1314,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5f7df81-8b80-45fd-9ff2-b8fbf63e9336",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Reviewers, @ddysher: Don't forget to consider, what happens if this crashes? Should probably have a \"defer util.HandleCrash()\" here.\n",
        "createdAt" : "2014-09-16T00:29:55Z",
        "updatedAt" : "2014-09-16T00:29:55Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "d5eb731b3f47d976fb0776e1a613f4a61ff6cc29",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +116,120 @@// proxyTCP proxies data bi-directionally between in and out.\nfunc proxyTCP(in, out *net.TCPConn) {\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tglog.Infof(\"Creating proxy between %v <-> %v <-> %v <-> %v\","
  },
  {
    "id" : "73a3b23f-c41e-4b04-95b8-034aab767c74",
    "prId" : 1273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8bc7e2a-df21-4f00-a830-f7e6c030dc0c",
        "parentId" : null,
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "I'd at least put a TODO to move this Dial into a goroutine.  If it takes a while to connect we might end up with a bottleneck here.\n",
        "createdAt" : "2014-09-11T18:10:06Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      },
      {
        "id" : "2a310441-cf15-41b6-acad-937321ffe0a7",
        "parentId" : "d8bc7e2a-df21-4f00-a830-f7e6c030dc0c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I added a TODO in UDP, cloned it here.\n",
        "createdAt" : "2014-09-11T19:53:08Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3181f3555d3503336a23994b9e81c7375cc27ad8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +102,106 @@\t\t// TODO: This could spin up a new goroutine to make the outbound connection,\n\t\t// and keep accepting inbound traffic.\n\t\toutConn, err := net.DialTimeout(\"tcp\", endpoint, endpointDialTimeout)\n\t\tif err != nil {\n\t\t\t// TODO: Try another endpoint?"
  },
  {
    "id" : "a6f14582-fbe5-4e45-9ee8-5f54693c0024",
    "prId" : 1273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67ab7496-1891-47fa-ba89-70a704b39cf5",
        "parentId" : null,
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "I'm not an expert here but I think that you want to use one of the UDP specific commands and get the sender of this packet.  You then want to ensure that the packet is coming from the expected IP/port.  This is a \"full cone\" type NAT situation (even though this isn't NAT, technically).\n\nScenario: \n- `Client A` sends UDP packet to `Service A`.  A new \"UDP Connection\" is created for client communication for the proxy.\n- Proxy forwards this to `Backend A` from `port A`. A new \"UDP Connection\" is created for server communication for the proxy.\n- Things time out and everything ages out of the proxy.\n- A new request for `Service B` from `Client B` comes in.  The same dance happens except `port A` ends up getting reused.\n- `Backend A` thinks the \"connection\" is still live.  It sends UDP traffic to `port A` on the proxy.  The proxy will (_I think_) associate this with the \"UDP Connection\" to `Backend B`.  It'll then go ahead and forward that packet on to `Client B`.\n\nIn a typical datacenter it is not unexpected to get all sorts of random crap flying around via UDP.  You need some level of filtering.  So -- if we get a UDP packet from an unexpected source we should drop it instead of forwarding it on.  TCP doesn't suffer from this problem as it is truly connection oriented.\n",
        "createdAt" : "2014-09-11T18:35:20Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      },
      {
        "id" : "631cca3e-9c7d-4fe1-97a6-c39f30e5b881",
        "parentId" : "67ab7496-1891-47fa-ba89-70a704b39cf5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "First, this triggered me to look at FDs and find a bug.  If Go had RAII I would not have written this bug (forgot to Close).\n\nIn this scenario it does look like you get the same 5-tuple.  I don't know enough networking to say whether the backend can tell the difference at all - that a client disconnected and another one used the same srcport.\n\nIf the backend can tell the difference, it will have terminated the logical connection, no?\n\nIf the backend can't tell the difference, then what exactly am I supposed to do?\n\nI don't grok what filtering you mean.  If I receive a UDP packet into the proxy port, I'm going to proxy it.  If I receive a packet from the backend, how do I know if it is legit or not?\n",
        "createdAt" : "2014-09-11T22:32:24Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d06a0fac-be00-47c7-8eb2-cc6a576cdd0c",
        "parentId" : "67ab7496-1891-47fa-ba89-70a704b39cf5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Maybe I get what you meant - Go's Conn.Read() for UDP does the equivalent of recvfrom() underneath.  So we're already only receiving info from the backend we expect.  But that does not solve the client-reuses-port problem, if it exists.\n",
        "createdAt" : "2014-09-11T22:41:28Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "653068ad-b690-47af-8007-b67ae7f64ba1",
        "parentId" : "67ab7496-1891-47fa-ba89-70a704b39cf5",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "@thockin Go uses \"defer x.Close()\" instead of RAII. Yes, this forces you to write shorter functions. \"Close\" or \"Unlock\" that's not deferred generally means there's a bug. (Even if you always close, imagine a panic unwinding the call stack-- non-deferred Close/Unlocks won't happen.)\n",
        "createdAt" : "2014-09-11T22:49:25Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "b68ec73a-2ff9-4e37-80c9-3bb4344c2abf",
        "parentId" : "67ab7496-1891-47fa-ba89-70a704b39cf5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "done (defer)\n",
        "createdAt" : "2014-09-11T23:31:33Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "4d0934ba-4bba-42b1-b022-63d2b63e3cff",
        "parentId" : "67ab7496-1891-47fa-ba89-70a704b39cf5",
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "Okay -- now that I am refreshed about \"connected UDP sockets\" I retract my issue here.  Man, this stuff is tricky.  The connected UDP socket should (I think) drop packets that come from other addresses that it isn't connected to.\n",
        "createdAt" : "2014-09-12T23:30:37Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      }
    ],
    "commit" : "3181f3555d3503336a23994b9e81c7375cc27ad8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +227,231 @@\tvar buffer [4096]byte\n\tfor {\n\t\tn, err := svrConn.Read(buffer[0:])\n\t\tif err != nil {\n\t\t\tif !logTimeout(err) {"
  },
  {
    "id" : "48bf2531-0009-4e9e-bfe2-5fa06af51e14",
    "prId" : 1273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bcf4381-8530-41a6-8906-0352d89b2cd4",
        "parentId" : null,
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "Will this break out when we close the listening socket?  Or will it leave this hanging here.  If it exits out the result will be that existing connections continue to be proxied but that we stop listening for new connections.  Not sure if that is the intended result.\n",
        "createdAt" : "2014-09-11T18:51:06Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      },
      {
        "id" : "6351bc6a-ef5f-4e38-a421-201fa5c56900",
        "parentId" : "8bcf4381-8530-41a6-8906-0352d89b2cd4",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I did not change any of the TCP logic.  I am also suspicious of it, but that's not part of the PR.\n",
        "createdAt" : "2014-09-11T22:24:04Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3181f3555d3503336a23994b9e81c7375cc27ad8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +87,91 @@\n\t\t// Block until a connection is made.\n\t\tinConn, err := tcp.Accept()\n\t\tif err != nil {\n\t\t\tglog.Errorf(\"Accept failed: %v\", err)"
  },
  {
    "id" : "89c7facc-2ae7-4008-87b5-6cce404f1645",
    "prId" : 1273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dcc34a3-65b3-4ba3-9d3a-e46dfc06134d",
        "parentId" : null,
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "With UDP, however, we won't go into a graceful lame duck mode.  Since all return paths are going back through the listening socket and we are closing it we have the affect of forcibly closing all \"UDP connections\"\n",
        "createdAt" : "2014-09-11T18:52:17Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      },
      {
        "id" : "27742585-b1bf-4bbc-959f-9a60ee8f3cce",
        "parentId" : "2dcc34a3-65b3-4ba3-9d3a-e46dfc06134d",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Is there a better answer?  Stop accepting and do an async close 2 seconds later?\n",
        "createdAt" : "2014-09-11T22:34:11Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "6f8bf9dd-f1e3-451b-9c00-65dfe9323c8a",
        "parentId" : "2dcc34a3-65b3-4ba3-9d3a-e46dfc06134d",
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "I'm not sure there is a better solution (at least not without some experimentation with creating a new UDP socket for the proxy/client leg with explicit addresses in Dial) but it might be worth documenting the behavior for TCP and UDP proxied connections when the service is removed.  Might help someone debug later if they hit an issue.\n",
        "createdAt" : "2014-09-12T23:32:01Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      }
    ],
    "commit" : "3181f3555d3503336a23994b9e81c7375cc27ad8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +158,162 @@\t\t// Block until data arrives.\n\t\t// TODO: Accumulate a histogram of n or something, to fine tune the buffer size.\n\t\tn, cliAddr, err := udp.ReadFrom(buffer[0:])\n\t\tif err != nil {\n\t\t\tif e, ok := err.(net.Error); ok {"
  },
  {
    "id" : "de6ea428-42eb-4cbc-b25b-5dd853670a58",
    "prId" : 1273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56248b67-2c3c-4cd5-adce-2cc646a21298",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "defer util.HandleCrash()?\n",
        "createdAt" : "2014-09-11T22:02:03Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "d2e800bd-fd9c-4f95-afde-85e0f724bc89",
        "parentId" : "56248b67-2c3c-4cd5-adce-2cc646a21298",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I guess.  I find the need for this to be sort of horrible and noisy.  I'll do it as a new commit so you can debate the utility of it vs the fugliness.  To be clear, if one of these crashes, I doubt that restarting it will actually be better.\n",
        "createdAt" : "2014-09-11T23:20:06Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3181f3555d3503336a23994b9e81c7375cc27ad8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +223,227 @@\n// This function is expected to be called as a goroutine.\nfunc (udp *udpProxySocket) proxyClient(cliAddr net.Addr, svrConn net.Conn, activeClients *clientCache, timeout time.Duration) {\n\tdefer svrConn.Close()\n\tvar buffer [4096]byte"
  },
  {
    "id" : "2aac421b-132e-4cd0-949f-4bff86a2c35e",
    "prId" : 1273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f01ea44-62c1-44cc-8137-83c6e82c2a0e",
        "parentId" : null,
        "authorId" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "body" : "*proxySocket ?\n",
        "createdAt" : "2014-09-12T03:32:18Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "tags" : [
        ]
      },
      {
        "id" : "72844019-2794-45f9-9d75-904285c8e7db",
        "parentId" : "7f01ea44-62c1-44cc-8137-83c6e82c2a0e",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "proxySocket is an interface\n",
        "createdAt" : "2014-09-12T16:18:54Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b781d58b-a480-4230-8aff-1fd7136882d0",
        "parentId" : "7f01ea44-62c1-44cc-8137-83c6e82c2a0e",
        "authorId" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "body" : "Ah, right. I checked proxySocket's type, but ended up looking at tcpProxySocket somehow.  Any way, learned a lot from the PR. :)  I saw you filed follow up issues, I can help with some work if possible.\n",
        "createdAt" : "2014-09-12T17:10:38Z",
        "updatedAt" : "2014-09-12T23:48:47Z",
        "lastEditedBy" : "7116d1ae-39f7-4e5d-81a9-1bcb75ebd909",
        "tags" : [
        ]
      },
      {
        "id" : "3725d235-1bb3-4356-a7db-fcf56f52958c",
        "parentId" : "7f01ea44-62c1-44cc-8137-83c6e82c2a0e",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "If you're imterested in the proxy, I'd be happy to help you get engaged on it.  It's not super complicated but it's important to get right.\n",
        "createdAt" : "2014-09-12T23:51:42Z",
        "updatedAt" : "2014-09-12T23:51:42Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3181f3555d3503336a23994b9e81c7375cc27ad8",
    "line" : 241,
    "diffHunk" : "@@ -1,1 +262,266 @@}\n\nfunc newProxySocket(protocol string, host string, port int) (proxySocket, error) {\n\tswitch strings.ToUpper(protocol) {\n\tcase \"TCP\":"
  },
  {
    "id" : "b43fd317-cc27-48f9-9df1-7f8d84b19c40",
    "prId" : 956,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99db551f-50fb-447f-8ed4-f14281464edc",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "OK to double-stop inactive services?\n",
        "createdAt" : "2014-08-19T19:38:28Z",
        "updatedAt" : "2014-08-19T19:38:28Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "153777b2-9232-4c54-bc46-72955c91d718",
        "parentId" : "99db551f-50fb-447f-8ed4-f14281464edc",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "yeah, stopService is idempotent.\n",
        "createdAt" : "2014-08-19T20:54:36Z",
        "updatedAt" : "2014-08-19T20:54:36Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "da74625ac6a40460077b1ab0501cb9545016a71f",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +203,207 @@\t\t\tcontinue\n\t\t}\n\t\tif exists && info.port != service.Port {\n\t\t\tproxier.StopProxy(service.ID)\n\t\t}"
  },
  {
    "id" : "7ea025b3-9ead-4ca8-b461-1706b0a13f2a",
    "prId" : 754,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9cb23b0-7fcc-4c8b-9afa-0a0489f01916",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "This is going to cause this message to get really spammy.  Let's make sure we only log when we're really stopping the service (move the log into stopProxyInternal?)\n",
        "createdAt" : "2014-08-04T16:28:18Z",
        "updatedAt" : "2014-08-05T14:18:53Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d3e660248a12153dfec0ea805b94e9be128b6d6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +221,225 @@\tdefer proxier.mu.Unlock()\n\tfor name, info := range proxier.serviceMap {\n\t\tif !activeServices.Has(name) {\n\t\t\tproxier.stopProxyInternal(info)\n\t\t}"
  },
  {
    "id" : "49bd8403-f58b-49b0-93d5-ae1d5b467322",
    "prId" : 682,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6258b849-c4fe-4a77-94b8-cbb6bb146891",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Do you really want to leave this locked forever?\n",
        "createdAt" : "2014-07-29T16:32:46Z",
        "updatedAt" : "2014-07-29T22:41:02Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "24ec7dac-8f53-4132-81fa-6b27331a1213",
        "parentId" : "6258b849-c4fe-4a77-94b8-cbb6bb146891",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "Done.\n",
        "createdAt" : "2014-07-29T19:05:59Z",
        "updatedAt" : "2014-07-29T22:41:02Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "99f0d2e8071b433ea4d39299fe1c401b9068b953",
    "line" : null,
    "diffHunk" : "@@ -1,1 +115,119 @@\t\tif !info.active {\n\t\t\tinfo.lock.Unlock()\n\t\t\tbreak\n\t\t}\n\t\tinfo.lock.Unlock()"
  },
  {
    "id" : "576c60e6-8d18-4945-8873-c89c3e3bae47",
    "prId" : 682,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e20cce8-f892-4dc5-831c-f81c41eb52fd",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Document that the lock must be held before calling this.\n",
        "createdAt" : "2014-07-29T21:05:02Z",
        "updatedAt" : "2014-07-29T22:41:02Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "135826ec-fd92-4906-8f2d-dfe5e78ae71a",
        "parentId" : "8e20cce8-f892-4dc5-831c-f81c41eb52fd",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2014-07-29T21:49:30Z",
        "updatedAt" : "2014-07-29T22:41:02Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "99f0d2e8071b433ea4d39299fe1c401b9068b953",
    "line" : null,
    "diffHunk" : "@@ -1,1 +85,89 @@\n// Requires that info.lock be held before calling.\nfunc (proxier *Proxier) stopProxyInternal(info *serviceInfo) error {\n\tinfo.active = false\n\treturn info.listener.Close()"
  },
  {
    "id" : "15ba417f-fad8-4b2b-9581-0749a199e609",
    "prId" : 682,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85eeee38-a6c4-4d8c-aea9-180303d62b31",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Godoc comment.\n",
        "createdAt" : "2014-07-29T21:05:12Z",
        "updatedAt" : "2014-07-29T22:41:02Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "0401d80a-e8e3-49b6-bcda-fd2faf1b661e",
        "parentId" : "85eeee38-a6c4-4d8c-aea9-180303d62b31",
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "done.\n",
        "createdAt" : "2014-07-29T21:49:24Z",
        "updatedAt" : "2014-07-29T22:41:02Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "99f0d2e8071b433ea4d39299fe1c401b9068b953",
    "line" : null,
    "diffHunk" : "@@ -1,1 +73,77 @@\n// StopProxy stops a proxy for the named service.  It stops the proxy loop and closes the socket.\nfunc (proxier *Proxier) StopProxy(service string) error {\n\t// TODO: delete from map here?\n\tinfo, found := proxier.getServiceInfo(service)"
  }
]
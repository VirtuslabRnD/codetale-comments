[
  {
    "id" : "7387e086-0b5a-4917-8b40-a99fd3809631",
    "prId" : 94564,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/94564#pullrequestreview-545593773",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5c10223-db27-445d-b4ac-3f68e25a269a",
        "parentId" : null,
        "authorId" : "87ab1d19-ad39-40d0-a045-817039414280",
        "body" : "Do you have any objections to returning the more verbose error with details on the current versus expected not being equal? Is the more concise error suggesting that a timeout would be the only reason this would fail?",
        "createdAt" : "2020-12-03T21:02:26Z",
        "updatedAt" : "2020-12-03T21:02:42Z",
        "lastEditedBy" : "87ab1d19-ad39-40d0-a045-817039414280",
        "tags" : [
        ]
      },
      {
        "id" : "89ea3ebf-cb9d-428e-936e-c5ffcb7f8cec",
        "parentId" : "b5c10223-db27-445d-b4ac-3f68e25a269a",
        "authorId" : "9e6ce3ed-e2f7-40ea-b6d7-b1b04fc48f70",
        "body" : "> Do you have any objections to returning the more verbose error with details on the current versus expected not being equal\r\n\r\nI think we could add some logging if what we got was different from the expected, but it might not be desired to return an error immediately as the poll would be interrupted.\r\n\r\n> Is the more concise error suggesting that a timeout would be the only reason this would fail?\r\n\r\nyes",
        "createdAt" : "2020-12-05T15:08:17Z",
        "updatedAt" : "2020-12-05T15:08:17Z",
        "lastEditedBy" : "9e6ce3ed-e2f7-40ea-b6d7-b1b04fc48f70",
        "tags" : [
        ]
      }
    ],
    "commit" : "9109d928cd0563b913aa889c954574dcee1aa3c3",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +194,198 @@\t\tdefer svcHandler.lock.Unlock()\n\t\tif reflect.DeepEqual(svcHandler.state, expectedSvcState) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, nil"
  },
  {
    "id" : "9552a093-7dd7-4ef8-9761-78a2c0185480",
    "prId" : 42108,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/42108#pullrequestreview-24023298",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "So this used to be meaningful, in that the first update was a \"clear\" if there were no endpoints.  It would be good to verify that we have at least one test in this group that covers - \"start, have empty state, get endpoints, delete endpoints, have empty state\" as well as \"have state, resync, add / remove endpoints, have same state as before, but never have empty state\".  Is there a test like that already?",
        "createdAt" : "2017-02-25T21:35:54Z",
        "updatedAt" : "2017-02-27T15:16:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c3c528e4-c758-4a50-9392-1450fd13d1fd",
        "parentId" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "> So this used to be meaningful, in that the first update was a \"clear\" if there were no endpoints\r\n\r\nSorry - don't understand this. Can you please clarify?\r\n\r\nBut anyway, I agree that previously \"SET\" was handled differently than \"ADD\", because:\r\n- ADD was used only in unit tests (i.e. production code was never issuing ADD) - it was always taking all contents from the underlying store and calling \"SET\" (meaning \"replace\") from those contents (no matter if it was add, update or remove).\r\n\r\nHowever, with the controller framework, \"REPLACE\" is not an external concept.\r\nIf we are doing relist, controller internally is handling it - it is computing the difference and sending appropriate Add, Update and Remove calls if needed to match the desired state.\r\nThe same for resync (though since resync is called from in-memory state, there are pretty much only update handlers called).\r\n\r\nThat means, that since those are internal details of controller framework, we don't have a good was for forcing it. Also, those are already tested at the level of Informer, so testing framework internals here doesn't sound like a good idea to me.\r\n\r\nBut if you don't agree, can you please clarify what exactly you want to be tested, since I'm not sure I understood it correctly.\r\n\r\n",
        "createdAt" : "2017-02-25T21:50:22Z",
        "updatedAt" : "2017-02-27T15:16:45Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "2421934c-efe1-4e78-89ce-158423658e26",
        "parentId" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I want to be sure that \r\n\r\n1. Kube-proxy doesn't do anything incorrect until initial sync\r\n2. Resync doesn't reset state of the proxy to \"no services\"",
        "createdAt" : "2017-02-25T21:58:15Z",
        "updatedAt" : "2017-02-27T15:16:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c59734ea-4047-4342-bffe-2ba814bec137",
        "parentId" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I think by #1 here you mean \"Make sure that the List has fully completed before we do anything with the state\", and a big +1 on that...  I think we've seen that bug in a few controllers.  But ... did this bug also exist previously (if not, can someone point me to magic where it was avoided?)\r\n\r\n(Also in general, if anyone has a good doc on Informers vs Reflectors vs direct-watching.  I prefer direct-watching, but I guess that means I have all sort of edge cases in my code.)",
        "createdAt" : "2017-02-25T23:05:49Z",
        "updatedAt" : "2017-02-27T15:16:45Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "4399e42b-375c-4f48-96b9-e4ea6f021a45",
        "parentId" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I agree with 1 - (though us @justinsb wrote, I think it also wasn't handled correctly before).\r\nWill add on Monday morning.\r\n\r\nRegarding 2 - this is covered by Informer (DeltaFifo) tests.",
        "createdAt" : "2017-02-26T07:10:52Z",
        "updatedAt" : "2017-02-27T15:16:45Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "7065ab59-6651-4e38-89e6-50627aaefa85",
        "parentId" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "So regarding one - it seems it's not easy to handle (and this is not the regression).\r\nBasically, both before and now, with the initial \"LIST\" operation (of the underlying reflector), we are sending the ADD events from the results of it one by one, and then passing to proxier.\r\n\r\nWe need a better way to handle it, but since this is not a regression, I would prefer fixing it in a separate PR (I can try sending it later today).",
        "createdAt" : "2017-02-27T15:19:30Z",
        "updatedAt" : "2017-02-27T15:19:36Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "660e655a-36fa-42a7-a19c-5fb1fb0a6133",
        "parentId" : "0625f38c-f286-413c-b58b-289b2d577bef",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That's fine",
        "createdAt" : "2017-02-27T16:08:11Z",
        "updatedAt" : "2017-02-27T16:08:11Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "c789704e8e7aa68e91f2465752eb322c5c90a1a6",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +167,171 @@\n\tendpointsController := NewEndpointsController(lw, 30*time.Second, ch)\n\tgo endpointsController.Run(wait.NeverStop)\n\n\t// Add the first endpoints"
  }
]
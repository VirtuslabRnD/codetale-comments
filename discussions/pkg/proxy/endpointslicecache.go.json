[
  {
    "id" : "d768fb44-c7ff-4c04-b0fe-460f75186f0f",
    "prId" : 101935,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101935#pullrequestreview-658153097",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3e5122b-ff6d-432e-92a1-8286f81fb1e0",
        "parentId" : null,
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "This is a great fix and should actually result in a bit of a performance improvement as well.",
        "createdAt" : "2021-05-12T17:02:49Z",
        "updatedAt" : "2021-05-12T17:06:19Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9cb68a2b13f5322005f4f938da3e9ee35f04372",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +295,299 @@\t\t// favor a true value here if it exists.\n\t\tif _, exists := endpointSet[endpointInfo.String()]; !exists || isLocal {\n\t\t\tendpointSet[endpointInfo.String()] = cache.makeEndpointInfo(endpointInfo)\n\t\t}\n\t}"
  },
  {
    "id" : "b4748436-1933-4cbb-8a7c-bd4ab86159e9",
    "prId" : 101935,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/101935#pullrequestreview-658810137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e7f4ece-a417-43c9-98e6-bce1e7d0cbb7",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "this questions is mostly curiosity, is `isLocal` really needed now?\r\nwe are identifying the endpoint by IP:Port now ...",
        "createdAt" : "2021-05-13T09:24:14Z",
        "updatedAt" : "2021-05-13T09:24:14Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "8c8d8fb2-44e8-47d1-9309-a58284c88cfe",
        "parentId" : "8e7f4ece-a417-43c9-98e6-bce1e7d0cbb7",
        "authorId" : "f13f3127-57ba-4e9c-91b9-35534b17d4fe",
        "body" : "I don't think so either. But this breaks one of the test case. ðŸ˜Ÿ\r\n\r\nThe only case I come up with that changes the property \"isLocal\" of the same endpoint is\r\n\r\n```\r\n# svc on host1\r\nsvc    -> pod1 10.0.0.1:8080 (host1, local)\r\n       -> pod2 10.0.0.2:8080 (host2, non local)\r\n\r\n# pods are deleted and rebuilt\r\nsvc    -> pod3 10.0.0.1:8080 (host2, non local)\r\n       -> pod4 10.0.0.2:8080 (host1, local)\r\n```\r\n\r\nBut I don't think it will happen in normal cases because nodes have non-overlapping pod CIDRs ...\r\n\r\nAny ideas?",
        "createdAt" : "2021-05-13T09:38:14Z",
        "updatedAt" : "2021-05-13T09:38:15Z",
        "lastEditedBy" : "f13f3127-57ba-4e9c-91b9-35534b17d4fe",
        "tags" : [
        ]
      },
      {
        "id" : "c1498490-d402-4563-a542-3a04d6f0d739",
        "parentId" : "8e7f4ece-a417-43c9-98e6-bce1e7d0cbb7",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "yeah, that is weird but we've seen worse :stuck_out_tongue: \r\nI don' think that it will hurt",
        "createdAt" : "2021-05-13T11:21:39Z",
        "updatedAt" : "2021-05-13T11:21:39Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9cb68a2b13f5322005f4f938da3e9ee35f04372",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +294,298 @@\t\t// isLocal should not vary between matching endpoints, but if it does, we\n\t\t// favor a true value here if it exists.\n\t\tif _, exists := endpointSet[endpointInfo.String()]; !exists || isLocal {\n\t\t\tendpointSet[endpointInfo.String()] = cache.makeEndpointInfo(endpointInfo)\n\t\t}"
  },
  {
    "id" : "5910d7d9-ea88-4891-ae0c-c6aff51fa871",
    "prId" : 96371,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96371#pullrequestreview-529631574",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e04b689-f162-4832-9858-78e0738a951b",
        "parentId" : null,
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Should nil really translate to true here?",
        "createdAt" : "2020-11-10T01:49:27Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "25e386eb-9d40-4a28-8629-43d766c03011",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I had assumed it should because this is the case for `Ready`. ",
        "createdAt" : "2020-11-12T02:26:42Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "77053945-96cf-4588-868c-4768348eaf49",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "maybe if `serving == nil` we set it to ready, but that would mean that we could never have ready terminating endpoints if serving is nil, maybe that's fine since epslice controller will always set them in lock step starting v1.21. ",
        "createdAt" : "2020-11-12T02:27:50Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "64c38a8e-9ddf-4690-9490-5132115a4a1e",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "yeah I think falling back to ready might be a bit better here but agree that it's not obvious which is better. Either way a comment might help explain the logic here since there is some ambiguity.",
        "createdAt" : "2020-11-12T02:33:28Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "3a9ed23b-3243-48f3-bb85-cdbd1233dfb1",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Alternatively what we're doing with `terminating` here (false if not specified) could also potentially be reasonable since we're primarily relying on `ready` still.",
        "createdAt" : "2020-11-12T02:34:37Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "45ee4096-5162-4349-966c-ae1bea06401f",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "body" : "These two statements are not aligned with the doc you have here: https://github.com/kubernetes/kubernetes/pull/96371/files#diff-e98883cc247c5cfc2f74946972a17e2b381ba288b35421db7bc9776612eb0366R54",
        "createdAt" : "2020-11-12T21:50:52Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "tags" : [
        ]
      },
      {
        "id" : "b89b5fc2-ac06-4730-b121-b597f706dfa2",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Yeah, that's a good point. Maybe the issue is that we're trying to translate 3 possible values (`*bool`) to 2 (`bool`) and it's not entirely clear what the nil case should be. It makes sense to default `terminating` to false when it isn't specified, I'm not sure that there is a sane default when `serving` isn't specified. Can we use a `*bool` for this instead?",
        "createdAt" : "2020-11-12T22:10:00Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "8dacaa82-3349-41d2-9ee4-01990267e7c3",
        "parentId" : "5e04b689-f162-4832-9858-78e0738a951b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "It seems reasonable to say that if `Serving == nil` then Serving defaults to !Terminating here, but that may just be over-thinking it?  Seems easy enough to adapt ",
        "createdAt" : "2020-11-13T01:21:42Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "a11abb54759919c07b0c0f363be07a80d1eb9a72",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +133,137 @@\t\t\t\t// conditions\n\t\t\t\tReady:       endpoint.Conditions.Ready == nil || *endpoint.Conditions.Ready,\n\t\t\t\tServing:     endpoint.Conditions.Serving == nil || *endpoint.Conditions.Serving,\n\t\t\t\tTerminating: endpoint.Conditions.Terminating != nil && *endpoint.Conditions.Terminating,\n\t\t\t}"
  },
  {
    "id" : "3a6a2204-b133-4e7e-81d8-67f8e281e37b",
    "prId" : 96371,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96371#pullrequestreview-550193015",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b256109-11e2-4aad-b043-2a30619c9948",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "Does this need a feature gate check? (Is it possible you're reading an out-of-date value here if the feature gate was previously on but then turned off?)",
        "createdAt" : "2020-12-09T12:24:48Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "6ae2cb8a-65de-438a-97af-66891702dc47",
        "parentId" : "7b256109-11e2-4aad-b043-2a30619c9948",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "IMO the cache updates don't need a feature gate since we handle the `nil` case, but the proxier behavior we will add later probably needs one. ",
        "createdAt" : "2020-12-11T15:22:12Z",
        "updatedAt" : "2021-01-11T21:27:57Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "a11abb54759919c07b0c0f363be07a80d1eb9a72",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +134,138 @@\t\t\t\tReady:       endpoint.Conditions.Ready == nil || *endpoint.Conditions.Ready,\n\t\t\t\tServing:     endpoint.Conditions.Serving == nil || *endpoint.Conditions.Serving,\n\t\t\t\tTerminating: endpoint.Conditions.Terminating != nil && *endpoint.Conditions.Terminating,\n\t\t\t}\n"
  },
  {
    "id" : "d5f3b50f-ac72-4c28-a895-d557cf11b36c",
    "prId" : 83206,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83206#pullrequestreview-297721855",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88fa5ef2-c4a7-4138-8be1-80cd83580e78",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "It may helped the performance more by not comparing the difference and just trigger sync as always. \r\n\r\nBut it may not make any difference given the test result. ",
        "createdAt" : "2019-10-02T23:45:44Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "52573928-4f6a-40a6-b5b6-fa3f0b8e6d0c",
        "parentId" : "88fa5ef2-c4a7-4138-8be1-80cd83580e78",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Unfortunately both the `EndpointChangesPending` metric and the last change trigger times rely on this being available on EndpointSlice addition (computing at proxier sync would not be helpful). The profiling I've done suggests that the full `updatePending` function, including this diffing, takes ~3% of total kube-proxy compute time (0.12s of 3.61s scaling to 10k endpoints). The actual `esInfoChanged` call within that is small enough to not be reported. Given the relative insignificance of that time I think it's worth maintaining the metrics as they exist.",
        "createdAt" : "2019-10-04T21:16:03Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e7de45034226c1339856ceecd31b22fdc5fe0aa",
    "line" : 157,
    "diffHunk" : "@@ -1,1 +160,164 @@\t}\n\n\treturn changed\n}\n"
  },
  {
    "id" : "adca17ba-c624-487b-b8b2-f21664cb508f",
    "prId" : 83206,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83206#pullrequestreview-297659085",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffc8583e-464d-44d3-a818-f11456fe1597",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "comment",
        "createdAt" : "2019-10-02T23:52:11Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "0011414e-96fe-4cd9-a34f-41c546a45ee5",
        "parentId" : "ffc8583e-464d-44d3-a818-f11456fe1597",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Added, thanks!",
        "createdAt" : "2019-10-04T18:54:08Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e7de45034226c1339856ceecd31b22fdc5fe0aa",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +55,59 @@// by a proxier along with any pending EndpointSlices that have been updated\n// in this cache but not yet applied by a proxier.\ntype endpointSliceTracker struct {\n\tapplied endpointSliceInfoByName\n\tpending endpointSliceInfoByName"
  },
  {
    "id" : "ba1b4a26-de02-443e-94a8-c9d9271f2dc1",
    "prId" : 83206,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83206#pullrequestreview-297659148",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "918dbd49-7260-441c-9266-4a8ac5a50f73",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "comment",
        "createdAt" : "2019-10-02T23:52:14Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "2f7ad449-3c76-4d5e-a819-06baaff9b435",
        "parentId" : "918dbd49-7260-441c-9266-4a8ac5a50f73",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Added, thanks!",
        "createdAt" : "2019-10-04T18:54:16Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e7de45034226c1339856ceecd31b22fdc5fe0aa",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +62,66 @@// endpointSliceInfoByName groups endpointSliceInfo by the names of the\n// corresponding EndpointSlices.\ntype endpointSliceInfoByName map[string]*endpointSliceInfo\n\n// endpointSliceInfo contains just the attributes kube-proxy cares about."
  },
  {
    "id" : "2546dcfa-6b76-426a-8b72-93aa76f78689",
    "prId" : 83206,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83206#pullrequestreview-302253040",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d4038bc2-6cde-4355-a699-3fb4272d869d",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "add comment\r\nadd unit test",
        "createdAt" : "2019-10-11T21:49:13Z",
        "updatedAt" : "2019-10-15T23:31:46Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "24010136-181b-48a3-8a6e-93382fdb4fc3",
        "parentId" : "d4038bc2-6cde-4355-a699-3fb4272d869d",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Added, thanks!",
        "createdAt" : "2019-10-15T23:33:23Z",
        "updatedAt" : "2019-10-15T23:33:23Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e7de45034226c1339856ceecd31b22fdc5fe0aa",
    "line" : 228,
    "diffHunk" : "@@ -1,1 +274,278 @@// esInfoChanged returns true if the esInfo parameter should be set as a new\n// pending value in the cache.\nfunc (cache *EndpointSliceCache) esInfoChanged(serviceKey types.NamespacedName, sliceKey string, esInfo *endpointSliceInfo) bool {\n\tif _, ok := cache.trackerByServiceMap[serviceKey]; ok {\n\t\tappliedInfo, appliedOk := cache.trackerByServiceMap[serviceKey].applied[sliceKey]"
  },
  {
    "id" : "da65325c-f85a-489a-b857-14c38715845d",
    "prId" : 83035,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83035#pullrequestreview-292682825",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e49727a6-6c85-4eea-91c2-c833cfeb1b8d",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "We could add `CompareByIP(Endpoint* other) int` to the Endpoint interface and implement with bytes.compare() to avoid allocating a string on each comparison.",
        "createdAt" : "2019-09-24T17:24:49Z",
        "updatedAt" : "2019-09-24T17:24:49Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      },
      {
        "id" : "8e18dc48-e74f-40c4-b765-3268b19cc43f",
        "parentId" : "e49727a6-6c85-4eea-91c2-c833cfeb1b8d",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "@bowei This actually is just returning an IP:Port string that happens to be the only string stored with this endpoint struct. Previously when using the `.IP()` method it was actually resulting in a netutil call to parse that out which was resulting in the slowness. Here it's just returning the string that is already stored as is.",
        "createdAt" : "2019-09-24T19:57:29Z",
        "updatedAt" : "2019-09-24T19:57:29Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "33829c9a-6775-438a-ac39-7406e8056e04",
        "parentId" : "e49727a6-6c85-4eea-91c2-c833cfeb1b8d",
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "Ah right, I thought for some reason it was stored as an IP internally.",
        "createdAt" : "2019-09-24T20:19:50Z",
        "updatedAt" : "2019-09-24T20:19:51Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4b694a49778e16a6013af80f34b9764e335936e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +250,254 @@}\nfunc (e byIP) Less(i, j int) bool {\n\treturn e[i].String() < e[j].String()\n}"
  },
  {
    "id" : "b89a805c-84e8-4a61-8670-a57e97f97bd7",
    "prId" : 82393,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82393#pullrequestreview-284607307",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5910a094-8dd1-4e81-8bed-80537dfacb61",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "add a type decl for the map map\r\n`type ServicePortToEndpointMap map[ServicePortName]map[string]Endpoint`\r\nprefer to move var decl closer to where used:\r\n\r\n```\r\nsliceInfoByName, ok := cache.sliceByServiceMap[serviceNN]\r\nif !ok {\r\n  return spToEndpointMap{}\r\n}\r\nendpointInfoBySP := map[ServicePortName]map[string]Endpoint{}\r\n```",
        "createdAt" : "2019-09-06T00:04:18Z",
        "updatedAt" : "2019-09-06T00:33:23Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      },
      {
        "id" : "f31a3b00-a471-4ec4-8e72-d12905ace46b",
        "parentId" : "5910a094-8dd1-4e81-8bed-80537dfacb61",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Good call, thanks, should be fixed now.",
        "createdAt" : "2019-09-06T00:34:19Z",
        "updatedAt" : "2019-09-06T00:34:19Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1e3afa28e58b9ee5c8fd708e1b95ed86b1a8ce5",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +128,132 @@func (cache *EndpointSliceCache) endpointInfoByServicePort(serviceNN types.NamespacedName) spToEndpointMap {\n\tendpointInfoBySP := spToEndpointMap{}\n\tsliceInfoByName, ok := cache.sliceByServiceMap[serviceNN]\n\n\tif !ok {"
  },
  {
    "id" : "1181e764-638f-4222-bed6-15fc6ab194c0",
    "prId" : 82289,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82289#pullrequestreview-283392785",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9baa0c4b-64ff-4f19-a039-5df513255463",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "verify serviceName is non-zero-length?",
        "createdAt" : "2019-09-04T04:19:19Z",
        "updatedAt" : "2019-09-04T16:09:56Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "390aa6f0-5c23-4d17-8716-7035fffbd2c5",
        "parentId" : "9baa0c4b-64ff-4f19-a039-5df513255463",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I had been checking this and a few other conditions after the function was called, but you're right that it makes more sense to include it in the function itself, thanks!",
        "createdAt" : "2019-09-04T06:07:42Z",
        "updatedAt" : "2019-09-04T16:09:56Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f9483d827f0e7f2b605a0bce95e11702f1ff9c7",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +227,231 @@\t} else if endpointSlice.Namespace == \"\" || endpointSlice.Name == \"\" {\n\t\terr = fmt.Errorf(\"Expected EndpointSlice name and namespace to be set: %v\", endpointSlice)\n\t}\n\treturn types.NamespacedName{Namespace: endpointSlice.Namespace, Name: serviceName}, endpointSlice.Name, err\n}"
  },
  {
    "id" : "500c921b-619c-4017-a160-00486a5dcd4c",
    "prId" : 82289,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82289#pullrequestreview-283982415",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "935b1d9b-02bf-4d51-96fc-6ffba0fa43ec",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "the KEP says \"For EndpointSlice instances that are not derived from kubernetes Services, the above label must not be applied.\"... are endpointslice objects without that label filtered out so they aren't handled by this controller?",
        "createdAt" : "2019-09-05T01:47:38Z",
        "updatedAt" : "2019-09-05T01:47:38Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "7a2bac56-7c0d-429f-8dc0-77d654a625b7",
        "parentId" : "935b1d9b-02bf-4d51-96fc-6ffba0fa43ec",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Only endpoint slices that match a service with a selector are currently processed by the controller (matching the corresponding endpoints controller logic). This behavior could be amended/changed if we get any feedback during alpha.",
        "createdAt" : "2019-09-05T01:51:22Z",
        "updatedAt" : "2019-09-05T01:51:23Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f9483d827f0e7f2b605a0bce95e11702f1ff9c7",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +222,226 @@func endpointSliceCacheKeys(endpointSlice *discovery.EndpointSlice) (types.NamespacedName, string, error) {\n\tvar err error\n\tserviceName, ok := endpointSlice.Labels[discovery.LabelServiceName]\n\tif !ok || serviceName == \"\" {\n\t\terr = fmt.Errorf(\"No %s label set on endpoint slice: %s\", discovery.LabelServiceName, endpointSlice.Name)"
  },
  {
    "id" : "407bcafa-44ed-419a-8e86-0c2139a1d80c",
    "prId" : 82289,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82289#pullrequestreview-284511046",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8798ce79-bb8a-4385-9a38-228cac7ec813",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Should nil be returned as the first component of return value (types.NamespacedName) in this case ?",
        "createdAt" : "2019-09-05T19:49:45Z",
        "updatedAt" : "2019-09-05T19:49:46Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "98e87505-d6a9-4087-bc00-b50ec332e02f",
        "parentId" : "8798ce79-bb8a-4385-9a38-228cac7ec813",
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "See #82389",
        "createdAt" : "2019-09-05T20:09:33Z",
        "updatedAt" : "2019-09-05T20:09:33Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "8f9483d827f0e7f2b605a0bce95e11702f1ff9c7",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +226,230 @@\t\terr = fmt.Errorf(\"No %s label set on endpoint slice: %s\", discovery.LabelServiceName, endpointSlice.Name)\n\t} else if endpointSlice.Namespace == \"\" || endpointSlice.Name == \"\" {\n\t\terr = fmt.Errorf(\"Expected EndpointSlice name and namespace to be set: %v\", endpointSlice)\n\t}\n\treturn types.NamespacedName{Namespace: endpointSlice.Namespace, Name: serviceName}, endpointSlice.Name, err"
  },
  {
    "id" : "f471f90c-d3b2-49d7-8c42-cfd39c9a1e11",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-277947313",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cde74347-738f-4faf-8816-c7dad3d7be17",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "future reference, endpointsslicecache{,_test}.go by itself is a good PR to make that is independent and can be pretty easy to review.",
        "createdAt" : "2019-08-21T17:53:08Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +-1,3 @@/*\nCopyright 2019 The Kubernetes Authors.\n"
  },
  {
    "id" : "73fe8410-041f-4d0d-b42d-cefe3d9c423d",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-278668127",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "400d5146-099d-4b04-ba85-97b906ea676a",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "don't need `utilproxy` (no conflict)",
        "createdAt" : "2019-08-21T17:53:38Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      },
      {
        "id" : "50a319af-ef75-4732-9d35-c4f2eb1c7962",
        "parentId" : "400d5146-099d-4b04-ba85-97b906ea676a",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "That's what it's referred to/imported as throughout kube-proxy as far as I can tell, despite there generally not being conflicts with just a `util` import. I'd thought that was to help keep calls to that package consistent and clear - there are a lot of util packages out there. This was me trying to follow the pattern I'd seen elsewhere in the kube-proxy codebase. If there were a future conflict, should the first lib that had been imported be the one that kept the `util` name?",
        "createdAt" : "2019-08-22T20:27:58Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +25,29 @@\t\"k8s.io/client-go/tools/record\"\n\t\"k8s.io/klog\"\n\tutilproxy \"k8s.io/kubernetes/pkg/proxy/util\"\n\tutilnet \"k8s.io/utils/net\"\n)"
  },
  {
    "id" : "5bb9110c-b16c-4736-b91d-a0acaa49590f",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-278670503",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e16eaf84-126b-46f2-9e5f-b18c1ea787f1",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "don't need `utilnet` (no conflict)",
        "createdAt" : "2019-08-21T17:53:55Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      },
      {
        "id" : "d9c19b98-36f1-49f7-b851-faf1c2565354",
        "parentId" : "e16eaf84-126b-46f2-9e5f-b18c1ea787f1",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Same thoughts as above, in this case calls importing as `net` seems like it could be confused with the stdlib `net`, but I'm still pretty new to Go and not sure what's standard practice here, was just going off of what I saw elsewhere in kube-proxy.",
        "createdAt" : "2019-08-22T20:29:53Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "d0feaf29-ced1-45a3-bc6f-d9bbd129ce7c",
        "parentId" : "e16eaf84-126b-46f2-9e5f-b18c1ea787f1",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "A quick search of the k8s codebase for \"k8s.io/utils/net\" shows that it's always required with some kind of name, most commonly `utilnet`. I can't find any cases of it being used as just `net`.",
        "createdAt" : "2019-08-22T20:32:35Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +26,30 @@\t\"k8s.io/klog\"\n\tutilproxy \"k8s.io/kubernetes/pkg/proxy/util\"\n\tutilnet \"k8s.io/utils/net\"\n)\n"
  },
  {
    "id" : "ce2249fb-8f95-4047-8acd-ba86761ca7f4",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-279244970",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "024725ac-5a17-4bef-a74b-07ca254b4317",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "should this be gated and return nil if not enabled?",
        "createdAt" : "2019-08-21T17:58:35Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ecfe38aa-31fc-445d-8be3-16979ca74852",
        "parentId" : "024725ac-5a17-4bef-a74b-07ca254b4317",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "There are two feature gates now. The one we already had is at a very high level in the kube-proxy startup where we initialize the endpoint slice informer and handlers if the feature gate is enabled, otherwise we enable the traditional endpoints logic. https://github.com/robscott/kubernetes/blob/endpointslice-proxy/cmd/kube-proxy/app/server.go#L621\r\n\r\nI added a second feature gate check in the ipvs and iptables proxiers that gets passed through to NewEndpointChangeTracker() and only initializes an EndpointSliceCache if that feature gate is set. Hopefully those two are sufficient. https://github.com/robscott/kubernetes/blob/endpointslice-proxy/pkg/proxy/iptables/proxier.go#L329",
        "createdAt" : "2019-08-23T22:20:35Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +60,64 @@\n// NewEndpointSliceCache initializes an EndpointSliceCache.\nfunc NewEndpointSliceCache(hostname string, isIPv6Mode *bool, recorder record.EventRecorder, makeEndpointInfo makeEndpointFunc) *EndpointSliceCache {\n\tif makeEndpointInfo == nil {\n\t\tmakeEndpointInfo = standardEndpointInfo"
  },
  {
    "id" : "8b956a87-010d-44a7-8607-5f3fc473b88d",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-277947313",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12307091-cdfb-45f0-ac17-49c624694372",
        "parentId" : null,
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "// Topology is ?map of labels? to ? (please document)",
        "createdAt" : "2019-08-21T18:00:16Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +56,60 @@type endpointInfo struct {\n\tAddresses []string\n\tTopology  map[string]string\n}\n"
  },
  {
    "id" : "3ac15d1d-bfad-4c73-a46d-019dfbc5888c",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-277961864",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31e912df-3f42-4b6f-9376-903423a86226",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "leave a `TODO: handle nil ports to mean \"all\"` ?",
        "createdAt" : "2019-08-21T18:14:48Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +128,132 @@\t\t\t// TODO: handle nil ports to mean \"all\"\n\t\t\tif port.Port == nil || *port.Port == int32(0) {\n\t\t\t\tklog.Warningf(\"ignoring invalid endpoint port %s\", *port.Name)\n\t\t\t\tcontinue\n\t\t\t}"
  },
  {
    "id" : "e60fe27b-1827-4eab-b9d3-1148227def17",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-279825869",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34fc0988-54a8-4e3a-ab59-b557610fd892",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "add a comment here:\r\n\r\nendpoint with nil ready condition is interpreted as Ready.",
        "createdAt" : "2019-08-26T20:42:19Z",
        "updatedAt" : "2019-08-29T08:08:21Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +91,95 @@\t}\n\tfor _, endpoint := range endpointSlice.Endpoints {\n\t\tif endpoint.Conditions.Ready == nil || *endpoint.Conditions.Ready == true {\n\t\t\tesInfo.Endpoints = append(esInfo.Endpoints, &endpointInfo{\n\t\t\t\tAddresses: endpoint.Addresses,"
  },
  {
    "id" : "c91f6660-5fc1-42c3-ab0b-0c7d88332d54",
    "prId" : 81430,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81430#pullrequestreview-281772275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "549f37d0-407e-427d-b1e4-f9c22e0340f2",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Should the error be returned ?\r\n\r\nOr, do what line 220 does.\r\n\r\nIf you agree, I can send out a PR (with 2nd option which I think makes more sense).",
        "createdAt" : "2019-08-29T23:37:50Z",
        "updatedAt" : "2019-08-29T23:54:44Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "9665c590c7ac8801215a0bc89d12a9bafb8ceb9d",
    "line" : 223,
    "diffHunk" : "@@ -1,1 +221,225 @@\t}\n\tif len(endpointSlice.OwnerReferences) > 1 {\n\t\tklog.Errorf(\"More than 1 owner reference set on endpoint slice: %s\", endpointSlice.Name)\n\t}\n\townerRef := endpointSlice.OwnerReferences[0]"
  },
  {
    "id" : "c2301db5-9674-4e20-a3b4-48110d419638",
    "prId" : 72046,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72046#pullrequestreview-317244091",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c2c04ab-cba1-4f18-88b5-648358aeae99",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "epslice controller currently hardcodes hostname, zone, region as keys.\r\n\r\n@robscott - should we change that to look at service topology keys if the gate is enabled?  Or is that too confusing for now?",
        "createdAt" : "2019-11-12T20:58:11Z",
        "updatedAt" : "2019-11-15T06:38:02Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "16d89d0c-14e8-4efc-81f5-4e412b433901",
        "parentId" : "5c2c04ab-cba1-4f18-88b5-648358aeae99",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "@thockin Just catching up here, what would that look like? Would it involve changing what is being set in `EndpointSlices.Endpoints[i].Topology` to only include keys from `Service.Spec.TopologyKeys`?",
        "createdAt" : "2019-11-13T05:38:37Z",
        "updatedAt" : "2019-11-15T06:38:02Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "f05268d3-fb7c-47ff-b3cd-98a81b7432f4",
        "parentId" : "5c2c04ab-cba1-4f18-88b5-648358aeae99",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "That's what I was thinking.  Or maybe the magic 3 PLUS anything set in topology keys ?",
        "createdAt" : "2019-11-14T20:38:24Z",
        "updatedAt" : "2019-11-15T06:38:02Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "31d623b4d74ceadfad101d36a4710d4406fcf144",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +255,259 @@\n\t\tisLocal := cache.isLocal(endpoint.Topology[v1.LabelHostname])\n\t\tendpointInfo := newBaseEndpointInfo(endpoint.Addresses[0], portNum, isLocal, endpoint.Topology)\n\n\t\t// This logic ensures we're deduping potential overlapping endpoints"
  }
]
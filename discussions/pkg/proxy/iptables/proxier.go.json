[
  {
    "id" : "2284ac3c-ab55-43af-b781-56141ac25053",
    "prId" : 103451,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103451#pullrequestreview-700493693",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7d8e6542-cb7d-4163-b8b3-eca983abb659",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Should we remove them from the interface?",
        "createdAt" : "2021-07-06T19:06:10Z",
        "updatedAt" : "2021-07-06T19:18:51Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "be3dd608-44e0-4ce5-b247-c868b5d51ee1",
        "parentId" : "7d8e6542-cb7d-4163-b8b3-eca983abb659",
        "authorId" : "795a7242-f965-4c9a-b641-070356320c29",
        "body" : "Since `userspace` still exists, we can't remove it from the interface just yet. Once we remove support for `userspace` we remove from the interface as well.",
        "createdAt" : "2021-07-06T19:25:04Z",
        "updatedAt" : "2021-07-06T19:25:04Z",
        "lastEditedBy" : "795a7242-f965-4c9a-b641-070356320c29",
        "tags" : [
        ]
      },
      {
        "id" : "cfb8c76e-1a2e-49fa-adb6-ec6c1d031ba2",
        "parentId" : "7d8e6542-cb7d-4163-b8b3-eca983abb659",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "cc @danwinship ",
        "createdAt" : "2021-07-06T22:37:02Z",
        "updatedAt" : "2021-07-06T22:37:02Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "a2134dbf-b0bd-44f2-87cc-b993fa648204",
        "parentId" : "7d8e6542-cb7d-4163-b8b3-eca983abb659",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Definitely no need to block this PR, but both `userspace` and `win_userspace` proxiers actually appear to have old copies of this code contained locally so it is likely safe to remove these at some point.\r\n\r\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/userspace/proxier.go#L668\r\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/winuserspace/proxier.go#L438",
        "createdAt" : "2021-07-06T22:38:37Z",
        "updatedAt" : "2021-07-06T22:42:51Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "58dbc909-f9c8-4fc8-9f09-41b59907d6d7",
        "parentId" : "7d8e6542-cb7d-4163-b8b3-eca983abb659",
        "authorId" : "795a7242-f965-4c9a-b641-070356320c29",
        "body" : "It is possible, but the change would require changes to the expected interfaces in the ProxyServers in `cmd/kube-proxy` and changing the logic to keep track of the userspace proxiers vs the other proxiers. I feel like instead of adding that, it may be better to remove that path completely if userspace is no longer an option we want to support.",
        "createdAt" : "2021-07-07T01:14:43Z",
        "updatedAt" : "2021-07-07T01:14:43Z",
        "lastEditedBy" : "795a7242-f965-4c9a-b641-070356320c29",
        "tags" : [
        ]
      }
    ],
    "commit" : "0a42f7b9890b9ffc68e88d9eede5207e7f3ea869",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +581,585 @@\n// iptables proxier only uses EndpointSlice, the following methods\n// exist to implement the Proxier interface but are noops\n\n// OnEndpointsAdd is called whenever creation of new endpoints object"
  },
  {
    "id" : "7529e69e-3111-450b-a77e-fdb7291c078b",
    "prId" : 99653,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99653#pullrequestreview-605596381",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2363dcf-15d7-4c3b-8d9b-886a66e5b937",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "really minor point: this still includes COMMIT.  If you moved it up 9 lines, before we add the COMMIT, it would be a tiiiiiiiiny bit more accurate :)",
        "createdAt" : "2021-03-05T16:33:48Z",
        "updatedAt" : "2021-03-05T16:36:32Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ada5f67f-521a-4b83-96ca-41e23753cd39",
        "parentId" : "a2363dcf-15d7-4c3b-8d9b-886a66e5b937",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "O(N+1) XD",
        "createdAt" : "2021-03-05T21:03:26Z",
        "updatedAt" : "2021-03-05T21:03:26Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "654be57022d6d78f1ed487c7f548bf8497cfa0b5",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1605,1609 @@\tproxier.iptablesData.Write(proxier.natRules.Bytes())\n\n\tnumberFilterIptablesRules := utilproxy.CountBytesLines(proxier.filterRules.Bytes())\n\tmetrics.IptablesRulesTotal.WithLabelValues(string(utiliptables.TableFilter)).Set(float64(numberFilterIptablesRules))\n\tnumberNatIptablesRules := utilproxy.CountBytesLines(proxier.natRules.Bytes())"
  },
  {
    "id" : "8c9c3487-f3af-4e06-b2f8-bd0f5f7fc80f",
    "prId" : 98130,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98130#pullrequestreview-573514251",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f092bbe-625d-4ac3-8d0b-571ff8727963",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "just skip v1.ProtocolUDP too to not hold the local port, I want to discard that is this who is swallowing the packet",
        "createdAt" : "2021-01-21T16:24:44Z",
        "updatedAt" : "2021-02-15T08:38:35Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "8b1e14d5-58e0-47d7-96bc-8cd30c1ea5c9",
        "parentId" : "4f092bbe-625d-4ac3-8d0b-571ff8727963",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "sorry wong place, this is only for externalIPs\r\n",
        "createdAt" : "2021-01-21T16:32:54Z",
        "updatedAt" : "2021-02-15T08:38:35Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "00e26e97855dbc47e47dcd09569430642470a480",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +1098,1102 @@\t\t\t// machine, hold the local port open so no other process can open it\n\t\t\t// (because the socket might open but it would never work).\n\t\t\tif (svcInfo.Protocol() != v1.ProtocolSCTP) && localAddrSet.Has(net.ParseIP(externalIP)) {\n\t\t\t\tlp := utilnet.LocalPort{\n\t\t\t\t\tDescription: \"externalIP for \" + svcNameString,"
  },
  {
    "id" : "291e8571-042d-4cd6-8d2c-6ae89caf2155",
    "prId" : 98130,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98130#pullrequestreview-574104275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ab3d01c-e636-465f-ba26-ed6df6402bd7",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "this is unfortunate, so we are using lowercase in all the `proxy` code but in the library we use uppercase",
        "createdAt" : "2021-01-22T09:46:35Z",
        "updatedAt" : "2021-02-15T08:38:35Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "cdfa91ba-2812-4d9e-8d15-cc3142ec57f3",
        "parentId" : "2ab3d01c-e636-465f-ba26-ed6df6402bd7",
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : "That is the big differece between proxy/util/port.go and k8s.io/util/port.go. The other is LocalPort of k8s.io/util/port.go has new field ipfamily.",
        "createdAt" : "2021-01-22T09:50:59Z",
        "updatedAt" : "2021-02-15T08:38:35Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      }
    ],
    "commit" : "00e26e97855dbc47e47dcd09569430642470a480",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +1104,1108 @@\t\t\t\t\tIPFamily:    localPortIPFamily,\n\t\t\t\t\tPort:        svcInfo.Port(),\n\t\t\t\t\tProtocol:    utilnet.Protocol(svcInfo.Protocol()),\n\t\t\t\t}\n\t\t\t\tif proxier.portsMap[lp] != nil {"
  },
  {
    "id" : "89689dea-2192-4317-9565-576a863cd685",
    "prId" : 98083,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/98083#pullrequestreview-579005238",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6236015-b8b2-4d9a-829f-7f35c55d1545",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "When you put these right next to each other, they seem to overlap a bit.  We should clean this up.  Later.",
        "createdAt" : "2021-01-29T07:33:46Z",
        "updatedAt" : "2021-01-29T07:35:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d79cda1f-b867-4f66-9be7-10224a6b2e22",
        "parentId" : "c6236015-b8b2-4d9a-829f-7f35c55d1545",
        "authorId" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "body" : "which place you think it is overlap? :)  ",
        "createdAt" : "2021-01-29T07:42:00Z",
        "updatedAt" : "2021-01-29T07:42:01Z",
        "lastEditedBy" : "5c4757f6-5a7a-438b-b77f-778928cb6979",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f506cadb040940dffbc40b8aae394bdbdd757f6",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +993,997 @@\t}\n\n\tlocalAddrSet := utilproxy.GetLocalAddrSet()\n\tnodeAddresses, err := utilproxy.GetNodeAddresses(proxier.nodePortAddresses, proxier.networkInterfacer)\n\tif err != nil {"
  },
  {
    "id" : "465a6568-f841-4600-ad76-b34cc83c30d1",
    "prId" : 97824,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97824#pullrequestreview-581706922",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ba9a1cf-3b30-4de2-99c4-73bb7df6745a",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "should go inside the `if svcInfo.NodePort() != 0` section",
        "createdAt" : "2021-02-02T13:10:58Z",
        "updatedAt" : "2021-02-03T15:23:20Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "8a09d6f9-b425-4e4e-b42f-f1d439c5e1c7",
        "parentId" : "9ba9a1cf-3b30-4de2-99c4-73bb7df6745a",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Node ports are now optional for load balancers (see `spec.allocateLoadBalancerNodePorts`), so a separate check still makes sense since healthCheckNodePorts is always set regardless of whether node ports is enabled. ",
        "createdAt" : "2021-02-02T14:53:52Z",
        "updatedAt" : "2021-02-03T15:23:20Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "2ef30978-7cae-4830-ae9d-bff5e7e993e7",
        "parentId" : "9ba9a1cf-3b30-4de2-99c4-73bb7df6745a",
        "authorId" : "89c2ffa8-b294-43fc-85c3-8f33b486c9b5",
        "body" : "Second to @andrewsykim, I think these are effectively the same, for now, `HealthCheckNodePort` will be non-zero only if the svc is of `LoadBalancer` type. And if the service is of `LoadBalancer` type, then it should have a non-zero `NodePort`. To me it's api-server's job to validate the spec and ensure all the svc proxy sees are valid (see my previous [comment](https://github.com/kubernetes/kubernetes/pull/97824#issuecomment-756515241)). If couple the logic here then if someday the validation logic changed, then we also need to fix it here.",
        "createdAt" : "2021-02-02T19:40:10Z",
        "updatedAt" : "2021-02-03T15:23:20Z",
        "lastEditedBy" : "89c2ffa8-b294-43fc-85c3-8f33b486c9b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "4cd1eacbc1f90e60061818d1b4713f78e78de0f9",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +1340,1344 @@\n\t\t// Capture healthCheckNodePorts.\n\t\tif svcInfo.HealthCheckNodePort() != 0 {\n\t\t\t// no matter if node has local endpoints, healthCheckNodePorts\n\t\t\t// need to add a rule to accept the incoming connection"
  },
  {
    "id" : "f6fdca35-e152-44b6-a9f0-0389bfe82c2e",
    "prId" : 97678,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97678#pullrequestreview-563136365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa9e5318-d24b-462a-aa9c-6a3775326f59",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "same",
        "createdAt" : "2021-01-07T00:46:45Z",
        "updatedAt" : "2021-01-07T02:49:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "07990e44bff4dcfec47dcb2fb0685ea50331add1",
    "line" : 126,
    "diffHunk" : "@@ -1,1 +703,707 @@func (proxier *Proxier) OnNodeDelete(node *v1.Node) {\n\tif node.Name != proxier.hostname {\n\t\tklog.ErrorS(nil, \"Received a watch event for a node that doesn't match the current node\",\n\t\t\t\"eventNode\", node.Name, \"currentNode\", proxier.hostname)\n\t\treturn"
  },
  {
    "id" : "189830eb-ac2c-42c0-ba79-4218642bd37e",
    "prId" : 97678,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97678#pullrequestreview-563136365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "93af7204-0e44-43e8-aa2b-ca178304e183",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "protocol here is correct",
        "createdAt" : "2021-01-07T00:49:29Z",
        "updatedAt" : "2021-01-07T02:49:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "07990e44bff4dcfec47dcb2fb0685ea50331add1",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +854,858 @@\tfor _, svcPortName := range endpointUpdateResult.StaleServiceNames {\n\t\tif svcInfo, ok := proxier.serviceMap[svcPortName]; ok && svcInfo != nil && conntrack.IsClearConntrackNeeded(svcInfo.Protocol()) {\n\t\t\tklog.V(2).InfoS(\"Stale service\", \"protocol\", strings.ToLower(string(svcInfo.Protocol())), \"svcPortName\", svcPortName.String(), \"clusterIP\", svcInfo.ClusterIP().String())\n\t\t\tstaleServices.Insert(svcInfo.ClusterIP().String())\n\t\t\tfor _, extIP := range svcInfo.ExternalIPStrings() {"
  },
  {
    "id" : "a99190c4-1768-4616-82ef-20e4531c0921",
    "prId" : 97238,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97238#pullrequestreview-693093776",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Does this mean we're adding significantly more chains (`O(endpoints)`)?  Or do we have per endpoint chains elsewhere?  What's the performance impact of this?",
        "createdAt" : "2021-03-09T14:38:43Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "523be334-90b5-48c7-9527-f66a8dfb35aa",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Or can i safely assume this is NOT adding more per endpoint chains?  The comment is confusing.  Are we going from `O(ready endpoints)` chains to `O(endpoints)` chains?",
        "createdAt" : "2021-03-09T14:39:35Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "40f1d69a-e0ff-4b6b-a02f-0dd79aa15381",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yeah, I guess this change roughly changes kube-proxy from `O(ready endpoints)` to `O(ready endpoints + local endpoints + not serving endpoints)` chains and loops?",
        "createdAt" : "2021-03-09T14:43:56Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "c294730c-5a51-41c8-95bd-5a6a7c0eb133",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I think this actually reduces total number of iptable rules. There are actually two sets of rules that exist today:\r\n1. The entire endpoint chains containing DNAT rules to a pod\r\n2. The service chain which randomly picks one of the endpoint chains from 1. \r\n\r\nThis change preserves the full endpoint chain from 1, but it updates 2. to only include ready endpoints or terminating endpoints. \r\n\r\nThere is a performance penalty here for kube-proxy's sync loop though, because it now does two loops per Service, once for `endpointChains` and once for `readyEndpointChains`, but this seems negligible to me. ",
        "createdAt" : "2021-03-10T15:49:35Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "ea91554e-5a7d-434e-9749-66dbbae92293",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Previously we only made chains for ready endpoints, and not-ready endpoints were just skipped.  Now we have chains for all endpoints.  If you assume that most endpoints are ready most of the time, this seems OK.  I don't see how this is less rules, though?\r\n\r\nThis updates the XLB chain, not the main service chain, and the whole point of this is that it can include terminating endpoints when it used to include nothing - so strictly MORE rules.  Right?",
        "createdAt" : "2021-03-13T19:14:17Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "402b2585-f125-40c4-b502-0428964da145",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> This updates the XLB chain, not the main service chain, and the whole point of this is that it can include terminating endpoints when it used to include nothing - so strictly MORE rules. Right?\r\n\r\nAt some point this PR updated the main service chain cause we wanted to fallback for `internalTrafficPolicy` as well, but I think we're now saying we only want it for `externalTrafficPolicy`, so yes more chains in that case. ",
        "createdAt" : "2021-04-05T15:33:47Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "cc542080-8752-4b5e-a13d-8f2c6826f0ff",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "To close this out - we will make more chains after this change but it should not be significant because most chains are ready most of the time, anyway?",
        "createdAt" : "2021-05-28T23:09:32Z",
        "updatedAt" : "2021-05-28T23:27:31Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b524e68d-8bde-4d61-8447-f33ab34795b4",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I think ultimately we are going to be adding more chains, but the # of rules evaluated should not change since only ALL ready or ALL terminating endpoints are evaluated based on the probalistic load balancing in the service chain. ",
        "createdAt" : "2021-06-04T02:01:34Z",
        "updatedAt" : "2021-06-04T02:01:34Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "1157f8e4-e6cd-4ebb-b805-2f4a5b7d03dd",
        "parentId" : "0611b3bb-1cc4-4ae2-86ac-8959a229c8f9",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Resolving this in favor of the above comment thread",
        "createdAt" : "2021-06-25T21:29:09Z",
        "updatedAt" : "2021-06-25T22:28:27Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "1010e6a9d98f406a6687eb33573713893dc5431e",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +1447,1451 @@\t\t// Every endpoint gets a chain, regardless of its state. This is required later since we may\n\t\t// want to jump to endpoint chains that are terminating.\n\t\tfor i, endpointChain := range endpointChains {\n\t\t\tepIP := endpoints[i].IP()\n\t\t\tif epIP == \"\" {"
  },
  {
    "id" : "a45635cd-da1b-4486-aad6-0da48858b6e3",
    "prId" : 97238,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/97238#pullrequestreview-695856750",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is going to make Chains for all endpoints, even if we choose not to use them.  Is that what we want?  If so, we should comment it in the next section.  If not, maybe that happens later?",
        "createdAt" : "2021-03-13T18:42:04Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c486325e-50c9-4694-b10f-95f219d3af94",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> This is going to make Chains for all endpoints, even if we choose not to use them. Is that what we want?\r\n\r\nYes, all chains need to exist so we can use them when needed, but the iptables probablistic loadbalancing will not include chains we don't want. ",
        "createdAt" : "2021-04-05T15:31:15Z",
        "updatedAt" : "2021-04-29T20:54:43Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "0b2aa524-6abf-4fec-acec-d4902541462b",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'm worried about bloating the iptables-restore more than we need.  This will include unready endpoints, which did not used to be included.  I *hope* that's not a huge fraction (compared to ready endpoints) so this is PROBABLY safe, but I hope you see my concern.  Tell me I am missing something or this is not a big deal?",
        "createdAt" : "2021-05-28T22:49:45Z",
        "updatedAt" : "2021-05-28T23:27:31Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3c9d6cb1-2545-486d-b766-e19c3f4cee28",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Yes, this does increase total lines in iptables-restore, but it doesn't actually change the number of rules evaluated, since the service chain decides which endpoint chain to jump to based on probability, and that never includes terminating endpoints unless they are the only endpoints remaining. \r\n\r\nSo IMO as long as we are not adding more rules to be evaluated and assuming there aren't a huge number of unready endpoints compared to ready endpoints, this seems safe. ",
        "createdAt" : "2021-06-04T01:57:22Z",
        "updatedAt" : "2021-06-04T01:57:22Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "41b2fc4a-1325-4d50-a664-cbf8ccf3e8a0",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "^ although being honest I have not run extensive tests to prove this :) ",
        "createdAt" : "2021-06-04T01:57:37Z",
        "updatedAt" : "2021-06-04T01:57:37Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "a400dba4-5d6f-406f-8812-bb73d2f96e65",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "There is one performance problem \"evaluating rules\" and other one \"sending the rules\" to the kernel\r\nhttps://developers.redhat.com/blog/2020/04/27/optimizing-iptables-nft-large-ruleset-performance-in-user-space\r\nI think Tim refers to the later ... I have to look, I had some code that allows to specify a number of service and endpoint per service and returned the number of iptables rules generated\r\n\r\nWe have now metrics in kube-proxy to report the number of iptables rules https://github.com/kubernetes/kubernetes/commit/654be57022d6d78f1ed487c7f548bf8497cfa0b5\r\n\r\n",
        "createdAt" : "2021-06-08T11:04:34Z",
        "updatedAt" : "2021-06-08T11:04:34Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "da1d778b-9d45-4a86-9eb4-3bd9201c9810",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "I've found the code to test the number of generated lines, if nobody beats me I'll run it with and without this PR https://github.com/kubernetes/kubernetes/commit/d64d3da2ed1d34f09b2acee38b0e5c93118048e0",
        "createdAt" : "2021-06-08T12:29:15Z",
        "updatedAt" : "2021-06-08T12:29:35Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "6ea9d3d7-8b92-4b4c-a92a-fba772a521ef",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "hmm, I should be doing something wrong, I have the same number of iptables rules in this PR, in master and in 1.21.1\r\n\r\nhttps://gist.github.com/aojea/1308f16ad611d76d64b1eafd7bfc9c88#file-experiment-md",
        "createdAt" : "2021-06-11T08:50:58Z",
        "updatedAt" : "2021-06-11T08:50:58Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "92cf99b1-3b4c-4400-928d-7c85a5819747",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "oh, so this only increases the number of lines because we also create rules for the \"unready endpoints\", I don't know how to address that honestly, what is the proportion of unready endpoints and the average time they last?",
        "createdAt" : "2021-06-11T08:57:26Z",
        "updatedAt" : "2021-06-11T08:57:26Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "726fec44-cf29-44e6-b64c-acacaa8f4265",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> what is the proportion of unready endpoints and the average time they last?\r\n\r\nI would think that the # of unready endpoints is typically much lower than ready endpoints. But in certain failure scenarios, I can see this number being higher. It will always vary depending on the cluster and the workloads there. ",
        "createdAt" : "2021-06-11T15:54:38Z",
        "updatedAt" : "2021-06-11T15:54:38Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "d9a58849-1c8e-42f9-acff-3931ce5aef3f",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is what I am concerned about and I simply don't have data that allows us to make the decision.\r\n\r\nThe technical solution would be to overhaul some of this code to refcount endpoints and elide any that we don't need.  That's not a trivial amount of work (I think) but I don't know how to be \"safe\" without it.\r\n\r\nAnd I am not saying \"go do it\" but \"let's convince ourselves that we do or don't need to\"..",
        "createdAt" : "2021-06-25T18:30:00Z",
        "updatedAt" : "2021-06-25T22:28:27Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "4876dce4-8170-460c-b98e-f9329de07583",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "> This is what I am concerned about and I simply don't have data that allows us to make the decision.\r\n\r\nabsolutely agree, this is going to have a totally different behavior depending on the cluster and the workloads, and I can't see how we can know if we are going to regress on performance on 80%, 50%, 15%, ... of the clusters ...\r\n\r\n> The technical solution would be to overhaul some of this code to refcount endpoints and elide any that we don't need. That's not a trivial amount of work (I think) but I don't know how to be \"safe\" without it.\r\n\r\n.. we can always make this opt-in with a well-known annotation \r\n\r\n\r\n",
        "createdAt" : "2021-06-28T10:50:05Z",
        "updatedAt" : "2021-06-28T10:50:05Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "f15aed3b-9471-4078-b8e7-f88497d5d417",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> .. we can always make this opt-in with a well-known annotation\r\n\r\nPersonally against using annotations for things like this, especially if we are trying to do the right things automatically. I think in most cases, falling back to terminating is the right behavior (I could be totally wrong here though).\r\n\r\n> And I am not saying \"go do it\" but \"let's convince ourselves that we do or don't need to\"..\r\n\r\nQuite frankly I'm not sure how to measure this accurately but I'm definitely open to hearing suggestions and trying to run different tests that give us some meaningful data. In the meantime, I can also look into how much extra  work it would be to pre-calculate whether an endpoint chain should exist or not. I agree it's probably not a trivial amount of work. \r\n\r\n\r\n\r\n",
        "createdAt" : "2021-06-28T15:46:42Z",
        "updatedAt" : "2021-06-28T15:47:13Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "2064d593-f79e-472b-a79e-5b33087c6445",
        "parentId" : "2fb8c745-8ba0-475c-9cee-ac6e5b64fb13",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "> Personally against using annotations for things like this, especially if we are trying to do the right things automatically. I think in most cases, falling back to terminating is the right behavior (I could be totally wrong here though).\r\n> \r\n> >\r\n\r\nagree, just was trying to provide alternatives to move forward :smile: ",
        "createdAt" : "2021-06-30T08:44:26Z",
        "updatedAt" : "2021-06-30T08:44:26Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "1010e6a9d98f406a6687eb33573713893dc5431e",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1362,1366 @@\t\tendpointChains = endpointChains[:0]\n\t\tvar endpointChain utiliptables.Chain\n\t\tfor _, ep := range allEndpoints {\n\t\t\tepInfo, ok := ep.(*endpointsInfo)\n\t\t\tif !ok {"
  },
  {
    "id" : "436081c0-7c12-4738-a723-39952ef84544",
    "prId" : 96959,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96959#pullrequestreview-640881708",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d284f62b-b00c-44fd-a21c-4cd4349237ff",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "you can make the `chainName` argument to `WriteRuleLine` be a `utiliptables.Chain` rather than a `string` so that you don't need to cast it in all the callers",
        "createdAt" : "2021-04-18T20:39:26Z",
        "updatedAt" : "2021-04-21T14:41:50Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "3664f0b4-1b11-4079-a9f9-31c0a202b739",
        "parentId" : "d284f62b-b00c-44fd-a21c-4cd4349237ff",
        "authorId" : "b13b2229-4196-4d84-a0fb-238fbdc5407d",
        "body" : "done.",
        "createdAt" : "2021-04-21T09:59:46Z",
        "updatedAt" : "2021-04-21T14:41:50Z",
        "lastEditedBy" : "b13b2229-4196-4d84-a0fb-238fbdc5407d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3fe48e848f49d3c60dd16749228e6471a57458a",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +1069,1073 @@\t\t\t)\n\t\t\tif proxier.masqueradeAll {\n\t\t\t\tutilproxy.WriteRuleLine(proxier.natRules, string(svcChain), append(args, \"-j\", string(KubeMarkMasqChain))...)\n\t\t\t} else if proxier.localDetector.IsImplemented() {\n\t\t\t\t// This masquerades off-cluster traffic to a service VIP.  The idea"
  },
  {
    "id" : "81a87ca8-a505-427a-843f-cb2a9ee061af",
    "prId" : 96296,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96296#pullrequestreview-536017829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24ce5879-470b-4ab0-bca7-9f7dcd59d7f7",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Shouldn't you also jump to MASQ if it is not implemented?  Pessimistic",
        "createdAt" : "2020-11-20T23:33:26Z",
        "updatedAt" : "2020-11-21T23:58:18Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ab8d5937-ba20-4772-8f93-0d2a147b5e4e",
        "parentId" : "24ce5879-470b-4ab0-bca7-9f7dcd59d7f7",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "yep",
        "createdAt" : "2020-11-21T23:58:23Z",
        "updatedAt" : "2020-11-21T23:58:23Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e4642211ac6dc239b6ec2335f86e87696bdedf4",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1136,1140 @@\t\t\t\t\tdestChain = svcChain\n\t\t\t\t\t// This masquerades off-cluster traffic to a External IP.\n\t\t\t\t\tif proxier.localDetector.IsImplemented() {\n\t\t\t\t\t\twriteLine(proxier.natRules, proxier.localDetector.JumpIfNotLocal(args, string(KubeMarkMasqChain))...)\n\t\t\t\t\t} else {"
  },
  {
    "id" : "b1e1c741-9e29-4c51-b060-5b2d860cdaae",
    "prId" : 96296,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96296#pullrequestreview-537737517",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "147a1ee3-42ab-4575-a9e5-83ee7ec4f59d",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "It's been a while since I've read the local detector code, but does this also account for traffic that would be caught with `--src-type LOCAL`?\r\n\r\nCan we assume that externalIP _should_ bind locally in the same way `status.ingress[i].ip` (a.k.a loadbalancerIP) would? Loadbalancer IP has a check for `--src-type LOCAL` which accounts for host network traffic to external IPs. Should we add the same here?",
        "createdAt" : "2020-11-24T04:21:14Z",
        "updatedAt" : "2020-11-24T04:21:55Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "4e6d05ce-4522-4b5a-976d-67b8cb1ca063",
        "parentId" : "147a1ee3-42ab-4575-a9e5-83ee7ec4f59d",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Ah nvm, this would end up jumping to `svcXLBChain` anyways which would have the `--src-type LOCAL` check if traffic was local. ",
        "createdAt" : "2020-11-24T04:29:25Z",
        "updatedAt" : "2020-11-24T04:29:25Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "8191051f-18f1-4956-8995-97b3aeedf543",
        "parentId" : "147a1ee3-42ab-4575-a9e5-83ee7ec4f59d",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "> does this also account for traffic that would be caught with `--src-type LOCAL`?\r\n\r\nCuriously, NO.  It does not.  The \"by CIDR\" implementation will not catch hostNetwork pods.  Looking at how it is used today, it seems like we handle it specially (\"// Next, redirect all src-type=LOCAL -> LB IP to the service chain\") or is moot (MARK_MASQ does nothing).\r\n\r\nI wonder if we should fix that more completely.  Awkward because there are some other rules with the same predicates (MARK_MASQ on the above case).",
        "createdAt" : "2020-11-24T17:17:24Z",
        "updatedAt" : "2020-11-24T17:17:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e4642211ac6dc239b6ec2335f86e87696bdedf4",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1137,1141 @@\t\t\t\t\t// This masquerades off-cluster traffic to a External IP.\n\t\t\t\t\tif proxier.localDetector.IsImplemented() {\n\t\t\t\t\t\twriteLine(proxier.natRules, proxier.localDetector.JumpIfNotLocal(args, string(KubeMarkMasqChain))...)\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteLine(proxier.natRules, append(args, \"-j\", string(KubeMarkMasqChain))...)"
  },
  {
    "id" : "2ac64da0-7735-4a27-b7c2-c43709c1e8a1",
    "prId" : 96251,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/96251#pullrequestreview-524330447",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab8f8463-d399-4981-b7be-d26bdc8cf632",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "let's improve the error messages, we can add the endpointIP, protocol and nodeport number",
        "createdAt" : "2020-11-05T14:43:19Z",
        "updatedAt" : "2020-11-05T14:43:19Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "fdee7b2faade14cebb5156033f7d0e00ff6f1277",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +770,774 @@\t\t\t\terr = conntrack.ClearEntriesForPortNAT(proxier.exec, endpointIP, nodePort, svcProto)\n\t\t\t\tif err != nil {\n\t\t\t\t\tklog.Errorf(\"Failed to delete nodeport-related %s endpoint connections, error: %v\", epSvcPair.ServicePortName.String(), err)\n\t\t\t\t}\n\t\t\t}"
  },
  {
    "id" : "2126cb20-0ddc-42d3-a979-1c34b43b60b3",
    "prId" : 95694,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/95694#pullrequestreview-511518470",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0061dfc4-bd17-4728-95a9-6ed763fea082",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "is this the right way to log this , %v?",
        "createdAt" : "2020-10-19T08:15:53Z",
        "updatedAt" : "2020-10-19T08:15:53Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "edf56348-3458-495c-937a-43ba0c63d414",
        "parentId" : "0061dfc4-bd17-4728-95a9-6ed763fea082",
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "or is better to add a log entry by IP inside the for loop?",
        "createdAt" : "2020-10-19T08:16:57Z",
        "updatedAt" : "2020-10-19T08:16:57Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "914da29b-d9f3-4288-a15f-e196ceb7b8ab",
        "parentId" : "0061dfc4-bd17-4728-95a9-6ed763fea082",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "\"%v\" seem to work fine for map[string]Empty{}",
        "createdAt" : "2020-10-19T08:21:41Z",
        "updatedAt" : "2020-10-19T08:23:52Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3c1777f7d1e1ad0259b43039e6ba6612232c065",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1626,1630 @@\t// Finish housekeeping.\n\t// TODO: these could be made more consistent.\n\tklog.V(4).Infof(\"Deleting stale services IPs: %v\", staleServices.UnsortedList())\n\tfor _, svcIP := range staleServices.UnsortedList() {\n\t\tif err := conntrack.ClearEntriesForIP(proxier.exec, svcIP, v1.ProtocolUDP); err != nil {"
  },
  {
    "id" : "130df544-b74a-4cd8-87c2-2e1c6fa78419",
    "prId" : 95694,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/95694#pullrequestreview-511514233",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89272a8e-7981-47b3-a9fc-9e9c6c445661",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "same question as above, is this the correct way to do it?",
        "createdAt" : "2020-10-19T08:16:39Z",
        "updatedAt" : "2020-10-19T08:16:39Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3c1777f7d1e1ad0259b43039e6ba6612232c065",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +1632,1636 @@\t\t}\n\t}\n\tklog.V(4).Infof(\"Deleting stale endpoint connections: %v\", endpointUpdateResult.StaleEndpoints)\n\tproxier.deleteEndpointConnections(endpointUpdateResult.StaleEndpoints)\n}"
  },
  {
    "id" : "31ea82e2-2015-4744-8974-94fb9fbec15f",
    "prId" : 92312,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92312#pullrequestreview-577303432",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bfe10635-72c6-493f-b9d4-012ea1998dc3",
        "parentId" : null,
        "authorId" : "f3e672e5-b55c-4e3f-9443-b9abf25195da",
        "body" : "why we still need LB forward chain? Is there any rules can jump to LB forward chain if ingress IPMode is Proxy?",
        "createdAt" : "2021-01-27T12:53:37Z",
        "updatedAt" : "2021-01-27T12:54:03Z",
        "lastEditedBy" : "f3e672e5-b55c-4e3f-9443-b9abf25195da",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd5646d56da62a0b930abefd86d142a2ca9404e8",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +1176,1180 @@\t\t\t\t\t// For loadbalancers which direct traffic to service NodePort, the firewall rules will not apply.\n\n\t\t\t\t\tif !utilfeature.DefaultFeatureGate.Enabled(features.LoadBalancerIPMode) || *ingress.IPMode == v1.LoadBalancerIPModeVIP {\n\t\t\t\t\t\targs = append(args[:0],\n\t\t\t\t\t\t\t\"-A\", string(kubeServicesChain),"
  },
  {
    "id" : "07fd6944-ef64-4460-a57a-d362e5f91d36",
    "prId" : 92035,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92035#pullrequestreview-430994581",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71f03b50-1837-4a16-b945-ac4689cdf15c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "as above - a comment about why?",
        "createdAt" : "2020-06-15T21:10:22Z",
        "updatedAt" : "2020-06-15T22:47:00Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "c12534d8b4724424405f848fc7a9afe830859891",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +926,930 @@\t}...)\n\t// Clear the mark to avoid re-masquerading if the packet re-traverses the network stack.\n\twriteLine(proxier.natRules, []string{\n\t\t\"-A\", string(kubePostroutingChain),\n\t\t// XOR proxier.masqueradeMark to unset it"
  },
  {
    "id" : "26dc69d1-0523-4e4b-af52-12ac6caa43b0",
    "prId" : 90103,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/90103#pullrequestreview-422256911",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ef568e0-e44a-4c1b-8c9f-661850666db5",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "nit: we probably want `nodeAddresses` to be casted into a list with `List()` or `UnsortedList()`.",
        "createdAt" : "2020-06-02T00:01:07Z",
        "updatedAt" : "2020-06-02T20:33:20Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "b68312e6884ec7f7c8552ba187cdcf00b7d723c8",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +810,814 @@\tlocalAddrSet.Insert(localAddrs...)\n\n\tnodeAddresses, err := utilproxy.GetNodeAddresses(proxier.nodePortAddresses, proxier.networkInterfacer)\n\tif err != nil {\n\t\tklog.Errorf(\"Failed to get node ip address matching nodeport cidrs %v, services with nodeport may not work as intended: %v\", proxier.nodePortAddresses, err)"
  },
  {
    "id" : "1d0771bf-4ddb-4b74-b921-f2d579257a1d",
    "prId" : 89792,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/89792#pullrequestreview-387612856",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0009d605-ca11-4d4e-846f-51b80774ef66",
        "parentId" : null,
        "authorId" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "body" : "if `externalIP` is invalid `net.ParseIP(externalIP)` will be nil  and this will panic if there is no `localAddrSet.Len() > 0`\r\n\r\nI've tested it with \r\n```\r\nfunc TestIPNets(t *testing.T) {\r\n\ts := IPNetSet{}\r\n\tif s.Has(nil) {\r\n\t\tfmt.Println(\"ok\")\r\n\t}\r\n```\r\nand panics, however with \r\n\r\n```\r\n\ts := IPNetSet{}\r\n\tif len(s) > 0 && s.Has(nil) {\r\n\t\tfmt.Println(\"ok\")\r\n\t}\r\n````\r\nit does not panic",
        "createdAt" : "2020-04-03T21:13:28Z",
        "updatedAt" : "2020-04-03T21:13:29Z",
        "lastEditedBy" : "203dfb85-d185-4057-88b3-a1b4f09fd1fd",
        "tags" : [
        ]
      },
      {
        "id" : "f516aa5b-3e04-4511-808e-00f6b5e1e4d3",
        "parentId" : "0009d605-ca11-4d4e-846f-51b80774ef66",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "That's only because you are using an empty set and the `Has()` method is never called. If there was an invalid externalIP and we still had len > 0 local addresses it would still panic. ",
        "createdAt" : "2020-04-03T22:20:57Z",
        "updatedAt" : "2020-04-03T22:24:00Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "5169ef5fb544471610c575dfaa35410ec85ffd0f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1034,1038 @@\t\t\t// machine, hold the local port open so no other process can open it\n\t\t\t// (because the socket might open but it would never work).\n\t\t\tif (svcInfo.Protocol() != v1.ProtocolSCTP) && localAddrSet.Has(net.ParseIP(externalIP)) {\n\t\t\t\tlp := utilproxy.LocalPort{\n\t\t\t\t\tDescription: \"externalIP for \" + svcNameString,"
  },
  {
    "id" : "57546b11-27c9-4b1c-b9c7-108cd585dfbb",
    "prId" : 87699,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87699#pullrequestreview-351498611",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6eff0251-c5ee-4cdf-a930-7e1e5c734447",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "you don't need `isIPv6` here; you can just call `utilnet.IsIPv6String(lp.IP)`... oh... except you can't because it might be `\"\"`. Well, you could just add an `IPFamily` field to `LocalPort` then.",
        "createdAt" : "2020-01-31T13:07:45Z",
        "updatedAt" : "2020-01-31T13:09:08Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "adbc96f5-96dd-4cf1-b61e-1eae179e7c0f",
        "parentId" : "6eff0251-c5ee-4cdf-a930-7e1e5c734447",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "or maybe set `Protocol` to `tcp4`/`tcp6` rather than just `tcp`? (I didn't look deeply to see if that would make sense...)",
        "createdAt" : "2020-01-31T13:11:17Z",
        "updatedAt" : "2020-01-31T13:11:18Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "9f1937b9-65fc-475b-9635-34e32b447bd3",
        "parentId" : "6eff0251-c5ee-4cdf-a930-7e1e5c734447",
        "authorId" : "ed14b7b6-8d83-4e85-b8b6-0a10d4437a09",
        "body" : "You're right, that (`IPFamily`) also seemed cleaner to me but wasn't sure about `LocalPort`s outside of `openLocalPort` but I'll just ignore it in those cases (i.e. with protocols not tcp or udp).",
        "createdAt" : "2020-01-31T13:15:11Z",
        "updatedAt" : "2020-01-31T13:19:28Z",
        "lastEditedBy" : "ed14b7b6-8d83-4e85-b8b6-0a10d4437a09",
        "tags" : [
        ]
      },
      {
        "id" : "bb41ae35-6d6c-4138-9a96-40005ddae075",
        "parentId" : "6eff0251-c5ee-4cdf-a930-7e1e5c734447",
        "authorId" : "ed14b7b6-8d83-4e85-b8b6-0a10d4437a09",
        "body" : "oh yeah `tcp4`/`tcp6` is better! although I'm not sure how many `protocol == \"tcp\"` kinda checks there are in the code. I'll look into it.",
        "createdAt" : "2020-01-31T13:19:36Z",
        "updatedAt" : "2020-01-31T13:19:36Z",
        "lastEditedBy" : "ed14b7b6-8d83-4e85-b8b6-0a10d4437a09",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eea0d14052d2b00d2191ea1833164896cc3ff51",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +1613,1617 @@}\n\nfunc openLocalPort(lp *utilproxy.LocalPort, isIPv6 bool) (utilproxy.Closeable, error) {\n\t// For ports on node IPs, open the actual port and hold it, even though we\n\t// use iptables to redirect traffic."
  },
  {
    "id" : "1dc75c2c-c174-463b-96f5-d153d2ba8b15",
    "prId" : 87699,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/87699#pullrequestreview-351492365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddd5fbb5-7f11-4a00-a4f5-f0668ad9725e",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "it'd be a little simpler to just have like `family = \"4\"` / `family = \"6\"` outside of the switch and then `net.Listen(\"tcp\" + family, ...`. (So there's less duplication between the tcp and udp cases.)",
        "createdAt" : "2020-01-31T13:08:55Z",
        "updatedAt" : "2020-01-31T13:09:08Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eea0d14052d2b00d2191ea1833164896cc3ff51",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +1633,1637 @@\t\t\tnetwork = \"tcp6\"\n\t\t}\n\t\tlistener, err := net.Listen(network, net.JoinHostPort(lp.IP, strconv.Itoa(lp.Port)))\n\t\tif err != nil {\n\t\t\treturn nil, err"
  },
  {
    "id" : "d9e335cf-9dbc-428f-bb9f-5ba665ddde8b",
    "prId" : 85617,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85617#pullrequestreview-338766163",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f536c6fc-2e05-4fa6-90cc-b237479324f9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Should we log if len(localAddrs) == 0 ?  You specifically tested for it below, but I think that would be a nice thing to log.",
        "createdAt" : "2019-12-17T20:01:17Z",
        "updatedAt" : "2020-02-11T21:44:50Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3071b23e-6038-450a-86ff-f35e71cb0b01",
        "parentId" : "f536c6fc-2e05-4fa6-90cc-b237479324f9",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "done",
        "createdAt" : "2020-01-06T17:01:33Z",
        "updatedAt" : "2020-02-11T21:44:50Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "1653476e3f696a2c42d3a509225cedf966f103cf",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +802,806 @@\t} else if len(localAddrs) == 0 {\n\t\tklog.Warning(\"No local addresses found, assuming all external IPs are not local\")\n\t}\n\n\tlocalAddrSet := utilnet.IPSet{}"
  },
  {
    "id" : "56026bfb-e607-4177-98d2-a03b029c2a0f",
    "prId" : 85617,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/85617#pullrequestreview-357346326",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25fadd30-4e10-46ef-bd2b-d20ce8edfb98",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "nit: Do we really need to check `.Len() == 0` ?",
        "createdAt" : "2020-02-11T22:19:36Z",
        "updatedAt" : "2020-02-11T22:25:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cd82a0d0-1d6e-4d03-9809-3a8865538aba",
        "parentId" : "25fadd30-4e10-46ef-bd2b-d20ce8edfb98",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "No this check was here before the set type was added so I think it's redundant now. I'll remove this in a follow-up PR ",
        "createdAt" : "2020-02-12T10:36:27Z",
        "updatedAt" : "2020-02-12T10:36:28Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "1653476e3f696a2c42d3a509225cedf966f103cf",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +1041,1045 @@\t\t\t// machine, hold the local port open so no other process can open it\n\t\t\t// (because the socket might open but it would never work).\n\t\t\tif localAddrSet.Len() > 0 && (svcInfo.Protocol() != v1.ProtocolSCTP) && localAddrSet.Has(net.ParseIP(externalIP)) {\n\t\t\t\tlp := utilproxy.LocalPort{\n\t\t\t\t\tDescription: \"externalIP for \" + svcNameString,"
  },
  {
    "id" : "a06d543e-1aed-4a7f-a6c0-52440fc2053c",
    "prId" : 82462,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82462#pullrequestreview-333519271",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1cf8e094-97d1-4be7-a63b-17d71760fd81",
        "parentId" : null,
        "authorId" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "body" : "ipt[0] and ipt[1] can have `ipv4, ipv6` or `ipv6,ipv4` as per the code in https://github.com/kubernetes/kubernetes/pull/82462/files#diff-934760ea1a4e195e49bcd10625cf4e46R174",
        "createdAt" : "2019-11-30T01:00:27Z",
        "updatedAt" : "2019-12-17T06:50:36Z",
        "lastEditedBy" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "tags" : [
        ]
      },
      {
        "id" : "d3d7e556-6d72-4a9c-8b32-7696ea5780f7",
        "parentId" : "1cf8e094-97d1-4be7-a63b-17d71760fd81",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "ipt[] is now guaranteed to be v4, v6.  Are clusterCidr[] and nodeIP?  It seems they are, though same comments as above - perhaps turning it into maps would be better",
        "createdAt" : "2019-12-17T19:25:41Z",
        "updatedAt" : "2019-12-17T19:28:26Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "23957a6b28927716bbd84216245106866c131f7b",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +352,356 @@) (proxy.Provider, error) {\n\t// Create an ipv4 instance of the single-stack proxier\n\tipv4Proxier, err := NewProxier(ipt[0], sysctl,\n\t\texec, syncPeriod, minSyncPeriod,\n\t\tmasqueradeAll, masqueradeBit, clusterCIDR[0], hostname, nodeIP[0],"
  },
  {
    "id" : "89d39485-668e-4d26-a45c-0f8e360649a9",
    "prId" : 82462,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/82462#pullrequestreview-324871626",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "807214fa-eb4a-449c-8a89-c5fcc331c79e",
        "parentId" : null,
        "authorId" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "body" : "@lachie83 @aramase \r\nFYI the new metaproxy for both ipvs and iptables does support endpoint slice. So yes. iptables dualstack will support endpointslice. ",
        "createdAt" : "2019-11-30T01:03:14Z",
        "updatedAt" : "2019-12-17T06:50:36Z",
        "lastEditedBy" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "tags" : [
        ]
      }
    ],
    "commit" : "23957a6b28927716bbd84216245106866c131f7b",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +368,372 @@\t}\n\n\treturn metaproxier.NewMetaProxier(ipv4Proxier, ipv6Proxier), nil // TODO move meta-proxier to mode-neutral package\n}\n"
  },
  {
    "id" : "c79effb5-f15e-4f7c-a9d5-7e5973c4b0a6",
    "prId" : 81886,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81886#pullrequestreview-335669212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e427bc24-42b0-48e5-afd4-d637bb354be3",
        "parentId" : null,
        "authorId" : "87ab1d19-ad39-40d0-a045-817039414280",
        "body" : "The comment above suggests that not returning the args was an explicit decision. I'm not sure that re-adding them is the right choice. ",
        "createdAt" : "2019-09-25T14:41:37Z",
        "updatedAt" : "2019-12-22T20:32:35Z",
        "lastEditedBy" : "87ab1d19-ad39-40d0-a045-817039414280",
        "tags" : [
        ]
      },
      {
        "id" : "52b7df10-3158-4db2-9ebf-79cb57504c0b",
        "parentId" : "e427bc24-42b0-48e5-afd4-d637bb354be3",
        "authorId" : "da08428a-7a79-4f6f-8f27-373f0802426a",
        "body" : "We need `return args` here, otherwise on L1187 in this file will replace `args` by nil - see https://github.com/kubernetes/kubernetes/pull/81886#discussion_r328288746.",
        "createdAt" : "2019-09-25T18:59:46Z",
        "updatedAt" : "2019-12-22T20:32:35Z",
        "lastEditedBy" : "da08428a-7a79-4f6f-8f27-373f0802426a",
        "tags" : [
        ]
      },
      {
        "id" : "6d968295-91b9-4ffc-9349-25c9ab86f851",
        "parentId" : "e427bc24-42b0-48e5-afd4-d637bb354be3",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This is fixed in #81563 ",
        "createdAt" : "2019-12-17T00:36:06Z",
        "updatedAt" : "2019-12-22T20:32:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e299a079-3c82-4141-ac84-a4b18d812f4e",
        "parentId" : "e427bc24-42b0-48e5-afd4-d637bb354be3",
        "authorId" : "da08428a-7a79-4f6f-8f27-373f0802426a",
        "body" : "Should we wait for that PR to merge?",
        "createdAt" : "2019-12-22T20:33:31Z",
        "updatedAt" : "2019-12-22T20:33:31Z",
        "lastEditedBy" : "da08428a-7a79-4f6f-8f27-373f0802426a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a54e5cec54b2a11f72e1a77cfe2411b2c8d140d8",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +733,737 @@\t// is large enough, we simply drop those comments.\n\tif proxier.endpointChainsNumber > endpointChainsNumberThreshold {\n\t\treturn args\n\t}\n\treturn append(args, \"-m\", \"comment\", \"--comment\", svcName)"
  },
  {
    "id" : "c1d854e0-d536-4c95-af99-79c35d4f31dc",
    "prId" : 81886,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81886#pullrequestreview-293296137",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "59dc8a70-c308-4041-bc1d-5dbe579cd84d",
        "parentId" : null,
        "authorId" : "da08428a-7a79-4f6f-8f27-373f0802426a",
        "body" : "This change means that the return value of `appendServiceCommentLocked` was previously not used, so comments were never added. PR #81563 was also opened to address this, but because this was also caught by staticcheck I have also fixed it in this PR.",
        "createdAt" : "2019-09-25T18:58:58Z",
        "updatedAt" : "2019-12-22T20:32:35Z",
        "lastEditedBy" : "da08428a-7a79-4f6f-8f27-373f0802426a",
        "tags" : [
        ]
      }
    ],
    "commit" : "a54e5cec54b2a11f72e1a77cfe2411b2c8d140d8",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +1267,1271 @@\t\t\t\t\t\"-A\", string(svcChain),\n\t\t\t\t)\n\t\t\t\targs = proxier.appendServiceCommentLocked(args, svcNameString)\n\t\t\t\targs = append(args,\n\t\t\t\t\t\"-m\", \"recent\", \"--name\", string(endpointChain),"
  },
  {
    "id" : "81bc802f-bbc9-4145-8762-d14569180453",
    "prId" : 81517,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81517#pullrequestreview-277331436",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b20713c-a7bb-43e5-b4d4-dfde36923e42",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Comment on the intentions here, for future me?",
        "createdAt" : "2019-08-20T17:41:52Z",
        "updatedAt" : "2019-09-17T14:20:00Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3948f16ff4060955b7f25d26d261b99589963ade",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +327,331 @@\t// We need to pass *some* maxInterval to NewBoundedFrequencyRunner anyway though.\n\t// time.Hour is arbitrary.\n\tproxier.syncRunner = async.NewBoundedFrequencyRunner(\"sync-runner\", proxier.syncProxyRules, minSyncPeriod, time.Hour, burstSyncs)\n\tgo ipt.Monitor(utiliptables.Chain(\"KUBE-PROXY-CANARY\"),\n\t\t[]utiliptables.Table{utiliptables.TableMangle, utiliptables.TableNAT, utiliptables.TableFilter},"
  },
  {
    "id" : "bdfbc92a-9b2a-4a63-9348-1e88541403c1",
    "prId" : 81517,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/81517#pullrequestreview-294185031",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84e3f6b0-fa57-4473-b2c6-c56ee3f2b617",
        "parentId" : null,
        "authorId" : "5f3d0da0-11c3-49d0-9aa9-f897fad1c961",
        "body" : "I suspect this will break iptables healthz on quiescent clusters. It marks kube-proxy unheahlthy if iptables hasn't been successfully synced in more than 2*SyncPeriod seconds.",
        "createdAt" : "2019-09-27T08:37:50Z",
        "updatedAt" : "2019-09-27T08:37:50Z",
        "lastEditedBy" : "5f3d0da0-11c3-49d0-9aa9-f897fad1c961",
        "tags" : [
        ]
      }
    ],
    "commit" : "3948f16ff4060955b7f25d26d261b99589963ade",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +327,331 @@\t// We need to pass *some* maxInterval to NewBoundedFrequencyRunner anyway though.\n\t// time.Hour is arbitrary.\n\tproxier.syncRunner = async.NewBoundedFrequencyRunner(\"sync-runner\", proxier.syncProxyRules, minSyncPeriod, time.Hour, burstSyncs)\n\tgo ipt.Monitor(utiliptables.Chain(\"KUBE-PROXY-CANARY\"),\n\t\t[]utiliptables.Table{utiliptables.TableMangle, utiliptables.TableNAT, utiliptables.TableFilter},"
  },
  {
    "id" : "c00d3452-48af-4282-b288-fc1f8eeeab96",
    "prId" : 79846,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/79846#pullrequestreview-259092274",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a9d7cbe-6c17-496c-baac-7d3d75543f7f",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "Fix the preceding comment as well. Probably best to say \"`implements proxy.Provider`\". (Likewise in a couple of other places.)",
        "createdAt" : "2019-07-08T18:17:14Z",
        "updatedAt" : "2019-07-08T18:48:49Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "33d7c323-2d6a-4751-aa4f-109b626c22b7",
        "parentId" : "8a9d7cbe-6c17-496c-baac-7d3d75543f7f",
        "authorId" : "62eb404a-5fe6-4b29-afab-583b57ce8f19",
        "body" : "Done!",
        "createdAt" : "2019-07-08T18:49:28Z",
        "updatedAt" : "2019-07-08T18:49:29Z",
        "lastEditedBy" : "62eb404a-5fe6-4b29-afab-583b57ce8f19",
        "tags" : [
        ]
      }
    ],
    "commit" : "2878270f5b9143d6acbf02a45a3ae9734be3cf93",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +274,278 @@\n// Proxier implements proxy.Provider\nvar _ proxy.Provider = &Proxier{}\n\n// NewProxier returns a new Proxier given an iptables Interface instance."
  },
  {
    "id" : "7a609817-7af2-4d73-9965-a3dfc7734db5",
    "prId" : 78662,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78662#pullrequestreview-255968782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d68b9296-e79c-4328-a995-4a2670a4c704",
        "parentId" : null,
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Mentioned here https://github.com/kubernetes/kubernetes/issues/65387#issuecomment-490637949 that this masquerade rule is not needed since we masquerade at the `KEP-SEP*` chains. Thoughts on removing in a follow-up PR? ",
        "createdAt" : "2019-06-03T20:17:42Z",
        "updatedAt" : "2019-06-28T20:42:20Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "29c1d506-3244-4384-8741-8f9ff571cec6",
        "parentId" : "d68b9296-e79c-4328-a995-4a2670a4c704",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "ACK if we can prove it :)",
        "createdAt" : "2019-06-28T20:29:16Z",
        "updatedAt" : "2019-06-28T20:42:20Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "23246a91-b282-493e-bd11-38d1cd845a9d",
        "parentId" : "d68b9296-e79c-4328-a995-4a2670a4c704",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I actually like the explicitness here, will leave it for now ",
        "createdAt" : "2019-06-28T20:50:04Z",
        "updatedAt" : "2019-06-28T20:50:04Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "ba19451020457c2fa89ee9066986243956048091",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +1240,1244 @@\t\targs = append(args[:0], \"-A\", string(svcXlbChain))\n\t\twriteLine(proxier.natRules, append(args,\n\t\t\t\"-m\", \"comment\", \"--comment\", fmt.Sprintf(`\"masquerade LOCAL traffic for %s LB IP\"`, svcNameString),\n\t\t\t\"-m\", \"addrtype\", \"--src-type\", \"LOCAL\", \"-j\", string(KubeMarkMasqChain))...)\n\t\twriteLine(proxier.natRules, append(args,"
  },
  {
    "id" : "ed4c700e-0c08-4353-a037-45ea48751eba",
    "prId" : 78547,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/78547#pullrequestreview-280332458",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85dba528-ed8d-4fda-b5db-f63eb8d0867c",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "So this rule is added both by kube-proxy and by kubelet (`pkg/kubelet/kubelet_network_linux.go`). Currently they're in sync so they're both trying to ensure the existence of the same rule so we only get one copy, but if you change it here, that might break and then we'd end up with 2 rules, one with `--random-fully` and one without.\r\n\r\nThe easy fix is to just also make the `--random-fully` change in kubelet so they stay in sync, but longer term we should probably disentangle these and make them use separate chains...",
        "createdAt" : "2019-08-27T12:19:10Z",
        "updatedAt" : "2019-09-02T02:07:52Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "937c0972-4f3c-40b9-9ce0-61c942972dcb",
        "parentId" : "85dba528-ed8d-4fda-b5db-f63eb8d0867c",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Oh!  I did not even know that kubelet establishes the same rule.\r\n\r\nAnd it looks to me like it does NOT add `--random-fully`:\r\nhttps://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_network_linux.go#L99-L101\r\n\r\nI agree, we should not have two independent pieces of code establishing the same rule.  The kubelet and iptables and ipvs proxies should call one common bit of code.  Any opinion on where that common code should be?",
        "createdAt" : "2019-08-27T15:06:15Z",
        "updatedAt" : "2019-09-02T02:07:52Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "e9127833-fcc7-48be-96d3-af97ada8ec4e",
        "parentId" : "85dba528-ed8d-4fda-b5db-f63eb8d0867c",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "I feel like the right fix is that kubelet and kube-proxy shouldn't try to share rules. But I think this is a bigger conversation then we want to have as part of this PR. So for now I'd recommend just updating the code in kubelet to match the code in kube-proxy.",
        "createdAt" : "2019-08-27T16:48:46Z",
        "updatedAt" : "2019-09-02T02:07:52Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      }
    ],
    "commit" : "d86d1defa1e619b60031d173ed401b00a2d8957f",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +786,790 @@\t\t\"-m\", \"comment\", \"--comment\", `\"kubernetes service traffic requiring SNAT\"`,\n\t\t\"-m\", \"mark\", \"--mark\", proxier.masqueradeMark,\n\t\t\"-j\", \"MASQUERADE\",\n\t}\n\tif proxier.iptables.HasRandomFully() {"
  },
  {
    "id" : "ca86efa8-d77c-40cc-bd2b-9f7cb0480862",
    "prId" : 77523,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77523#pullrequestreview-244131976",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9316698f-bb68-4533-8eab-a9882b846d7f",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Minor point - the comment here says \"first rule\", but you broke that :)\r\n\r\nCan you put the new block after this block, and word the comments in similar fashion? ",
        "createdAt" : "2019-05-31T04:37:08Z",
        "updatedAt" : "2019-05-31T04:39:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5165e7f6-6803-4e16-b305-ccf575a539d7",
        "parentId" : "9316698f-bb68-4533-8eab-a9882b846d7f",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Will do, thanks Tim!",
        "createdAt" : "2019-05-31T04:46:50Z",
        "updatedAt" : "2019-05-31T04:46:50Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "8dfd4def99ea1cc6296b25bc2121af9a72661fdf",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1213,1217 @@\t\t\t\"-m\", \"addrtype\", \"--src-type\", \"LOCAL\", \"-j\", string(svcChain))...)\n\n\t\t// First rule in the chain redirects all pod -> external VIP traffic to the\n\t\t// Service's ClusterIP instead. This happens whether or not we have local\n\t\t// endpoints; only if clusterCIDR is specified"
  },
  {
    "id" : "ab74d780-9b83-4ea2-a8d7-0e80ed7b773d",
    "prId" : 75265,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/75265#pullrequestreview-215729908",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e7bd578-6e9f-4f21-8ff5-779f3affc58f",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Should we catch status.ingress.ip too?",
        "createdAt" : "2019-03-18T15:36:01Z",
        "updatedAt" : "2019-03-18T15:36:01Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "df4856f5-319d-4294-8ba2-0982ffe71b6c",
        "parentId" : "7e7bd578-6e9f-4f21-8ff5-779f3affc58f",
        "authorId" : "1d448ca4-67df-492a-9e1d-11f07f840d09",
        "body" : "@thockin yes we should catch status.ingress.ip also. I will submit another PR",
        "createdAt" : "2019-03-18T17:01:00Z",
        "updatedAt" : "2019-03-18T17:01:00Z",
        "lastEditedBy" : "1d448ca4-67df-492a-9e1d-11f07f840d09",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3548165d5dacd25a12896bacd0f8b6f71c55510",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +674,678 @@\t\t\tklog.V(2).Infof(\"Stale udp service %v -> %s\", svcPortName, svcInfo.ClusterIPString())\n\t\t\tstaleServices.Insert(svcInfo.ClusterIPString())\n\t\t\tfor _, extIP := range svcInfo.ExternalIPStrings() {\n\t\t\t\tstaleServices.Insert(extIP)\n\t\t\t}"
  },
  {
    "id" : "5bc11ac9-d760-417b-903e-3a65f27555d0",
    "prId" : 74840,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/74840#pullrequestreview-223512272",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "114bdbd5-1fe4-4351-b136-61cabe1b2057",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "Wouldn't this need to be near the start of `syncProxyRules` rather than near the end? Many packets have already been matched and redirected by this point...",
        "createdAt" : "2019-03-28T20:25:20Z",
        "updatedAt" : "2019-03-28T20:25:21Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "915a9068-3284-4e0b-a63a-49260c1c1e61",
        "parentId" : "114bdbd5-1fe4-4351-b136-61cabe1b2057",
        "authorId" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "body" : "Yes, it's the first rule in KUBE-FORWARD chain. \r\n\r\n```\r\nChain KUBE-FORWARD (1 references)\r\ntarget     prot opt source               destination \r\n*** NEW RULE INSERTED HERE ***\r\nACCEPT     all  --  anywhere             anywhere             /* kubernetes forwarding rules */ mark match 0x4000/0x4000\r\nACCEPT     all  --  10.36.0.0/14         anywhere             /* kubernetes forwarding conntrack pod source rule */ ctstate RELATED,ESTABLISHED\r\nACCEPT     all  --  anywhere             10.36.0.0/14         /* kubernetes forwarding conntrack pod destination rule */ ctstate RELATED,ESTABLISHED\r\n\r\n```",
        "createdAt" : "2019-03-28T23:03:49Z",
        "updatedAt" : "2019-03-28T23:03:49Z",
        "lastEditedBy" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "tags" : [
        ]
      },
      {
        "id" : "b1f4ea41-e92a-42ab-af4e-942f94273339",
        "parentId" : "114bdbd5-1fe4-4351-b136-61cabe1b2057",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "oh, all the (relevant) stuff before that is in `natRules`, not `filterRules`. ok",
        "createdAt" : "2019-03-29T11:27:23Z",
        "updatedAt" : "2019-03-29T11:27:23Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "6d951cdf-67eb-4462-b62e-a52b0b070d1e",
        "parentId" : "114bdbd5-1fe4-4351-b136-61cabe1b2057",
        "authorId" : "87ab1d19-ad39-40d0-a045-817039414280",
        "body" : "FYI Calico is doing similar things for disabling ConntrackInvalid https://github.com/projectcalico/felix/pull/1424 .\r\n\r\nThe Calico implementation also works for a cluster that runs IPVS as a load-balancer with iptables-mode of k8s-proxy .",
        "createdAt" : "2019-04-04T20:23:55Z",
        "updatedAt" : "2019-04-04T20:24:01Z",
        "lastEditedBy" : "87ab1d19-ad39-40d0-a045-817039414280",
        "tags" : [
        ]
      },
      {
        "id" : "65ed6659-b061-4cd4-af83-ec0c26ace479",
        "parentId" : "114bdbd5-1fe4-4351-b136-61cabe1b2057",
        "authorId" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "body" : "Ah, good to know. Thanks to bring it up @cmluciano . not sure if it should be an option here.. any reason not to enable that option? ",
        "createdAt" : "2019-04-05T23:29:16Z",
        "updatedAt" : "2019-04-05T23:29:16Z",
        "lastEditedBy" : "fa37bbb4-59dd-42f0-8202-52d5717aff5e",
        "tags" : [
        ]
      }
    ],
    "commit" : "a07169bcadf3c35ff456c17bed970ccbca0963cb",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1303,1307 @@\t// https://github.com/kubernetes/kubernetes/issues/74839\n\twriteLine(proxier.filterRules,\n\t\t\"-A\", string(kubeForwardChain),\n\t\t\"-m\", \"conntrack\",\n\t\t\"--ctstate\", \"INVALID\","
  },
  {
    "id" : "abad346d-0cb3-4e9f-acff-66f227c0faae",
    "prId" : 73323,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/73323#pullrequestreview-199788108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3ca7ec2-5d4c-4c16-b693-bd9378c88ada",
        "parentId" : null,
        "authorId" : "cd884bc9-4e36-4d3c-8053-d8739052d502",
        "body" : "This has the potential to indiscriminantly remove all sessions matching external IP to endpointIP regardless if it's stale or not.  Can this be written to be more selective especially if we know the port(s) involved in the stale session?",
        "createdAt" : "2019-01-30T20:11:06Z",
        "updatedAt" : "2019-02-13T17:56:25Z",
        "lastEditedBy" : "cd884bc9-4e36-4d3c-8053-d8739052d502",
        "tags" : [
        ]
      },
      {
        "id" : "6c8027cb-4063-4975-b961-da4e93534312",
        "parentId" : "c3ca7ec2-5d4c-4c16-b693-bd9378c88ada",
        "authorId" : "c1166017-761f-41df-8ad7-07e3dd792799",
        "body" : "There is a check above(L608) to delete stale connections based on the NodePort. If user is not using NodePort and has specified TargetPort by name, that could have a different value for each endPoint. ServiceEndpoint currently does not expose this value.",
        "createdAt" : "2019-02-04T20:20:32Z",
        "updatedAt" : "2019-02-13T17:56:25Z",
        "lastEditedBy" : "c1166017-761f-41df-8ad7-07e3dd792799",
        "tags" : [
        ]
      }
    ],
    "commit" : "24d3ab83dcb97c57eba65fe7b0c0b1c458a7ca82",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +615,619 @@\t\t\t}\n\t\t\tfor _, extIP := range svcInfo.ExternalIPStrings() {\n\t\t\t\terr := conntrack.ClearEntriesForNAT(proxier.exec, extIP, endpointIP, v1.ProtocolUDP)\n\t\t\t\tif err != nil {\n\t\t\t\t\tklog.Errorf(\"Failed to delete %s endpoint connections for externalIP %s, error: %v\", epSvcPair.ServicePortName.String(), extIP, err)"
  },
  {
    "id" : "d2748588-ea5f-4ec8-8bb5-6563cfa62bef",
    "prId" : 72334,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/72334#pullrequestreview-192114306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e68d9879-6926-44b0-a1fe-6f12dcc953d3",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Is this dropping precision? why?  I expect that most of the time this takes < 1 second, butthe difference between 0.2 seconds and 0.9 seconds is kind of meaningful.  It seems to be float so maybe it's just weird naming?",
        "createdAt" : "2019-01-11T16:44:51Z",
        "updatedAt" : "2019-01-11T16:47:28Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d44f72f4-8738-4049-8d18-81bfd86493e0",
        "parentId" : "e68d9879-6926-44b0-a1fe-6f12dcc953d3",
        "authorId" : "a472aa4a-c4f7-4692-bc21-708257a1dacc",
        "body" : "@thockin In fact, `SinceInSeconds` (nanoseconds level) have higher precision than `SinceInMicroseconds` (microseconds level).\r\nFor example:\r\nThe result of this case:\r\n```\r\nfmt.Printf(\"SinceInMicroseconds: %v\\nSinceInSeconds: %v\\n\", SinceInMicroseconds(time.Now().Add(-time.Second)), SinceInSeconds(time.Now().Add(-time.Second)))\r\n```\r\nis\r\n```\r\nSinceInMicroseconds: 1.000001e+06\r\nSinceInSeconds: 1.000000806\r\n```\r\nThe name `SinceInSeconds` is used to show its unit as `seconds`.\r\nBut we can discuss about this naming. cc @brancz",
        "createdAt" : "2019-01-14T03:12:23Z",
        "updatedAt" : "2019-01-14T03:12:23Z",
        "lastEditedBy" : "a472aa4a-c4f7-4692-bc21-708257a1dacc",
        "tags" : [
        ]
      },
      {
        "id" : "b8dfe27a-8c2b-4a05-8033-9bee5185e77c",
        "parentId" : "e68d9879-6926-44b0-a1fe-6f12dcc953d3",
        "authorId" : "4108cff4-d61c-4717-862b-6c3be3b73be2",
        "body" : "We're not loosing precision as it's still a float64, this is just a consistency change, to make sure all metrics use the base unit, which is the best practice so it is easier for different metrics to be used with each other (this is part of the Prometheus instrumentation best practices, which among others includes using [seconds as time base unit](https://prometheus.io/docs/practices/naming/#base-units). Complying to the Prometheus best practices is one of the motivations for the [metrics overhaul KEP](https://github.com/kubernetes/enhancements/blob/master/keps/sig-instrumentation/0031-kubernetes-metrics-overhaul.md#motivation), which this is part of.",
        "createdAt" : "2019-01-14T11:45:28Z",
        "updatedAt" : "2019-01-14T11:45:28Z",
        "lastEditedBy" : "4108cff4-d61c-4717-862b-6c3be3b73be2",
        "tags" : [
        ]
      }
    ],
    "commit" : "1fb91a720686bdce2afcd9ce27b1dfe2438da533",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +644,648 @@\tstart := time.Now()\n\tdefer func() {\n\t\tmetrics.SyncProxyRulesLatency.Observe(metrics.SinceInSeconds(start))\n\t\tmetrics.DeprecatedSyncProxyRulesLatency.Observe(metrics.SinceInMicroseconds(start))\n\t\tklog.V(4).Infof(\"syncProxyRules took %v\", time.Since(start))"
  },
  {
    "id" : "a1061623-a580-4528-871d-9430cdeb68ca",
    "prId" : 62003,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/62003#pullrequestreview-119729553",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a8aa442d-fa70-43ff-8481-95bfbf2faffb",
        "parentId" : null,
        "authorId" : "bcebf3b5-032b-4720-ba66-12ac441f6151",
        "body" : "Can I suggest rewriting this in this way:\r\n\r\n```\r\nlps := make([]utilproxy.LocalPort, 0)\r\nfor address := range addresses {\r\n\tlp := utilproxy.LocalPort{`\r\n\t\tDescription: \"nodePort for \" + svcNameString,\r\n\t\tIP: address,\r\n\t\tPort: svcInfo.NodePort,\r\n\t\tProtocol: protocol,\r\n\t}\r\n\tif utilproxy.IsZeroCIDR(address) {\r\n\t\tlp.IP = \"\"\r\n                lps.append(lps, lp)\r\n\t\t// If we encounter a zero CIDR, then there is no point in processing the rest of the addresses.\t\r\n\t\tbreak\r\n\t} \r\n        lps.append(lps, lp)\r\n}\r\n```\r\n\r\nSaves you 10 lines if you do it here and in the ipvs code :)",
        "createdAt" : "2018-05-09T15:47:37Z",
        "updatedAt" : "2018-05-14T08:08:48Z",
        "lastEditedBy" : "bcebf3b5-032b-4720-ba66-12ac441f6151",
        "tags" : [
        ]
      },
      {
        "id" : "d2073d0d-9537-41aa-a540-187c0a70ee47",
        "parentId" : "a8aa442d-fa70-43ff-8481-95bfbf2faffb",
        "authorId" : "f2d7a78e-606f-4060-903e-a21198d7084e",
        "body" : "Definitely make sense! It's fixed now. PTAL.\r\n\r\nTHANKS!",
        "createdAt" : "2018-05-14T08:09:43Z",
        "updatedAt" : "2018-05-14T08:09:43Z",
        "lastEditedBy" : "f2d7a78e-606f-4060-903e-a21198d7084e",
        "tags" : [
        ]
      }
    ],
    "commit" : "029a16a1ebd85efc8c66abe431b657e6cad06540",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +967,971 @@\t\t\t}\n\n\t\t\tlps := make([]utilproxy.LocalPort, 0)\n\t\t\tfor address := range addresses {\n\t\t\t\tlp := utilproxy.LocalPort{"
  },
  {
    "id" : "b46ad962-82b9-451b-8891-31374482cd94",
    "prId" : 60306,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/60306#pullrequestreview-99013981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc731e71-0af3-4c2a-b322-68b8097faf1d",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "worth making a var for this slice?",
        "createdAt" : "2018-02-23T18:52:51Z",
        "updatedAt" : "2018-02-23T18:53:33Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "225941679e348a0d94f0f275600ba5498da0f6c9",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +438,442 @@\nvar iptablesJumpChains = []iptablesJumpChain{\n\t{utiliptables.TableFilter, kubeExternalServicesChain, utiliptables.ChainInput, \"kubernetes externally-visible service portals\", []string{\"-m\", \"conntrack\", \"--ctstate\", \"NEW\"}},\n\t{utiliptables.TableFilter, kubeServicesChain, utiliptables.ChainOutput, \"kubernetes service portals\", []string{\"-m\", \"conntrack\", \"--ctstate\", \"NEW\"}},\n\t{utiliptables.TableNAT, kubeServicesChain, utiliptables.ChainOutput, \"kubernetes service portals\", nil},"
  },
  {
    "id" : "c782e93a-f200-44c2-b39a-09ec491d906c",
    "prId" : 58052,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58052#pullrequestreview-99210686",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43483f3f-3b7e-4fe2-983e-8d8cecb0ee29",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "If GetNodeAddresses returned an IPv6 address and the proxier is in ipv4 mode, it will crash iptables and get stuck in a loop.  You either need to pass v4/v6 to GetNodeAddresses and filter there or else filter here.",
        "createdAt" : "2018-02-26T04:55:27Z",
        "updatedAt" : "2018-02-26T15:49:45Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "9eb3d325-30ae-48d2-8d0b-8b8fee7cc651",
        "parentId" : "43483f3f-3b7e-4fe2-983e-8d8cecb0ee29",
        "authorId" : "f2d7a78e-606f-4060-903e-a21198d7084e",
        "body" : "Nice finding, it's fixed now. I fix it by filter them outside:\r\n\r\n```\r\nisIPv6 := proxier.iptables.IsIpv6()\r\n// Ignore IP addresses with incorrect version\r\nif isIPv6 && !conntrack.IsIPv6(address) || !isIPv6 && conntrack.IsIPv6(address) {\r\n  glog.Errorf(\"IP address %s has incorrect IP version\", address)\r\n  continue\r\n}\r\n```",
        "createdAt" : "2018-02-26T08:11:44Z",
        "updatedAt" : "2018-02-26T15:49:45Z",
        "lastEditedBy" : "f2d7a78e-606f-4060-903e-a21198d7084e",
        "tags" : [
        ]
      }
    ],
    "commit" : "2edc97bf17cc7e8c6fba1f5b91e270296ea56fab",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +1325,1329 @@\t\t\t\t\"-A\", string(kubeServicesChain),\n\t\t\t\t\"-m\", \"comment\", \"--comment\", `\"kubernetes service nodeports; NOTE: this must be the last rule in this chain\"`,\n\t\t\t\t\"-d\", address,\n\t\t\t\t\"-j\", string(kubeNodePortsChain))\n\t\t\twriteLine(proxier.natRules, args...)"
  },
  {
    "id" : "1d773a4b-a445-4b2b-bb37-d065ba6e4ed4",
    "prId" : 58052,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58052#pullrequestreview-99438229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9209cf4d-f3ff-40bb-b09c-bbc4aaf7768d",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "need to also test the v6-ness of it.  If I specified \"10.0.0.0/8,::/0\" I would not expect 192.168.1.1 to match.",
        "createdAt" : "2018-02-26T19:38:46Z",
        "updatedAt" : "2018-02-26T20:02:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "2edc97bf17cc7e8c6fba1f5b91e270296ea56fab",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +1306,1310 @@\t\tfor address := range addresses {\n\t\t\t// TODO(thockin, m1093782566): If/when we have dual-stack support we will want to distinguish v4 from v6 zero-CIDRs.\n\t\t\tif utilproxy.IsZeroCIDR(address) {\n\t\t\t\targs = append(args[:0],\n\t\t\t\t\t\"-A\", string(kubeServicesChain),"
  },
  {
    "id" : "99f5467a-d383-4101-a733-a04bb6d00928",
    "prId" : 58052,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/58052#pullrequestreview-99438229",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "694ef7b9-f837-4345-8151-217f38a123ce",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "`if isIPv6 != conntrack.IsIPv6String(address)`\r\n\r\n?",
        "createdAt" : "2018-02-26T19:39:26Z",
        "updatedAt" : "2018-02-26T20:02:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "2edc97bf17cc7e8c6fba1f5b91e270296ea56fab",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +1317,1321 @@\t\t\t}\n\t\t\t// Ignore IP addresses with incorrect version\n\t\t\tif isIPv6 && !conntrack.IsIPv6String(address) || !isIPv6 && conntrack.IsIPv6String(address) {\n\t\t\t\tglog.Errorf(\"IP address %s has incorrect IP version\", address)\n\t\t\t\tcontinue"
  },
  {
    "id" : "dabeb205-ddcb-4b3a-b5fd-2dd3946dcab0",
    "prId" : 57461,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/57461#pullrequestreview-98384915",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1656bce6-3525-4dc2-bd95-8d987a255215",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "The 'args' here are mostly the same as the args just above, with the exception of -j REJECT and the comment.  Any chance to just have a common args and have each one then append what they need in their own block?",
        "createdAt" : "2018-02-06T20:18:17Z",
        "updatedAt" : "2018-02-13T12:52:55Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      },
      {
        "id" : "cd08e2ef-2ab6-49ee-ae80-7f8ba2d04a29",
        "parentId" : "1656bce6-3525-4dc2-bd95-8d987a255215",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "There is already a lot of redundancy with args anyway:\r\n\r\n\t\"-m\", protocol, \"-p\", protocol,\r\n\t\"-d\", utilproxy.ToCIDR(svcInfo.clusterIP),\r\n\t\"--dport\", strconv.Itoa(svcInfo.port),\r\n\r\nvs\r\n\r\n\t\"-m\", protocol, \"-p\", protocol,\r\n\t\"-d\", utilproxy.ToCIDR(net.ParseIP(externalIP)),\r\n\t\"--dport\", strconv.Itoa(svcInfo.port),\r\n\r\nvs\r\n\r\n\t\"-m\", protocol, \"-p\", protocol,\r\n\t\"-d\", utilproxy.ToCIDR(net.ParseIP(ingress.IP)),\r\n\t\"--dport\", strconv.Itoa(svcInfo.port),\r\n\r\netc. I think this can wait for a future cleanup. (And the fact that we need to have other args both before and after the shared part makes it not very clean to try to share part of the string array anyway.)",
        "createdAt" : "2018-02-06T21:15:15Z",
        "updatedAt" : "2018-02-13T12:52:55Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "2fa281a2-1b7b-448b-bd84-c4c2182edbf0",
        "parentId" : "1656bce6-3525-4dc2-bd95-8d987a255215",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "@danwinship ok sure",
        "createdAt" : "2018-02-21T22:26:24Z",
        "updatedAt" : "2018-02-21T22:26:24Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "07ead7d8e243397601d72997e2cb86305afe4f94",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +880,884 @@\t\t\twriteLine(proxier.natRules, append(args, \"-j\", string(svcChain))...)\n\t\t} else {\n\t\t\twriteLine(proxier.filterRules,\n\t\t\t\t\"-A\", string(kubeServicesChain),\n\t\t\t\t\"-m\", \"comment\", \"--comment\", fmt.Sprintf(`\"%s has no endpoints\"`, svcNameString),"
  },
  {
    "id" : "26353c7d-ce31-466a-945a-20f9f5556054",
    "prId" : 48551,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48551#pullrequestreview-62739489",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1623e653-20a2-46d0-bc6c-9756d217c629",
        "parentId" : null,
        "authorId" : "59098d78-f4f5-4a00-90c5-b35bc66e6750",
        "body" : "Is it always guaranteed that ip is a valid IP address? IOW no need to check for nil? Just wondering if all the callers using this are providing valid IP addresses.",
        "createdAt" : "2017-07-07T11:25:51Z",
        "updatedAt" : "2017-09-16T13:18:57Z",
        "lastEditedBy" : "59098d78-f4f5-4a00-90c5-b35bc66e6750",
        "tags" : [
        ]
      },
      {
        "id" : "d4d039e7-40eb-4b65-940b-bdd3f51333ea",
        "parentId" : "1623e653-20a2-46d0-bc6c-9756d217c629",
        "authorId" : "4faef5a2-5fc5-4b77-959f-3bd30e4e04fc",
        "body" : "The nil check isn't being done as a sanity check, it's being done to determine if the IP address is IPv4 or IPv6.",
        "createdAt" : "2017-09-14T13:06:32Z",
        "updatedAt" : "2017-09-16T13:18:57Z",
        "lastEditedBy" : "4faef5a2-5fc5-4b77-959f-3bd30e4e04fc",
        "tags" : [
        ]
      }
    ],
    "commit" : "5fbc9e45cceea8c4b081a520e12aea402bfae323",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +967,971 @@func hostAddress(ip net.IP) string {\n\tlen := 32\n\tif ip.To4() == nil {\n\t\tlen = 128\n\t}"
  },
  {
    "id" : "1d707b08-f6bd-40eb-9a31-1e6e05503780",
    "prId" : 48085,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48085#pullrequestreview-46395427",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d2821ad-96fc-4eb9-a97e-dbc4a80ff86c",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "This is an error... it shouldn't be happening at all. Why is it happening so much that it causes problems?",
        "createdAt" : "2017-06-26T20:15:32Z",
        "updatedAt" : "2017-06-26T20:15:33Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "0cdf0d64-4af2-42bd-a18d-d9ee0a40e67a",
        "parentId" : "2d2821ad-96fc-4eb9-a97e-dbc4a80ff86c",
        "authorId" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "body" : "ref: https://github.com/kubernetes/kubernetes/issues/48052#issuecomment-311051189",
        "createdAt" : "2017-06-26T20:22:04Z",
        "updatedAt" : "2017-06-26T20:22:04Z",
        "lastEditedBy" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "tags" : [
        ]
      },
      {
        "id" : "64491878-e366-4350-9ca6-ebdb5bd2264e",
        "parentId" : "2d2821ad-96fc-4eb9-a97e-dbc4a80ff86c",
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "Please don't merge this PR without also filing an issue about the actual bug. (ie, that apparently there are locking timeout issues causing some kube-proxy iptables updates to get dropped)",
        "createdAt" : "2017-06-26T21:34:01Z",
        "updatedAt" : "2017-06-26T21:34:01Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "1ee7c8bd-033e-4d4b-a187-39b08b4494b8",
        "parentId" : "2d2821ad-96fc-4eb9-a97e-dbc4a80ff86c",
        "authorId" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "body" : "Filed https://github.com/kubernetes/kubernetes/issues/48107. Thanks.",
        "createdAt" : "2017-06-26T21:53:43Z",
        "updatedAt" : "2017-06-26T21:53:43Z",
        "lastEditedBy" : "57a5e7e7-e6d7-467b-96ab-41e4ca978eee",
        "tags" : [
        ]
      }
    ],
    "commit" : "d354e0bf4fa156f3d49dd64b3da94080f69e70df",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1573,1577 @@\tif err != nil {\n\t\tglog.Errorf(\"Failed to execute iptables-restore: %v\", err)\n\t\tglog.V(2).Infof(\"Rules:\\n%s\", proxier.iptablesData.Bytes())\n\t\t// Revert new local ports.\n\t\trevertPorts(replacementPortsMap, proxier.portsMap)"
  },
  {
    "id" : "11dc6f63-761f-4160-b9a8-da86fddd7a74",
    "prId" : 46350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46350#pullrequestreview-40120240",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a25dbb6d-37e4-44a9-b04d-da12a72f7c67",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Does this make a difference vs doing it inside the loop?  Is it because we force the dereference of svcInfo?",
        "createdAt" : "2017-05-24T15:22:04Z",
        "updatedAt" : "2017-05-30T08:50:46Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "853632ba-4402-4c6f-8a67-f2560fe1bf72",
        "parentId" : "a25dbb6d-37e4-44a9-b04d-da12a72f7c67",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We allocate it once. It doesn't change that much, but it also doesn't make sense to create the same var with the same value multiple times.",
        "createdAt" : "2017-05-24T18:58:56Z",
        "updatedAt" : "2017-05-30T08:50:46Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "03c255d7c5bd20ab76bfdc1eab62070d271cb6d3",
    "line" : 266,
    "diffHunk" : "@@ -1,1 +1255,1259 @@\n\t\t// Capture load-balancer ingress.\n\t\tfwChain := svcInfo.serviceFirewallChainName\n\t\tfor _, ingress := range svcInfo.loadBalancerStatus.Ingress {\n\t\t\tif ingress.IP != \"\" {"
  },
  {
    "id" : "641d40e7-9fdf-4147-9e64-3c71b8c37d28",
    "prId" : 46350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46350#pullrequestreview-40225343",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1d15391c-f7f2-414d-a520-c1697d77e689",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "If we do this in a couple places, maybe `ipPart(epSvcPair.endpoint)` as a utility func, which does the max as above?",
        "createdAt" : "2017-05-24T20:12:29Z",
        "updatedAt" : "2017-05-30T08:50:46Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b5690d5b-aaf7-4799-8747-05ac9240f18e",
        "parentId" : "1d15391c-f7f2-414d-a520-c1697d77e689",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done",
        "createdAt" : "2017-05-25T07:43:06Z",
        "updatedAt" : "2017-05-30T08:50:46Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "03c255d7c5bd20ab76bfdc1eab62070d271cb6d3",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +950,954 @@\tfor epSvcPair := range connectionMap {\n\t\tif svcInfo, ok := proxier.serviceMap[epSvcPair.servicePortName]; ok && svcInfo.protocol == api.ProtocolUDP {\n\t\t\tendpointIP := epSvcPair.endpoint[0:strings.Index(epSvcPair.endpoint, \":\")]\n\t\t\tglog.V(2).Infof(\"Deleting connection tracking state for service IP %s, endpoint IP %s\", svcInfo.clusterIP.String(), endpointIP)\n\t\t\terr := utilproxy.ExecConntrackTool(proxier.exec, \"-D\", \"--orig-dst\", svcInfo.clusterIP.String(), \"--dst-nat\", endpointIP, \"-p\", \"udp\")"
  },
  {
    "id" : "ca9ec093-6574-4df0-9869-7d0d40318d3d",
    "prId" : 46350,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46350#pullrequestreview-40810230",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a12d52d6-6098-4962-9fff-3f4cb6e16547",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : ":+1: ",
        "createdAt" : "2017-05-29T17:44:38Z",
        "updatedAt" : "2017-05-30T08:50:46Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "03c255d7c5bd20ab76bfdc1eab62070d271cb6d3",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +935,939 @@}\n\nfunc (esp *endpointServicePair) IPPart() string {\n\tif index := strings.Index(esp.endpoint, \":\"); index != -1 {\n\t\treturn esp.endpoint[0:index]"
  },
  {
    "id" : "8f8ac1a4-6857-443e-8753-61c7c5f8cbf0",
    "prId" : 46201,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46201#pullrequestreview-39567576",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23102325-37fe-45a8-b772-ebdda64782fa",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I guess this works.  I was thinking of the return as \"did this update() cause a change\", but this should be behaviorally equivalent at the end.",
        "createdAt" : "2017-05-22T19:39:44Z",
        "updatedAt" : "2017-05-22T19:39:44Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "ee505677f70439ff8f5515cc899eab7c18cdb1dd",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +240,244 @@\t\tdelete(ecm.items, *namespacedName)\n\t}\n\treturn len(ecm.items) > 0\n}\n"
  },
  {
    "id" : "8536b25c-efe0-46a3-80d7-0381fc233b19",
    "prId" : 46033,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46033#pullrequestreview-39269585",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "afb6b947-bc6d-4b8d-a79a-107b7a5281ff",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Comment that this is to avoid re-allocations",
        "createdAt" : "2017-05-19T18:23:17Z",
        "updatedAt" : "2017-05-19T19:34:13Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "97c2e16e-be64-442e-9032-f2e6717fb646",
        "parentId" : "afb6b947-bc6d-4b8d-a79a-107b7a5281ff",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "done.",
        "createdAt" : "2017-05-19T18:45:23Z",
        "updatedAt" : "2017-05-19T19:34:13Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3da8d73004a8727574d96ebb38dbbe719c6b3ab",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +1007,1011 @@\t}\n\n\t// Reset all buffers used later.\n\t// This is to avoid memory reallocations and thus improve performance.\n\tproxier.filterChains.Reset()"
  },
  {
    "id" : "859ec206-e950-45cf-91fd-4801f1e2e58d",
    "prId" : 46033,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/46033#pullrequestreview-39420327",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f9b8581-5706-48a7-a939-411c5e9a4d01",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "weird constructs like this warrant a comment",
        "createdAt" : "2017-05-21T04:15:12Z",
        "updatedAt" : "2017-05-21T04:15:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e1c22e93-23e3-4970-8233-127bd4fd3663",
        "parentId" : "3f9b8581-5706-48a7-a939-411c5e9a4d01",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "In this case it's not longer needed - I will send a PR removing it on Monday.",
        "createdAt" : "2017-05-21T07:45:54Z",
        "updatedAt" : "2017-05-21T07:45:54Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "fc6daac3-bbc7-4d8a-964c-848276927771",
        "parentId" : "3f9b8581-5706-48a7-a939-411c5e9a4d01",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "https://github.com/kubernetes/kubernetes/pull/46201 is already out for review",
        "createdAt" : "2017-05-22T08:57:27Z",
        "updatedAt" : "2017-05-22T08:57:27Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3da8d73004a8727574d96ebb38dbbe719c6b3ab",
    "line" : 402,
    "diffHunk" : "@@ -1,1 +1499,1503 @@\tproxier.iptablesData.Write(proxier.natRules.Bytes())\n\n\tif glog.V(5) {\n\t\tglog.V(5).Infof(\"Restoring iptables rules: %s\", proxier.iptablesData.Bytes())\n\t}"
  },
  {
    "id" : "fed8d671-7635-4e3c-99fa-2f1bea56c6cb",
    "prId" : 45816,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45816#pullrequestreview-39287551",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc2efc9d-0f4c-415c-9abd-3fdbfdc33e7f",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Do these need to be 1? Seem more like 4. How often is this code  running?",
        "createdAt" : "2017-05-15T12:26:23Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "f9a0272a-b8f8-4136-a6a1-a80b44121a8a",
        "parentId" : "bc2efc9d-0f4c-415c-9abd-3fdbfdc33e7f",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I'm fine with changing those, but it used to be like that in the past (this is not introducing new logs, it just preserves the existing behavior). I will leave the final call to @thockin ",
        "createdAt" : "2017-05-15T12:28:41Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "ce8c5c65-22b3-4b49-9844-a68e2f876629",
        "parentId" : "bc2efc9d-0f4c-415c-9abd-3fdbfdc33e7f",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "leave as-is, we can log-scrub later",
        "createdAt" : "2017-05-19T20:27:32Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0c41aa083ed490527b94f3cf142f25bb16285d6",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +283,287 @@\t\t_, exists := (*sm)[serviceName]\n\t\tif !exists {\n\t\t\tglog.V(1).Infof(\"Adding new service %q at %s:%d/%s\", serviceName, info.clusterIP, info.port, info.protocol)\n\t\t} else {\n\t\t\tglog.V(1).Infof(\"Updating existing service %q at %s:%d/%s\", serviceName, info.clusterIP, info.port, info.protocol)"
  },
  {
    "id" : "5f2d1fd4-17b2-43a5-86e1-13f8e1b1a5b6",
    "prId" : 45816,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45816#pullrequestreview-39334089",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6d6adfe1-3485-477a-981a-17b118fc3a56",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "The comment says unconditional, but the reason is not unconditional",
        "createdAt" : "2017-05-19T20:04:10Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "aa4a94a0-3721-4eca-b6e6-55b2a9fd9a49",
        "parentId" : "6d6adfe1-3485-477a-981a-17b118fc3a56",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Good point. Though with the next PR (which you already LGTMed) it is unconditional. So leaving as is (the comment will be accurate once the second PR is merged).",
        "createdAt" : "2017-05-20T12:13:11Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0c41aa083ed490527b94f3cf142f25bb16285d6",
    "line" : 343,
    "diffHunk" : "@@ -1,1 +731,735 @@\tproxier.endpointsSynced = true\n\tproxier.mu.Unlock()\n\t// Call it unconditionally - this is called once per lifetime.\n\tproxier.syncProxyRules(syncReasonEndpoints)\n}"
  },
  {
    "id" : "a2a5eabc-1a36-498e-bcf4-d5f832a02c4b",
    "prId" : 45816,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45816#pullrequestreview-39334089",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a1634b8-1ef7-49f1-807b-1044ffc74e56",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "same comment as endpoints - it says unconditional, but the arg is not.",
        "createdAt" : "2017-05-19T20:10:55Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c6c8f32f-452a-457a-a990-a53f69ea5d25",
        "parentId" : "2a1634b8-1ef7-49f1-807b-1044ffc74e56",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Good point. Though with the next PR (which you already LGTMed) it is unconditional. So leaving as is (the comment will be accurate once the second PR is merged).",
        "createdAt" : "2017-05-20T12:13:04Z",
        "updatedAt" : "2017-05-20T12:27:03Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0c41aa083ed490527b94f3cf142f25bb16285d6",
    "line" : 193,
    "diffHunk" : "@@ -1,1 +639,643 @@\tproxier.servicesSynced = true\n\tproxier.mu.Unlock()\n\t// Call it unconditionally - this is called once per lifetime.\n\tproxier.syncProxyRules(syncReasonServices)\n}"
  },
  {
    "id" : "da989539-da8a-4d8b-a50e-6089d28b3384",
    "prId" : 45816,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/45816#pullrequestreview-40452492",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66bca79b-9b6a-477e-8989-d76bb087378d",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm surprised this doesn't show up in profiles - reflect.DeepEqual is usually quite expensive in terms of allocations.",
        "createdAt" : "2017-05-26T04:35:47Z",
        "updatedAt" : "2017-05-26T04:35:47Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "fe6dadce-8de7-4c9a-b8af-9d5891e2f8be",
        "parentId" : "66bca79b-9b6a-477e-8989-d76bb087378d",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "This is happening once per endpoint/service watch event.\r\nGiven what is happening in syncProxyRules function in terms of both allocations and cpu usage (it's better after recent changes, but it's still a lot), I'm not that surprised.\r\nFYI - 2 weeks ago we used to allocated ~38GB of memory during load test on 100-node clusters - this was significantly more than apiserver was allocating.",
        "createdAt" : "2017-05-26T06:21:52Z",
        "updatedAt" : "2017-05-26T06:21:52Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c0c41aa083ed490527b94f3cf142f25bb16285d6",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +265,269 @@\t}\n\tchange.current = serviceToServiceMap(current)\n\tif reflect.DeepEqual(change.previous, change.current) {\n\t\tdelete(scm.items, *namespacedName)\n\t\treturn false"
  },
  {
    "id" : "e8d14d50-abfe-484f-a93c-5e47a3dfce00",
    "prId" : 44968,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44968#pullrequestreview-35894190",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47eb03ea-fde2-4c90-aa26-23093e83ca2c",
        "parentId" : null,
        "authorId" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "body" : "@nicksardo Moved `UpdateTimestamp` to the end of `syncProxyRules` so that it wouldn't be updated if anything fails in between, thanks!",
        "createdAt" : "2017-05-02T21:21:51Z",
        "updatedAt" : "2017-05-05T21:45:05Z",
        "lastEditedBy" : "26bd3fa6-ac8d-4cb0-b746-a30dc1dc2931",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5db5dc3a1f0be7c96beda3488b42d84376ac23f",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +1504,1508 @@\n\t// Update healthz timestamp if it is periodic sync.\n\tif proxier.healthzServer != nil && reason == syncReasonForce {\n\t\tproxier.healthzServer.UpdateTimestamp()\n\t}"
  },
  {
    "id" : "ea2f3dea-519a-4b78-86e1-95a7bdec2ba1",
    "prId" : 44494,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44494#pullrequestreview-33170331",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f53757b1-a4e5-41ca-85b3-d003f3be8f63",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This could grow a test now that it is a function.",
        "createdAt" : "2017-04-14T16:43:36Z",
        "updatedAt" : "2017-04-20T06:37:41Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3ae259ee-e9cc-412b-b57f-22abc559e8dc",
        "parentId" : "f53757b1-a4e5-41ca-85b3-d003f3be8f63",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Done",
        "createdAt" : "2017-04-18T09:01:40Z",
        "updatedAt" : "2017-04-20T06:37:41Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f250435fd34151bf4c00fab86f9ea3ff29c12d1",
    "line" : 231,
    "diffHunk" : "@@ -1,1 +695,699 @@}\n\nfunc getLocalIPs(endpointsMap proxyEndpointsMap) map[types.NamespacedName]sets.String {\n\tlocalIPs := make(map[types.NamespacedName]sets.String)\n\tfor svcPort := range endpointsMap {"
  },
  {
    "id" : "6d8cb995-58cc-4283-b3b3-ccb73b332803",
    "prId" : 44019,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44019#pullrequestreview-31692767",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e16cab57-49c8-4e83-8a99-03ed121e4de1",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "return ?",
        "createdAt" : "2017-04-07T08:32:20Z",
        "updatedAt" : "2017-04-08T03:47:20Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "9074e12b-0ccb-489e-a800-cf1a2ffedfd7",
        "parentId" : "e16cab57-49c8-4e83-8a99-03ed121e4de1",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Oops!  That is why we do code review, I guess.",
        "createdAt" : "2017-04-08T03:46:51Z",
        "updatedAt" : "2017-04-08T03:47:20Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bfb88d2d7a14e8a6c07f5d57f7d7aea5ce7dc7e",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +743,747 @@\t// If this was called because of a services update, but nothing actionable has changed, skip it.\n\tif reason == syncReasonServices && reflect.DeepEqual(newServices, proxier.serviceMap) {\n\t\tglog.V(3).Infof(\"Skipping iptables sync because nothing changed\")\n\t\treturn\n\t}"
  },
  {
    "id" : "f135c243-c968-4d1e-afdf-534e3bfa97a5",
    "prId" : 44019,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/44019#pullrequestreview-31507267",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd967070-923f-4548-9e68-1b3040ff9a8a",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "return ?",
        "createdAt" : "2017-04-07T08:32:29Z",
        "updatedAt" : "2017-04-08T03:47:20Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bfb88d2d7a14e8a6c07f5d57f7d7aea5ce7dc7e",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +752,756 @@\t// If this was called because of an endpoints update, but nothing actionable has changed, skip it.\n\tif reason == syncReasonEndpoints && reflect.DeepEqual(newEndpoints, proxier.endpointsMap) {\n\t\tglog.V(3).Infof(\"Skipping iptables sync because nothing changed\")\n\t\treturn\n\t}"
  },
  {
    "id" : "49209a5a-f43d-4f0f-aec1-e54d0a8b2c3c",
    "prId" : 43415,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/43415#pullrequestreview-28020560",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb0d3d86-8b8c-4f67-8783-832398e6dfa2",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "We could do the \"no endpoints\" check before writing the MARK/SVC or XLB rules.  But I presume we want to keep the rules less volatile?",
        "createdAt" : "2017-03-21T00:53:25Z",
        "updatedAt" : "2017-03-21T04:37:18Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "a5039c01-5d09-40a4-a5fa-951099309e3a",
        "parentId" : "eb0d3d86-8b8c-4f67-8783-832398e6dfa2",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I have an idea for future refactoring that will make this nice, so I made the smallest change I could.",
        "createdAt" : "2017-03-21T03:31:37Z",
        "updatedAt" : "2017-03-21T04:37:18Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "a2161b1d-aaf3-42b6-b5ad-51db263e7f04",
        "parentId" : "eb0d3d86-8b8c-4f67-8783-832398e6dfa2",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "You're saying you have a cunning plan?  :+1: ",
        "createdAt" : "2017-03-21T04:21:50Z",
        "updatedAt" : "2017-03-21T04:37:18Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ec87999a97eb68557fc7fdc9f42e615f6b61f9e",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1109,1113 @@\t\t\t\twriteLine(natRules, append(args, \"-j\", string(svcXlbChain))...)\n\t\t\t}\n\n\t\t\t// If the service has no endpoints then reject packets.  The filter\n\t\t\t// table doesn't currently have the same per-service structure that"
  },
  {
    "id" : "9a35d65a-db6e-4cd9-a67a-e0bcc9bef969",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22147807",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "691c39d9-6dcf-4e26-afc0-4f9f50190135",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "This function actually does a lot of things. \r\nBut basically it 1. construct endpoints maps, 2. gather staleConnections and 3. update healthcheck. Only 3 is taking action though. How about returning the healthchecks needed and do healthcheck update outside?",
        "createdAt" : "2017-02-16T00:31:00Z",
        "updatedAt" : "2017-02-16T01:40:07Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 148,
    "diffHunk" : "@@ -1,1 +604,608 @@\n// Convert a slice of api.Endpoints objects into a map of service-port -> endpoints.\nfunc updateEndpoints(allEndpoints []api.Endpoints, curMap map[proxy.ServicePortName][]*endpointsInfo, hostname string,\n\thealthChecker healthChecker) (newMap map[proxy.ServicePortName][]*endpointsInfo, staleSet map[endpointServicePair]bool) {\n"
  },
  {
    "id" : "39af033c-71d1-4e46-b069-69aa8f402526",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22147807",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b31a96c-7afe-4d11-9b48-ac50b84f517f",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "I do not understand the reason why memorizing the batch of endpoints. This data is not used across updates.",
        "createdAt" : "2017-02-16T01:25:08Z",
        "updatedAt" : "2017-02-16T01:40:07Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +196,200 @@\tportsMap                  map[localPort]closeable\n\thaveReceivedServiceUpdate bool            // true once we've seen an OnServiceUpdate event\n\tallEndpoints              []api.Endpoints // nil until we have seen an OnEndpointsUpdate event\n\tthrottle                  flowcontrol.RateLimiter\n"
  },
  {
    "id" : "3f370d4e-6722-4338-bc13-dcb9e93b4f89",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22358673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7202ac60-c0ac-45e0-b633-72cd527255a4",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "Combine this loop that sets allSvcPorts[svcPort] = true with the just-above \"for svcPort, epList\" loop so you don't have to loop through twice?",
        "createdAt" : "2017-02-16T20:50:59Z",
        "updatedAt" : "2017-02-17T00:19:46Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 239,
    "diffHunk" : "@@ -1,1 +642,646 @@\t\tallSvcPorts[svcPort] = true\n\t}\n\tfor svcPort := range newMap {\n\t\tallSvcPorts[svcPort] = true\n\t}"
  },
  {
    "id" : "1c7cc24e-feae-4201-ba86-4829df51935d",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22358673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1513c491-9be0-447e-9cdf-3f2459048b16",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "Previously isLocal was gated by the feature gate thing.  That's still done for the healthcheck updates due to updateHealthCheckEntries().  But it's no longer done for the endpoint lists.  Is that going to be a problem?  eg, now things that used to be isLocal = false will be treated as isLocal = true in syncProxyRules() when creating local endpoint chains.",
        "createdAt" : "2017-02-16T21:43:19Z",
        "updatedAt" : "2017-02-17T00:19:46Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 286,
    "diffHunk" : "@@ -1,1 +681,685 @@\t\t\t\t\thost:    addr.IP,\n\t\t\t\t\tport:    int(port.Port),\n\t\t\t\t\tisLocal: addr.NodeName != nil && *addr.NodeName == hostname,\n\t\t\t\t}\n\t\t\t\t(*svcPortToInfoMap)[svcPort] = append((*svcPortToInfoMap)[svcPort], hostPortObject)"
  },
  {
    "id" : "b54bbd2c-03a3-47a7-8384-a83d271a6789",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22358673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb156938-6735-459a-bd29-54e395d20df8",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "curEndpoints isn't used anywhere in this function.",
        "createdAt" : "2017-02-16T21:47:03Z",
        "updatedAt" : "2017-02-17T00:19:46Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 267,
    "diffHunk" : "@@ -1,1 +662,666 @@// - naming is poor and responsibilities are muddled\nfunc accumulateEndpointsMap(endpoints *api.Endpoints, hostname string,\n\tcurEndpoints map[proxy.ServicePortName][]*endpointsInfo,\n\tnewEndpoints *map[proxy.ServicePortName][]*endpointsInfo,\n\tsvcPortToInfoMap *map[proxy.ServicePortName][]hostPortInfo) {"
  },
  {
    "id" : "3f087a6c-6e16-47d5-ad43-b4fe70289e40",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22358673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7233fc29-b15a-444e-b98c-10359752452b",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "This is kinda weird to have accumulateEndpointsMap take a pointer to the maps.  Why not just move the \"for allEndpoints\" into accumulateEndpointsMap and have it return the new endpoints map and the serviceporttoendpoint maps?",
        "createdAt" : "2017-02-16T21:48:12Z",
        "updatedAt" : "2017-02-17T00:19:47Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +616,620 @@\t// Update endpoints for services.\n\tfor i := range allEndpoints {\n\t\taccumulateEndpointsMap(&allEndpoints[i], hostname, curMap, &newMap, &svcPortToInfoMap)\n\t}\n\t// Check stale connections against endpoints missing from the update."
  },
  {
    "id" : "bb5c4d00-d00f-4a67-8646-7b453e96bc18",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22358673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c472bee1-a9f8-4724-9960-a0ee15422410",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "While you're at it, can you:\r\n\r\nfunc (e *endpointsInfo) String() string {\r\n\treturn fmt.Sprintf(\"%v\", *e)\r\n}\r\n\r\nSo that something reasonable can be printed in testcases?",
        "createdAt" : "2017-02-17T00:11:15Z",
        "updatedAt" : "2017-02-17T00:19:47Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +151,155 @@type endpointsInfo struct {\n\tendpoint string // TODO: should be an endpointString type\n\tisLocal  bool\n}\n"
  },
  {
    "id" : "0f5b2a0a-0546-43b5-8bdb-431dbfcd4e25",
    "prId" : 41022,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/41022#pullrequestreview-22358673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "51085990-7a64-436b-8c26-207fb7a59a9c",
        "parentId" : null,
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "Not sure it matters, but if the endpoint record has invalid addresses, this will still add the endpoint to the map.  Maybe filter those out before calling buildEndpointInfoList()?  Or if you feel that apiserver validation is sufficient, ignore this.\r\n\r\n```\r\nfunc addTestEndpointAddress(array []api.EndpointAddress, ip, hostname string, nodename *string) []api.EndpointAddress {\r\n\taddr := api.EndpointAddress{\r\n\t\tIP:       ip,\r\n\t\tHostname: hostname,\r\n\t\tNodeName: nodename,\r\n\t}\r\n\treturn append(array, addr)\r\n}\r\n\r\n\t\tmakeTestEndpoint(\"somewhere\", \"invalid-addresses\", func(s *api.EndpointSubset) {\r\n\t\t\ts.Addresses = addTestEndpointAddress(s.Addresses, \"\", \"foobar.com\", &node1)\r\n\t\t\ts.Addresses = addTestEndpointAddress(s.Addresses, \"\", \"foobar.com\", nil)\r\n\t\t\ts.Ports = addTestEndpointPort(s.Ports, \"first\", \"UDP\", 4444)\r\n\t\t\ts.Ports = addTestEndpointPort(s.Ports, \"second\", \"TCP\", 5555)\r\n\t\t}),\r\n```\r\n\r\nThis invalid endpoint will still be added to the returned new endpoints map, it probably shouldn't.",
        "createdAt" : "2017-02-17T00:16:07Z",
        "updatedAt" : "2017-02-17T00:19:47Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ce3395e7f201c230de92d98ac7bca8d56234836",
    "line" : 112,
    "diffHunk" : "@@ -1,1 +576,580 @@\t\tkey := net.JoinHostPort(hpp.host, strconv.Itoa(hpp.port))\n\t\tif lookupSet.Has(key) {\n\t\t\tfilteredEndpoints = append(filteredEndpoints, &endpointsInfo{endpoint: key, isLocal: hpp.isLocal})\n\t\t}\n\t}"
  },
  {
    "id" : "588de131-bde7-4638-93f4-a514efb5fc42",
    "prId" : 38996,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38996#pullrequestreview-13778467",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba20c77f-8340-4aa6-ba46-99150b0f9bac",
        "parentId" : null,
        "authorId" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "body" : "you're testing the same case twice here?",
        "createdAt" : "2016-12-20T14:35:10Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "c490e441-2b9f-41f2-8559-d47be0ea8836",
        "tags" : [
        ]
      },
      {
        "id" : "0c863d91-4695-4012-add3-542e47b37f37",
        "parentId" : "ba20c77f-8340-4aa6-ba46-99150b0f9bac",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "Yeah, meant to remove it from the if above.",
        "createdAt" : "2016-12-20T15:10:23Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "59076391403821201de2f226e24bd34d797b7aad",
    "line" : 139,
    "diffHunk" : "@@ -1,1 +453,457 @@\t\t}\n\t\t// Even if ClusterIP is set, ServiceTypeExternalName services don't get proxied\n\t\tif service.Spec.Type == api.ServiceTypeExternalName {\n\t\t\tglog.V(3).Infof(\"Skipping service %s due to Type=ExternalName\", svcName)\n\t\t\tcontinue"
  },
  {
    "id" : "f60e2105-5cc6-4d38-8877-72f6189c6279",
    "prId" : 38996,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38996#pullrequestreview-15210818",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2643a335-26d6-4dab-bbb8-16781d10e685",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This highligts that this could maybe fail without error or retry...",
        "createdAt" : "2016-12-22T07:10:29Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "73313c56-9494-4183-912b-5b4fe2bad89a",
        "parentId" : "2643a335-26d6-4dab-bbb8-16781d10e685",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "@thockin added a FIXME so we don't forget it",
        "createdAt" : "2017-01-04T22:19:32Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "59076391403821201de2f226e24bd34d797b7aad",
    "line" : null,
    "diffHunk" : "@@ -1,1 +521,525 @@\t\t// Turn on healthcheck responder to listen on the health check nodePort\n\t\t// FIXME: handle failures from adding the service\n\t\thealthcheck.AddServiceListener(hc.namespace, hc.nodeport)\n\t}\n\tfor _, hc := range hcDel {"
  },
  {
    "id" : "a4485b30-3c15-474b-b5a3-970c18010a61",
    "prId" : 38996,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38996#pullrequestreview-15215962",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbd2ceef-dcd4-4707-be5e-1ce1612c3de1",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "log if this is a skip, maybe V(3) ?",
        "createdAt" : "2016-12-22T07:22:00Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "65dbcb00-32f9-4b74-b29b-7adf2e0249ff",
        "parentId" : "bbd2ceef-dcd4-4707-be5e-1ce1612c3de1",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "Done.",
        "createdAt" : "2017-01-04T22:50:55Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "59076391403821201de2f226e24bd34d797b7aad",
    "line" : null,
    "diffHunk" : "@@ -1,1 +536,540 @@\t} else {\n\t\tglog.V(4).Infof(\"Skipping proxy iptables rule sync on service update because nothing changed\")\n\t}\n\n\tproxier.deleteServiceConnections(staleUDPServices.List())"
  },
  {
    "id" : "758f8a53-9264-4cdc-88af-96cc7fff89dd",
    "prId" : 38996,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38996#pullrequestreview-15216521",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2cb1dced-955f-4cf4-bc24-73b6289a7b32",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "only do the DeepEqual if REALLY necessary, i.e. after proving `exists == true`",
        "createdAt" : "2016-12-22T07:24:08Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "a578f01e-72c5-4a91-a510-17bd8224e908",
        "parentId" : "2cb1dced-955f-4cf4-bc24-73b6289a7b32",
        "authorId" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "body" : "I checked that before doing this, I don't think it's necessary as DeepEqual already checks for nil and exits early.  Basically doing exactly what I would do if I open-coded it here.\r\n\r\n```\r\nfunc DeepEqual(x, y interface{}) bool {\r\n\r\n\t\tif x == nil || y == nil {\r\n\r\n\t\t\treturn x == y\r\n\r\n\t\t}\r\n```",
        "createdAt" : "2017-01-04T22:54:16Z",
        "updatedAt" : "2017-01-11T21:18:14Z",
        "lastEditedBy" : "57f729dd-988a-4d1a-83bf-ee70bf637c64",
        "tags" : [
        ]
      }
    ],
    "commit" : "59076391403821201de2f226e24bd34d797b7aad",
    "line" : null,
    "diffHunk" : "@@ -1,1 +468,472 @@\t\t\tinfo := newServiceInfo(serviceName, servicePort, service)\n\t\t\toldInfo, exists := oldServiceMap[serviceName]\n\t\t\tequal := reflect.DeepEqual(info, oldInfo)\n\t\t\tif !exists {\n\t\t\t\tglog.V(1).Infof(\"Adding new service %q at %s:%d/%s\", serviceName, info.clusterIP, servicePort.Port, servicePort.Protocol)"
  },
  {
    "id" : "d779b8be-cfe9-4231-a523-9b7ce9fd77e6",
    "prId" : 38920,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38920#pullrequestreview-13657336",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83476142-1315-4a19-91e2-951ecb721a5a",
        "parentId" : null,
        "authorId" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "body" : "How frequently does this part of the sync loop get hit?",
        "createdAt" : "2016-12-19T22:36:14Z",
        "updatedAt" : "2016-12-22T12:13:24Z",
        "lastEditedBy" : "392f7c7a-6820-4848-94e2-2b8e009fec9d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0dfa4ad47cd9968ed59906ab6a3aceb904c2df1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1014,1018 @@\t\t\t\t\t\t\t\tNamespace: \"\",\n\t\t\t\t\t\t\t}, api.EventTypeWarning, err.Error(), msg)\n\t\t\t\t\t\tglog.Error(msg)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}"
  },
  {
    "id" : "3a7f19fc-1a86-4f38-a34a-bcd18c496c92",
    "prId" : 35334,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35334#pullrequestreview-7018075",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e12c910f-6375-4ed8-86a5-58432713321e",
        "parentId" : null,
        "authorId" : "190682e4-89be-4512-aec9-ed2f7c7a5663",
        "body" : "As you do divide by the minSyncPeriod, please add a check for a zero value to return an error.\n",
        "createdAt" : "2016-11-03T11:24:03Z",
        "updatedAt" : "2016-11-04T17:30:49Z",
        "lastEditedBy" : "190682e4-89be-4512-aec9-ed2f7c7a5663",
        "tags" : [
        ]
      },
      {
        "id" : "1f7faff9-ecc5-4879-bf20-dc16e007894f",
        "parentId" : "e12c910f-6375-4ed8-86a5-58432713321e",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Done. \n",
        "createdAt" : "2016-11-03T14:33:02Z",
        "updatedAt" : "2016-11-04T17:30:49Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "1cb97b83cab57372826a0fa9e2a89a92bfbb80a6",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +222,226 @@// will not terminate if a particular iptables call fails.\nfunc NewProxier(ipt utiliptables.Interface, sysctl utilsysctl.Interface, exec utilexec.Interface, syncPeriod time.Duration, minSyncPeriod time.Duration, masqueradeAll bool, masqueradeBit int, clusterCIDR string, hostname string, nodeIP net.IP) (*Proxier, error) {\n\t// check valid user input\n\tif minSyncPeriod == 0 || minSyncPeriod > syncPeriod {\n\t\treturn nil, fmt.Errorf(\"min-sync (%v) must be < sync(%v) and > 0 \", minSyncPeriod, syncPeriod)"
  },
  {
    "id" : "66ee46f7-69e7-428a-9ba7-28f82cd34c83",
    "prId" : 35334,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35334#pullrequestreview-7242266",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f248689-8d6c-457c-ab85-93e0840d019d",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'm curious why min == 0 is disallowed - the semantic seems to be \"no rate limit\".  It's not important, but curious.  Just to avoid div-by-zero ?\n",
        "createdAt" : "2016-11-04T04:32:45Z",
        "updatedAt" : "2016-11-04T17:30:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "84e3f316-fe7d-4d1c-b255-70465da7b250",
        "parentId" : "7f248689-8d6c-457c-ab85-93e0840d019d",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "div-by-zero. \n",
        "createdAt" : "2016-11-04T13:23:31Z",
        "updatedAt" : "2016-11-04T17:30:49Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "2adc9c5b-a321-4ccf-9d51-545668b93646",
        "parentId" : "7f248689-8d6c-457c-ab85-93e0840d019d",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "would it be cleaner to just special case min == 0 as 1000 tokens in the bucket or something?\n",
        "createdAt" : "2016-11-04T16:59:46Z",
        "updatedAt" : "2016-11-04T17:30:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "1cb97b83cab57372826a0fa9e2a89a92bfbb80a6",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +223,227 @@func NewProxier(ipt utiliptables.Interface, sysctl utilsysctl.Interface, exec utilexec.Interface, syncPeriod time.Duration, minSyncPeriod time.Duration, masqueradeAll bool, masqueradeBit int, clusterCIDR string, hostname string, nodeIP net.IP) (*Proxier, error) {\n\t// check valid user input\n\tif minSyncPeriod == 0 || minSyncPeriod > syncPeriod {\n\t\treturn nil, fmt.Errorf(\"min-sync (%v) must be < sync(%v) and > 0 \", minSyncPeriod, syncPeriod)\n\t}"
  },
  {
    "id" : "90dd7202-8d64-4edc-9766-58086de9c9b4",
    "prId" : 35334,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35334#pullrequestreview-7145131",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eaddc5a2-eae7-4dc9-b8d8-ac32daa67378",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "comment on the literal `2`?\n",
        "createdAt" : "2016-11-04T04:34:28Z",
        "updatedAt" : "2016-11-04T17:30:49Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "1cb97b83cab57372826a0fa9e2a89a92bfbb80a6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +262,266 @@\t\tminSyncPeriod: minSyncPeriod,\n\t\t// The average use case will process 2 updates in short succession\n\t\tthrottle:       flowcontrol.NewTokenBucketRateLimiter(syncsPerSecond, 2),\n\t\tiptables:       ipt,\n\t\tmasqueradeAll:  masqueradeAll,"
  },
  {
    "id" : "5695f233-e5a9-444c-8fe8-af1be26b2e3f",
    "prId" : 33587,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/33587#pullrequestreview-1833841",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f41aedc-d606-48d3-b52e-8760fbe3ef2c",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "I do not understand this rule. If you jump to KUBE-SVC chain from KUBE-XLB chain. Then it may reach any backend pods right? \n",
        "createdAt" : "2016-09-27T21:50:21Z",
        "updatedAt" : "2016-09-30T00:36:01Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "7f2d3dde-f8f0-43ff-9ba7-0dfa27759cae",
        "parentId" : "8f41aedc-d606-48d3-b52e-8760fbe3ef2c",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Oh I see the bug now. You want to allow pods on the node to access the LB. \n",
        "createdAt" : "2016-09-27T21:53:47Z",
        "updatedAt" : "2016-09-30T00:36:01Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "06cbb36a1ff2f792de0e99d83c5541b8110b8084",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +1196,1200 @@\t\t\t}\n\t\t}\n\t\t// First rule in the chain redirects all pod -> external vip traffic to the\n\t\t// Service's ClusterIP instead. This happens whether or not we have local\n\t\t// endpoints."
  },
  {
    "id" : "c4402ba2-abb9-4b14-ae78-21b4bdeac767",
    "prId" : 32561,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/32561#pullrequestreview-10914966",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "431ad85a-85a8-4a4b-9b2e-69edfd88aa40",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "We don't really need this fallback path any more - would be safer to just log.",
        "createdAt" : "2016-12-01T07:40:56Z",
        "updatedAt" : "2016-12-01T07:52:52Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "88cf6fe5-4597-485e-b490-824e4a4f9597",
        "parentId" : "431ad85a-85a8-4a4b-9b2e-69edfd88aa40",
        "authorId" : "66b41c00-a618-4a70-858b-bb08aafe463e",
        "body" : "Done",
        "createdAt" : "2016-12-01T07:53:07Z",
        "updatedAt" : "2016-12-01T07:53:07Z",
        "lastEditedBy" : "66b41c00-a618-4a70-858b-bb08aafe463e",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc54a8d46ef2ab3bb3badb3feb223b73d9278eef",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1340,1344 @@\t\t\tglog.Errorf(\"conntrack return with error: %v\", err)\n\t\t}\n\t} else {\n\t\tglog.Errorf(\"Wrong port number. The port number must be greater than zero\")\n\t}"
  },
  {
    "id" : "5c1746f0-bf23-403f-b1f1-7802041190b5",
    "prId" : 31828,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d1553ed-565a-473a-9302-5ab59b827899",
        "parentId" : null,
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "are we unconditionally calling this for any/all services? are you sure it doesn't have side-effects for normal services? maybe we should do a periodic background gc instaed? \n",
        "createdAt" : "2016-09-02T22:16:52Z",
        "updatedAt" : "2016-09-06T18:36:06Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      }
    ],
    "commit" : "81b36aaba612995bd2aac3fb5d27981c1dde734a",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +453,457 @@\t\t\t} else {\n\t\t\t\t// Delete healthcheck responders, if any, previously listening for this service\n\t\t\t\thealthcheck.DeleteServiceListener(serviceName.NamespacedName, 0)\n\t\t\t}\n\t\t\tproxier.serviceMap[serviceName] = info"
  },
  {
    "id" : "a315b0f0-3024-44d5-be1d-48a5766ea17b",
    "prId" : 29409,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "181ab6f8-d7b0-4ff6-923f-18c148c40f3c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Reading this I am confused.  lookupMap is derived from  from endpointIPs, so I assume it is keyed by IP strings.  But here I see you generating a key that is ip:port.  So SOMETHING is named badly and under-commented.  This code is tricky.  Please err on the side of too much explanation.\n",
        "createdAt" : "2016-08-16T04:56:26Z",
        "updatedAt" : "2016-08-23T23:16:56Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b82c028f77d85ac0be39b510ccdbc2783e43fdc7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +502,506 @@\tvar filteredEndpoints []*endpointsInfo\n\tfor _, hpp := range endPoints {\n\t\tkey := net.JoinHostPort(hpp.host, strconv.Itoa(hpp.port))\n\t\tif lookupSet.Has(key) {\n\t\t\tfilteredEndpoints = append(filteredEndpoints, &endpointsInfo{ip: key, localEndpoint: hpp.localEndpoint})"
  },
  {
    "id" : "05a99a0f-ef5f-430c-a5a7-4841532b8ebe",
    "prId" : 29409,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d318829-a43d-46da-9ebf-31b2c2210f25",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "comment on why a set rather than []namespacedName\n",
        "createdAt" : "2016-08-16T22:55:56Z",
        "updatedAt" : "2016-08-23T23:16:56Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b82c028f77d85ac0be39b510ccdbc2783e43fdc7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +592,596 @@func (proxier *Proxier) updateHealthCheckEntries(name types.NamespacedName, hostPorts []hostPortInfo) {\n\t// Use a set instead of a slice to provide deduplication\n\tendpoints := sets.NewString()\n\tfor _, portInfo := range hostPorts {\n\t\tif portInfo.localEndpoint {"
  },
  {
    "id" : "b8eb32c8-3d49-451c-a64d-85f9e975d044",
    "prId" : 29409,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66e52f53-5dbc-4f85-bbfa-06d3140e9cd8",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Think about: can we merge this with the identical block above?  Maybe a function?\n",
        "createdAt" : "2016-08-16T23:08:42Z",
        "updatedAt" : "2016-08-23T23:16:56Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b82c028f77d85ac0be39b510ccdbc2783e43fdc7",
    "line" : 409,
    "diffHunk" : "@@ -1,1 +1177,1181 @@\t\t} else {\n\t\t\t// Setup probability filter rules only over local endpoints\n\t\t\tfor i, endpointChain := range localEndpointChains {\n\t\t\t\t// Balancing rules in the per-service chain.\n\t\t\t\targs := []string{"
  },
  {
    "id" : "3f153214-7da4-4ed4-b555-f37f2b3829c0",
    "prId" : 29409,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92a1714e-7f67-4ddc-8f53-abda3ec8124c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For followup: we should expose a stat for number of HC ports open\n",
        "createdAt" : "2016-08-17T22:07:43Z",
        "updatedAt" : "2016-08-23T23:16:56Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "f9fbf13f-a839-4143-9777-d866bf881a8b",
        "parentId" : "92a1714e-7f67-4ddc-8f53-abda3ec8124c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "if you do more edits, add a TODO for stats\n",
        "createdAt" : "2016-08-19T00:23:52Z",
        "updatedAt" : "2016-08-23T23:16:56Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b82c028f77d85ac0be39b510ccdbc2783e43fdc7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +466,470 @@\t\t\t\t// Remove ServiceListener health check nodePorts from the health checker\n\t\t\t\t// TODO - Stats\n\t\t\t\thealthcheck.DeleteServiceListener(name.NamespacedName, info.healthCheckNodePort)\n\t\t\t}\n\t\t}"
  },
  {
    "id" : "d82942ea-9d1f-4a95-9362-8e607ae60d1b",
    "prId" : 29409,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc8026e9-ef40-4d73-8775-d1ff8112366b",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "polease add a TODO that explains that this is duplicated from above and an opportunity for future cleanup\n",
        "createdAt" : "2016-08-17T22:14:01Z",
        "updatedAt" : "2016-08-23T23:16:56Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b82c028f77d85ac0be39b510ccdbc2783e43fdc7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1177,1181 @@\t\t} else {\n\t\t\t// Setup probability filter rules only over local endpoints\n\t\t\tfor i, endpointChain := range localEndpointChains {\n\t\t\t\t// Balancing rules in the per-service chain.\n\t\t\t\targs := []string{"
  },
  {
    "id" : "e0b55d88-51de-4d0b-a316-6d940c152e82",
    "prId" : 24429,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f97a2250-6222-483f-aee8-83450d75d82a",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This will write once per-service, won't it?  Can you achieve the same effect by writing once at ~L687\n",
        "createdAt" : "2016-04-18T21:59:41Z",
        "updatedAt" : "2016-04-20T04:39:51Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "574d0ff5-042a-4413-85c6-f5aaa13dc30f",
        "parentId" : "f97a2250-6222-483f-aee8-83450d75d82a",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "or is that too broad?  Hmm, don't do it yet, let me think.\n",
        "createdAt" : "2016-04-18T22:00:20Z",
        "updatedAt" : "2016-04-20T04:39:51Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cc50fd27-3fe5-4fa4-8754-16998531df68",
        "parentId" : "f97a2250-6222-483f-aee8-83450d75d82a",
        "authorId" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "body" : "Thought about that too. I copied the functionality of `--masquerade-all`\n",
        "createdAt" : "2016-04-18T22:08:41Z",
        "updatedAt" : "2016-04-20T04:39:51Z",
        "lastEditedBy" : "3cd3a661-80f4-45b3-bae0-5a78fbaedc59",
        "tags" : [
        ]
      },
      {
        "id" : "eccaa87b-b34e-4a7d-a2ae-f65c6079cc05",
        "parentId" : "f97a2250-6222-483f-aee8-83450d75d82a",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Yeah, you're right.  It's unfortunate, but any simpler solution is either too broad or costs the same number of rules.\n",
        "createdAt" : "2016-04-19T00:08:06Z",
        "updatedAt" : "2016-04-20T04:39:51Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "760568796f97613f4c538299525f88bb586ffb39",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +795,799 @@\t\t\twriteLine(natRules, append(args, \"-j\", string(kubeMarkMasqChain))...)\n\t\t}\n\t\tif len(proxier.clusterCIDR) > 0 {\n\t\t\twriteLine(natRules, append(args, \"! -s\", proxier.clusterCIDR, \"-j\", string(kubeMarkMasqChain))...)\n\t\t}"
  },
  {
    "id" : "4c4761ae-348c-48bd-8423-fb88a334950b",
    "prId" : 22573,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d148b63-5495-4e21-b4a3-91b8f370485d",
        "parentId" : null,
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "do we handle the case : no endpoints deleted, but a service got deleted ?\n",
        "createdAt" : "2016-03-11T23:40:27Z",
        "updatedAt" : "2016-04-18T21:59:12Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      },
      {
        "id" : "5e06022a-57ee-4f1c-b6b8-ba80ffb84d6f",
        "parentId" : "4d148b63-5495-4e21-b4a3-91b8f370485d",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Good Catch! Added logic to clean up stale service connections \n",
        "createdAt" : "2016-03-12T01:14:24Z",
        "updatedAt" : "2016-04-18T21:59:12Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad8c67723a62664ac667555acaed76421615e6e6",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +507,511 @@\tfor name := range proxier.endpointsMap {\n\t\tif !activeEndpoints[name] {\n\t\t\t// record endpoints of unactive service to stale connections\n\t\t\tfor _, ep := range proxier.endpointsMap[name] {\n\t\t\t\tstaleConnections[endpointServicePair{endpoint: ep, servicePortName: name}] = true"
  },
  {
    "id" : "d3cfa682-fa94-4140-bff6-6d8609aaa7b5",
    "prId" : 22573,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5bf1168-898f-4fd3-81cd-0db52be3c033",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "could this whole function be\n\n```\nreturn sets.NewString(curEndpoints).Difference(sets.NewString(newEndpoints))\n```\n",
        "createdAt" : "2016-04-08T04:29:36Z",
        "updatedAt" : "2016-04-18T21:59:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "81a73dbf-209a-4d8d-9204-6341263927e6",
        "parentId" : "c5bf1168-898f-4fd3-81cd-0db52be3c033",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Need a robust unit test for this function proving the polarity\n",
        "createdAt" : "2016-04-08T04:31:20Z",
        "updatedAt" : "2016-04-18T21:59:12Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad8c67723a62664ac667555acaed76421615e6e6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +575,579 @@\n// getRemovedEndpoints returns the endpoint IPs that are missing in the new endpoints\nfunc getRemovedEndpoints(curEndpoints, newEndpoints []string) []string {\n\treturn sets.NewString(curEndpoints...).Difference(sets.NewString(newEndpoints...)).List()\n}"
  },
  {
    "id" : "4d4a1b19-d941-493b-a426-e012545409f6",
    "prId" : 20647,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13c17ce0-89c6-4209-bd38-c7c25fda2c64",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is this sysctl call still appropriate for the proxier to set, rather than the network plugin?\n",
        "createdAt" : "2016-02-20T16:12:45Z",
        "updatedAt" : "2016-02-23T15:35:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "67a6af1c-11ff-49a8-9b1d-a0f08180f4d0",
        "parentId" : "13c17ce0-89c6-4209-bd38-c7c25fda2c64",
        "authorId" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "body" : "We can move it to a plugin when we start using plugins by default. For now I'd like to keep things as they are unless absolutely necessary. the no-op plugin should really no-op. \n",
        "createdAt" : "2016-02-22T02:04:15Z",
        "updatedAt" : "2016-02-23T15:35:11Z",
        "lastEditedBy" : "395f4f9a-98be-4485-b436-51f0897d7c9f",
        "tags" : [
        ]
      },
      {
        "id" : "92c38b49-e024-4210-b498-ff8b72ab2fd1",
        "parentId" : "13c17ce0-89c6-4209-bd38-c7c25fda2c64",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Worse, there was a separate PR, somewhere, that made the no-op plugin go away and be a nil pointer.\n",
        "createdAt" : "2016-02-22T21:13:39Z",
        "updatedAt" : "2016-02-23T15:35:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "6248939e11a4d5b422da5ffdc7ec52a6c1ded54a",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +189,193 @@\t// Set the route_localnet sysctl we need for\n\tif err := utilsysctl.SetSysctl(sysctlRouteLocalnet, 1); err != nil {\n\t\treturn nil, fmt.Errorf(\"can't set sysctl %s: %v\", sysctlRouteLocalnet, err)\n\t}\n"
  },
  {
    "id" : "4758c6ab-1d32-4be2-b9b6-eb6694c12b61",
    "prId" : 20471,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae9f09d6-306d-45fa-bec0-c25c62d94e20",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "should we add one of these to the syncProxyRules() ?\n",
        "createdAt" : "2016-02-03T20:46:37Z",
        "updatedAt" : "2016-02-03T20:58:55Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "47f7f4417dcfe550e2ac06342eaad28ed2525a76",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +352,356 @@func (proxier *Proxier) OnEndpointsUpdate(allEndpoints []api.Endpoints) {\n\tstart := time.Now()\n\tdefer func() {\n\t\tglog.V(4).Infof(\"OnEndpointsUpdate took %v for %d endpoints\", time.Since(start), len(allEndpoints))\n\t}()"
  },
  {
    "id" : "413f402c-fd8c-4e40-81d1-f273891d3ff1",
    "prId" : 19576,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1803fe0f-1c08-4e1e-9435-7e46f44b3525",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "also de-dup here.  This comes down to a loop over a table of {table, chain} and all have the same body.\n",
        "createdAt" : "2016-01-16T05:58:30Z",
        "updatedAt" : "2016-02-04T20:57:43Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "81365056-a333-498c-ab86-481d031aa649",
        "parentId" : "1803fe0f-1c08-4e1e-9435-7e46f44b3525",
        "authorId" : "1ea147b5-c83a-4bb6-93f7-fe98d18e45bf",
        "body" : "@thockin I am only adding the rule to the OUTPUT chain on filter table right? there is no PREROUTING?\n",
        "createdAt" : "2016-01-16T08:57:08Z",
        "updatedAt" : "2016-02-04T20:57:43Z",
        "lastEditedBy" : "1ea147b5-c83a-4bb6-93f7-fe98d18e45bf",
        "tags" : [
        ]
      }
    ],
    "commit" : "c33fcba311bf7f19d3a080b430e3c8b955fe7cee",
    "line" : null,
    "diffHunk" : "@@ -1,1 +489,493 @@\t}\n\tcomment := \"kubernetes service portals\"\n\targs := []string{\"-m\", \"comment\", \"--comment\", comment, \"-j\", string(iptablesServicesChain)}\n\tfor _, tc := range tableChainsNeedJumpServices {\n\t\tif _, err := proxier.iptables.EnsureRule(utiliptables.Prepend, tc.table, tc.chain, args...); err != nil {"
  },
  {
    "id" : "566741dd-f46d-4ee9-9aa1-bb54e3b6b0d5",
    "prId" : 16548,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40ae522e-43d5-4996-8a3b-aa86424643bb",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "how could `currentReadIndex` ever be less than `leftTrimIndex` ?\n",
        "createdAt" : "2015-10-29T21:59:59Z",
        "updatedAt" : "2015-10-29T22:30:22Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "c8d2b805-f954-48d5-b5ec-9e82a8881d89",
        "parentId" : "40ae522e-43d5-4996-8a3b-aa86424643bb",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "It can't be less.\nI still need to handle to == case.\n",
        "createdAt" : "2015-10-29T22:01:19Z",
        "updatedAt" : "2015-10-29T22:30:22Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "5367a32ee9ff484acf942bdfd58b7fcdd42046c1",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +823,827 @@\t\t} else if (byteArray[currentReadIndex] == '\\n') || (currentReadIndex == (len(byteArray) - 1)) {\n\t\t\t// end of line or byte buffer is reached\n\t\t\tif currentReadIndex <= leftTrimIndex {\n\t\t\t\treturn \"\", currentReadIndex + 1\n\t\t\t}"
  },
  {
    "id" : "959fcd1c-d054-47e3-b54c-f414139b8885",
    "prId" : 12561,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d14fa5f6-6f06-4667-b4a0-f0e75b081591",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Comment, something like\n\nAllow traffic for external IPs that does not come from a bridge (i.e. not from a container) nor from a local process to be forwarded to the service.  This roughly translates to \"all traffic from off-machine\".  This is imperfect in the face of network plugins that might not use a bridge, but we can revisit that later.\n",
        "createdAt" : "2015-08-19T20:29:46Z",
        "updatedAt" : "2015-08-20T23:10:30Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6b8e993937b8a3f21d41a9a3841f79bfa894f36",
    "line" : null,
    "diffHunk" : "@@ -1,1 +573,577 @@\t\t\t// This rule roughly translates to \"all traffic from off-machine\".\n\t\t\t// This is imperfect in the face of network plugins that might not use a bridge, but we can revisit that later.\n\t\t\texternalTrafficOnlyArgs := append(args,\n\t\t\t\t\"-m\", \"physdev\", \"!\", \"--physdev-is-in\",\n\t\t\t\t\"-m\", \"addrtype\", \"!\", \"--src-type\", \"LOCAL\")"
  },
  {
    "id" : "9c170a8d-f0b6-45d7-8ef6-451028440d7c",
    "prId" : 9210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ee307ea-a167-4362-bee7-b5f712b9d09b",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "syncProxyRules() takes the mutex.\n\nYou've gotten to the hard part of multi-threading - figuring out WTF just happened.\n",
        "createdAt" : "2015-08-11T01:06:00Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "09fd2841-c607-459e-be7f-c327dd1204b5",
        "parentId" : "4ee307ea-a167-4362-bee7-b5f712b9d09b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Now I know why that wasn't taking it before except in the closure. Fun.\nWell I think syncProxyRules is only called from mutex holding callers now,\nso I can just make syncProxyRules not take the mutex, need to double check.\n\nOn Mon, Aug 10, 2015 at 9:07 PM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36703127\n> :\n> \n> > -       }\n> > -   }\n> >   +\n> > -   for name, info := range proxier.serviceMap {\n> > -       if !activeServices[name] {\n> > -           glog.V(1).Infof(\"Removing service %q\", name)\n> > -           proxier.removeServiceInternal(name, info)\n> > -       }\n> > -   }\n> >   +\n> > -   glog.V(6).Infof(\"Syncing rules.\")\n> > -   if err := proxier.iptablesInit(); err != nil {\n> > -       glog.Errorf(\"Failed to ensure iptables: %v\", err)\n> > -   }\n> > -   // this locks proxier.mu, hence the closure above\n> > -   if err := proxier.syncProxyRules(); err != nil {\n> \n> syncProxyRules() takes the mutex.\n> \n> You've gotten to the hard part of multi-threading - figuring out WTF just\n> happened.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36703127\n> .\n",
        "createdAt" : "2015-08-11T01:09:11Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "a2f353e3-3a9f-4cbb-b77d-97f3c8502977",
        "parentId" : "4ee307ea-a167-4362-bee7-b5f712b9d09b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "As a last pass we should reduce contention on tht lock as much as we can\n\nOn Mon, Aug 10, 2015 at 6:09 PM, Benjamin Elder notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36703283\n> :\n> \n> > -       }\n> > -   }\n> >   +\n> > -   for name, info := range proxier.serviceMap {\n> > -       if !activeServices[name] {\n> > -           glog.V(1).Infof(\"Removing service %q\", name)\n> > -           proxier.removeServiceInternal(name, info)\n> > -       }\n> > -   }\n> >   +\n> > -   glog.V(6).Infof(\"Syncing rules.\")\n> > -   if err := proxier.iptablesInit(); err != nil {\n> > -       glog.Errorf(\"Failed to ensure iptables: %v\", err)\n> > -   }\n> > -   // this locks proxier.mu, hence the closure above\n> > -   if err := proxier.syncProxyRules(); err != nil {\n> \n> Now I know why that wasn't taking it before except in the closure. Fun.\n> Well I think syncProxyRules is only called from mutex holding callers now,\n> so I can just make syncProxyRules not take the mutex, need to double check.\n> … <#14f1a4e62a07715c_>\n> On Mon, Aug 10, 2015 at 9:07 PM, Tim Hockin notifications@github.com\n> wrote: In pkg/proxy/iptables/proxier.go <\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36703127>\n> : > + } > + } > + > + for name, info := range proxier.serviceMap { > + if\n> !activeServices[name] { > + glog.V(1).Infof(\"Removing service %q\", name) >\n> - proxier.removeServiceInternal(name, info) > + } > + } > + > +\n>   glog.V(6).Infof(\"Syncing rules.\") > + if err := proxier.iptablesInit(); err\n>   != nil { > + glog.Errorf(\"Failed to ensure iptables: %v\", err) > + } > + //\n>   this locks proxier.mu, hence the closure above > + if err :=\n>   proxier.syncProxyRules(); err != nil { syncProxyRules() takes the mutex.\n>   You've gotten to the hard part of multi-threading - figuring out WTF just\n>   happened. — Reply to this email directly or view it on GitHub <\n>   https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36703127>\n>   .\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36703283\n> .\n",
        "createdAt" : "2015-08-11T01:18:55Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e19d5ece-dcf2-4ceb-9a32-dce98f3192e3",
        "parentId" : "4ee307ea-a167-4362-bee7-b5f712b9d09b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "In the next iteration it should only be held and released in\nOnServiceUpdate and OnEndpointsUpdate.\n\nOn Mon, Aug 10, 2015 at 9:19 PM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36703752\n> :\n> \n> > -       }\n> > -   }\n> >   +\n> > -   for name, info := range proxier.serviceMap {\n> > -       if !activeServices[name] {\n> > -           glog.V(1).Infof(\"Removing service %q\", name)\n> > -           proxier.removeServiceInternal(name, info)\n> > -       }\n> > -   }\n> >   +\n> > -   glog.V(6).Infof(\"Syncing rules.\")\n> > -   if err := proxier.iptablesInit(); err != nil {\n> > -       glog.Errorf(\"Failed to ensure iptables: %v\", err)\n> > -   }\n> > -   // this locks proxier.mu, hence the closure above\n> > -   if err := proxier.syncProxyRules(); err != nil {\n> \n> As a last pass we should reduce contention on tht lock as much as we can\n> … <#14f1a576ddf9c294_>\n> On Mon, Aug 10, 2015 at 6:09 PM, Benjamin Elder notifications@github.com\n> wrote: In pkg/proxy/iptables/proxier.go <\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36703283>\n> : > + } > + } > + > + for name, info := range proxier.serviceMap { > + if\n> !activeServices[name] { > + glog.V(1).Infof(\"Removing service %q\", name) >\n> - proxier.removeServiceInternal(name, info) > + } > + } > + > +\n>   glog.V(6).Infof(\"Syncing rules.\") > + if err := proxier.iptablesInit(); err\n>   != nil { > + glog.Errorf(\"Failed to ensure iptables: %v\", err) > + } > + //\n>   this locks proxier.mu, hence the closure above > + if err :=\n>   proxier.syncProxyRules(); err != nil { Now I know why that wasn't taking it\n>   before except in the closure. Fun. Well I think syncProxyRules is only\n>   called from mutex holding callers now, so I can just make syncProxyRules\n>   not take the mutex, need to double check. … <#14f1a4e62a07715c_> On Mon,\n>   Aug 10, 2015 at 9:07 PM, Tim Hockin notifications@github.com wrote: In\n>   pkg/proxy/iptables/proxier.go <\n>   https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36703127>\n>   : > + } > + } > + > + for name, info := range proxier.serviceMap { > + if\n>   !activeServices[name] { > + glog.V(1).Infof(\"Removing service %q\", name) >\n> - proxier.removeServiceInternal(name, info) > + } > + } > + > +\n>   glog.V(6).Infof(\"Syncing rules.\") > + if err := proxier.iptablesInit(); err\n>   != nil { > + glog.Errorf(\"Failed to ensure iptables: %v\", err) > + } > + //\n>   this locks proxier.mu, hence the closure above > + if err :=\n>   proxier.syncProxyRules(); err != nil { syncProxyRules() takes the mutex.\n>   You've gotten to the hard part of multi-threading - figuring out WTF just\n>   happened. — Reply to this email directly or view it on GitHub <\n>   https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36703127>\n>   . — Reply to this email directly or view it on GitHub <\n>   https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36703283>\n>   .\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36703752\n> .\n",
        "createdAt" : "2015-08-11T01:21:20Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae569e20b53d9dc19e41aa273c39490ecb073710",
    "line" : null,
    "diffHunk" : "@@ -1,1 +286,290 @@\t}\n\n\tif err := proxier.syncProxyRules(); err != nil {\n\t\tglog.Errorf(\"Failed to sync iptables rules: %v\", err)\n\t}"
  },
  {
    "id" : "a33d95e1-f063-4c51-8ca3-c7b9eabce3f1",
    "prId" : 9210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dd25348-35c4-4cd4-86c8-64f9cc0ea5ea",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "this needs a comment about the service/endpoints interlock for deletion\n",
        "createdAt" : "2015-08-11T19:57:37Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae569e20b53d9dc19e41aa273c39490ecb073710",
    "line" : null,
    "diffHunk" : "@@ -1,1 +346,350 @@\t\t\t// only remove ServicePorts that have no endpoints and were not in the service update,\n\t\t\t// that way we only remove ServicePorts that were not in both.\n\t\t\tproxier.serviceMap[service].endpoints = nil\n\t\t}\n\t}"
  },
  {
    "id" : "de0691a9-2ed6-44fa-a49e-d2112504215c",
    "prId" : 9210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "726cc9db-029d-454a-833d-f617a72fa5d9",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think we should make the `i == n-1` case not include probability at all.  I'm worried about floating point errors causing 1-in-a-million hangs (also it's pointless to say probabiltity == 1)\n",
        "createdAt" : "2015-08-12T04:58:25Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae569e20b53d9dc19e41aa273c39490ecb073710",
    "line" : null,
    "diffHunk" : "@@ -1,1 +496,500 @@\t\t\t// Roughly round robin statistically if we have more than one host\n\t\t\tif i < (n - 1) {\n\t\t\t\trulesLines.WriteString(fmt.Sprintf(\"-A %s -m comment --comment \\\"%s\\\" -m statistic --mode random --probability %f -j %s\\n\", svcChain, name.String(), 1.0/float64(n-i), hostChain))\n\t\t\t} else {\n\t\t\t\trulesLines.WriteString(fmt.Sprintf(\"-A %s -m comment --comment \\\"%s\\\" -j %s\\n\", svcChain, name.String(), hostChain))"
  },
  {
    "id" : "558a5c4d-1f90-46ba-96d1-51694c173c91",
    "prId" : 9210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a30b024-4e44-49e7-a5e0-c41c5bb76e9c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I removed a service and saw this log line twice.  Not sure why.  Can you repro?\n",
        "createdAt" : "2015-08-12T05:08:27Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "14ef24c2-b23c-4f30-b5e5-8c485aa36c62",
        "parentId" : "4a30b024-4e44-49e7-a5e0-c41c5bb76e9c",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Looking into it.\n\nOn Wed, Aug 12, 2015 at 1:09 AM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36827064\n> :\n> \n> > -           if state != nil {\n> > -               curEndpoints = state.endpoints\n> > -           }\n> > -           newEndpoints := flattenValidEndpoints(portsToEndpoints[portname])\n> >   +\n> > -           if len(curEndpoints) != len(newEndpoints) || !slicesEquiv(slice.CopyStrings(curEndpoints), newEndpoints) {\n> > -               glog.V(1).Infof(\"Setting endpoints for %s to %+v\", svcPort, newEndpoints)\n> > -               state.endpoints = newEndpoints\n> > -           }\n> > -           registeredEndpoints[svcPort] = true\n> > -       }\n> > -   }\n> > -   // Remove endpoints missing from the update.\n> > -   for service := range proxier.serviceMap {\n> > -       if _, exists := registeredEndpoints[service]; !exists {\n> > -           glog.V(2).Infof(\"Removing endpoints for %s\", service)\n> \n> I removed a service and saw this log line twice. Not sure why. Can you\n> repro?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36827064\n> .\n",
        "createdAt" : "2015-08-12T05:14:20Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "b81b4d06-57e8-499f-af5e-340de474be87",
        "parentId" : "4a30b024-4e44-49e7-a5e0-c41c5bb76e9c",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "I think this is probably multiple endpoint events before a service event. We can check if the endpoints are already nil to prevent this.\n",
        "createdAt" : "2015-08-12T05:43:43Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "d71ceab8-ab65-40aa-b197-84297f0a9898",
        "parentId" : "4a30b024-4e44-49e7-a5e0-c41c5bb76e9c",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "This should fix in theory.\n\n```\n// Remove endpoints missing from the update.\n    for service, info := range proxier.serviceMap {\n        // if missing from update and not already set by previous endpoints event\n        if _, exists := registeredEndpoints[service]; !exists && info.endpoints != nil {\n            glog.V(2).Infof(\"Removing endpoints for %s\", service)\n            // Set the endpoints to nil, we will check for this in OnServiceUpdate so that we\n            // only remove ServicePorts that have no endpoints and were not in the service update,\n            // that way we only remove ServicePorts that were not in both.\n            proxier.serviceMap[service].endpoints = nil\n        }\n    }\n```\n",
        "createdAt" : "2015-08-12T05:50:27Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae569e20b53d9dc19e41aa273c39490ecb073710",
    "line" : null,
    "diffHunk" : "@@ -1,1 +342,346 @@\t\t// if missing from update and not already set by previous endpoints event\n\t\tif _, exists := registeredEndpoints[service]; !exists && info.endpoints != nil {\n\t\t\tglog.V(2).Infof(\"Removing endpoints for %s\", service)\n\t\t\t// Set the endpoints to nil, we will check for this in OnServiceUpdate so that we\n\t\t\t// only remove ServicePorts that have no endpoints and were not in the service update,"
  },
  {
    "id" : "fbf12cd5-ff37-4c8f-91f5-cd84059740f1",
    "prId" : 9210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I deleted a service and found orphaned chains - this did not seem to trigger\n\n```\n-A KUBE-SVC-6YXX3VD3WCLEDEMGARZ -p tcp -m comment --comment \"default/hostnames:foobar\" -j DNAT --to-destination 10.244.0.7:9376\n-A KUBE-SVC-NJYEB6NTCQ5G6PYRULJ -p tcp -m comment --comment \"default/hostnames:foobar\" -j DNAT --to-destination 10.244.2.6:9376\n-A KUBE-SVC-SHGK6DMD7JYPY65MRNA -p tcp -m comment --comment \"default/hostnames:foobar\" -j DNAT --to-destination 10.244.3.3:9376\n```\n",
        "createdAt" : "2015-08-12T05:12:51Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "f873e0e5-ed97-4ed3-b533-d19b613b5148",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Line 526: change || to &&\n",
        "createdAt" : "2015-08-12T05:17:02Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e94038af-441c-444f-bf2b-9108f63d3a25",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Oops, it looks like iptables-restore doesn't support -X - you'll have to fix that by imperative rules, I guess\n",
        "createdAt" : "2015-08-12T05:22:05Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e3e4b79f-663d-4349-833b-1ffde9529cc9",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Hmm, that's unfortunate.\n\nOn Wed, Aug 12, 2015 at 1:22 AM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36827443\n> :\n> \n> > -       for _, ingress := range info.loadBalancerStatus.Ingress {\n> > -           if ingress.IP != \"\" {\n> > -               rulesLines.WriteString(fmt.Sprintf(\"-A %s -m comment --comment \\\"load-balancer portal for %s\\\" -d %s/32 -m state --state NEW -p %s -m %s --dport %d -j %s\\n\", iptablesServicesChain, name.String(), ingress.IP, protocol, protocol, info.portal.port, svcChain))\n> > -           }\n> > -       }\n> > -   }\n> >   +\n> > -   // Delete chains no longer in use:\n> > -   activeChains := make(map[utiliptables.Chain]bool) // use a map as a set\n> > -   for _, chain := range newHostChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for _, chain := range newServiceChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for chain := range existingChains {\n> \n> Oops, it looks like iptables-restore doesn't support -X - you'll have to\n> fix that by imperative rules, I guess\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36827443\n> .\n",
        "createdAt" : "2015-08-12T05:24:18Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "c6f674b3-3ca6-4f01-a10a-47f30d7a0d6c",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "need to beef up your manual testing at least.  Would be nice to cover these with e2e but your time is short\n",
        "createdAt" : "2015-08-12T05:25:09Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "9b2f7dbf-3e1a-421a-8fce-eecdd5465d50",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Oh, it DOES support -X, you just also have to -F those chains.\n",
        "createdAt" : "2015-08-12T05:29:21Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "07772ddf-dbfb-4fba-b952-532cb3115bed",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Yeah. The recent pushes haven't been as thoroughly tested yet since firing\nup a cluster is really slow for me (vagrant). I'm mostly checking for\nbuilds and integration tests during the day and watching the e2e results\nthen going over the cluster stuff locally when things quiet down eg at the\nend of the day.\n\nI'm working with a cluster locally right now fixing some of the stuff\nmentioned here so far.\nI'll try to have everything patched tonight so we can move on tomorrow.\n\nOn Wed, Aug 12, 2015 at 1:25 AM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36827532\n> :\n> \n> > -       for _, ingress := range info.loadBalancerStatus.Ingress {\n> > -           if ingress.IP != \"\" {\n> > -               rulesLines.WriteString(fmt.Sprintf(\"-A %s -m comment --comment \\\"load-balancer portal for %s\\\" -d %s/32 -m state --state NEW -p %s -m %s --dport %d -j %s\\n\", iptablesServicesChain, name.String(), ingress.IP, protocol, protocol, info.portal.port, svcChain))\n> > -           }\n> > -       }\n> > -   }\n> >   +\n> > -   // Delete chains no longer in use:\n> > -   activeChains := make(map[utiliptables.Chain]bool) // use a map as a set\n> > -   for _, chain := range newHostChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for _, chain := range newServiceChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for chain := range existingChains {\n> \n> need to beef up your manual testing at least. Would be nice to cover these\n> with e2e but your time is short\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36827532\n> .\n",
        "createdAt" : "2015-08-12T05:29:33Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "9b6babe6-a862-49c2-a6a1-3f4c7e4a277a",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Ah, that makes sense. It should throw an error in the logs in the rules\naren't supported.\nEasy fix then, flush and delete. Will have in next push.\n\nOn Wed, Aug 12, 2015 at 1:30 AM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36827676\n> :\n> \n> > -       for _, ingress := range info.loadBalancerStatus.Ingress {\n> > -           if ingress.IP != \"\" {\n> > -               rulesLines.WriteString(fmt.Sprintf(\"-A %s -m comment --comment \\\"load-balancer portal for %s\\\" -d %s/32 -m state --state NEW -p %s -m %s --dport %d -j %s\\n\", iptablesServicesChain, name.String(), ingress.IP, protocol, protocol, info.portal.port, svcChain))\n> > -           }\n> > -       }\n> > -   }\n> >   +\n> > -   // Delete chains no longer in use:\n> > -   activeChains := make(map[utiliptables.Chain]bool) // use a map as a set\n> > -   for _, chain := range newHostChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for _, chain := range newServiceChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for chain := range existingChains {\n> \n> Oh, it DOES support -X, you just also have to -F those chains.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36827676\n> .\n",
        "createdAt" : "2015-08-12T05:32:21Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "7847e4da-237f-4a3a-b819-aae762e3f1e5",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Also, I am seeing KUBE-SERVICES get caught.  Don't check for that prefix!\n",
        "createdAt" : "2015-08-12T05:36:43Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "4028f861-5330-4e84-804f-657448e542a0",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Locally it's now:\n`if !strings.HasPrefix(chainString, \"KUBE-SVC-\") &&\n!strings.HasPrefix(chainString, \"KUBE-SEP-\") && chainString !=\n\"KUBE-SERVICES\" {`\n\nOn Wed, Aug 12, 2015 at 1:37 AM, Tim Hockin notifications@github.com\nwrote:\n\n> In pkg/proxy/iptables/proxier.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210#discussion_r36827956\n> :\n> \n> > -       for _, ingress := range info.loadBalancerStatus.Ingress {\n> > -           if ingress.IP != \"\" {\n> > -               rulesLines.WriteString(fmt.Sprintf(\"-A %s -m comment --comment \\\"load-balancer portal for %s\\\" -d %s/32 -m state --state NEW -p %s -m %s --dport %d -j %s\\n\", iptablesServicesChain, name.String(), ingress.IP, protocol, protocol, info.portal.port, svcChain))\n> > -           }\n> > -       }\n> > -   }\n> >   +\n> > -   // Delete chains no longer in use:\n> > -   activeChains := make(map[utiliptables.Chain]bool) // use a map as a set\n> > -   for _, chain := range newHostChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for _, chain := range newServiceChains {\n> > -       activeChains[chain] = true\n> > -   }\n> > -   for chain := range existingChains {\n> \n> Also, I am seeing KUBE-SERVICES get caught. Don't check for that prefix!\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/9210/files#r36827956\n> .\n",
        "createdAt" : "2015-08-12T05:39:29Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      },
      {
        "id" : "3dbf86c1-a74a-4862-917b-51a8b11f54c1",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "the last clause seems wrong - if the prefix is not KUBE-SVC or KUBE-SEP, skip it.  Nothing els eneeded\n",
        "createdAt" : "2015-08-12T05:53:04Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "4e6c13ad-34c2-42b8-a4c9-b332378dba72",
        "parentId" : "326c4123-edca-4444-9980-f3b2b36a4c0b",
        "authorId" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "body" : "Ah, true. KUBE-SERVICES shouldn't ever show up in that set anyhow. Fixed.\n",
        "createdAt" : "2015-08-12T05:55:46Z",
        "updatedAt" : "2015-08-12T06:39:21Z",
        "lastEditedBy" : "46e1ba13-482b-4bcd-8fb1-be821bac3b04",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae569e20b53d9dc19e41aa273c39490ecb073710",
    "line" : 532,
    "diffHunk" : "@@ -1,1 +530,534 @@\t\tactiveChains[chain] = true\n\t}\n\tfor chain := range existingChains {\n\t\tif !activeChains[chain] {\n\t\t\tchainString := string(chain)"
  }
]
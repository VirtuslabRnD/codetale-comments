[
  {
    "id" : "a2638838-0949-4639-b8a1-3e023ccd8d1a",
    "prId" : 27708,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe7ee353-40d4-4a4a-9f77-d54b7252c3d4",
        "parentId" : null,
        "authorId" : null,
        "body" : "As discussed, for both headless and non-headless, we should return a CNAME (to the local service's DNS name if the service exists and has endoints, or to the zone-local DNS name if the local service has no endpoints).\n",
        "createdAt" : "2016-06-23T20:46:55Z",
        "updatedAt" : "2016-06-24T00:50:28Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0c5bf839-68ce-4b8d-80ca-1bbb13e7f1a4",
        "parentId" : "fe7ee353-40d4-4a4a-9f77-d54b7252c3d4",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "done\n",
        "createdAt" : "2016-06-23T22:51:07Z",
        "updatedAt" : "2016-06-24T00:50:28Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "7be429307bdc7fc545c671e46be91f27e322f378",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +368,372 @@}\n\n// Verifies that quering KubeDNS for a headless federation service returns the DNS hostname when a local service does not exist and returns the endpoint IP when a local service exists.\nfunc TestFederationHeadlessService(t *testing.T) {\n\tkd := newKubeDNS()"
  },
  {
    "id" : "a8740cde-4eb5-447a-96e3-0bb7151fda55",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4829acd6-0e55-42da-ac4d-f74317a712f7",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Should the endpoints be removed after check and asserted that len(endpoints) == 0 at the end of this test? What if a bug causes all the records to point to the same endpoints address?\n",
        "createdAt" : "2016-05-11T21:52:54Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "cc8043fd-a696-47cc-93a5-68cdba334c95",
        "parentId" : "4829acd6-0e55-42da-ac4d-f74317a712f7",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "I believe we do it already, just not in the assert.. function since the function should not be mutating anything..\n",
        "createdAt" : "2016-05-19T18:59:49Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : 290,
    "diffHunk" : "@@ -1,1 +288,292 @@\tassert.Equal(t, len(endpoints), len(records))\n\tfor _, record := range records {\n\t\t_, found := endpoints[record.Host]\n\t\tassert.True(t, found)\n\t}"
  },
  {
    "id" : "353b7afa-80e1-4960-ab4e-ce964222bcb8",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11999206-980e-4c4e-9319-f59462157ec8",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "\"Could not get the expected number of records for %s\" may be? len(records) might be > 1 and we still get this assertion failure.\n",
        "createdAt" : "2016-05-11T21:57:20Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "b4bd308a-7a05-4004-8bc7-3b57f2d62217",
        "parentId" : "11999206-980e-4c4e-9319-f59462157ec8",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "i am looking for exactly 1 record...\n",
        "createdAt" : "2016-05-19T20:00:17Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : 316,
    "diffHunk" : "@@ -1,1 +314,318 @@\trecords, err := kd.Records(cname, false)\n\trequire.NoError(t, err)\n\tassert.Equal(t, 1, len(records), \"Could not get IP for CNAME record for %s\", cname)\n\tassert.NotNil(t, net.ParseIP(records[0].Host), \"Invalid IP address %q\", records[0].Host)\n\treturn records[0].Host"
  }
]
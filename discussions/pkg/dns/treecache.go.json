[
  {
    "id" : "71056c28-74fa-43f3-8ac2-a5e1e348fc69",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1fdd6e0-cc5f-4843-b7be-8a99f6d3952c",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "Collapse the last two lines to\n\n```\nreturn childNode.Entries[key]\n```\n",
        "createdAt" : "2016-05-11T22:24:33Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      },
      {
        "id" : "0f5eab06-642b-498b-8c9c-4b1f263664fa",
        "parentId" : "a1fdd6e0-cc5f-4843-b7be-8a99f6d3952c",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "can't you just return nil, and skip the bool return?\n",
        "createdAt" : "2016-05-17T19:11:51Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5e002a81-5281-431a-b57a-81e0ee800b5b",
        "parentId" : "a1fdd6e0-cc5f-4843-b7be-8a99f6d3952c",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "@thockin Wherever an interface is involved in the return values, it totally scares me to use `nil` to mean anything. Thanks to Go's your-nil-pointer-to-an-underlying-concrete-type-is-not-the-same-as-nil-interface subtlety. It's probably Ok in this case because Entries' value is an interface as well, but I would stay away from that pattern wherever I can.\n",
        "createdAt" : "2016-05-17T20:06:30Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +74,78 @@\tchildNode := cache.getSubCache(path...)\n\tval, ok := childNode.Entries[key]\n\treturn val, ok\n}\n"
  },
  {
    "id" : "55c85b80-7295-47c9-b8c6-484f807cf712",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6a5ccd8-14e3-4084-ac2a-f98d4cdfaa50",
        "parentId" : null,
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "If you are always appending to ref[0], then why do you need the 2D array?\n",
        "createdAt" : "2016-05-11T22:31:27Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +157,161 @@func (cache *TreeCache) appendValues(recursive bool, ref [][]interface{}) {\n\tfor _, value := range cache.Entries {\n\t\tref[0] = append(ref[0], value)\n\t}\n\tif recursive {"
  },
  {
    "id" : "dbc3a707-1f42-4779-b18e-3a17ce3e800a",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e4af566-efa5-46c2-be44-fcf87accbd38",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This warrants a generous description of what this abstraction is doing, and the place where we instantiate it should describe WHY we are doing it.\n",
        "createdAt" : "2016-05-17T18:27:11Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +23,27 @@)\n\ntype TreeCache struct {\n\tChildNodes map[string]*TreeCache\n\tEntries    map[string]interface{}"
  },
  {
    "id" : "1a3c225d-2453-4d8a-beeb-fa5ae0b4116d",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b5ca53f-b786-4516-8a28-3766ad51bc7f",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "do you want `interface{}` here or `object` (since you defined that above)\n",
        "createdAt" : "2016-05-17T18:28:08Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +25,29 @@type TreeCache struct {\n\tChildNodes map[string]*TreeCache\n\tEntries    map[string]interface{}\n}\n"
  },
  {
    "id" : "814bdf9c-99f6-44dc-8783-750bb8bd5259",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "22dfc21c-170a-4d2b-b120-fdd054c445fa",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "do you want interface{} here or object (since you defined that above)\n",
        "createdAt" : "2016-05-17T18:28:24Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "12eca683-5749-4140-aedb-7ebe5e98ccb5",
        "parentId" : "22dfc21c-170a-4d2b-b120-fdd054c445fa",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "removed object type def\n",
        "createdAt" : "2016-05-19T23:18:40Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +31,35 @@\treturn &TreeCache{\n\t\tChildNodes: make(map[string]*TreeCache),\n\t\tEntries:    make(map[string]interface{}),\n\t}\n}"
  },
  {
    "id" : "66ffb8d0-e085-465c-a2a6-874f517cf56a",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7976b5e-863a-4758-aca7-a21127bf048a",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "function comment please, since this is a public symbol (though it probably doesn't need to be)\n",
        "createdAt" : "2016-05-17T18:28:57Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +28,32 @@}\n\nfunc NewTreeCache() *TreeCache {\n\treturn &TreeCache{\n\t\tChildNodes: make(map[string]*TreeCache),"
  },
  {
    "id" : "e1935d90-48da-4cf5-a89e-c2cc863b10e7",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11d4746c-16a9-4a21-ad27-b6f00b449c28",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Isn't this a loop?  I think you want to add all childNodes of node, not node itself.  Consider when path is just `[\"*\"]` - first time through you find the root of your tree, you match \"*\" so you add the root of the tree back onto the list.  a unit test would have caught that\n",
        "createdAt" : "2016-05-17T19:18:14Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +86,90 @@\t\t\tfor _, node := range nodesToExplore {\n\t\t\t\tif subpath == \"*\" {\n\t\t\t\t\tnextNodesToExplore = append(nextNodesToExplore, node)\n\t\t\t\t} else {\n\t\t\t\t\tif val, ok := node.Entries[subpath]; ok {"
  },
  {
    "id" : "20df1564-9062-4d2c-81e6-f485b5c63d83",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6c92a6d-e7e0-4ef1-8d2e-e334f16e7614",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "comment that this assumes the cache is locked\n",
        "createdAt" : "2016-05-20T01:21:40Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "1c560670-dcd3-4aa6-9757-6c2bdddea747",
        "parentId" : "a6c92a6d-e7e0-4ef1-8d2e-e334f16e7614",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "with the lock outside, it should be ok.\n",
        "createdAt" : "2016-05-20T20:54:33Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +55,59 @@}\n\nfunc (cache *TreeCache) getSubCache(path ...string) *TreeCache {\n\tchildCache := cache\n\tfor _, subpath := range path {"
  },
  {
    "id" : "cc378e1c-5137-4521-b691-b39ab0a15e14",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15ff21ed-f1b3-4dbc-9eb6-88d39ea1dcfb",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'd rather do the locking outside of this function and document that this assumes it is called with the lock held.\n",
        "createdAt" : "2016-05-20T01:24:59Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e75ca138-e256-4608-825f-68e80bd0acc8",
        "parentId" : "15ff21ed-f1b3-4dbc-9eb6-88d39ea1dcfb",
        "authorId" : "0970b119-085d-41b4-8f33-e10409965eba",
        "body" : "yes, thats fine. It means I need to have a decorator struct which wraps the non-thread-safe functions on the cache strut. \n",
        "createdAt" : "2016-05-20T20:55:09Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "0970b119-085d-41b4-8f33-e10409965eba",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +66,70 @@}\n\nfunc (cache *TreeCache) setSubCache(key string, subCache *TreeCache, path ...string) {\n\tnode := cache.ensureChildNode(path...)\n\tnode.ChildNodes[key] = subCache"
  },
  {
    "id" : "acbfa50c-1707-4d8b-9c28-3a8c2c3851ad",
    "prId" : 23930,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d543ec79-ffbc-400d-a062-3cf9bd034763",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I'd rather do the locking outside of this function and document that this assumes it is called with the lock held.\n",
        "createdAt" : "2016-05-20T01:26:41Z",
        "updatedAt" : "2016-05-21T06:25:35Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ada2170a320b4bee15d6b1d372d0f9e0cadb838",
    "line" : null,
    "diffHunk" : "@@ -1,1 +77,81 @@}\n\nfunc (cache *TreeCache) getValuesForPathWithWildcards(path ...string) []interface{} {\n\tretval := []interface{}{}\n\tnodesToExplore := []*TreeCache{cache}"
  }
]
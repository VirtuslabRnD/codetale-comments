[
  {
    "id" : "77cdb577-eaf2-445f-804c-30a344f77bdf",
    "prId" : 36775,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36775#pullrequestreview-8963753",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58d08436-3fa9-4cb1-90c5-309af99a656f",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I should have been clearer - the pattern we're recommending for most cases is to read a single configmap key as a JSON blob, and parse that into a native struct, rather than a bunch of keys.\n\nThis lets you build arbitrary config structure, with lists and maps and types and whatnot.  That JSON blob is the one that should hold typemeta. \n",
        "createdAt" : "2016-11-17T05:46:58Z",
        "updatedAt" : "2016-11-19T00:12:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "32cdb32b-254e-4b23-a4d2-a028e9920ff2",
        "parentId" : "58d08436-3fa9-4cb1-90c5-309af99a656f",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "but let's do what we need to get this wrapped and in.  we can always come back.\n",
        "createdAt" : "2016-11-17T05:47:37Z",
        "updatedAt" : "2016-11-19T00:12:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "19be1d250426ddf9842d9d66c69f91df05b8b28f",
    "line" : 188,
    "diffHunk" : "@@ -1,1 +186,190 @@\nfunc (sync *kubeSync) updateFederations(cm *api.ConfigMap, config *Config) (err error) {\n\tif flagValue, ok := cm.Data[\"federations\"]; ok {\n\t\tconfig.Federations = make(map[string]string)\n\t\tif err = fed.ParseFederationsFlag(flagValue, config.Federations); err != nil {"
  },
  {
    "id" : "0192b15b-5bf0-4bde-8ba0-1f150e3b7af8",
    "prId" : 36775,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/36775#pullrequestreview-9139938",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd1c2fb5-9a7f-4cbc-a27d-5ddcd0eec3f8",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "It might be simpler to just poll the apiserver every 10 seconds or so.  The code becomes much simpler, if you can justify being a little bit stale...\n",
        "createdAt" : "2016-11-17T05:49:45Z",
        "updatedAt" : "2016-11-19T00:12:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "d55f462f-fb57-4a8c-bb55-b066b3c7fd50",
        "parentId" : "bd1c2fb5-9a7f-4cbc-a27d-5ddcd0eec3f8",
        "authorId" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "body" : "I wrote the code both ways and the complexity is not much different. Using the official Kubernetes watcher API has build in support for backoffs due to error etc.\n",
        "createdAt" : "2016-11-17T23:12:05Z",
        "updatedAt" : "2016-11-19T00:12:24Z",
        "lastEditedBy" : "b714f738-aa05-4f49-a624-eaaf3e0cbb70",
        "tags" : [
        ]
      }
    ],
    "commit" : "19be1d250426ddf9842d9d66c69f91df05b8b28f",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +55,59 @@\t}\n\n\tlistWatch := &cache.ListWatch{\n\t\tListFunc: func(options api.ListOptions) (runtime.Object, error) {\n\t\t\toptions.FieldSelector = fields.Set{\"metadata.name\": name}.AsSelector()"
  }
]
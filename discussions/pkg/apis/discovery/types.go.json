[
  {
    "id" : "9097df8e-7886-489f-9ceb-8d1269af6ae3",
    "prId" : 99522,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99522#pullrequestreview-604880299",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c54c985-baf7-4821-96f1-8c1eeaabe629",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Add a `+featureGate=<gate>`  tag",
        "createdAt" : "2021-03-05T06:29:44Z",
        "updatedAt" : "2021-03-08T23:38:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "2e6b1565-1ef4-4d44-a59e-dae257a18667",
        "parentId" : "4c54c985-baf7-4821-96f1-8c1eeaabe629",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Updated, thanks!",
        "createdAt" : "2021-03-05T07:51:44Z",
        "updatedAt" : "2021-03-08T23:38:14Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f07be06a19918910004b024af084123ae88d88cd",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +104,108 @@\t// consumed.\n\t// +featureGate=TopologyAwareHints\n\t// +optional\n\tHints *EndpointHints\n}"
  },
  {
    "id" : "e5447e67-fb28-4bb8-b038-e722ba535c6a",
    "prId" : 99522,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/99522#pullrequestreview-604880370",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d59a414d-08c4-4004-8b26-e154f5e99f8c",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Document limit of 8 zones",
        "createdAt" : "2021-03-05T06:32:04Z",
        "updatedAt" : "2021-03-08T23:38:14Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "8a2d74f3-7943-41df-b104-d8212ff6ca96",
        "parentId" : "d59a414d-08c4-4004-8b26-e154f5e99f8c",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Updated, thanks!",
        "createdAt" : "2021-03-05T07:51:51Z",
        "updatedAt" : "2021-03-08T23:38:14Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f07be06a19918910004b024af084123ae88d88cd",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +135,139 @@// EndpointHints provides hints describing how an endpoint should be consumed.\ntype EndpointHints struct {\n\t// forZones indicates the zone(s) this endpoint should be consumed by to\n\t// enable topology aware routing. May contain a maximum of 8 entries.\n\tForZones []ForZone"
  },
  {
    "id" : "4f26b93e-a2c8-4277-8375-e95f1a433497",
    "prId" : 92968,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/92968#pullrequestreview-524754673",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "parentId" : null,
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Probably not a good idea, but could we update the `Terminating` condition to mean both `Terminating` and `Ready`? We would simply exclude endpoints that were both terminating and not ready in this list.",
        "createdAt" : "2020-10-31T00:07:56Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "a25ab677-83f7-40f1-85a2-80d1f3aabe67",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "If we did that, why do we have the Ready bit at all?",
        "createdAt" : "2020-10-31T05:55:09Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ded90b9e-c8a5-4ba3-856b-daf67cb955f8",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I guess I was just trying to see if we could survive without the `Serving` bool. Here's how I understand the rationale for that field:\r\n\r\n- Adding the Terminating condition means the endpoints will stick around longer than previously.\r\n- To make that relatively safe, we need the existing `Ready` field to be false.\r\n- Consumers want to know if an endpoint is `Terminating` but still able to handle traffic.\r\n- Our solution to that was to add a `Serving` field that would be true even if an endpoint was `Terminating`.\r\n\r\nMy question is if we can have a single condition that indicates that an endpoint is terminating and can handle traffic. My argument is that consumers likely don't care about endpoints that are terminating and can't handle traffic so we could just drop them from the list. (I'm not actually sure on that part, maybe consumers do care about those endpoints).\r\n\r\nThis would be a pretty simple approach:\r\n\r\n- `Ready` remains unchanged\r\n- New `Terminating` condition to indicate that an endpoint is terminating but still able to handle traffic. \r\n\r\nMaybe the actual name of the condition might need to be clearer, but if we can safely say that no one cares about the `Terminating=true,Serving=false` condition, it seems unnecessary to add a second condition here.",
        "createdAt" : "2020-10-31T06:52:47Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "e9da91e3-30ba-4da5-b218-b1cccf9697c4",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> My argument is that consumers likely don't care about endpoints that are terminating and can't handle traffic so we could just drop them from the list. (I'm not actually sure on that part, maybe consumers do care about those endpoints).\r\n\r\nWhile I agree that generally we won't care too much about {!R,T} endpoints, I think it would still be useful to allow consumers to check for this state. In this thread https://github.com/kubernetes/enhancements/pull/1607#discussion_r412581130 I think we agreed that while it's not very common, it's may still be useful for consumers (e.g. kube-proxy) to track this state so we shouldn't disallow it.",
        "createdAt" : "2020-11-01T03:08:59Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "ce69be97-0ab1-46aa-8847-81de130693c2",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Re-reading the discussion linked, we did agree that we should explore all 4 quadrants.\r\n\r\n@robscott if `Ready` means \"serving && !terminating\" and `Terminating` means \"serving && terminating\", then `!Ready && !Terminating` means \"!serving\" but that's all we know for sure. There's no representation of \"!serving && terminating\", right? \r\n\r\nIt seems maybe more useful to flatten all Terminating into one.  So `Ready` means \"serving && !terminating\" and `Terminating` means \"terminating\".  It seems to me (with no real data) that pods will catch SIGTERM and either stop accepting or keep accepting, but that all pods in a set will do the same thing.  Thus, it seems unlikely that we will have a mix of serving and !serving all terminating, or at least it won't last long.  But even as I type that out, it's all async, so we WILL have that mix, but I think it will be fleeting, and it will either settle at \"serving && terminating\" or move from towards \"!serving && terminating\".  It seems unlikelty to move from \"!serving\" -> \"serving\".\r\n\r\nFor the original `Local` use-case, does this matter?  If I have an ingress LB daemonset, the difference between serving and not serving isn't going to matter much (generally 1 instance). \r\n\r\nSo I could be convinced to ignore serving within the set of terminating.  It's not what we said before. - is the one less bit and somewhat more cognitive load worhtwhile?",
        "createdAt" : "2020-11-02T18:39:41Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "dcb14737-5bc5-4a17-aa14-d40daba45e08",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Thanks for the context here, it was helpful to read through the previous conversation around this. One of the points that stood out to me was:\r\n\r\n> Sending traffic to any pod that fails readiness seems like we're breaking API contract. I'm personally in favor of only falling back to {R, T} endpoints\r\n\r\nThat makes it sound like there's no value in tracking endpoints that are `!Ready && Terminating`. As a variation of what Tim said above, maybe we could use 2 conditions that were defined as the following:\r\n\r\n`ready`: `serving && !terminating`\r\n`draining`: `serving && terminating`\r\n\r\nThose conditions should never be true at the same time. I'm not sure that `draining` is the appropriate term here, I just wanted to throw out an alternative to `terminating` since that may be too broad for what I'm suggesting.",
        "createdAt" : "2020-11-02T19:27:31Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "dfa3dbd5-afce-4320-85cf-9c8427b00ada",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Reposting Tim's comment https://github.com/kubernetes/kubernetes/pull/92968#issuecomment-720684922 cause email replies from Github doesn't seem to recognize threads:\r\n\r\n> So the implied third state here is `!Ready && !Draining` which can only\r\nmean !serving, regardless of terminating or not.\r\n\r\n> This is a little different than the discussion, but I am not sure it is\r\nmeaningful.  Andrew?\r\n\r\n",
        "createdAt" : "2020-11-02T20:13:17Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "6b1798c8-58d2-473e-8018-f2b059789bd9",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "While I still think there's no real use-case yet for tracking {!R,T} endpoints, I don't think it hurts to leave room in the API to track it. If we went with `ready` and `draining` but in the future we wanted to support {!R, T}, we would have to add two additional conditions (total 4), to not breaking the existing meaning of `draining`.\r\n\r\nI also think we want each condition to mean one thing and not have overlapping meaning with respect to terminating state. In an ideal scenario Ready refers to the pod's readiness and Terminating just refers to terminating, but because that's breaking I think the next best thing is to leave `Ready` as-is and add `serving` and `terminating`. Whether we actually account for {!R,T} in kube-proxy is a separate discussion I think.",
        "createdAt" : "2020-11-02T20:23:46Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "2b934a79-3493-43f1-beca-64ab11eea6d2",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : ">  If we went with ready and draining but in the future we wanted to support {!R, T}, we would have to add two additional conditions (total 4), to not breaking the existing meaning of draining.\r\n\r\nI think `draining` as proposed refers to a `{R, T}` state. If in the future we wanted to add a state for `{!R, T}`, I think that could be accomplished with one additional condition (`UnhealthyTerminating` or similar). That condition would also only be true if both `Ready` and `Draining` were false. I agree with you that a condition like that is probably not useful though.\r\n\r\nIt could actually be easy to explain (and understand) `ready` and `draining`, although this may be an oversimplification:\r\n\r\n`ready`: An endpoint is ready for new connections and requests.\r\n`draining`: An endpoint is closing out existing connections. \r\n\r\nOn the other hand, I think a third `serving` condition may add unnecessary complexity at this point.",
        "createdAt" : "2020-11-02T20:43:16Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "eefb5f30-3524-4db4-a440-235c00bfb2d3",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> draining: An endpoint is closing out existing connections.\r\n\r\nI think the misleading thing here is that an endpoint could be closing existing connections AND not be ready. In the context of the kube-proxy issue we're trying to address, `Draining` could mean two things:\r\n\r\n1. an endpoint doesn't receive traffic and is closing out existing connections.\r\n2. an endpoint is used as a fallback endpoint if no other endpoints exists.  \r\n\r\nI think 2. will be difficult to articulate with only a `Draining` condition.",
        "createdAt" : "2020-11-02T21:00:21Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "3fcf27cb-c7f4-4b92-beb1-bf1cab9ffaf1",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "> no real use-case yet for tracking {!R,T} endpoints\r\n\r\nI'd amend that - there's no real use-case for tracking {!R,T} distinct from {!R,!T}.  Rob's proposal lumps those together.  If we did need to distinguish between them, we could add an \"Unready\" or \"Failing\" condition (or a better name) that explicitly means {!R, !T} (IOW - should be ready but isn't).  That leaves the \"no conditions\" state as implicitly {!R, T}, though I think we'd want to just call that unknown.\r\n\r\nWe're dangerously close to defining a state machine, though.\r\n\r\n",
        "createdAt" : "2020-11-02T21:06:33Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "bb94feda-677e-4533-a2c6-3ed1b2e01aa5",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Thinking out loud... I'll go out on a limb a bit - it can be \"compatible\" to split an existing set of endpoints by changing the meaning of conditions or adding new conditions as long as we believe the change is safe (won't cause things to break).\r\n\r\nSimpy adding `terminating` is NOT safe because it first *expands* the set of endpoints to include dangerous ones (endpoints that are imminently going away) and then segments them.  As discussed elsewhere, any client who was looking just at `ready` would suddenly see more endpoints and not safe ones.\r\n\r\nThat said, once we have expanded the endpoints to \"all\", we can subset.  For example, if we wanted to distinguish pods that are !ready from pods that are just starting up, we could (in theory) track whether a pod has EVER been ready and, if not call it \"starting\", thereby subsetting the {!R} set.  Again, this sounds state-machiney, but it's just an example.  That would be a \"safe\" change because clients who were looking for !R would not be getting anything new.\r\n\r\nI am trying to find other hypotheticals that would make this discussion more concrete.  Here's one.  Suppose we define a new pod-condition \"flapping\" - the pod is flipping ready/unready too often.\r\n\r\nHow would you think of that?\r\n",
        "createdAt" : "2020-11-02T21:34:23Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "49c54c5a-69b1-47b3-9e38-ea20151ca26c",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "I feel that `flapping` and `draining` are describing behaviors instead of conditions. Maybe they are the same things just at different levels of granularity.  A consumer of this API should be able to extract `flapping` by seeing the `serving` condition flip between `true` and `false` repeatedly. In the same way, `draining` should be extracted from checking `terminating` and `serving`. To me at least, EndpointSlice is the lowest denominator here (assuming it is too expensive to watch all pods) so it should try not to be prescriptive to behaviours and only describe states that are deterministic with well defined definitions.  ",
        "createdAt" : "2020-11-02T23:03:59Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "c88df0b8-dd3b-4176-9623-e0c55f811f4a",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "> Draining could mean two things:\r\n> 1. an endpoint doesn't receive traffic and is closing out existing connections.\r\n> 2. an endpoint is used as a fallback endpoint if no other endpoints exists.\r\n\r\nThat's a fair point, maybe draining isn't the right word here. Maybe there's another word that can communicate the `{R,T}` state?\r\n\r\n> there's no real use-case for tracking {!R,T} distinct from {!R,!T}\r\n\r\nGood clarification, thanks!\r\n\r\n> That leaves the \"no conditions\" state as implicitly {!R, T}, though I think we'd want to just call that unknown.\r\n\r\nWouldn't unknown/empty map more naturally to all conditions being false? \r\n\r\n> Suppose we define a new pod-condition \"flapping\" - the pod is flipping ready/unready too often.\r\n\r\nI'd imagine that we would set `ready` to false and optionally add a new `flapping` condition that would also only be true if every other condition for the endpoint was false.",
        "createdAt" : "2020-11-02T23:08:51Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "be64a5da-d5dd-4b14-849a-15e6a50fb44d",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "> I feel that flapping and draining are describing behaviors instead of conditions. \r\n\r\nI'm open to different names here, I just want to avoid adding two new conditions when we only actually care about one very specific combination `{R, T}`. What if we need to add some additional condition in the future that relies on pod readiness being expanded or contracted in some way? Would we need a new condition like `serving` for that expansion as well?",
        "createdAt" : "2020-11-02T23:11:38Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "a435837e-aa14-4c69-b73d-dbfe53b3c381",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "Really on the fence about this one :thinking: \r\n\r\nWhile I do think a `serving` condition (or similar) is generically useful to consumers, I agree that having to add two new conditions is not ideal. My gut tells me that consumers would want a way to track pod readiness independent of anything else but I don't really have good evidence or use-cases to back this up. Since we are going to alpha gate this for one release anyways I think I'm okay to stick with one condition for now since it'll be easier to transition to two conditions if we change our minds later.\r\n\r\nRegarding naming of the condition, I thought about both `draining` and `cordoning` but both I feel are inaccurate because they're prescriptive to the behavior consumers _should_ be doing as opposed to describing the endpoint status and letting consumers do what they wish with it. I'm thinking the best name for this condition is just `readyTerminating`. Thoughts?     ",
        "createdAt" : "2020-11-04T15:00:08Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      },
      {
        "id" : "1966a6ee-5f66-4a5c-a9bf-391088e1bb5f",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I'm not 100% sold on that name, but I don't hate it. I think `readyTerminating` makes sense if EndpointSlices were only ever going to be used to reference Pods. Since we want this to be a more generic API, I think a more generic term here might be helpful. I still don't mind `draining` but can see the hesitation there as it could be seen as too prescriptive. Naming things is hard. ",
        "createdAt" : "2020-11-05T21:16:06Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "f13c6fa3-5568-4364-9621-516b28da32fb",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : ">  Since we are going to alpha gate this for one release \r\n\r\nAt least.  If we get it wrong it could be several.\r\n\r\nI really don't like the evolution towards N mutually-exclusive state-conditions.  I think the right answer at this layer is orthogonal.\r\n\r\nWhat about \"up\" and \"terminating\" if we don't like Serving?",
        "createdAt" : "2020-11-05T23:02:39Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "902ee15f-632f-421d-8fbe-479c1326166b",
        "parentId" : "79211c9e-2242-4b97-9356-bc8c04539b38",
        "authorId" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "body" : "> I really don't like the evolution towards N mutually-exclusive state-conditions. I think the right answer at this layer is orthogonal.\r\n\r\nI agree.\r\n\r\n> What about \"up\" and \"terminating\" if we don't like Serving?\r\n\r\nI also suggested here https://github.com/kubernetes/kubernetes/pull/92968#issuecomment-720710258 to use `ready` and `readiness`. But I think @robscott's concern is less about naming (up vs serving) but more so that we are adding two conditions for one use-case. ",
        "createdAt" : "2020-11-05T23:34:10Z",
        "updatedAt" : "2020-11-06T00:19:09Z",
        "lastEditedBy" : "6dd71efb-88b1-4bb0-b30a-0df658362f14",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cf19e5fb78587cc1eac9b69a9e935821410c335",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +127,131 @@\t// terminating indicates that this endpoint is terminating. A nil value indicates an\n\t// unknown state. Consumers should interpret this unknown state to mean that the\n\t// endpoint is not terminating.\n\t// +optional\n\tTerminating *bool"
  },
  {
    "id" : "4fbaf5a6-5164-486e-bcb7-97feeaa568ae",
    "prId" : 84971,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/84971#pullrequestreview-315214080",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d70183c-6940-4ddf-b603-c6b2155d6588",
        "parentId" : null,
        "authorId" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "body" : "Let what `api-reviewers` will comeback with. on deprecating in ALPHA state apis ",
        "createdAt" : "2019-11-08T23:26:50Z",
        "updatedAt" : "2019-11-12T17:04:31Z",
        "lastEditedBy" : "0c76e20f-41a5-4725-b3c3-d5b6cae89641",
        "tags" : [
        ]
      },
      {
        "id" : "c590ce78-1030-4519-ba0d-762d86db0d94",
        "parentId" : "8d70183c-6940-4ddf-b603-c6b2155d6588",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I prefer to deprecate if we can afford to do so.",
        "createdAt" : "2019-11-11T19:18:23Z",
        "updatedAt" : "2019-11-12T17:04:31Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ec8436dc-f7a6-411d-bfd5-5ebb113a682e",
        "parentId" : "8d70183c-6940-4ddf-b603-c6b2155d6588",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "as long as we don't allow the deprecated value to be created or added via the beta EndpointSlice API, marking as deprecated in alpha is fine",
        "createdAt" : "2019-11-11T21:44:51Z",
        "updatedAt" : "2019-11-12T17:04:31Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "74866cc2-228a-409d-b2dc-7afe8db7f132",
        "parentId" : "8d70183c-6940-4ddf-b603-c6b2155d6588",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "thanks for clarifying!",
        "createdAt" : "2019-11-11T23:21:25Z",
        "updatedAt" : "2019-11-12T17:04:31Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0fa9981e0106d7f0d6f9c88fc49d4cdf779c95c1",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +62,66 @@\t// and IPv6 adddress types. New resources with this address type will be\n\t// considered invalid. This will be fully removed in 1.18.\n\t// +deprecated\n\tAddressTypeIP = AddressType(\"IP\")\n\t// AddressTypeIPv4 represents an IPv4 Address."
  },
  {
    "id" : "b2a5d882-6c92-44a5-b34b-b3663a48cd33",
    "prId" : 83815,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/83815#pullrequestreview-313715212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "parentId" : null,
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Need to have more detail comment about the format and default values. Plus examples",
        "createdAt" : "2019-10-14T20:51:02Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "e85c99f4-cd87-4468-959b-fd47223850ca",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "@freehan @howardjohn what formats should we allow here? I think the label validation that John added is a good start here. Should we limit this to a length shorter than the current 63 characters we get from that validation? Would a protocol ever include non alphanumeric characters? Should we enforce all uppercase or lowercase values so we don't get different `https` and `HTTPS` values? I think we agreed that the default value is nil/there isn't one, right?\r\n\r\nMy naive thought would be to leave the upper limit at 63, require alphanumeric characters only, and require uppercase letters, but I'm very open to other ideas.",
        "createdAt" : "2019-10-17T18:23:57Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "0c6fad8c-dcc6-4873-89b6-75a06084197a",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "@thockin Any thoughts on how we should limit/validate AppProtocol?",
        "createdAt" : "2019-10-17T18:31:02Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "c9c1ce11-59aa-4a40-bda9-03915491001f",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "82028e42-35a4-463f-89f8-e989e3402f51",
        "body" : "My thoughts:\r\n* Length limit - 63 seems reasonable, I cannot imagine needing a longer protocol really and its pretty standard across Kubernetes\r\n* Character set: I assume values like `mycompany.com/our-custom-protocol` are not something that would really be used here. If that is the case, all uppercase sounds good. We may also want to support a `-`?\r\n\r\nSome examples of things someone might want to set with various constraints:\r\n`DNSOVERHTTPS`, `DNS-OVER-HTTPS`, `DNS-Over-HTTPS`, `dns-over-https`\r\n`HTTP`, `http`\r\n`MYSQL`, `MY-SQL`, `mySql`, `mysql`\r\n\r\nBased on this, I think `-` is required, but I don't think there is value to mixing cases.\r\n\r\nAnd agree, default value is `nil`",
        "createdAt" : "2019-10-22T18:25:17Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "82028e42-35a4-463f-89f8-e989e3402f51",
        "tags" : [
        ]
      },
      {
        "id" : "3719fdd5-8699-484b-8873-9483fc7269ba",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think there are 2 options:\r\n\r\n1) Treat these as constants.  Constants start with capital letters, acronyms are in caps.  e.g. `HTTP`, `DNSOverHTTPS`, `MySQL`, `MyCustomProtocol`\r\n\r\n2) Treat this as a label key.  Un-prefixed names would be reserved for standardized values, prefixed names would be for non-standard values.  E.g. `http`, `dns-over-https`, `mysql`, `mycompany.com/my-custom-protocol`\r\n\r\nI don't think any other options make sense.  Between those two, I don't feel VERY strongly - I have a slight lean toward label-style, but it's a little weird if we expect the vast majority of use-cases to be the non-prefixed.  Which do we expect more of?",
        "createdAt" : "2019-10-22T23:05:23Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "45e44740-8fc2-4988-9fca-ddb4d6c3c640",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "Very interesting. How would we validate that second approach? Would we have a whitelist for anything without a domain prefix and then anything with a prefix like that is valid? Or do we just provide guidelines such as 1 or 2 and only enforce something as simple as max/min length and characters allowed? Any kind of whitelist here would be challenging to change post-alpha assuming it would be similarly [complex as adding addressTypes](https://github.com/kubernetes/kubernetes/pull/84091#discussion_r338268424).",
        "createdAt" : "2019-10-24T00:45:41Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "3c00320a-74a9-4066-a6c4-5ffa1f547c12",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "82028e42-35a4-463f-89f8-e989e3402f51",
        "body" : "I am not sure that standardized values is the best approach here. There are a lot of protocols out there (wikipedia [lists about 50](https://en.wikipedia.org/wiki/Application_layer) and there are of course many more less standardized one). I think it would be hard to hit the sweet spot of having the list of \"standard\" protocols not too small or too large. It would also be a bit awkward UX to be able to specify `MySQL` but then I have another database and now I have to specify `postgresql.org/psql` or something. It seems a bit arbitrary. What do you think?\r\n\r\nSince the protocol is given meaning by the application consuming it, I think just allowing arbitrary strings here makes the most sense.\r\n\r\nI don't have any opinion on the exact character set here though, as long as its not just upper case letters (`DNSOVERHTTPS` is awkward)",
        "createdAt" : "2019-10-25T00:16:36Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "82028e42-35a4-463f-89f8-e989e3402f51",
        "tags" : [
        ]
      },
      {
        "id" : "4550218e-f8c4-41f7-aa4b-2668e3d6025e",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I agree with that. It would be hard to settle on a set of standard app protocols here. Maybe instead it would make sense to have actual validation be limited to a simple character set and max length, but provide guidance on how protocols should be represented. As an example, a potential comment could look like this:\r\n\r\n```\r\nThe application protocol for this port.\r\nMay contain alphanumeric characters as well as `.`, `-`, and `/`.\r\nMust be no longer than 63 characters.\r\nThe following application protocols should consistently be represented as:\r\n- HTTP\r\n- HTTPS\r\n- DNS\r\n...\r\n```\r\n\r\nI don't know, just throwing something out there.",
        "createdAt" : "2019-10-25T18:15:48Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "62b343a3-0f48-4a73-b2c1-f12c73347a22",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "82028e42-35a4-463f-89f8-e989e3402f51",
        "body" : "```\r\nThe application protocol for this port.\r\nMay contain alphanumeric characters as well as `.`, `-`, and `/`.\r\nMust be no longer than 63 characters.\r\nExamples: HTTP, HTTPS, TCP\r\n```\r\n\r\nWould something like that make sense? It still feels a little weird to have a list of \"blessed\" protocols, even if its just in the docs. I don't care too much either way though",
        "createdAt" : "2019-10-25T22:41:13Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "82028e42-35a4-463f-89f8-e989e3402f51",
        "tags" : [
        ]
      },
      {
        "id" : "8641c819-ce12-4b10-a815-b09a41344ede",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "If the intention is to allow semi-arbitrary strings, the precedent that jumps to mind is Condition Reason:\r\n\r\n```\r\n    Reason string `json:\"reason,omitempty\" protobuf:\"bytes,5,opt,name=reason\"`\r\n    // Human-readable message indicating details about last transition.\r\n    // +optional\r\n    Message string `json:\"message,omitempty\" protobuf:\"bytes,6,opt,name=message\"`             \r\n```\r\n\r\nIn other words, comment that the convention is CamelCase and then don't validate it very much.  Validating that it is less than 63 seems appropriate and as for character set, maybe ASCII?\r\n\r\nAlternatively, there *is* a spec for this: https://tools.ietf.org/html/rfc6335\r\n\r\nHow about we blend ideas.  Somethng like:\r\n\r\n```\r\nThis field follows standard Kubernetes label syntax.  Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names).  Non-standard protocols should use prefixed names.\r\n```\r\n\r\nWhat do you think?",
        "createdAt" : "2019-11-04T22:53:09Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "e53173f9-0a1c-4214-b24b-c0718873d412",
        "parentId" : "2552b0d9-e15b-42eb-86a6-af377ea2a3af",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I think that strikes a great balance here. There's only so much that can be validated, but this provides clear guidance.",
        "createdAt" : "2019-11-08T00:03:05Z",
        "updatedAt" : "2019-11-08T17:22:59Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "d00794ca60bb94cc466f9f763d95466522bc01b9",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +131,135 @@\t// interpreted in the context of the specific consumer.\n\tPort *int32\n\t// The application protocol for this port.\n\t// This field follows standard Kubernetes label syntax.\n\t// Un-prefixed names are reserved for IANA standard service names (as per"
  },
  {
    "id" : "312a5ce2-c25e-4abb-898e-142d46e0d28d",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-274576365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55be2992-2a1a-4830-931c-1af67f63b215",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "minor: put structs in the order they are used.  EPSlice uses EPPort and TargetType before EP.\r\n\r\nStoring in order makes it easier to read.",
        "createdAt" : "2019-08-13T22:07:17Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +49,53 @@\tPorts []EndpointPort\n}\n\n// AddressType represents the type of address referred to by an endpoint.\ntype AddressType string"
  },
  {
    "id" : "25fd1539-0eb0-45f2-8cab-28b643ec4a9a",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-274576365",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0fd28954-6254-4057-8ffc-2195a8bb0c57",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I am not super keen on \"conditions\" here, given the nearly-standard *Conditions types.  \"Status\" would be bad.  Other ideas?",
        "createdAt" : "2019-08-13T22:37:11Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@\tAddresses []string\n\t// conditions contains information about the current status of the endpoint.\n\tConditions EndpointConditions\n\t// hostname of this endpoint. This field may be used by consumers of\n\t// endpoints to distinguish endpoints from each other (e.g. in DNS names)."
  },
  {
    "id" : "df3753d2-7665-4d7e-931f-878b1b5578c2",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-275718223",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f48f86f3-206c-457d-b4e9-6e7e1ef011aa",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Are we going to require that all ports have unique proto+numbers, or are we OK having two entries here with TCP 53 (for example).  Let's define our intention and if we intend that to be unique, validate it.  Corner cases, corner cases..  It seems weird to have duplicates, but I don't know if we should disallow it - can you think of any downstream user of endpoints who might be broken if we allow it?",
        "createdAt" : "2019-08-15T15:52:58Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3ca66b16-0636-45df-ac96-551db23a96ed",
        "parentId" : "f48f86f3-206c-457d-b4e9-6e7e1ef011aa",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "I feel like the port number may not be unique right? Since we allow different service port map to the same target port.\r\n\r\nsvcPort1 -> 80\r\nsvcPort2 -> 80",
        "createdAt" : "2019-08-15T18:28:33Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "04de0d3b-d4ce-4a5a-bf0e-a2a48fd9d615",
        "parentId" : "f48f86f3-206c-457d-b4e9-6e7e1ef011aa",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "good point.",
        "createdAt" : "2019-08-15T23:38:21Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +47,51 @@\t// +optional\n\t// +listType=atomic\n\tPorts []EndpointPort\n}\n"
  },
  {
    "id" : "5a47e6ab-6b5a-4cfd-a0f1-a5fbc2afce81",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-276056626",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4f935877-67bb-42e0-8d88-84ce5bfed1e0",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Do we want to specify a limit to number of Endpoints in a slice?  We never get another chance.  1000?  2000?  5000?\r\n\r\n@freehan ",
        "createdAt" : "2019-08-15T17:08:11Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5d9dad08-100d-4824-8696-a47f140b68ba",
        "parentId" : "4f935877-67bb-42e0-8d88-84ce5bfed1e0",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "It will hit the object storage limit naturally. Which means it is around 5000 in normal cases. \r\n\r\nSo we might as well set it to 1000?",
        "createdAt" : "2019-08-15T18:24:14Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "c4b739b5-0d7e-413a-8ebf-3f01612588bf",
        "parentId" : "4f935877-67bb-42e0-8d88-84ce5bfed1e0",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "1000 seems reasonable.  We can lift limits if we need to.  Let's define it and validate it.  We have `field.TooLong` but that's not right.  Maybe we want to add `field.TooMany()` ?",
        "createdAt" : "2019-08-15T23:34:53Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "5c0a58bd-2227-4d07-9531-3a397abc7a61",
        "parentId" : "4f935877-67bb-42e0-8d88-84ce5bfed1e0",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I added field.TooMany() in my latest commit, hopefully it makes sense.",
        "createdAt" : "2019-08-16T16:44:50Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      },
      {
        "id" : "3f0b08ac-435b-4170-9ba1-084282a310b0",
        "parentId" : "4f935877-67bb-42e0-8d88-84ce5bfed1e0",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "(1000 is also set as the limit here now)",
        "createdAt" : "2019-08-16T16:48:53Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +39,43 @@\t// include a maximum of 1000 endpoints.\n\t// +listType=atomic\n\tEndpoints []Endpoint\n\t// ports specifies the list of network ports exposed by each endpoint in\n\t// this slice. Each port must have a unique name. When ports is empty, it"
  },
  {
    "id" : "1f001205-2159-489b-beef-e32a8c6d8be0",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-276056306",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4087a8a5-f000-4d9f-8b6e-e0fdacab018d",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "do we want to specify a limit to number of ports?  100?  200?  500?",
        "createdAt" : "2019-08-15T17:08:27Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "8be9dde1-f1f4-48cb-afd8-d88340b369d7",
        "parentId" : "4087a8a5-f000-4d9f-8b6e-e0fdacab018d",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "This needs to match services though. Without port range, I would imagine many people specifying many ports. ",
        "createdAt" : "2019-08-15T18:26:03Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "ff742c53-ad1e-4483-a26a-7550e22579b6",
        "parentId" : "4087a8a5-f000-4d9f-8b6e-e0fdacab018d",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "There's a practical limit that we want to defend, and if it overflows it could just become a new slice, right?  E.g. if we limit to 100 ports and I need 101, make 2 slices? Even if we start at 500, we'll need some overflow handling... (and tests)",
        "createdAt" : "2019-08-15T23:37:20Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "445ffe56-82f5-4c3f-9840-7678168ac84f",
        "parentId" : "4087a8a5-f000-4d9f-8b6e-e0fdacab018d",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I added an initial limit of 100 here, easy to change the value if another number makes more sense.",
        "createdAt" : "2019-08-16T16:48:15Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +46,50 @@\t// maximum of 100 ports.\n\t// +optional\n\t// +listType=atomic\n\tPorts []EndpointPort\n}"
  },
  {
    "id" : "c110de1c-574d-485b-9f6c-fd9838adbb3e",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-276071084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "afc71100-0887-436e-aed4-d5cb34f400ec",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "do we want to specify a limit to number of addresses?  100?  200?  500?",
        "createdAt" : "2019-08-15T17:08:59Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3378e3d3-e2fe-4b41-9b46-aad5425f0cda",
        "parentId" : "afc71100-0887-436e-aed4-d5cb34f400ec",
        "authorId" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "body" : "Can we say AddressType==IP, then at most 2 Address?\r\n\r\nAnd then we extend the validation based on AddressType",
        "createdAt" : "2019-08-15T18:29:40Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "e83108b8-1fb2-416b-9298-d5b70c14f708",
        "tags" : [
        ]
      },
      {
        "id" : "f580dee8-cbc8-48d5-ab7b-28e5feb52901",
        "parentId" : "afc71100-0887-436e-aed4-d5cb34f400ec",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "No, there are people doing multi-IP stuff.  In fact, that may be a reason to change this to \r\n\r\n```\r\nAddresses []EndpointAddress\r\n```\r\n```\r\ntype EndpointAddress struct {\r\n    address strring\r\n}\r\n```\r\n\r\nSo we can later copy metadata from Pod.IPs[].\r\n\r\nThoughts?  It's kind of obnoxious and would add another dimension of inefficiency.  I don't know if we'll need it so we can revisit as we progress alpha.\r\n\r\nHow about a limit of 100 with validation?",
        "createdAt" : "2019-08-15T23:46:02Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "24e4c473-f406-43b7-b9cd-b389c0ab635e",
        "parentId" : "afc71100-0887-436e-aed4-d5cb34f400ec",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For IPs, 16 would probably be enough.  4 would probably be enough, but let's just set it big enough that nobody complains?",
        "createdAt" : "2019-08-15T23:46:43Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "0b7b352c-874b-4a03-a694-b2c7f1d511e1",
        "parentId" : "afc71100-0887-436e-aed4-d5cb34f400ec",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "I added an additional limit of 100 here, happy to change to something else if it makes more sense",
        "createdAt" : "2019-08-16T17:20:49Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +67,71 @@\t// more than 100.\n\t// +listType=set\n\tAddresses []string\n\t// conditions contains information about the current status of the endpoint.\n\tConditions EndpointConditions"
  },
  {
    "id" : "08bee35a-438c-4cfc-8043-3bade0a50e6f",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-276054598",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6056db7f-a4ab-406b-ad31-f2cbf6fd86e7",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "now it says the unique-names requirement twice, LOL.  Sorry.",
        "createdAt" : "2019-08-15T23:31:15Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b38cca88-123c-4b41-9b01-c98f7d6d7d7a",
        "parentId" : "6056db7f-a4ab-406b-ad31-f2cbf6fd86e7",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "lol oh my, that should finally be fixed, I hope.",
        "createdAt" : "2019-08-16T16:44:15Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@\tEndpoints []Endpoint\n\t// ports specifies the list of network ports exposed by each endpoint in\n\t// this slice. Each port must have a unique name. When ports is empty, it\n\t// indicates that there are no defined ports. When a port is defined with a\n\t// nil port value, it indicates \"all ports\". Each slice may include a"
  },
  {
    "id" : "af398997-027f-4094-a4bc-b17be40fa38f",
    "prId" : 80766,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/80766#pullrequestreview-279716378",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d4ad44f-d07c-42af-9868-d91f84439928",
        "parentId" : null,
        "authorId" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "body" : "Since one endpoint is represented, should the trailing 's' be removed ?",
        "createdAt" : "2019-08-26T01:45:04Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "42b1e004-4fa7-4e43-84cf-5378839b49ad",
        "tags" : [
        ]
      },
      {
        "id" : "6639723d-8f53-4133-a03d-54e4a86cc5c4",
        "parentId" : "5d4ad44f-d07c-42af-9868-d91f84439928",
        "authorId" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "body" : "We actually started with the singular `EndpointCondition` here. After thinking it through more we decided the plural form would make more sense as this would eventually refer to multiple conditions for a given endpoint. Although the only condition currently included is `Ready`, that's expected to grow over time.",
        "createdAt" : "2019-08-26T17:13:05Z",
        "updatedAt" : "2019-08-26T21:50:24Z",
        "lastEditedBy" : "399a0f74-29de-4365-9ae5-f743ae5f278c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f80cee928040ad458fbced70392063e0a5d160e5",
    "line" : 100,
    "diffHunk" : "@@ -1,1 +98,102 @@\n// EndpointConditions represents the current condition of an endpoint.\ntype EndpointConditions struct {\n\t// ready indicates that this endpoint is prepared to receive traffic,\n\t// according to whatever system is managing the endpoint. A nil value"
  }
]
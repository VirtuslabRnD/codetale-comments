[
  {
    "id" : "4998014d-e931-42fd-aef4-8985bdbaa40f",
    "prId" : 48051,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/48051#pullrequestreview-59678380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0cbe6ad-9c8c-4abd-80e2-a7c74c6e35ae",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "@deads2k iirc, you asked this include ObjectMeta",
        "createdAt" : "2017-08-30T19:19:28Z",
        "updatedAt" : "2017-09-01T11:16:29Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "ece0f2df-1f11-4f8c-b1d3-6c783dd6de0d",
        "parentId" : "d0cbe6ad-9c8c-4abd-80e2-a7c74c6e35ae",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> @deads2k iirc, you asked this include ObjectMeta\r\n\r\nIf we fixed enough that this actually makes it though machinery without it, I don't feel strongly.",
        "createdAt" : "2017-08-30T20:07:56Z",
        "updatedAt" : "2017-09-01T11:16:29Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "790374da10d3a59899ae832c24a73349b802f72b",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +163,167 @@// SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server.\ntype SelfSubjectRulesReview struct {\n\tmetav1.TypeMeta\n\tmetav1.ObjectMeta\n"
  },
  {
    "id" : "aafde66e-8f34-4d54-8364-896c5cff6012",
    "prId" : 31271,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6afb04e-0920-4532-9b2a-6d76ffec6db4",
        "parentId" : null,
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Sorry, I couldn't find documentation on what `+noMethods` accomplishes. Does it limit the actions generated to \"Create\"?\n",
        "createdAt" : "2016-08-23T17:47:47Z",
        "updatedAt" : "2016-08-29T13:55:13Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "9716d2b9-b096-4970-a482-510b83583714",
        "parentId" : "b6afb04e-0920-4532-9b2a-6d76ffec6db4",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Sorry, I couldn't find documentation on what +noMethods accomplishes. Does it limit the actions generated to \"Create\"?\n\nIt prevents the client generator from generating methods.  Since this isn't a normal resource, it doesn't have types for things like `SelfSubjectAccessReviewList` (no get method), so the default generator fails.\n\nIt means you have to manually create the `Create` methods in the generated_expansion.go file.\n",
        "createdAt" : "2016-08-23T17:51:16Z",
        "updatedAt" : "2016-08-29T13:55:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "8d9236fb-2941-4880-ae25-974c81526030",
        "parentId" : "b6afb04e-0920-4532-9b2a-6d76ffec6db4",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "> It means you have to manually create the Create methods in the generated_expansion.go file.\n\nNice. Does that not get overridden as soon as someone else regenerates? (not to get too off topic)\n",
        "createdAt" : "2016-08-23T17:53:45Z",
        "updatedAt" : "2016-08-29T13:55:13Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "70d89992-c327-4b11-8770-5d7048be1660",
        "parentId" : "b6afb04e-0920-4532-9b2a-6d76ffec6db4",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Nice. Does that not get overridden as soon as someone else regenerates? (not to get too off topic)\n\nNo, it is preserved.\n",
        "createdAt" : "2016-08-23T17:55:52Z",
        "updatedAt" : "2016-08-29T13:55:13Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f642ebc9edac8afd1755a32942977e71d8f770f",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +41,45 @@// +genclient=true\n// +nonNamespaced=true\n// +noMethods=true\n\n// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a"
  },
  {
    "id" : "329b1bc9-53c0-4b8f-9a41-09af54d56553",
    "prId" : 20573,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Adding this allows the `kubectl create` flow to work and all the \"normal\" flows through our REST API.  It means we have a \"name\" on a resource you can't GET, but I think it probably makes the API more \"normal\" overall.\n",
        "createdAt" : "2016-08-02T18:48:52Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "3d7b2d62-458f-41a6-b6e3-1042624979ad",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "What is `kubectl create` doing that it requires there to be ObjectMeta?\nWhat would be the minimal changes to kubectl to be able to handle these objects without ObjectMeta?\n\nI feel like these are not \"normal\" objects because they are not persisted, and IIUC, cannot be GET-ed.  So, maybe the need a different kind of metadata.\n",
        "createdAt" : "2016-08-04T18:44:10Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "df7be25a-ec5a-42fc-9c33-3d6f1a6f5e20",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> What is kubectl create doing that it requires there to be ObjectMeta?\n> What would be the minimal changes to kubectl to be able to handle these objects without ObjectMeta?\n> \n> I feel like these are not \"normal\" objects because they are not persisted, and IIUC, cannot be GET-ed. So, maybe the need a different kind of metadata.\n\nThe metadata accessor libraries require everything.  In addition, if we use this for delegated authorization, it will be a hot-path and including this type allows us to take advantage of conforming to the `meta.Accessor` fast path.\n",
        "createdAt" : "2016-08-04T19:01:59Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "558e2a6a-b823-4c5a-9f96-ced6f272ad97",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> What is kubectl create doing that it requires there to be ObjectMeta?\n> What would be the minimal changes to kubectl to be able to handle these objects without ObjectMeta?\n\nIt seems to be required API server side for setting the self-link.  For a long time we had a special-cased hack in origin to skip that for certain types.  I don't know how its working downstream now.\n\nGiven the difficulty in making it work and the amount of code that assumes that every type has `ObjectMeta`, this seems lower friction.\n",
        "createdAt" : "2016-08-04T19:08:49Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "5f0bc268-f698-4e69-8ef3-414dbd21bf48",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "@smarterclayton. These are actually the only resources without objectmeta and I really question whether it's worth the pain.  I don't think it buys us anything.  You ok with it?\n",
        "createdAt" : "2016-08-04T20:54:15Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "88725d53-ccec-4fec-917e-2048c39293f9",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Do they?  I can fix that - you're not quite an object, and we can make an\nexception.  You can also implement fake meta accessor and return nothing.\n\nOn Thu, Aug 4, 2016 at 3:02 PM, David Eads notifications@github.com wrote:\n\n> In pkg/apis/authorization/types.go\n> https://github.com/kubernetes/kubernetes/pull/20573#discussion_r73583095\n> :\n> \n> >  // SubjectAccessReview checks whether or not a user or group can perform an action.  Not filling in a\n> >  // spec.namespace means \"in all namespaces\".\n> >  type SubjectAccessReview struct {\n> >     unversioned.TypeMeta\n> > -   api.ObjectMeta\n> \n> What is kubectl create doing that it requires there to be ObjectMeta?\n> What would be the minimal changes to kubectl to be able to handle these\n> objects without ObjectMeta?\n> \n> I feel like these are not \"normal\" objects because they are not persisted,\n> and IIUC, cannot be GET-ed. So, maybe the need a different kind of metadata.\n> \n> The metadata accessor libraries require everything. In addition, if we use\n> this for delegated authorization, it will be a hot-path and including this\n> type allows us to take advantage of conforming to the meta.Accessor fast\n> path.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20573/files/42b8be284e0c00b2658d26d652153ea70c691626#r73583095,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/ABG_p9IcwASj_Iqt-7UhRiChop_EMlOVks5qcjc1gaJpZM4HSwZB\n> .\n",
        "createdAt" : "2016-08-04T21:53:36Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "40dd16f7-0775-4321-a30d-6948e6826577",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I really like having the metadata though.  It makes life easier here, keeps one-offs that I've had trouble with in openshift out of our codebase, and someday might allow us to return semistructured data back via annotations.\n\nAre you ok with including it here?\n",
        "createdAt" : "2016-08-04T22:10:54Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "16d3c242-207f-430b-9839-1253a87e5db3",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Can we add a validation rule that the ObjectMeta is empty for SubjectAccessReview?\n",
        "createdAt" : "2016-08-04T23:43:18Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "b688e205-3329-41fa-b723-083ac089da8e",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "We have ListMeta and ObjectMeta.  I was thinking maybe we need a third kind of Meta for non-persisted non-listing things like tokenreview and subjectaccessreview and imagereview.    Maybe we call it FunctionMeta.\n",
        "createdAt" : "2016-08-05T00:08:05Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "51e5c337-2b8c-4708-bd56-7d957cff2db5",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "FunctionMeta will need to support all metadata accessor methods, though most of them will return nothing.\n",
        "createdAt" : "2016-08-05T00:21:50Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "5085995e-43dd-429c-93cf-22d5c536424b",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Adding a validation rule to force it to be submitted empty will allow us to change our mind.  Sound good Eric?\n",
        "createdAt" : "2016-08-05T00:40:29Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "5dfc44d2-3f5d-4332-992b-ef9377c44e17",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I don't really want to propagate this problem though.  ObjectMeta is not\nintended for things that aren't objects.  Code that assumes that is broken,\nand we're just going to be piling on to the bad here.\n\nOn Thu, Aug 4, 2016 at 3:09 PM, David Eads notifications@github.com wrote:\n\n> In pkg/apis/authorization/types.go\n> https://github.com/kubernetes/kubernetes/pull/20573#discussion_r73584170\n> :\n> \n> >  // SubjectAccessReview checks whether or not a user or group can perform an action.  Not filling in a\n> >  // spec.namespace means \"in all namespaces\".\n> >  type SubjectAccessReview struct {\n> >     unversioned.TypeMeta\n> > -   api.ObjectMeta\n> \n> What is kubectl create doing that it requires there to be ObjectMeta?\n> What would be the minimal changes to kubectl to be able to handle these\n> objects without ObjectMeta?\n> \n> It seems to be required API server side for setting the self-link. For a\n> long time we had a special-cased hack in origin to skip that for certain\n> types. I don't know how its working downstream now.\n> \n> Given the difficulty in making it work and the amount of code that assumes\n> that every type has ObjectMeta, this seems lower friction.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20573/files/42b8be284e0c00b2658d26d652153ea70c691626#r73584170,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/ABG_p9_upc1XxX1MamW5YN3XoqZ3rUKLks5qcjjbgaJpZM4HSwZB\n> .\n",
        "createdAt" : "2016-08-05T01:16:59Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "d81cdc6b-779b-47be-a191-c065f899d1cd",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm ok with the workaround, but we really need to fix the underlying\nproblem.  Can you spawn an issue and assign it to me?\n\nOn Thu, Aug 4, 2016 at 9:16 PM, Clayton Coleman ccoleman@redhat.com wrote:\n\n> I don't really want to propagate this problem though.  ObjectMeta is not\n> intended for things that aren't objects.  Code that assumes that is broken,\n> and we're just going to be piling on to the bad here.\n> \n> On Thu, Aug 4, 2016 at 3:09 PM, David Eads notifications@github.com\n> wrote:\n> \n> > In pkg/apis/authorization/types.go\n> > https://github.com/kubernetes/kubernetes/pull/20573#discussion_r73584170\n> > :\n> > \n> > >  // SubjectAccessReview checks whether or not a user or group can perform an action.  Not filling in a\n> > >  // spec.namespace means \"in all namespaces\".\n> > >  type SubjectAccessReview struct {\n> > >    unversioned.TypeMeta\n> > > -  api.ObjectMeta\n> > \n> > What is kubectl create doing that it requires there to be ObjectMeta?\n> > What would be the minimal changes to kubectl to be able to handle these\n> > objects without ObjectMeta?\n> > \n> > It seems to be required API server side for setting the self-link. For a\n> > long time we had a special-cased hack in origin to skip that for certain\n> > types. I don't know how its working downstream now.\n> > \n> > Given the difficulty in making it work and the amount of code that\n> > assumes that every type has ObjectMeta, this seems lower friction.\n> > \n> > â€”\n> > You are receiving this because you were mentioned.\n> > Reply to this email directly, view it on GitHub\n> > https://github.com/kubernetes/kubernetes/pull/20573/files/42b8be284e0c00b2658d26d652153ea70c691626#r73584170,\n> > or mute the thread\n> > https://github.com/notifications/unsubscribe-auth/ABG_p9_upc1XxX1MamW5YN3XoqZ3rUKLks5qcjjbgaJpZM4HSwZB\n> > .\n",
        "createdAt" : "2016-08-05T01:18:10Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1570504c-c7c9-453a-a8ba-d57478692011",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Can you spawn an issue and assign it to me?\n\nOk, I will after fixing up Chao's comments.  Let's talk tomorrow.\n",
        "createdAt" : "2016-08-05T01:22:59Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "7d155e7e-86e1-412f-bca0-29a4182edec3",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I'm fine with validating that it is empty.  I think that will allow us to back out the ObjectMeta once Clayton has a better fix.\n",
        "createdAt" : "2016-08-05T05:54:43Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "1249a783-27d4-4e41-856c-976657eea4e8",
        "parentId" : "d8d450a5-067f-425c-a4f4-cba47fddd6a3",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "David talked me around to the idea that many things that aren't classic\n\"objects\" on the system have both name and namespace, resource version and\nself link.  Some of those might use annotations for extensions (i.e. submit\na subject access review with an annotation for a custom feature not yet\nimplemented in the platform, or return an experimental feature in an\nannotation).\n\nIf we have all of those, then what is left is basically object meta.  We\nshould definitely require those fields be empty for the short term, or\ncreate a new restricted objectmeta if we do.\n\nOn Fri, Aug 5, 2016 at 1:54 AM, Eric Tune notifications@github.com wrote:\n\n> In pkg/apis/authorization/types.go\n> https://github.com/kubernetes/kubernetes/pull/20573#discussion_r73645007\n> :\n> \n> >  // SubjectAccessReview checks whether or not a user or group can perform an action.  Not filling in a\n> >  // spec.namespace means \"in all namespaces\".\n> >  type SubjectAccessReview struct {\n> >     unversioned.TypeMeta\n> > -   api.ObjectMeta\n> \n> I'm fine with validating that it is empty. I think that will allow us to\n> back out the ObjectMeta once Clayton has a better fix.\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20573/files/42b8be284e0c00b2658d26d652153ea70c691626#r73645007,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/ABG_p8zO8BsUFSyyqcGrd4iTVnlkPcfQks5qctAygaJpZM4HSwZB\n> .\n",
        "createdAt" : "2016-08-05T15:20:07Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9a203409af6be6293585289c821025a46530694",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +30,34 @@type SubjectAccessReview struct {\n\tunversioned.TypeMeta\n\tapi.ObjectMeta\n\n\t// Spec holds information about the request being evaluated"
  },
  {
    "id" : "c5b1a6f7-7595-4fb0-a69c-787b624fd42e",
    "prId" : 20573,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3d30f08-b11d-481f-958b-4c158baea19a",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "This doesn't change any external serialization, but it's required so that protobuf generates the nested types properly.\n",
        "createdAt" : "2016-08-02T18:49:24Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9a203409af6be6293585289c821025a46530694",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +112,116 @@\t// Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer\n\t// it needs a reflection here.\n\tExtra map[string]ExtraValue\n}\n"
  },
  {
    "id" : "a67faf70-597d-4233-a509-9603590c4f15",
    "prId" : 20573,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac3c20ed-56d7-4d11-ab13-308794753fcd",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "This field allows us to cleanly mirror the `Authorize() (allowed bool, reason string, evaluationError error)` signature we have.\n",
        "createdAt" : "2016-08-02T18:50:06Z",
        "updatedAt" : "2016-08-05T15:37:51Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9a203409af6be6293585289c821025a46530694",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +137,141 @@\t// It is entirely possible to get an error and be able to continue determine authorization status in spite of it.\n\t// For instance, RBAC can be missing a role, but enough roles are still present and bound to reason about the request.\n\tEvaluationError string\n}"
  },
  {
    "id" : "a557a6a4-6ac6-4fae-b9d4-8340b1b4e363",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0855c0e3-51c5-460e-a0e7-0ea0ecf6dc0c",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "do we want or care about query?\n",
        "createdAt" : "2015-12-15T21:15:28Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "a5af50db-7e03-4e71-9c2d-ef59674cb945",
        "parentId" : "0855c0e3-51c5-460e-a0e7-0ea0ecf6dc0c",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> do we want or care about query?\n\nAuthorizers don't have access to the query, so we can't plumb it through.  I'm not sure that I'd make policy decisions based on a query.\n\nAdd it later if we want it?\n",
        "createdAt" : "2015-12-15T21:18:51Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +83,87 @@// NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface\ntype NonResourceAttributes struct {\n\t// Path is the URL path of the request\n\tPath string\n\t// Verb is the standard HTTP verb"
  },
  {
    "id" : "31ebb813-848c-46d8-97f3-8edb349b079d",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d309f75a-9193-41fd-a301-48ed5cb31fb7",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "What is \"the current user\"?\n",
        "createdAt" : "2016-01-08T16:08:15Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "de138f2e-a376-4634-b3fa-219e44868b4f",
        "parentId" : "d309f75a-9193-41fd-a301-48ed5cb31fb7",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> What is \"the current user\"?\n\n\"current user\" is the `UserInfo` object contained in the `Context` object.  That gets filled in my the authentication layer and plumbed through `RESTStorage`\n",
        "createdAt" : "2016-01-14T21:05:40Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +33,37 @@}\n\n// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a\n// spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able\n// to check whether they can perform an action"
  },
  {
    "id" : "86cf8568-2bef-46bb-a8aa-9b024a69e209",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4314d147-d993-47ba-8b11-e6934b7e17ee",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I am confused about why the non-local version allows you to specify a namespace, if this one exists?\n",
        "createdAt" : "2016-01-08T16:09:18Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "fc4dab7a-067c-4eef-81a1-ea4e31aa7a0b",
        "parentId" : "4314d147-d993-47ba-8b11-e6934b7e17ee",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Namespace scoped is a convenience wrapper around the non-local version.\nThis version is an end user endpoint - the other endpoint is the \"correct\"\nendpoint that system integrators use to ask the cluster itself what it\nallows.\n\nOn Fri, Jan 8, 2016 at 11:09 AM, Daniel Smith notifications@github.com\nwrote:\n\n> In pkg/apis/authorization/types.go\n> https://github.com/kubernetes/kubernetes/pull/18722#discussion_r49204494\n> :\n> \n> > +\n> > +// SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a\n> > +// spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able\n> > +// to check whether they can perform an action\n> > +type SelfSubjectAccessReview struct {\n> > -   unversioned.TypeMeta\n> >   +\n> > -   // Spec holds information about the request being evaluated.\n> > -   Spec SelfSubjectAccessReviewSpec\n> >   +\n> > -   // Status is filled in by the server and indicates whether the request is allowed or not\n> > -   Status SubjectAccessReviewStatus\n> >   +}\n> >   +\n> >   +// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace.\n> >   +// Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions\n> \n> I am confused about why the non-local version allows you to specify a\n> namespace, if this one exists?\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/18722/files#r49204494.\n",
        "createdAt" : "2016-01-13T17:01:56Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +47,51 @@\n// LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace.\n// Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions\n// checking.\ntype LocalSubjectAccessReview struct {"
  },
  {
    "id" : "f999b81d-b70d-4a73-be59-22c488332cfb",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2daabb4a-6cd9-47d0-8746-6b10a886ccaa",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is there a canonical list of verbs somewhere?\n",
        "createdAt" : "2016-01-08T16:10:46Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "b85983db-3940-4e3e-887e-6be2bc0b3da3",
        "parentId" : "2daabb4a-6cd9-47d0-8746-6b10a886ccaa",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I think that @deads2k intends that:\n- `subjectAccessReview` and friends are APIs that you get only if you install `authorization.k8s.io`\n- `authorization.k8s.io` also will grow, in future PRs, to include most or all parts of \"Open Shift Policy\"\n- one of those future PRs will add code that defines some verbs\n- however, the list of verbs is not an enum and may grow in future, and is not centrally defined\n- some verbs can be seen here: https://github.com/openshift/origin/blob/94003d801014352de236c34bbce2426c2dda91c6/test/fixtures/bootstrappolicy/bootstrap_cluster_roles.yaml\n",
        "createdAt" : "2016-01-13T16:47:45Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "191a09be-5fd5-4791-acf6-bedc44b65cb9",
        "parentId" : "2daabb4a-6cd9-47d0-8746-6b10a886ccaa",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I think that @deads2k intends that:\n\nCorrect, though I'm willing to split the rest of our policy engine into a separate API group, for this to work, an authorizer implementation that uses it would still need to available in this API server.\n\nAs noted, `Verb` is not an enumeration.  There are conventions, but there are not strict requirements or limitations on the field.\n",
        "createdAt" : "2016-01-14T21:07:58Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +68,72 @@\tNamespace string\n\t// Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  \"*\" means all.\n\tVerb string\n\t// Group is the API Group of the Resource.  \"*\" means all.\n\tGroup string"
  },
  {
    "id" : "a3a0d5e4-4c58-4b91-93e3-92ab36bc20ea",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5eb5c677-494c-4326-9692-da69fbf31363",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Documentation for this type? Is it used? (I mean, I know it's in the struct below, but is it something we actually intend to implement?)\n",
        "createdAt" : "2016-01-08T16:12:26Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f8035424-c9c9-4972-b7c3-fa001e333778",
        "parentId" : "5eb5c677-494c-4326-9692-da69fbf31363",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Documentation for this type? Is it used? (I mean, I know it's in the struct below, but is it something we actually intend to implement?)\n\nI will add it.  Basically this is way to express the authorization attributes available for non-resource requests to the Authorizer interface.  This is a hole in the openshift SAR implementation that limits delegation ability.\n",
        "createdAt" : "2016-01-14T21:09:15Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +82,86 @@\n// NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface\ntype NonResourceAttributes struct {\n\t// Path is the URL path of the request\n\tPath string"
  },
  {
    "id" : "e912565b-29df-4afe-afe7-077e2e25fff1",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36ab2245-c077-40f0-a33e-51ff18c1bdf3",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "NaÃ®ve question: why not just have `type SubjectAccessReview` which is namespaced, and which, after being installed normally, is served off of both (1) `/apis/authorization.k8s.io/v1beta1/subjectAccessReviews` and (2)  `/apis/authorization.k8s.io/v1beta1/namespace/$NS/subjectAccessReviews`; and it does the cluster-wide behavior when you do (1) and the local behavior when you do (2)?\n\nI know that you want to authorize only a few people to do (1) and more people to do (2).  But don't you have the same issue with GET `/apis/v1/pods` vs  GET `/apis/v1/namespace/$NS/pods`?\n",
        "createdAt" : "2016-01-13T16:40:18Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "4d15993c-aa51-491b-ba15-ac7571d01fb4",
        "parentId" : "36ab2245-c077-40f0-a33e-51ff18c1bdf3",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I know that you want to authorize only a few people to do (1) and more people to do (2). But don't you have the same issue with GET /apis/v1/pods vs GET /apis/v1/namespace/$NS/pods?\n\nWe actually had that working when we shipped v1, but the API server, the scheme, and the RESTMapper freak out at the idea of a kind or a resource being both namespaced and non-namespaced (see https://github.com/kubernetes/kubernetes/issues/18679).  Keeping the resources and kinds separated keeps our conventions closer to the normal kube API conventions.\n",
        "createdAt" : "2016-01-14T21:11:44Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "50918574-3bfc-4c3c-bcff-246e943ee6e3",
        "parentId" : "36ab2245-c077-40f0-a33e-51ff18c1bdf3",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@lavalamp will you take a read over  #18679 and this comment and tell me if you have a preference between the two options:\n1. different named go types with identical fields, one namespaced and another not\n2. refactoring of API server, RESTMapper, etc allows same go type defintion to be used for both namespaced and non-namespaced rest paths\n",
        "createdAt" : "2016-01-15T17:13:06Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +49,53 @@// Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions\n// checking.\ntype LocalSubjectAccessReview struct {\n\tunversioned.TypeMeta\n"
  },
  {
    "id" : "6243cf29-8c23-4ef4-9c9d-546f858dd7e5",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ad7c7f0-60e0-48dc-bf14-d18544a59b5b",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@bgrant0607 this PR is establishing a pattern where, to do an RPC, your arguments go into `Spec`, and the response contains a copy of your `Spec`, plus return values in `Status`.  The call is synchronous.   The Spec is not persisted, AFAICS, and there is no controller that is filling status.  Appropriate reuse of these terms, or should we have a different convention for RPC-like things?\n",
        "createdAt" : "2016-01-13T16:51:10Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +57,61 @@\n\t// Status is filled in by the server and indicates whether the request is allowed or not\n\tStatus SubjectAccessReviewStatus\n}\n"
  },
  {
    "id" : "b1476241-1ad1-4e28-b62b-dda1b976c5e3",
    "prId" : 18722,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ae892b6-714a-431e-a0c3-25cf183c5dc9",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "If I specify \"User\" but not \"Group\", then is it interpreted as \"What if User were not a member of any groups, what could she do?\".  Or does it mean \"Please check the Group membership of User and use those groups to determine what User can do?\".  I think that the latter is way more useful.  \n\nThe only hiccup I see is that some authentication methods provide group memberships as part of the Request, via headers, and other authentication methods provide a means to look up group membership.   I think the solution could be for group-providing authentication methods to cause a map[User][]Groups to be updated, and then for SubjectAccessReviews to query that map.\n",
        "createdAt" : "2016-01-13T17:01:42Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "9a7b1ebf-255f-4265-ba31-156d3519a4e3",
        "parentId" : "2ae892b6-714a-431e-a0c3-25cf183c5dc9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I vaguely remember discussing this...\n\npros of groupifying server-side:\n- allows things outside the auth-layer to check actual access for a user without needing to know the user's group membership\n\ncons of groupifying server-side:\n- tightly couples the SAR implementation to the auth layer\n- as you point out, makes it more difficult to support auth methods that communicate group membership at login time (like SAML or auth proxies with extended attributes)\n\nother thoughts:\n- what if the user cannot be groupified? for act-as, we had said we thought that should be a failure, but that doesn't seem right here\n- I would want the ability to check just a user's access (e.g. `{user:\"bob\",groups:[]}`), but leaving groups `nil` to request groupification from the server seems super-subtle\n",
        "createdAt" : "2016-01-14T03:01:13Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "92d9413e-f9fb-4147-8c75-8888c86af289",
        "parentId" : "2ae892b6-714a-431e-a0c3-25cf183c5dc9",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> If I specify \"User\" but not \"Group\", then is it interpreted as \"What if User were not a member of any groups, what could she do?\"\n\nCorrect, if you specify `User` and not `Group`, it is interpreted as \"What if User were not a member of any groups, what could she do?\"\n",
        "createdAt" : "2016-01-14T21:12:39Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "efd3990e-28cd-4c74-a478-caa48300cf1a",
        "parentId" : "2ae892b6-714a-431e-a0c3-25cf183c5dc9",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Please update comments to clarify that groupification does not happen server side.  This may not be obvious to users.\n",
        "createdAt" : "2016-01-15T17:20:33Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "2355b471-5071-4e59-8b91-46b4476cb03f",
        "parentId" : "2ae892b6-714a-431e-a0c3-25cf183c5dc9",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "never mind.   I see you did this already.\n",
        "createdAt" : "2016-01-15T17:21:21Z",
        "updatedAt" : "2016-01-20T13:24:17Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      }
    ],
    "commit" : "14396fc4643b1b1e7b86ba6cc652e85fa1b0b2c5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +101,105 @@\tUser string\n\t// Groups is the groups you're testing for.\n\tGroups []string\n}\n"
  }
]
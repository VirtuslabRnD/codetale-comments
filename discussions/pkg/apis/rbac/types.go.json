[
  {
    "id" : "fe3f3e69-1412-4c4c-9dce-21b867e8933b",
    "prId" : 31543,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb448c41-36c1-46e7-8c46-23d8c952ee50",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "implicitly disallowing cross-namespace references by omitting Namespace?\n",
        "createdAt" : "2016-08-31T19:19:30Z",
        "updatedAt" : "2016-09-09T13:56:15Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9fad73d5-8e28-43e7-8e68-5eb2a106d06f",
        "parentId" : "bb448c41-36c1-46e7-8c46-23d8c952ee50",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> implicitly disallowing cross-namespace references by omitting Namespace?\n\nYes and they were already explicitly disallowed in the evaluation code before.\n",
        "createdAt" : "2016-08-31T19:30:49Z",
        "updatedAt" : "2016-09-09T13:56:15Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "7f6cb437fe595ac69fde9ccb072b8a37a53bbce9",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +88,92 @@\tKind string\n\t// Name is the name of resource being referenced\n\tName string\n}\n"
  },
  {
    "id" : "14f06217-635b-4efb-932f-370b5c1745a8",
    "prId" : 24900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e94d5c3-76ed-4d53-9bdc-6cc73ff74662",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "I still like this being a point where I can code in special behavior for a given rule if I want to write the authorization rule using code or other secondary information, but I'm calling it out in case @erictune disagrees.\n",
        "createdAt" : "2016-04-28T11:54:31Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a1f46895e0074883d78613e3a2e6f4cc70e2743",
    "line" : null,
    "diffHunk" : "@@ -1,1 +46,50 @@\t// AttributeRestrictions will vary depending on what the Authorizer/AuthorizationAttributeBuilder pair supports.\n\t// If the Authorizer does not recognize how to handle the AttributeRestrictions, the Authorizer should report an error.\n\tAttributeRestrictions runtime.Object\n\t// APIGroups is the name of the APIGroup that contains the resources.\n\t// If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed."
  },
  {
    "id" : "de522f7b-884a-4a32-a3c0-dca423348036",
    "prId" : 24900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84453117-69a7-4cbb-9162-7ec00e103bbb",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "subresources are represented as `<resource>/<subresource>`\n",
        "createdAt" : "2016-04-28T14:21:24Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d811f869-aed6-48d5-82c7-82b39e60a6ad",
        "parentId" : "84453117-69a7-4cbb-9162-7ec00e103bbb",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> subresources are represented as <resource>/<subresource>\n\nShall we continue our long running argument here?  Sometimes this works really well: `namespace/status` or some such.  Sometimes it doesn't work out so well: HPA needs to be able to call `*/scale`.  Long term, I'd like to see it split out.\n\nThe change is largely compatible.\n",
        "createdAt" : "2016-04-28T14:30:08Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a1f46895e0074883d78613e3a2e6f4cc70e2743",
    "line" : null,
    "diffHunk" : "@@ -1,1 +50,54 @@\t// If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.\n\tAPIGroups []string\n\t// Resources is a list of resources this rule applies to.  ResourceAll represents all resources.\n\tResources []string\n\t// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed."
  },
  {
    "id" : "18f52c04-5555-49b6-8ae9-ac11da70b5f0",
    "prId" : 24900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae0e8e2f-9b29-47f6-b29e-57c0933ce615",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Needs to be at least `APIGroup` qualified.  Its weird, but kube sets the `apiGroup` inside of the `apiVersion` field, so even though you'll probably always put a group in it, I think it needs to be called `APIVersion`.\n",
        "createdAt" : "2016-05-02T13:25:18Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "4b456067-1269-4727-92e2-d9fab351966d",
        "parentId" : "ae0e8e2f-9b29-47f6-b29e-57c0933ce615",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "That also makes sense for the cases of ServiceAccounts. Does this work?\n\n``` go\n// APIVersion holds the API group and verison of the referenced object. For\n// non-object references such as \"User\" and \"Group\" this is expected to be the\n// API verison of this API group. For example \"rbac.authorization/v1alpha1\"\nAPIVersion string\n```\n\nOr for \"User\" and \"Group\" should there be a sentinel API Group name?\n",
        "createdAt" : "2016-05-02T16:32:33Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "db173405-4fca-4fa0-961f-d2e05efce700",
        "parentId" : "ae0e8e2f-9b29-47f6-b29e-57c0933ce615",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "It seems confusing to me to call this a `Kind`, when it is not an object with ObjectMeta.\n\nWhat about:\n\n```\ntype Subject struct \n      // Set at most one of the following:\n      UserName string\n      Group string\n}\n```\n",
        "createdAt" : "2016-05-03T13:56:24Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "44c078fe-ec38-4f29-a984-9cc542b69c34",
        "parentId" : "ae0e8e2f-9b29-47f6-b29e-57c0933ce615",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> It seems confusing to me to call this a Kind, when it is not an object with ObjectMeta.\n\nWhen referencing a service account, it does have an object meta.  I think at some point there will be a new API group that realizes these entities.\n",
        "createdAt" : "2016-05-03T14:07:17Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a1f46895e0074883d78613e3a2e6f4cc70e2743",
    "line" : null,
    "diffHunk" : "@@ -1,1 +65,69 @@\t// Kind of object being referenced. Values defined by this API group are \"User\", \"Group\", and \"ServiceAccount\".\n\t// If the Authorizer does not recognized the kind value, the Authorizer should report an error.\n\tKind string\n\t// APIVersion holds the API group and version of the referenced object. For non-object references such as \"Group\" and \"User\" this is\n\t// expected to be API version of this API group. For example \"rbac.authorization.k8s.io/v1alpha1\"."
  },
  {
    "id" : "f1173828-de49-470a-97dc-92ff7517fc58",
    "prId" : 24900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc926b5a-982a-4586-b8d2-40cfb16d9bcf",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@deads2k Do you think it would be a possible simplification to only have NonResourceURLs permissions at the ClusterRole level, and not at the namespace level?  Seems like:\n- all authorized users should have read access to a fixed set of NonResourceURLs for api discovery\n- only cluster admins and their tasks need access to health checking and debugging URLs in a multi-tenant environment, or else all users get access in a permissive environment.\n- only cluster admins need write access to NonResourceURLs.\n- Note lack of namespace distinction here.\n- Not suggesting exactly how to factor structs to achieve this, just whether not exposing NonResourceURLs at the namespace level is clearer for users.\n",
        "createdAt" : "2016-05-03T13:47:26Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "c60f0051-443f-49e0-9a9f-f214d1c43137",
        "parentId" : "dc926b5a-982a-4586-b8d2-40cfb16d9bcf",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> all authorized users should have read access to a fixed set of NonResourceURLs for api discovery\n\nWe actually expose discovery to all authenticated and unauthenticated users so that a project admin can grant unauthenticated access to some resources and that unauthenticated user can manage version negotiation without logging in.\n\n> Note lack of namespace distinction here.\n\nBased on our current URL parser, no namespaced URL can be a non-resource.  I'm not against splitting it out, but I don't think I'd start there since it would be more refactoring of the evaluator.\n",
        "createdAt" : "2016-05-03T14:05:54Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a1f46895e0074883d78613e3a2e6f4cc70e2743",
    "line" : null,
    "diffHunk" : "@@ -1,1 +57,61 @@\t// If an action is not a resource API request, then the URL is split on '/' and is checked against the NonResourceURLs to look for a match.\n\t// Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.\n\tNonResourceURLs []string\n}\n"
  },
  {
    "id" : "ea09a388-8052-4bf5-83a3-fa22018c9d89",
    "prId" : 24900,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03fd26e5-5ff7-4476-80c9-ecf20934da0b",
        "parentId" : null,
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "@deads2k does it ever make sense for a ClusterRoleBinding to reference a Role in a namespace? If it was allowed would that Role's policies apply to the namespace the role is a part of?\n",
        "createdAt" : "2016-05-03T19:06:00Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "6d9854f6-e442-4cb1-95ab-7626478c7db5",
        "parentId" : "03fd26e5-5ff7-4476-80c9-ecf20934da0b",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> @deads2k does it ever make sense for a ClusterRoleBinding to reference a Role in a namespace? If it was allowed would that Role's policies apply to the namespace the role is a part of?\n\nNo, it does not make sense.\n",
        "createdAt" : "2016-05-03T19:07:39Z",
        "updatedAt" : "2016-05-11T10:02:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a1f46895e0074883d78613e3a2e6f4cc70e2743",
    "line" : null,
    "diffHunk" : "@@ -1,1 +143,147 @@\t// RoleRef can only reference a ClusterRole in the global namespace.\n\t// If the RoleRef cannot be resolved, the Authorizer must return an error.\n\tRoleRef api.ObjectReference\n}\n"
  }
]
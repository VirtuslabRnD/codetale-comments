[
  {
    "id" : "393e2392-3f52-4257-b9fb-6ecff3fa0ce3",
    "prId" : 38330,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/38330#pullrequestreview-12106892",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "871461f7-cb2f-482f-94dc-00a5a99124e5",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "\"that does not do conversion\" followed by using an argument that \"// GroupVersioner refines a set of possible conversion targets into a single option.\" is a little weird.  Just reading straight down, so I haven't investigated usage.",
        "createdAt" : "2016-12-08T20:09:10Z",
        "updatedAt" : "2016-12-08T20:09:10Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "8af15f4d30da565907bf5b245ec3b2b41e97e69b",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +221,225 @@}\n\n// EncoderForVersion returns an encoder that does not do conversion.\nfunc (f DirectCodecFactory) EncoderForVersion(serializer runtime.Encoder, version runtime.GroupVersioner) runtime.Encoder {\n\treturn versioning.DirectEncoder{"
  },
  {
    "id" : "19336317-d8e8-4ebc-82c2-3f4a40b666de",
    "prId" : 26251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e93daf53-a2f3-4105-8285-d730bbfb19db",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@smarterclayton these are the important bits of this PR. Others are mostly generated code.\n",
        "createdAt" : "2016-05-25T17:40:19Z",
        "updatedAt" : "2016-05-31T17:14:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "f32f3966d69b83c0d3dbb8903b205c79e81210e4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +313,317 @@\n// DirectCodecFactory provides methods for retrieving \"DirectCodec\"s, which do not do conversion.\ntype DirectCodecFactory struct {\n\tCodecFactory\n}"
  },
  {
    "id" : "01e65fb3-fcd3-49ad-bf81-5a2198a0fe8f",
    "prId" : 24539,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "228a4784-6385-46a2-a6fe-d1fd38cee782",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Do we want to disable it? Or is it just WIP?\n",
        "createdAt" : "2016-04-22T11:31:31Z",
        "updatedAt" : "2016-04-22T15:07:37Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "25f8e716-4b23-4938-9d37-ce0e1015b449",
        "parentId" : "228a4784-6385-46a2-a6fe-d1fd38cee782",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Wip, doesn't work yet.  We could merge this without enabling it.\n",
        "createdAt" : "2016-04-22T12:46:01Z",
        "updatedAt" : "2016-04-22T15:07:37Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "668fae253f13310b06cce3afeb6eefe24c6364d6",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +80,84 @@\t\t\tSerializer:         yamlSerializer,\n\n\t\t\t// TODO: requires runtime.RawExtension to properly distinguish when the nested content is\n\t\t\t// yaml, because the yaml encoder invokes MarshalJSON first\n\t\t\t//AcceptStreamContentTypes: []string{\"application/yaml\", \"application/yaml;stream=watch\"},"
  },
  {
    "id" : "d46feba1-a39c-47da-be21-50b979f09aba",
    "prId" : 23288,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "805d9e82-0ec9-4f90-80d7-a05bf0b3c11d",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Looks like our first two serializers require a `json.MetaFactory` too.  Why is this limited to `runtime.Scheme`?\n",
        "createdAt" : "2016-03-21T18:36:54Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "573c540b-67c6-4232-bc7e-6c8f6e15445b",
        "parentId" : "805d9e82-0ec9-4f90-80d7-a05bf0b3c11d",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That's being removed in a follow on PR - there's really no value in us letting that be customizable now.\n",
        "createdAt" : "2016-03-21T20:55:25Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "54eaa56b921a4cd93ab5db5215d094decdc948bf",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +29,33 @@\n// serializerExtensions are for serializers that are conditionally compiled in\nvar serializerExtensions = []func(*runtime.Scheme) (serializerType, bool){}\n\ntype serializerType struct {"
  },
  {
    "id" : "ce850918-0645-4252-ada0-68d2187acd4d",
    "prId" : 23288,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32c57921-6551-49c7-9e01-1ffbf5686633",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "reading this reminded me that  I really want `Codec` and `Serializer` to be non-overlapping interfaces.  It's really hard for me to figure out which one is intended in every location.  Making them compatible via wrapping is fine with me, but having them auto-cast \"appropriately\" makes it hard for me to read the code.\n",
        "createdAt" : "2016-03-21T18:38:49Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "f3c99461-a0db-43a5-8413-3ff7282fe3d5",
        "parentId" : "32c57921-6551-49c7-9e01-1ffbf5686633",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes, they need to be improved.\n",
        "createdAt" : "2016-03-21T20:55:54Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "54eaa56b921a4cd93ab5db5215d094decdc948bf",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +92,96 @@}\n\n// NewCodecFactory provides methods for retrieving serializers for the supported wire formats\n// and conversion wrappers to define preferred internal and external versions. In the future,\n// as the internal version is used less, callers may instead use a defaulting serializer and"
  },
  {
    "id" : "0bf9a5f3-4efa-40ed-8911-090df2cb0abb",
    "prId" : 23288,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2200a93-451c-4c63-9a07-796ab6e780e0",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "It's not obvious to my why this is better than leaving it `nil`.  If not every `CodecFactory` has a `legacySerializer`, that seems like an ok state.\n",
        "createdAt" : "2016-03-21T18:41:21Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "038e1b6b-8b6a-4216-a8a6-3294ab679c75",
        "parentId" : "d2200a93-451c-4c63-9a07-796ab6e780e0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Probably fine.\n",
        "createdAt" : "2016-03-21T20:57:24Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "54eaa56b921a4cd93ab5db5215d094decdc948bf",
    "line" : 156,
    "diffHunk" : "@@ -1,1 +152,156 @@\t}\n\tif legacySerializer == nil {\n\t\tlegacySerializer = serializers[0].Serializer\n\t}\n\treturn CodecFactory{"
  },
  {
    "id" : "21c118fb-198d-4063-9d1f-e2a804aeabd4",
    "prId" : 23288,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b147a5a3-bb9c-4f12-988c-0c0e3439ae1a",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Why would this take a map?\n",
        "createdAt" : "2016-03-21T20:51:38Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "87bce828-0738-43be-bb40-e651db53b47e",
        "parentId" : "b147a5a3-bb9c-4f12-988c-0c0e3439ae1a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "application/json;pretty=1\n\nContent types declare options.\n",
        "createdAt" : "2016-03-21T21:36:33Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b6d0875a-b297-43ee-9c0c-caf89e2daf4f",
        "parentId" : "b147a5a3-bb9c-4f12-988c-0c0e3439ae1a",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Let me clarify if I understand correctly.\nBased on the ContentType, we choose serializerType, and for a given serializerType, we give opportunity to specialize it based on additional options. Am I right?\nIf so, I don't understand that last sentence of the comment:\n\"but could also be used to support strong typing via the content-type header\"\n\nCan you please clarify?\n",
        "createdAt" : "2016-03-22T08:36:50Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "eaee2d41-5bd9-442e-b2a1-8c9b51d8e2b8",
        "parentId" : "b147a5a3-bb9c-4f12-988c-0c0e3439ae1a",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Yes, you are correct.  Strong typing might be:\n\n```\napplication/protobuf; type=k8s.io/kubernetes/pkg/api/v1.Pod\n```\n\nwhere the caller asks for protobuf, specifies the type, and gets back a\nmessage in the exact format.  GRPC does this with a header, but it's\neffectively avoiding the need for a runtime type mapper.  I'll try to\nclarify the comment to something more useful.\n\nOn Tue, Mar 22, 2016 at 4:37 AM, Wojciech Tyczynski <\nnotifications@github.com> wrote:\n\n> In pkg/runtime/serializer/codec_factory.go\n> https://github.com/kubernetes/kubernetes/pull/23288#discussion_r56951070\n> :\n> \n> > -func NewCodecFactory(scheme *runtime.Scheme) CodecFactory {\n> > -   return newCodecFactory(scheme, json.DefaultMetaFactory)\n> > -   Serializer       runtime.Serializer\n> > -   PrettySerializer runtime.Serializer\n> > -   // RawSerializer serializes an object without adding a type wrapper. Some serializers, like JSON\n> > -   // automatically include identifying type information with the JSON. Others, like Protobuf, need\n> > -   // a wrapper object that includes type information. This serializer should be set if the serializer\n> > -   // can serialize / deserialize objects without type info. Note that this serializer is will always\n> > -   // be expected to pass into or a gvk to Decode, since no type information will be available.\n> > -   RawSerializer runtime.Serializer\n> >   +\n> > -   // Specialize gives the type the opportunity to return a different serializer implementation if\n> > -   // the content type contains alternate operations. Here it is used to implement \"pretty\" as an\n> > -   // option to application/json, but could also be used to support strong typing via the content-type\n> > -   // header.\n> > -   Specialize func(map[string]string) (runtime.Serializer, bool)\n> \n> Let me clarify if I understand correctly.\n> Based on the ContentType, we choose serializerType, and for a given\n> serializerType, we give opportunity to specialize it based on additional\n> options. Am I right?\n> If so, I don't understand that last sentence of the comment:\n> \"but could also be used to support strong typing via the content-type\n> header\"\n> \n> Can you please clarify?\n> \n> —\n> You are receiving this because you authored the thread.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/23288/files/d1795d969a42d04fad220f4c75f2b95f1cfceb85#r56951070\n",
        "createdAt" : "2016-03-23T01:28:27Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "54eaa56b921a4cd93ab5db5215d094decdc948bf",
    "line" : null,
    "diffHunk" : "@@ -1,1 +50,54 @@\t// option to application/json, but could also be used to allow serializers to perform type\n\t// defaulting or alter output.\n\tSpecialize func(map[string]string) (runtime.Serializer, bool)\n}\n"
  },
  {
    "id" : "e5aca5af-5491-41d0-8baf-8e782cc86db0",
    "prId" : 23288,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78aee83f-ac35-4add-afc2-4899ff4d8212",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This return seems the same as the above return. Why do you need to make different CodecFactories for these two cases?\n",
        "createdAt" : "2016-03-21T20:54:16Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "478e7ef4-daa6-4f45-bac3-4a4ad68ac159",
        "parentId" : "78aee83f-ac35-4add-afc2-4899ff4d8212",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Today, application/json for a watch and regular list call are the same\nserializer.  application/yaml or protobuf would not be - when we write\na framed proto message or a \"---\" delimited yaml object the delimiter\nmust be written after each object (or before, for proto).  So a\nstreaming serializer and a regular serializer are not quite the same.\nFurthermore, the streaming serializer also needs to be a regular\nserializer (object -> yaml doc).\n\nThat said, part of the open design question was whether the streaming\ncodec is a different interface, which would make the one factory\nreturn something different.  The constant call is the mime type, but\nwhat happens on encode and decode is different between streaming vs\nnot.\n",
        "createdAt" : "2016-03-21T21:41:18Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "91cad056-3025-4c84-89ff-f877bf5aafc2",
        "parentId" : "78aee83f-ac35-4add-afc2-4899ff4d8212",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Also, I don't want code like the client or server dictating framing -\nframing is intrinsic to a defined mime type.\n",
        "createdAt" : "2016-03-21T21:41:57Z",
        "updatedAt" : "2016-03-23T21:25:25Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "54eaa56b921a4cd93ab5db5215d094decdc948bf",
    "line" : null,
    "diffHunk" : "@@ -1,1 +106,110 @@// TODO: determine whether this returns a streaming.Serializer AND runtime.Serializer, or whether\n// streaming should be added to the CodecFactory interface.\nfunc NewStreamingCodecFactory(scheme *runtime.Scheme) CodecFactory {\n\treturn newStreamingCodecFactory(scheme, json.DefaultMetaFactory)\n}"
  },
  {
    "id" : "5c46eb88-6abc-4bbe-b13f-8dbea89311b2",
    "prId" : 20377,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a4fa5066-8b02-4078-8847-5f1a8cd3cee0",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "What's that? Can you please add a comment?\n",
        "createdAt" : "2016-02-26T13:44:27Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "718938d3-bbe0-4e89-b24f-4618139220f1",
        "parentId" : "a4fa5066-8b02-4078-8847-5f1a8cd3cee0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Names probably aren't very good, this takes the extra flags provided on the\nmime type and passes them to a function which can do more specific checks.\nSo if we had a content-type\n\"application/vnd.kubernetes.protobuf;type=Event\" the map {\"type\": \"Event\"}\nis passed to specialize.  It's used today for \"pretty\".  Will add a comment.\n\nOn Fri, Feb 26, 2016 at 7:44 AM, Wojciech Tyczynski <\nnotifications@github.com> wrote:\n\n> In pkg/runtime/serializer/codec_factory.go\n> https://github.com/kubernetes/kubernetes/pull/20377#discussion_r54243769\n> :\n> \n> > -// NewCodecFactory provides methods for retrieving serializers for the supported wire formats\n> > -// and conversion wrappers to define preferred internal and external versions. In the future,\n> > -// as the internal version is used less, callers may instead use a defaulting serializer and\n> > -// only convert objects which are shared internally (Status, common API machinery).\n> > -// TODO: allow other codecs to be compiled in?\n> > -// TODO: accept a scheme interface\n> > -func NewCodecFactory(scheme *runtime.Scheme) CodecFactory {\n> > -   return newCodecFactory(scheme, json.DefaultMetaFactory)\n> > -   Serializer       runtime.Serializer\n> > -   PrettySerializer runtime.Serializer\n> > -   // If set, will be used for streaming codecs. This serializer is assumed to not need explicit\n> > -   // typing via a wrapper.\n> > -   ImplicitSerializer runtime.Serializer\n> >   +\n> > -   Specialize func(map[string]string) (runtime.Serializer, bool)\n> \n> What's that? Can you please add a comment?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20377/files#r54243769.\n",
        "createdAt" : "2016-03-09T05:02:27Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "19a74d19-bd3c-4f6d-ae62-a984a94c5ac4",
        "parentId" : "a4fa5066-8b02-4078-8847-5f1a8cd3cee0",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Added comment in #23288\n",
        "createdAt" : "2016-03-21T18:03:16Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2139b186ccaac91a28473ce872a825fbed31691",
    "line" : null,
    "diffHunk" : "@@ -1,1 +50,54 @@\t// option to application/json, but could also be used to allow serializers to perform type\n\t// defaulting or alter output.\n\tSpecialize func(map[string]string) (runtime.Serializer, bool)\n}\n"
  },
  {
    "id" : "0888d705-9aa7-492b-b21e-54a5d80dfb2b",
    "prId" : 20377,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "590106d2-f27e-4eda-af9a-3ece6ab6601c",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "We need to define it first (IIUC we don't have scheme interface yet) :)\n",
        "createdAt" : "2016-03-10T12:38:41Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2139b186ccaac91a28473ce872a825fbed31691",
    "line" : null,
    "diffHunk" : "@@ -1,1 +97,101 @@// only convert objects which are shared internally (Status, common API machinery).\n// TODO: allow other codecs to be compiled in?\n// TODO: accept a scheme interface\nfunc NewCodecFactory(scheme *runtime.Scheme) CodecFactory {\n\tserializers := newSerializersForScheme(scheme, json.DefaultMetaFactory)"
  },
  {
    "id" : "54953b58-fced-40dc-ae1c-315d971ff8f2",
    "prId" : 20377,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc35f5d5-7d65-4453-8a04-cd068cd605fb",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "IIUC, nothing is implementing Framer interface for now. That means streamers will always be empty.\nCan you please add a TODO in json/yaml/proto serializer to make the implements streaming.Framer?\n",
        "createdAt" : "2016-03-10T12:43:38Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "2ffa544c-bc25-498c-a6ee-0d45388e636c",
        "parentId" : "bc35f5d5-7d65-4453-8a04-cd068cd605fb",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That's in the watch branch (not a PR yet), I will add the comment here.\n\nOn Thu, Mar 10, 2016 at 7:43 AM, Wojciech Tyczynski <\nnotifications@github.com> wrote:\n\n> In pkg/runtime/serializer/codec_factory.go\n> https://github.com/kubernetes/kubernetes/pull/20377#discussion_r55673068\n> :\n> \n> > +}\n> > +\n> > +// NewStreamingCodecFactory returns serializers that support the streaming.Serializer interface.\n> > +func NewStreamingCodecFactory(scheme *runtime.Scheme) CodecFactory {\n> > -   return newStreamingCodecFactory(scheme, json.DefaultMetaFactory)\n> >   +}\n> >   +\n> >   +// newStreamingCodecFactory handles providing streaming codecs\n> >   +func newStreamingCodecFactory(scheme *runtime.Scheme, mf json.MetaFactory) CodecFactory {\n> > -   serializers := newSerializersForScheme(scheme, mf)\n> > -   streamers := []serializerType{}\n> > -   for i := range serializers {\n> > -       if serializers[i].ImplicitSerializer != nil {\n> > -           serializers[i].Serializer = serializers[i].ImplicitSerializer\n> > -       }\n> > -       if s, ok := serializers[i].Serializer.(streaming.Framer); ok {\n> \n> IIUC, nothing is implementing Framer interface for now. That means\n> streamers will always be empty.\n> Can you please add a TODO in json/yaml/proto serializer to make the\n> implements streaming.Framer?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/20377/files#r55673068.\n",
        "createdAt" : "2016-03-10T16:01:12Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "b7e33569-8cf0-46ad-8117-c87f573cc1ec",
        "parentId" : "bc35f5d5-7d65-4453-8a04-cd068cd605fb",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Added comment in #23288\n",
        "createdAt" : "2016-03-21T18:05:08Z",
        "updatedAt" : "2016-03-31T15:38:20Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2139b186ccaac91a28473ce872a825fbed31691",
    "line" : null,
    "diffHunk" : "@@ -1,1 +118,122 @@\t\t\tserializers[i].Serializer = serializers[i].RawSerializer\n\t\t}\n\t\tif s, ok := serializers[i].Serializer.(streaming.Framer); ok {\n\t\t\t// TODO: more elegant option?\n\t\t\t// TODO: add tests and assertions for which serializers should"
  }
]
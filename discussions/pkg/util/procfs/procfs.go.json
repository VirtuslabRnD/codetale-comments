[
  {
    "id" : "b5219733-50bf-4ea1-a275-53a4335364ad",
    "prId" : 30087,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c51957f-de3e-4650-9bb0-a9375bbe9801",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "This is slightly different from `pkill`'s behavior. `pkill` would continue killing all matching processes.\n",
        "createdAt" : "2016-08-10T17:29:56Z",
        "updatedAt" : "2016-08-10T21:15:12Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce93cb9d9c595dfc635f81b3f3ba3addfae3a17d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +82,86 @@\terrList := []error{}\n\tfor _, pid := range pids {\n\t\tif err = syscall.Kill(pid, sig); err != nil {\n\t\t\terrList = append(errList, err)\n\t\t}"
  },
  {
    "id" : "53c0dac1-62bc-4ae9-b75b-edf1c2772336",
    "prId" : 30087,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a074cc48-f976-49f5-b762-aea6d9450349",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Add godoc style comment for the function.\n",
        "createdAt" : "2016-08-10T20:20:47Z",
        "updatedAt" : "2016-08-10T21:15:12Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "776b94e1-bbb4-4c02-8877-de0d68647a92",
        "parentId" : "a074cc48-f976-49f5-b762-aea6d9450349",
        "authorId" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "body" : "Ack\n",
        "createdAt" : "2016-08-10T21:14:36Z",
        "updatedAt" : "2016-08-10T21:15:12Z",
        "lastEditedBy" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce93cb9d9c595dfc635f81b3f3ba3addfae3a17d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +68,72 @@// Find process(es) using a regular expression and send a specified\n// signal to each process\nfunc PKill(name string, sig syscall.Signal) error {\n\tif len(name) == 0 {\n\t\treturn fmt.Errorf(\"name should not be empty\")"
  },
  {
    "id" : "aa81dd85-9fb2-4697-8185-55dea3304e3e",
    "prId" : 30087,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5e2682a-1cba-4765-b75f-8600acbca3a1",
        "parentId" : null,
        "authorId" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "body" : "Add godoc style comment for the function.\n",
        "createdAt" : "2016-08-10T20:20:51Z",
        "updatedAt" : "2016-08-10T21:15:12Z",
        "lastEditedBy" : "1bd2d65a-7c93-4c22-b408-c7794d037dc5",
        "tags" : [
        ]
      },
      {
        "id" : "078cdbf5-56c3-467f-a576-4b7fc7931f36",
        "parentId" : "e5e2682a-1cba-4765-b75f-8600acbca3a1",
        "authorId" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "body" : "Ack\n",
        "createdAt" : "2016-08-10T21:14:29Z",
        "updatedAt" : "2016-08-10T21:15:12Z",
        "lastEditedBy" : "bd04f755-e62f-45fb-8771-4cc2b5db49d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "ce93cb9d9c595dfc635f81b3f3ba3addfae3a17d",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +102,106 @@}\n\nfunc getPids(re *regexp.Regexp) []int {\n\tpids := []int{}\n\tfilepath.Walk(\"/proc\", func(path string, info os.FileInfo, err error) error {"
  },
  {
    "id" : "c96a8ddb-a030-461b-8715-8e435db368d5",
    "prId" : 12182,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f7692da9-6edc-49b1-b5fe-bf07c93a5633",
        "parentId" : null,
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "@vmarmol: Is \"devices\" mounted by default on all containers?\n",
        "createdAt" : "2015-08-06T20:26:46Z",
        "updatedAt" : "2015-08-07T18:18:46Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      },
      {
        "id" : "75661c93-6ca5-4c5f-9071-55207cae55ab",
        "parentId" : "f7692da9-6edc-49b1-b5fe-bf07c93a5633",
        "authorId" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "body" : "@rjnagal said we check for this, and can assume this, I believe?\n",
        "createdAt" : "2015-08-06T21:20:34Z",
        "updatedAt" : "2015-08-07T18:18:46Z",
        "lastEditedBy" : "3c734967-9d67-42aa-a243-d401c1524cb6",
        "tags" : [
        ]
      },
      {
        "id" : "b2baa23c-e90c-43ca-82f4-c21e4ad8a3c6",
        "parentId" : "f7692da9-6edc-49b1-b5fe-bf07c93a5633",
        "authorId" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "body" : "We have to assume device cgroup mounted to make docker container work. :-) \n",
        "createdAt" : "2015-08-07T16:45:04Z",
        "updatedAt" : "2015-08-07T18:18:46Z",
        "lastEditedBy" : "a6409368-42e0-44a9-bf79-9d3042ac3b65",
        "tags" : [
        ]
      },
      {
        "id" : "f30ca2fa-4d98-41f6-a15f-495fa38aaac0",
        "parentId" : "f7692da9-6edc-49b1-b5fe-bf07c93a5633",
        "authorId" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "body" : "yes, docker/libcontainer would not work if devices is not mounted. If there is no device cgroup, there will be no docker containers, and no qos :)\n\nNo new dependencies here.\n",
        "createdAt" : "2015-08-07T16:49:07Z",
        "updatedAt" : "2015-08-07T18:18:46Z",
        "lastEditedBy" : "88a0ee93-4188-47b5-8881-3624e4a411f2",
        "tags" : [
        ]
      },
      {
        "id" : "47af4a69-50ba-420c-b301-161530eb7aa4",
        "parentId" : "f7692da9-6edc-49b1-b5fe-bf07c93a5633",
        "authorId" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "body" : "Ack. \n",
        "createdAt" : "2015-08-07T17:31:50Z",
        "updatedAt" : "2015-08-07T18:18:46Z",
        "lastEditedBy" : "c4b970b3-3b9c-4773-bc9b-f8d005b15fd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ef3de1d5f1d4b19c154ba15f2bd4686b6036f0c",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +35,39 @@\tfor _, line := range lines {\n\t\tentries := strings.SplitN(line, \":\", 3)\n\t\tif len(entries) == 3 && entries[1] == \"devices\" {\n\t\t\treturn strings.TrimSpace(entries[2]), nil\n\t\t}"
  }
]
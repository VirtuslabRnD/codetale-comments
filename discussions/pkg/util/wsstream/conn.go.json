[
  {
    "id" : "15b4c4eb-0819-4234-a054-5abb96bbab9f",
    "prId" : 26541,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "939dcb3f-3d0e-474a-bfcd-2fcb84e6f63e",
        "parentId" : null,
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "one line too much\n",
        "createdAt" : "2016-08-12T15:42:17Z",
        "updatedAt" : "2016-08-20T13:59:09Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "e792d4117d8735784f4d830ad1c9d4f68cfee145",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +156,160 @@// future use. The channel types for each channel are passed as an array, supporting the different\n// duplex modes. Read and Write refer to whether the channel can be used as a Reader or Writer.\n//\n// The protocols parameter maps subprotocol names to ChannelProtocols. The empty string subprotocol\n// name is used if websocket.Config.Protocol is empty."
  },
  {
    "id" : "f91e2aa5-0bad-4b7a-8e71-b0d0541f43dc",
    "prId" : 13885,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d2ec8ab-e6c6-472e-a955-5aa12e459cf1",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "It's too bad you have to allocate a new byte array and copy into it just to prepend the channel number. Is there any alternative?\n",
        "createdAt" : "2015-09-22T14:22:58Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "479680c3-f98c-4281-8198-620df4e98a6b",
        "parentId" : "3d2ec8ab-e6c6-472e-a955-5aa12e459cf1",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Not with message framing, no.\n",
        "createdAt" : "2015-09-23T20:44:45Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9136d49dc9090142b7ad2838af91703666713d76",
    "line" : 252,
    "diffHunk" : "@@ -1,1 +250,254 @@\t\tframe := make([]byte, len(data)+1)\n\t\tframe[0] = num\n\t\tcopy(frame[1:], data)\n\t\tif err := websocket.Message.Send(conn.ws, frame); err != nil {\n\t\t\treturn 0, err"
  },
  {
    "id" : "8bef9295-92cd-4032-aa4e-465156befef6",
    "prId" : 13885,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ac8d601-efa4-41ed-8f15-c1fee37f2d0e",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "You defer `conn.Close()` both here and in `conn.handle`. Is that appropriate? Harmful in any way?\n",
        "createdAt" : "2015-09-22T14:26:56Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "6e9a8cc7-86fa-4efe-baef-c35eb8449010",
        "parentId" : "6ac8d601-efa4-41ed-8f15-c1fee37f2d0e",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "If the websocket server (not our code) exits without invoking our code, the connection has to be closed.  Test code directly invokes handle.  The call is reentrant, and both places guarantee we properly close the WS.\n",
        "createdAt" : "2015-09-23T20:43:18Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9136d49dc9090142b7ad2838af91703666713d76",
    "line" : 169,
    "diffHunk" : "@@ -1,1 +167,171 @@\tgo func() {\n\t\tdefer util.HandleCrash()\n\t\tdefer conn.Close()\n\t\twebsocket.Server{Handshake: conn.handshake, Handler: conn.handle}.ServeHTTP(w, req)\n\t}()"
  },
  {
    "id" : "a279662e-fcb1-4221-b83e-9cf941497dc0",
    "prId" : 13885,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de11c09c-efb2-4f1b-9b6d-97162a452f92",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Godoc needed?\n",
        "createdAt" : "2015-09-22T14:34:33Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9136d49dc9090142b7ad2838af91703666713d76",
    "line" : null,
    "diffHunk" : "@@ -1,1 +290,294 @@// DataFromSocket is invoked by the connection receiver to move data from the connection\n// into a specific channel.\nfunc (p *websocketChannel) DataFromSocket(data []byte) (int, error) {\n\tif !p.read {\n\t\treturn len(data), nil"
  },
  {
    "id" : "6901730c-339f-468c-894c-1103d625229a",
    "prId" : 13885,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aaed245-9ec7-43fb-bc1d-68da4a924f99",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Should the channels be closed before the ws conn?\n",
        "createdAt" : "2015-09-22T14:35:24Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      },
      {
        "id" : "81f71902-12bb-49d7-8b99-02f19242285c",
        "parentId" : "1aaed245-9ec7-43fb-bc1d-68da4a924f99",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I will change the order, if you have pending data behavior is undefined anyway (you should finish your writing before closing).\n",
        "createdAt" : "2015-09-23T20:44:06Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "9136d49dc9090142b7ad2838af91703666713d76",
    "line" : null,
    "diffHunk" : "@@ -1,1 +203,207 @@func (conn *Conn) Close() error {\n\t<-conn.ready\n\tfor _, s := range conn.channels {\n\t\ts.Close()\n\t}"
  },
  {
    "id" : "9212b255-01d7-4f4f-b24b-ae4acbe6faac",
    "prId" : 13885,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d6e18ddd-70ac-4484-976a-b9c4b2126118",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Could you put a comment for what this matches?\n",
        "createdAt" : "2015-09-22T14:38:02Z",
        "updatedAt" : "2015-10-09T18:31:43Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9136d49dc9090142b7ad2838af91703666713d76",
    "line" : null,
    "diffHunk" : "@@ -1,1 +81,85 @@var (\n\t// connectionUpgradeRegex matches any Connection header value that includes upgrade\n\tconnectionUpgradeRegex = regexp.MustCompile(\"(^|.*,\\\\s*)upgrade($|\\\\s*,)\")\n)\n"
  }
]
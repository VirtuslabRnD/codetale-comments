[
  {
    "id" : "0d0c569b-3a76-4261-b765-51f808aa3440",
    "prId" : 28179,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2413360b-aec0-426f-b86e-f9afd5e4ccb5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "extract locating the existing index so we can test the search in isolation?\n\nalso, I don't know how long this slice will be, so I'd rather avoid removing and readding an item when we could just move the item within the list.\n\n```\ninsertionIndex = ...\n\nif exists {\n  if existingIndex = ...; insertionIndex != existingIndex {\n    move(entries, existingIndex, insertionIndex)\n  }\n  entries[insertionIndex] = entry\n} else {\n  ... current insertion behavior\n}\n```\n",
        "createdAt" : "2016-06-30T05:39:10Z",
        "updatedAt" : "2016-07-05T11:45:00Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "107b99b6-956e-461b-a953-9edba8b16de9",
        "parentId" : "2413360b-aec0-426f-b86e-f9afd5e4ccb5",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> extract locating the existing index so we can do this (also makes it easy to test the search in isolation)?\n\nI'm ok splitting out `findEntryIndex`, but the rest seems a little pointless.  In a sane implementation, the capacity is unlikely to change on a shrink by one operation.\n",
        "createdAt" : "2016-06-30T11:41:08Z",
        "updatedAt" : "2016-07-05T11:45:00Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "56598898e1bac7fb09bc41540a1d28d41706c7d8",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +191,195 @@\n\t// if the entry exists and is scheduled for later, go ahead and remove the entry\n\tif exists {\n\t\tif existingIndex := findEntryIndex(entries, existingTime, entry.data); existingIndex >= 0 && existingIndex < len(entries) {\n\t\t\tentries = append(entries[:existingIndex], entries[existingIndex+1:]...)"
  },
  {
    "id" : "a2001240-8a2d-4005-bd96-781d1e73bf16",
    "prId" : 24052,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb79313e-b0d0-4643-976c-280e92b49bd8",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "'Delayer' is probably the \"goish\" name.\n",
        "createdAt" : "2016-04-11T23:19:13Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf95b124e66acf503e6699e42504d8a5d45883ca",
    "line" : null,
    "diffHunk" : "@@ -1,1 +27,31 @@// DelayingInterface is an Interface that can Add an item at a later time.  This makes it easier to\n// requeue items after failures without ending up in a hot-loop.\ntype DelayingInterface interface {\n\tInterface\n\t// AddAfter adds an item to the workqueue after the indicated duration has passed"
  },
  {
    "id" : "99d46872-1ab4-4b63-a1cb-5dc15b22a9bf",
    "prId" : 24052,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f7828d1-8d18-4422-8781-833da1a2dd64",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Was this block necessary for some reason?\n",
        "createdAt" : "2016-04-11T23:27:02Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "5e558f4e-1303-4421-90f0-00628095acff",
        "parentId" : "9f7828d1-8d18-4422-8781-833da1a2dd64",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Seemed more efficient than adding one item from the channel per time through the loop\n",
        "createdAt" : "2016-04-11T23:47:31Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "9555dd7f-2051-4dc3-8cd4-d244219f6bf2",
        "parentId" : "9f7828d1-8d18-4422-8781-833da1a2dd64",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "My preference is to optimize for code simplicity unless you measured it and it will cause a problem.\n",
        "createdAt" : "2016-04-11T23:57:37Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "bcfb1920-d7dd-4a2a-9f2a-5124fddc8fe0",
        "parentId" : "9f7828d1-8d18-4422-8781-833da1a2dd64",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> My preference is to optimize for code simplicity unless you measured it and it will cause a problem.\n\nIf you don't drain the channel, the order of queued items can get weird on close times.  This makes external behavior more predictable.\n",
        "createdAt" : "2016-04-12T11:42:56Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "6df79099-0335-4fc7-98f6-060fce22fa3d",
        "parentId" : "9f7828d1-8d18-4422-8781-833da1a2dd64",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think this drain makes the \"weird\" cases rarer but does not eliminate them.\n",
        "createdAt" : "2016-04-12T20:57:47Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf95b124e66acf503e6699e42504d8a5d45883ca",
    "line" : null,
    "diffHunk" : "@@ -1,1 +158,162 @@\t\t\t}\n\n\t\t\tdrained := false\n\t\t\tfor !drained {\n\t\t\t\tselect {"
  },
  {
    "id" : "6928ac0e-f6fe-43c5-b83e-667bd912f3ee",
    "prId" : 24052,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7157f438-86a7-4803-95e8-0a9fec570ec5",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Maybe wrap this in a `if readyEntries > 0`-- reuse the previous one if nothing changed. Try not to leak more timers than necessary.\n",
        "createdAt" : "2016-04-11T23:32:05Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "da70ad25-a6cc-4e3b-b42f-893e40996ab5",
        "parentId" : "7157f438-86a7-4803-95e8-0a9fec570ec5",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "`> 0` check is already there. Reusing if the readyAt hasn't changed since the last time seems ok\n",
        "createdAt" : "2016-04-11T23:45:22Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf95b124e66acf503e6699e42504d8a5d45883ca",
    "line" : null,
    "diffHunk" : "@@ -1,1 +135,139 @@\t\tq.waitingForAdd = q.waitingForAdd[readyEntries:]\n\n\t\t// Set up a wait for the first item's readyAt (if one exists)\n\t\tnextReadyAt := never\n\t\tif len(q.waitingForAdd) > 0 {"
  },
  {
    "id" : "4db84548-42ad-4a14-8eaa-2b2e8093ab51",
    "prId" : 24052,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c47a8cf7-ceaf-412e-934c-76e7ab5a34ee",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "If this became item 0, should re-make the nextReadyAt channel.\n",
        "createdAt" : "2016-04-11T23:33:35Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "faaf2907-8bc6-4b79-9407-700e953591dd",
        "parentId" : "c47a8cf7-ceaf-412e-934c-76e7ab5a34ee",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Next time through the loop would do that (possibly conditional on the next readyAt having changed)\n",
        "createdAt" : "2016-04-11T23:50:04Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "413dd1fb-0118-4730-a1d7-dc9b3affb360",
        "parentId" : "c47a8cf7-ceaf-412e-934c-76e7ab5a34ee",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Maybe the current 0 is going to fire in 9 seconds but the one you're adding wants to fire in 1 second.\n",
        "createdAt" : "2016-04-11T23:56:50Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "63a0c28e-8efb-45f6-9b3f-3a281d05dae1",
        "parentId" : "c47a8cf7-ceaf-412e-934c-76e7ab5a34ee",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "This case means we're no longer waiting on the current 0's nextReadyAt channel, and instead will get the channel for the new 0's readyAt when we go back through the loop\n",
        "createdAt" : "2016-04-12T00:03:04Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf95b124e66acf503e6699e42504d8a5d45883ca",
    "line" : null,
    "diffHunk" : "@@ -1,1 +153,157 @@\t\tcase waitEntry := <-q.waitingForAddCh:\n\t\t\tif waitEntry.readyAt.After(q.clock.Now()) {\n\t\t\t\tq.waitingForAdd = insert(q.waitingForAdd, waitEntry)\n\t\t\t} else {\n\t\t\t\tq.Add(waitEntry.data)"
  },
  {
    "id" : "4e59e3f7-531f-41ca-ae67-4abc19eae0fb",
    "prId" : 24052,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26f1bd79-c35e-41dc-8708-f134579f9d81",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I have a mild preference for fixing whatever it is that caused you to add this :)\n",
        "createdAt" : "2016-04-11T23:40:46Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "9fc7af51-a745-429f-ad7d-be749f0d97ea",
        "parentId" : "26f1bd79-c35e-41dc-8708-f134579f9d81",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "Hard to fix paranoia borne from years of being bitten by the vagaries of time :)\n",
        "createdAt" : "2016-04-11T23:43:56Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "43101415-b047-4698-b5d0-dd2a061647ba",
        "parentId" : "26f1bd79-c35e-41dc-8708-f134579f9d81",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I have a mild preference for fixing whatever it is that caused you to add this :)\n\nFear due to having been bit many times in the past.  Time is weird and not moving forward is the least of its worries.  The heartbeat gives me confidence that I'll never have a lingering item.  No specific bug known as of yet.\n",
        "createdAt" : "2016-04-11T23:53:58Z",
        "updatedAt" : "2016-05-10T13:04:42Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf95b124e66acf503e6699e42504d8a5d45883ca",
    "line" : null,
    "diffHunk" : "@@ -1,1 +105,109 @@// maxWait keeps a max bound on the wait time.  It's just insurance against weird things happening.\n// Checking the queue every 10 seconds isn't expensive and we know that we'll never end up with an\n// expired item sitting for more than 10 seconds.\nconst maxWait = 10 * time.Second\n"
  },
  {
    "id" : "42d3c336-7b02-45fd-bb8d-d16ca0159cb9",
    "prId" : 23444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63fbde9f-86d9-4d3f-b3bb-b7b9be221d52",
        "parentId" : null,
        "authorId" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "body" : "Godoc?\n",
        "createdAt" : "2016-03-29T16:45:40Z",
        "updatedAt" : "2016-04-07T19:10:58Z",
        "lastEditedBy" : "b15d5707-82a8-4448-b49d-a2d6502b10f9",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf097ea233126a4d63f99cec25cdcc27f907794b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +27,31 @@// DelayingInterface is an Interface that can Add an item at a later time.  This makes it easier to\n// requeue items after failures without ending up in a hot-loop.\ntype DelayingInterface interface {\n\tInterface\n\t// AddAfter adds an item to the workqueue after the indicated duration has passed"
  },
  {
    "id" : "7ea8450a-15b1-4fea-a82a-ec9c7032b094",
    "prId" : 23444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ee1e104-8fd5-47ff-8c1f-c4122f0d4649",
        "parentId" : null,
        "authorId" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "body" : "I know this is internal, and maybe it should all be obvious, but it would be useful to have comments explaining each struct and its members.\n",
        "createdAt" : "2016-03-31T20:29:13Z",
        "updatedAt" : "2016-04-07T19:10:58Z",
        "lastEditedBy" : "6eca0ade-9879-4dd7-ad14-547e16f5c041",
        "tags" : [
        ]
      },
      {
        "id" : "b7c31cca-ba20-4064-8bdc-9c4cdcf3b7f8",
        "parentId" : "5ee1e104-8fd5-47ff-8c1f-c4122f0d4649",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I know this is internal, and maybe it should all be obvious, but it would be useful to have comments explaining each struct and its members.\n\nWill do.\n",
        "createdAt" : "2016-04-01T00:16:05Z",
        "updatedAt" : "2016-04-07T19:10:58Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "1e81c210-f4c8-4e72-b83c-37ee6393c8e0",
        "parentId" : "5ee1e104-8fd5-47ff-8c1f-c4122f0d4649",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> I know this is internal, and maybe it should all be obvious, but it would be useful to have comments explaining each struct and its members.\n\nLots of comments added.\n",
        "createdAt" : "2016-04-05T12:19:41Z",
        "updatedAt" : "2016-04-07T19:10:58Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf097ea233126a4d63f99cec25cdcc27f907794b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +53,57 @@\n// delayingType wraps an Interface and provides delayed re-enquing\ntype delayingType struct {\n\tInterface\n"
  },
  {
    "id" : "59146a32-4730-4e00-b13b-0ecf7a439513",
    "prId" : 23444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23efef4d-406e-4ae5-b4f5-44d1edc565d7",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "call `q.clock.Now()` once and use the same result for both calculations\n",
        "createdAt" : "2016-04-05T14:56:38Z",
        "updatedAt" : "2016-04-07T19:10:58Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf097ea233126a4d63f99cec25cdcc27f907794b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +174,178 @@\t}\n}\n\n// inserts the given entry into the sorted entries list\n// same semantics as append()... the given slice may be modified,"
  },
  {
    "id" : "04166abc-1dc4-4afa-8582-665536ba4d1e",
    "prId" : 23444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5a31eb6-f4c7-4f01-8b0a-878c900bdea8",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Looks so wrong, but docs say its right.  Who thought I'd miss the bad old `strncpy` style days.\n",
        "createdAt" : "2016-04-06T14:57:25Z",
        "updatedAt" : "2016-04-07T19:10:58Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf097ea233126a4d63f99cec25cdcc27f907794b",
    "line" : 188,
    "diffHunk" : "@@ -1,1 +186,190 @@\tentries = append(entries, waitFor{})\n\t// shift items from the insertion point to the end\n\tcopy(entries[insertionIndex+1:], entries[insertionIndex:])\n\t// insert the record\n\tentries[insertionIndex] = entry"
  }
]
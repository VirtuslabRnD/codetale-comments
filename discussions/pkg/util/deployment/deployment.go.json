[
  {
    "id" : "835ee1ca-f347-456a-b4d0-6c788167bed9",
    "prId" : 27012,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54699b71-2f09-4e07-98aa-6b34fc4f1e34",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Do you really need to return here? If a replica set has an invalid label selector then isn't it fine to just ignore it and try to update the deployment status anyway?\n",
        "createdAt" : "2016-06-10T00:12:30Z",
        "updatedAt" : "2016-06-10T16:55:37Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "26b5a52d-f654-457a-9f87-16f4be189af8",
        "parentId" : "54699b71-2f09-4e07-98aa-6b34fc4f1e34",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "@kargakis You may be right, but since this keeps the old behavior w.r.t. handling errors and today is the last day to get 1.3 stuff in, I vote that we should do it in a follow up if at all.\n",
        "createdAt" : "2016-06-10T16:14:33Z",
        "updatedAt" : "2016-06-10T16:55:37Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "764df2e096333e79fedf31dace1a71510218af5d",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +381,385 @@\t\tmatchingFunc, err := rsutil.MatchingPodsFunc(rs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif matchingFunc == nil {"
  },
  {
    "id" : "14d2b2f8-96aa-4343-897d-2d2f7091f53d",
    "prId" : 26922,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7939ae4-9fe8-44c4-baaf-4126a96d20c7",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Out of scope for this PR, but for failed sanity checks such as this one, we may want to start putting stack traces in the error to help debug what is going on.\n",
        "createdAt" : "2016-06-07T16:38:22Z",
        "updatedAt" : "2016-06-12T00:29:56Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "1980f7104f96c7964bf60ddb0c55f646e5fcb698",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +120,124 @@\t// This is checked by validation (of resources contain a podTemplateSpec).\n\tif len(template1.Labels) == 0 || len(template2.Labels) == 0 {\n\t\treturn false, fmt.Errorf(\"Unexpected empty labels found in given template\")\n\t}\n\thash1 := template1.Labels[extensions.DefaultDeploymentUniqueLabelKey]"
  },
  {
    "id" : "bd92f108-e66b-4931-9953-9a3df3416df4",
    "prId" : 26792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba92af62-5f48-476c-a3a6-813bce443e6d",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Add a comment about why these will never be empty.  (The PT must have a label so label selectors can find them.  This is checked by validation.)\n",
        "createdAt" : "2016-06-06T21:50:17Z",
        "updatedAt" : "2016-06-07T00:10:38Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "68617b09-a8ff-4d04-8595-e2232d999b6b",
        "parentId" : "ba92af62-5f48-476c-a3a6-813bce443e6d",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "done\n",
        "createdAt" : "2016-06-06T23:46:51Z",
        "updatedAt" : "2016-06-07T00:10:38Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3d905776eb7f35d45e0e3373c58345bcdd53beb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +148,152 @@\t// The podTemplateSpec must have a non-empty label so that label selectors can find them.\n\t// This is checked by validation (of resources contain a podTemplateSpec).\n\tif len(template1.Labels) == 0 || len(template2.Labels) == 0 {\n\t\treturn false, fmt.Errorf(\"Unexpected empty labels found in given template\")\n\t}"
  },
  {
    "id" : "5c0f454c-1033-4379-882e-7b968ebd0d6c",
    "prId" : 26792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b27220c7-f535-499b-b771-70e4a1f21903",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Given an example of an API change that would caused this (e.g. the addition of a new defaulted field will cause the hash code to change even when it is unspecified due to the defaulting.)\n",
        "createdAt" : "2016-06-06T21:51:35Z",
        "updatedAt" : "2016-06-07T00:10:38Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "b6c92eb8-d8fb-4e89-8531-ed41e54981f7",
        "parentId" : "b27220c7-f535-499b-b771-70e4a1f21903",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "added\n",
        "createdAt" : "2016-06-06T23:46:39Z",
        "updatedAt" : "2016-06-07T00:10:38Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3d905776eb7f35d45e0e3373c58345bcdd53beb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +142,146 @@\n// equalIgnoreHash returns true if two given podTemplateSpec are equal, ignoring the diff in value of Labels[pod-template-hash]\n// We ignore pod-template-hash because the hash result would be different upon podTemplateSpec API changes\n// (e.g. the addition of a new field will cause the hash code to change)\n// Note that we assume input podTemplateSpecs contain non-empty labels"
  },
  {
    "id" : "c535f0c2-c5f2-413f-891a-059d2d311071",
    "prId" : 26792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03899a5f-b5d4-4741-b61a-06d1a47f2f3f",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "What difference is there between api.Semantic.DeepEqual and reflect.DeepEqual \n",
        "createdAt" : "2016-06-07T05:15:40Z",
        "updatedAt" : "2016-06-07T05:15:40Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "2c5c69d0-ccf6-4f47-af57-242ebee0848d",
        "parentId" : "03899a5f-b5d4-4741-b61a-06d1a47f2f3f",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "> // DeepEqual is like reflect.DeepEqual, but focused on semantic equality\n> // instead of memory equality.\n> //\n> // It will use e's equality functions if it finds types that match.\n> //\n> // An empty slice _is_ equal to a nil slice for our purposes; same for maps.\n",
        "createdAt" : "2016-06-07T16:53:00Z",
        "updatedAt" : "2016-06-07T16:53:00Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "dc5fe651-19ce-4b73-b869-b99625e3357a",
        "parentId" : "03899a5f-b5d4-4741-b61a-06d1a47f2f3f",
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "@pwittrock thanks\n",
        "createdAt" : "2016-06-08T19:06:35Z",
        "updatedAt" : "2016-06-08T19:06:35Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3d905776eb7f35d45e0e3373c58345bcdd53beb",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +156,160 @@\ttemplate1.Labels[extensions.DefaultDeploymentUniqueLabelKey] = hash2\n\tresult := api.Semantic.DeepEqual(template1, template2)\n\ttemplate1.Labels[extensions.DefaultDeploymentUniqueLabelKey] = hash1\n\treturn result, nil\n}"
  },
  {
    "id" : "2eb8e2b1-47fb-4814-8c6e-5ec0546d3bfb",
    "prId" : 26792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "512fbf3e-2ae6-41c6-807e-b6b55fd46d96",
        "parentId" : null,
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "Can we assume that these keys will always exist ? If yes then it means the above len() check is not needed.\n",
        "createdAt" : "2016-06-07T05:24:06Z",
        "updatedAt" : "2016-06-07T05:24:06Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      },
      {
        "id" : "3211b5a8-a175-4cee-b93b-313800054b05",
        "parentId" : "512fbf3e-2ae6-41c6-807e-b6b55fd46d96",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "From @janetkuo, the key may not exist for an Adopted RS.  However the Labels map should never be empty for a PT in a RS because the RS relies on the Pod labels to match its label selector.  The length check is a sanity check only.\n",
        "createdAt" : "2016-06-07T16:53:25Z",
        "updatedAt" : "2016-06-07T16:56:54Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "9787c497-745f-4b25-aa66-fbcc821b4ed3",
        "parentId" : "512fbf3e-2ae6-41c6-807e-b6b55fd46d96",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "len() check isn't for hash key existence but for non-empty labels. We expect it to be non-empty since validation code will do that check. That's a sanity check. \n",
        "createdAt" : "2016-06-07T16:56:03Z",
        "updatedAt" : "2016-06-07T16:56:03Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "378f153a-48e6-424e-bdef-c28fc9822adb",
        "parentId" : "512fbf3e-2ae6-41c6-807e-b6b55fd46d96",
        "authorId" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "body" : "@pwittrock @janetkuo thanks. if its just a sanity check, does it make sense to assert. Not sure if that is a best practice in golang or not.\n",
        "createdAt" : "2016-06-08T06:57:24Z",
        "updatedAt" : "2016-06-08T06:57:24Z",
        "lastEditedBy" : "224e1088-78fe-4bdd-99d1-31be3e464996",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3d905776eb7f35d45e0e3373c58345bcdd53beb",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +153,157 @@\thash1 := template1.Labels[extensions.DefaultDeploymentUniqueLabelKey]\n\thash2 := template2.Labels[extensions.DefaultDeploymentUniqueLabelKey]\n\t// compare equality ignoring pod-template-hash\n\ttemplate1.Labels[extensions.DefaultDeploymentUniqueLabelKey] = hash2\n\tresult := api.Semantic.DeepEqual(template1, template2)"
  },
  {
    "id" : "0cdd2051-3cf5-4b4c-8499-518364165c08",
    "prId" : 26792,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de685670-d4f1-4833-b455-d0d6a70601a8",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "lowercase\n",
        "createdAt" : "2016-06-07T10:26:36Z",
        "updatedAt" : "2016-06-07T10:26:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3d905776eb7f35d45e0e3373c58345bcdd53beb",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +149,153 @@\t// This is checked by validation (of resources contain a podTemplateSpec).\n\tif len(template1.Labels) == 0 || len(template2.Labels) == 0 {\n\t\treturn false, fmt.Errorf(\"Unexpected empty labels found in given template\")\n\t}\n\thash1 := template1.Labels[extensions.DefaultDeploymentUniqueLabelKey]"
  },
  {
    "id" : "ee629d33-4344-44ec-8dec-829086ae53ff",
    "prId" : 22948,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c8c376c0-048f-4d88-8a8a-5785ab1b3323",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Do we really need this operation? We find the new rs just by looking at its template. Why can't we pick all the rest of the replica sets as the old replica sets?\n",
        "createdAt" : "2016-03-14T21:33:05Z",
        "updatedAt" : "2016-03-15T17:23:35Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "51e38279-b12b-4be3-bec8-02015b85e190",
        "parentId" : "c8c376c0-048f-4d88-8a8a-5785ab1b3323",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "This is used to separate old RSes that have pods in pod list and those who don't. We use pods list originally because we get RSes from pods that matches deployment's selector. We can use rs's status.replicas to do the same thing. But this can be a follow up PR and shouldn't block this one. \n",
        "createdAt" : "2016-03-14T23:25:59Z",
        "updatedAt" : "2016-03-15T17:23:35Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "26bcdb1bd677b3319496cb5283287ddf83962df3",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +59,63 @@\t\treturn nil, nil, fmt.Errorf(\"error listing ReplicaSets: %v\", err)\n\t}\n\tpodList, err := ListPods(deployment,\n\t\tfunc(namespace string, options api.ListOptions) (*api.PodList, error) {\n\t\t\treturn c.Core().Pods(namespace).List(options)"
  },
  {
    "id" : "b7762c26-0e60-4846-b1d1-95fcc476f579",
    "prId" : 22516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02ecc16a-d7d5-4fb2-972b-57d6aea84958",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Why pointers?\n",
        "createdAt" : "2016-03-04T15:14:50Z",
        "updatedAt" : "2016-03-07T12:03:49Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "9f44580f-da35-40d6-8518-47bd02c5d662",
        "parentId" : "02ecc16a-d7d5-4fb2-972b-57d6aea84958",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Already used in the rest of the IntOrString helpers so I opted not to change that here.\n",
        "createdAt" : "2016-03-04T15:19:31Z",
        "updatedAt" : "2016-03-07T12:03:49Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "13889199762e28b39c67b08bebdad191d39c91b5",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +477,481 @@// 2 desired, max unavailable 0%, surge 1% - should scale new(+1), then old(-1), then new(+1), then old(-1)\n// 1 desired, max unavailable 0%, surge 1% - should scale new(+1), then old(-1)\nfunc ResolveFenceposts(maxSurge, maxUnavailable *intstrutil.IntOrString, desired int) (int, int, error) {\n\tsurge, err := intstrutil.GetValueFromIntOrPercent(maxSurge, desired, true)\n\tif err != nil {"
  },
  {
    "id" : "2826e7fd-7e59-4a0d-b41c-459e4b067637",
    "prId" : 22384,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40b3ca1b-df35-49e8-9d11-60a5f09c0bf3",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Comments!\n\nWhy do we continue if the update failed but there was no error? Isn't the only case where that could happen is in the case that the RS was deleted?\n",
        "createdAt" : "2016-03-03T02:08:09Z",
        "updatedAt" : "2016-03-03T19:46:19Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "fe63ea92-3032-4cf6-aeae-d90290ad742a",
        "parentId" : "40b3ca1b-df35-49e8-9d11-60a5f09c0bf3",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Even if there were another case, we couldn't continue to update the selector, because then the controller would never retry to update the label, since we bail above if the selector has already been updated.\n",
        "createdAt" : "2016-03-03T02:09:18Z",
        "updatedAt" : "2016-03-03T19:46:19Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "2b53d56e-dbb7-462c-ad52-339494cffd96",
        "parentId" : "40b3ca1b-df35-49e8-9d11-60a5f09c0bf3",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Changed to return whenever the rs/pod update isn't performed and retry in the next loop. Added comments as well.\n",
        "createdAt" : "2016-03-03T19:35:58Z",
        "updatedAt" : "2016-03-03T19:46:19Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "75e570832b7682ab5abd628dd4d7787698cfc567",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +195,199 @@\t\t\treturn nil, fmt.Errorf(\"error updating %s %s/%s pod template label with template hash: %v\", updatedRS.Kind, updatedRS.Namespace, updatedRS.Name, err)\n\t\t}\n\t\tif rsUpdated {\n\t\t\t// Make sure rs pod template is updated so that it won't create pods without the new label (orphaned pods).\n\t\t\tif updatedRS.Generation > updatedRS.Status.ObservedGeneration {"
  },
  {
    "id" : "aa9a6397-5d85-4ad8-9c5c-5d2c21c9d1b0",
    "prId" : 22245,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3dc3ec5f-699e-4cd8-b261-03feac909baf",
        "parentId" : null,
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Improve the returned error from `labelPodsWithHash` as well?\n",
        "createdAt" : "2016-03-02T01:39:19Z",
        "updatedAt" : "2016-03-02T01:58:46Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "28b481c0-8412-43b0-8cb5-084d42d48d26",
        "parentId" : "3dc3ec5f-699e-4cd8-b261-03feac909baf",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "Done\n",
        "createdAt" : "2016-03-02T01:58:49Z",
        "updatedAt" : "2016-03-02T01:58:49Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dae82f6f1e9e56403fab52ba9bf77d907ea873a",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +214,218 @@\t\treturn nil, fmt.Errorf(\"error in getting pod list for namespace %s and list options %+v: %s\", namespace, options, err)\n\t}\n\tif err = labelPodsWithHash(podList, c, namespace, hash); err != nil {\n\t\treturn nil, fmt.Errorf(\"error in adding template hash label %s to pods %+v: %s\", hash, podList, err)\n\t}"
  },
  {
    "id" : "b2c5c54d-aa70-498a-ab89-2a2505748a11",
    "prId" : 22243,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e892783-15c3-4c22-94a6-785f8c43522b",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "applyUpdate should be able to return an error. It should be checking preconditions for the update. We shouldn't blindly retry.\n",
        "createdAt" : "2016-03-01T18:22:40Z",
        "updatedAt" : "2016-03-01T22:40:39Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "612d6a03-2b7c-4815-a583-bdf75cbb5da8",
        "parentId" : "9e892783-15c3-4c22-94a6-785f8c43522b",
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "There are no preconditions right now.\nIt just adds a label.\n\nWe can add preconditions and update the function to return an error, when its required.\n",
        "createdAt" : "2016-03-01T19:07:25Z",
        "updatedAt" : "2016-03-01T22:40:39Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      }
    ],
    "commit" : "b65180c3147f116725833020f9386dda134a3dd5",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +297,301 @@\t\t}\n\t\t// Apply the update, then attempt to push it to the apiserver.\n\t\tapplyUpdate(pod)\n\t\tif pod, err = podClient.Update(pod); err == nil {\n\t\t\t// Update successful."
  },
  {
    "id" : "330f193f-a743-4cc5-985f-273aebdcea84",
    "prId" : 21598,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d25170bc-9ea8-4d2d-bec0-1bb5645a2294",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Sorry for not being clear. We do need to check the condition status.\n",
        "createdAt" : "2016-02-19T23:50:58Z",
        "updatedAt" : "2016-02-19T23:58:56Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "3e98fb51-4e27-4023-b5c4-7df8aeafd007",
        "parentId" : "d25170bc-9ea8-4d2d-bec0-1bb5645a2294",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "c.Status == api.ConditionTrue\n",
        "createdAt" : "2016-02-19T23:51:53Z",
        "updatedAt" : "2016-02-19T23:58:56Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "99748269-a4e0-4aba-877d-9bb2c91fcdb2",
        "parentId" : "d25170bc-9ea8-4d2d-bec0-1bb5645a2294",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Fixed\n",
        "createdAt" : "2016-02-20T00:00:28Z",
        "updatedAt" : "2016-02-20T00:00:28Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "b267ede42cad2d514caeee7fd49d6ce35c143f7d",
    "line" : 47,
    "diffHunk" : "@@ -1,1 +207,211 @@\t\t\t// 2. LastTransitionTime (is set) + minReadySeconds (>0) < current time\n\t\t\tminReadySecondsDuration := time.Duration(minReadySeconds) * time.Second\n\t\t\tif minReadySeconds <= 0 || !c.LastTransitionTime.IsZero() && c.LastTransitionTime.Add(minReadySecondsDuration).Before(time.Now()) {\n\t\t\t\treturn true\n\t\t\t}"
  },
  {
    "id" : "e75b1fae-d140-47ef-bbb9-e1b1b2e3a51f",
    "prId" : 21030,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e67f0db-c2e0-47e5-9cd8-4116dc651979",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Note that we have also been special-casing interfaces in our deployment controllers and now we are looking into switching back to full namespacers since they are much cleaner and more predictable imho. Why can't we use namespacers here too?\n",
        "createdAt" : "2016-02-11T11:37:14Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "d5b2b97d-95f5-4ac9-8086-641b404f400a",
        "parentId" : "7e67f0db-c2e0-47e5-9cd8-4116dc651979",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "I put these special-casing interfaces because `getOldReplciaSets` and `getNewReplicaSet` are called both in deployment controller and in deployment util. In controller we use rsStore and podStore to `List`, but in deployment util we use clientset.Interface to `List`. They're of different types (`storeXxxNamespacer` vs. `XxxInterface`) so I'm not sure how to avoid special-casing interfaces. \n",
        "createdAt" : "2016-02-12T01:12:43Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "8391fcca-294b-4cc9-8d17-cbfd601ac606",
        "parentId" : "7e67f0db-c2e0-47e5-9cd8-4116dc651979",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Nevermind. Add a TODO here about investigating to switching to full namespacers and I can look into it if I ever find time.\n",
        "createdAt" : "2016-02-12T09:48:46Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "97367383-1489-4042-84b5-f9d19890b483",
        "parentId" : "7e67f0db-c2e0-47e5-9cd8-4116dc651979",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Actually can't we just use the client?\n",
        "createdAt" : "2016-02-12T15:39:14Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "c3979183-9543-40f2-8bf9-4d7ad0c1372c",
        "parentId" : "7e67f0db-c2e0-47e5-9cd8-4116dc651979",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Isn't using `List` of rsStore and podStore the whole point of having those cache stores?\n",
        "createdAt" : "2016-02-12T19:10:50Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "293a2985-1d3f-4ed6-b008-6d113cf901fb",
        "parentId" : "7e67f0db-c2e0-47e5-9cd8-4116dc651979",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Right. Please add a TODO for more investigation. \n",
        "createdAt" : "2016-02-18T11:43:04Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "4699a6d8a2c3d12f9efb821772f4201b32887985",
    "line" : null,
    "diffHunk" : "@@ -1,1 +60,64 @@\n// TODO: switch this to full namespacers\ntype rsListFunc func(string, api.ListOptions) ([]extensions.ReplicaSet, error)\ntype podListFunc func(string, api.ListOptions) (*api.PodList, error)\n"
  },
  {
    "id" : "b5cdc6b0-f0de-4758-8e94-b395b1cb15de",
    "prId" : 21030,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "04ae22fa-5ba1-462b-a4fc-3fa7a07f92c0",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Every client needs to do this. We should move this to the client library. I'll file an issue.\n",
        "createdAt" : "2016-02-18T17:13:14Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "d6357ba7-2031-46ef-8f02-aabdf608c716",
        "parentId" : "04ae22fa-5ba1-462b-a4fc-3fa7a07f92c0",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Filed #21479\n",
        "createdAt" : "2016-02-18T17:17:22Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "6e49982c-b27e-4065-b8b7-6927379cddd6",
        "parentId" : "04ae22fa-5ba1-462b-a4fc-3fa7a07f92c0",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "~~Can we utilize the Unconditional Update here? I verified that the the strategy of ReplicaSet allows that.~~\nPer offline discussion, we want to preserve the changes made by other parties so we cannot do unconditional update here. Patch (#20527) seems to be a better choice than retrying updates.\n",
        "createdAt" : "2016-02-18T18:15:16Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "4699a6d8a2c3d12f9efb821772f4201b32887985",
    "line" : null,
    "diffHunk" : "@@ -1,1 +258,262 @@\tvar err error\n\toldRs := rs\n\terr = wait.Poll(10*time.Millisecond, 1*time.Minute, func() (bool, error) {\n\t\t// Apply the update, then attempt to push it to the apiserver.\n\t\tapplyUpdate(rs)"
  },
  {
    "id" : "740afff1-607a-4579-83bf-603b7038c02e",
    "prId" : 21030,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b222de5e-d37f-4c33-b5bd-b0ef71cce8a2",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "return the error from above\n",
        "createdAt" : "2016-02-19T08:59:44Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "bb0e57d7-da4d-4974-be4c-a1d9ff20fffa",
        "parentId" : "b222de5e-d37f-4c33-b5bd-b0ef71cce8a2",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Fixed\n",
        "createdAt" : "2016-02-20T00:49:40Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "4699a6d8a2c3d12f9efb821772f4201b32887985",
    "line" : null,
    "diffHunk" : "@@ -1,1 +165,169 @@\t\treturn nil, nil, err\n\t}\n\treturn syncedRSList, syncedPodList, nil\n}\n"
  },
  {
    "id" : "68d7e4d7-09a0-478e-96b4-0511706c006c",
    "prId" : 21030,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1445659-3cc8-4bef-9ea3-8306d0429b50",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Move this to pkg/client/conditions.go\n",
        "createdAt" : "2016-02-22T11:01:59Z",
        "updatedAt" : "2016-02-22T18:59:36Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "41cfdfa0-2a2c-41b3-a0dc-b31eb00cce62",
        "parentId" : "c1445659-3cc8-4bef-9ea3-8306d0429b50",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Do you mean `pkg/client/unversioned/conditions.go`? We use the generated client  instead of the unversioned one in this function, so this function should not be there. cc @caesarxuchao \n",
        "createdAt" : "2016-02-22T19:27:37Z",
        "updatedAt" : "2016-02-22T19:27:37Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "707d9709-cf83-4a92-bdcf-1a011401075a",
        "parentId" : "c1445659-3cc8-4bef-9ea3-8306d0429b50",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Yes, sorry. How about creating `pkg/client/clientset_generated/internalclientset/conditions.go` then?\n",
        "createdAt" : "2016-02-22T19:44:43Z",
        "updatedAt" : "2016-02-22T19:44:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "4bf379ae-969c-4b50-85d4-dc25b462f460",
        "parentId" : "c1445659-3cc8-4bef-9ea3-8306d0429b50",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "No, because code in `pkg/client/clientset_generated` should be auto-generated. How about making a standalone `condition` package at `pkg/client/conditions/conditions.go`?\n",
        "createdAt" : "2016-02-22T20:00:49Z",
        "updatedAt" : "2016-02-22T20:00:49Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "bbd07542-eb43-42c4-868a-fcda0be53097",
        "parentId" : "c1445659-3cc8-4bef-9ea3-8306d0429b50",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Let's figure out the best place in another PR.\n",
        "createdAt" : "2016-02-22T20:48:02Z",
        "updatedAt" : "2016-02-22T20:48:02Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "901a39d0-af1b-48b5-b5e5-f353d6e08c3b",
        "parentId" : "c1445659-3cc8-4bef-9ea3-8306d0429b50",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "ok\n",
        "createdAt" : "2016-02-23T12:47:17Z",
        "updatedAt" : "2016-02-23T12:47:17Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "4699a6d8a2c3d12f9efb821772f4201b32887985",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +226,230 @@}\n\nfunc waitForReplicaSetUpdated(c clientset.Interface, desiredGeneration int64, namespace, name string) error {\n\treturn wait.Poll(10*time.Millisecond, 1*time.Minute, func() (bool, error) {\n\t\trs, err := c.Extensions().ReplicaSets(namespace).Get(name)"
  },
  {
    "id" : "6a420e41-3373-49de-9e9f-8e6cc53b68f4",
    "prId" : 20928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e1ec26fb-3549-4716-94f3-bca9ec7eb015",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Tests passed with this broken? Yikes.\n",
        "createdAt" : "2016-02-10T23:51:08Z",
        "updatedAt" : "2016-02-11T03:37:20Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "2cc09530-67d9-40ba-9b4e-075a816a4629",
        "parentId" : "e1ec26fb-3549-4716-94f3-bca9ec7eb015",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Just a name. Should be fine.\n",
        "createdAt" : "2016-02-11T00:07:40Z",
        "updatedAt" : "2016-02-11T03:37:20Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      },
      {
        "id" : "a99eab4b-d7da-4ea0-a4fd-eb4a95def13d",
        "parentId" : "e1ec26fb-3549-4716-94f3-bca9ec7eb015",
        "authorId" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "body" : "`getRcList` (and now `getRSList`) is a local name. That function is passed as an argument to `GetOldReplicaSetsFromLists()` and all the occurrences inside `GetOldReplicaSetsFromLists()` referred to getRcList, so it did not break the tests. But it is still scary. I hope I haven't missed this somewhere else where tests are silently passing.\n",
        "createdAt" : "2016-02-11T00:08:14Z",
        "updatedAt" : "2016-02-11T03:37:20Z",
        "lastEditedBy" : "f6905dc9-1980-4381-8220-a1c7ad8d5c82",
        "tags" : [
        ]
      }
    ],
    "commit" : "293793cf0d3c13f9ece496d22d1f2353531fa9d5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +73,77 @@\toldRSs := map[string]extensions.ReplicaSet{}\n\tallOldRSs := map[string]extensions.ReplicaSet{}\n\trsList, err := getRSList(namespace, options)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"error listing replica sets: %v\", err)"
  },
  {
    "id" : "3c71852b-6c98-4ade-9bd6-1ff5fe4ce647",
    "prId" : 20273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1216beb0-2d24-46a9-9b7f-d5df4bd72162",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "What is the relationship between the value on this annotation and the value in Spec.Replicas?  What does it mean when they are different?  Who is the owner / writer to each?\n",
        "createdAt" : "2016-05-18T21:47:17Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "3716e03b-0b03-45ee-b8a2-aa5bae821eff",
        "parentId" : "1216beb0-2d24-46a9-9b7f-d5df4bd72162",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Ah, it is the replicas desired by the deployment.  The name is a bit confusing since Spec.Replicas is also the desired replicas.  Maybe DeploymentTotalDesiredReplicas or ParentTotalDesiredReplicas depending on if we want to reuse the annotation across controllers that manage ReplicaSets.\n",
        "createdAt" : "2016-05-18T21:50:53Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "10e808f7-4887-4c77-8ab8-ea01919383cc",
        "parentId" : "1216beb0-2d24-46a9-9b7f-d5df4bd72162",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "This is a deployment-specific annotation, used for a specific reason (enables the deployment controller to determine if a reconcilation of a deployment is due to a scaling event), I am not sure we want to re-use it elsewhere.\n",
        "createdAt" : "2016-05-18T21:55:14Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "ab347ac3-27b1-42d5-b69f-ba804d21aa61",
        "parentId" : "1216beb0-2d24-46a9-9b7f-d5df4bd72162",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Yes for now it is, but if we develop another type of controller that manages scaling across multiple replica sets and wants to have similar behavior I wonder if we would want it to use the same annotation or a different one.  As I understand it, the annotation's purpose is to record what fraction of a whole this replica set is intended to represent.\n",
        "createdAt" : "2016-05-19T05:19:25Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "f5d0a473-f541-4857-9680-0e41d4b22740",
        "parentId" : "1216beb0-2d24-46a9-9b7f-d5df4bd72162",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Why would we want another controller for scaling multiple replica sets when we already have a controller for replica sets?\n",
        "createdAt" : "2016-05-19T09:24:39Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "3f30ae4f-f27e-44c0-923c-6c345b6dce53",
        "parentId" : "1216beb0-2d24-46a9-9b7f-d5df4bd72162",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Anyway, if we did such a thing it still wouldn't use these annotations because they are deployment-specific. This annotation's purpose is to record what fraction of a whole **deployment** this replica set is intended to represent.\n",
        "createdAt" : "2016-05-19T09:26:25Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3d2e3ff2203da20053f9a104f3cce6571dbe293",
    "line" : null,
    "diffHunk" : "@@ -1,1 +45,49 @@\t// in its replica sets. Helps in separating scaling events from the rollout process and for\n\t// determining if the new replica set for a deployment is really saturated.\n\tDesiredReplicasAnnotation = \"deployment.kubernetes.io/desired-replicas\"\n\t// MaxReplicasAnnotation is the maximum replicas a deployment can have at a given point, which\n\t// is deployment.spec.replicas + maxSurge. Used by the underlying replica sets to estimate their"
  },
  {
    "id" : "700ec918-d7de-4ee6-8dc7-2fd96d4378c1",
    "prId" : 20273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6eec9d25-5ee4-4742-b41a-97d2cbb6d074",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "what does it mean when int32(desired) == deployment.Spec.Replicas?  Does this mean that data is not consistent between what the deployment thinks the total replica count is and the replica set thinks it should be?  Is this caused by a failed write or a race condition between updating the Dep and RS?\n",
        "createdAt" : "2016-05-18T21:56:31Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "cb2efd96-9f45-447b-b5bf-069c6a47a384",
        "parentId" : "6eec9d25-5ee4-4742-b41a-97d2cbb6d074",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "A replica set is saturated when d.Spec.Replicas == rs.Spec.Replicas but you cannot be sure when you proportionally scale that this holds true prior to scaling a replica set. For example:\n\ndeployment:\nnginx.Spec.Replicas == 10 (maxSurge: 1, revision: 2)\n\nreplica sets:\nnginx-1.Spec.Replicas == 5 (desired-replicas: 10, total-replicas: 11)\nnginx-2.Spec.Replicas == 5 (desired-replicas: 10, total-replicas: 11)\n\nWe are in the middle of a rollout (paused or not it doesn't matter because we will scale proportionally in both cases)\n\nUser or autoscaler scales the nginx deployment to 5 replicas.\n\nnginx.Spec.Replicas == 5\n\nWithout the int32(desired) == deployment.Spec.Replicas check, the controller would see:\n\nnginx-2.Spec.Replicas == nginx.Spec.Replicas == 5\n\nIdentifies the new replica set as saturated and instantly scales down the old replica set (which we don't want to happen since that's the reason we are doing proportional scaling in the first place).\n\nWith the annotation check you have:\n\n5 == 5 && 10 == 5 which will avoid identifying the new replica set as saturated thus continue proportional scaling.\n",
        "createdAt" : "2016-05-18T22:12:29Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "1a0dbf12-69de-49e5-aabc-d649e432a2ee",
        "parentId" : "6eec9d25-5ee4-4742-b41a-97d2cbb6d074",
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "Thanks.  That is helpful.\n",
        "createdAt" : "2016-05-19T00:40:28Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3d2e3ff2203da20053f9a104f3cce6571dbe293",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +455,459 @@\t\treturn false\n\t}\n\treturn rs.Spec.Replicas == deployment.Spec.Replicas && int32(desired) == deployment.Spec.Replicas\n}\n"
  },
  {
    "id" : "e77334fc-242a-4c47-9a2b-6ac5345b1de5",
    "prId" : 20273,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af68e9f8-cf19-4250-b690-fb6f441d9f4e",
        "parentId" : null,
        "authorId" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "body" : "What saturated means in this wasn't immediately obvious to me when reading from the callers perspective, even though it does appear in a comment.  Usually I considered saturated as being full to the limit instead of having an exact count matching.  (e.g. a rate-limiter is saturated even if it is over the max amount)  As I understand it, this function returns true IFF both the deployment and the rs believe this rs can own all of the desired replicas in the deployment.  Is that correct?\n",
        "createdAt" : "2016-05-19T00:55:56Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "47ec15eb-72b4-4618-9e01-e3b37b6bac00",
        "tags" : [
        ]
      },
      {
        "id" : "e8afbd02-df01-4378-a8e5-6cdb321434ca",
        "parentId" : "af68e9f8-cf19-4250-b690-fb6f441d9f4e",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Correct. Updated the comment of the helper to mention it.\n",
        "createdAt" : "2016-05-19T09:46:44Z",
        "updatedAt" : "2016-06-20T10:13:43Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3d2e3ff2203da20053f9a104f3cce6571dbe293",
    "line" : null,
    "diffHunk" : "@@ -1,1 +446,450 @@// Both the deployment and the replica set have to believe this replica set can own all of the desired\n// replicas in the deployment and the annotation helps in achieving that.\nfunc IsSaturated(deployment *extensions.Deployment, rs *extensions.ReplicaSet) bool {\n\tif rs == nil {\n\t\treturn false"
  },
  {
    "id" : "7bea953f-1d4b-44b0-be85-d8cfd54311d5",
    "prId" : 19686,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd003c25-d2df-4de5-9852-af400b2ef39b",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "I thought we were grouping deployment (and any kind of resource for that matter) related annotations in the api files (https://github.com/kubernetes/kubernetes/blob/63ec304e42c4f1bb6bd90d3f638cf1aafafe4064/pkg/apis/extensions/types.go#L238)\n\n@bgrant0607 \n",
        "createdAt" : "2016-01-27T11:52:39Z",
        "updatedAt" : "2016-01-31T00:08:59Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "32685700-69d0-46b5-abe9-27a4bb0abfe8",
        "parentId" : "bd003c25-d2df-4de5-9852-af400b2ef39b",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "There's no consistent convention, but let's do keep Deployment's annotations together.\n",
        "createdAt" : "2016-01-27T16:07:31Z",
        "updatedAt" : "2016-01-31T00:08:59Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "cd6cb24b-1ea5-4d64-be4f-11fff00a36fd",
        "parentId" : "bd003c25-d2df-4de5-9852-af400b2ef39b",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Since we're breaking compatibility anyway, how about we change podTemplateHash to pod-template-hash to match the conventions:\nhttps://github.com/kubernetes/kubernetes/blob/master/docs/devel/api-conventions.md#label-selector-and-annotation-conventions\n",
        "createdAt" : "2016-01-27T16:09:44Z",
        "updatedAt" : "2016-01-31T00:08:59Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "a0954e23-fe90-498f-bf5d-4d896a0387cf",
        "parentId" : "bd003c25-d2df-4de5-9852-af400b2ef39b",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "> how about we change podTemplateHash to pod-template-hash to match the conventions\n\nsgtm\n",
        "createdAt" : "2016-01-27T16:11:11Z",
        "updatedAt" : "2016-01-31T00:08:59Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "3396db95106e3257946f78334017e6024e704b9b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +31,35 @@const (\n\t// The revision annotation of a deployment's replication controllers which records its rollout sequence\n\tRevisionAnnotation = \"deployment.kubernetes.io/revision\"\n)\n"
  },
  {
    "id" : "ac77a089-7464-4ca1-8be2-f0878e0cf033",
    "prId" : 19581,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7fefc73f-1e71-4f91-a592-73e252a4fc6b",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "asked about this in https://github.com/kubernetes/kubernetes/pull/19686#discussion_r50973865 but I think this is the correct place\n",
        "createdAt" : "2016-01-27T12:48:27Z",
        "updatedAt" : "2016-01-30T20:05:06Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "d63ea89d-0cc5-4826-adf8-4372ce372267",
        "parentId" : "7fefc73f-1e71-4f91-a592-73e252a4fc6b",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "You mean is not the correct place?\n",
        "createdAt" : "2016-01-27T17:00:27Z",
        "updatedAt" : "2016-01-30T20:05:06Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "f8e33af4-cc65-4b93-a5c4-222b596b4ba7",
        "parentId" : "7fefc73f-1e71-4f91-a592-73e252a4fc6b",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "> You mean is not the correct place?\n\nSorry for being ambiguous. I meant that this is the correct place to ask because this is the original PR making the change.\n",
        "createdAt" : "2016-01-27T17:03:36Z",
        "updatedAt" : "2016-01-30T20:05:06Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "62faf187-11d8-4055-a87b-3145861162b7",
        "parentId" : "7fefc73f-1e71-4f91-a592-73e252a4fc6b",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I agree that all the deployment-related annotations belong in the same place, but it's ok with me if this gets moved in a subsequent PR, since we have so many interdependent PRs right now.\n",
        "createdAt" : "2016-01-27T23:43:32Z",
        "updatedAt" : "2016-01-30T20:05:06Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "a73e10ae-ae44-451f-96d8-9826b55a00d5",
        "parentId" : "7fefc73f-1e71-4f91-a592-73e252a4fc6b",
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "fine with me\n",
        "createdAt" : "2016-01-28T10:32:45Z",
        "updatedAt" : "2016-01-30T20:05:06Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "42f712467efa2f3f4b272ec3c288f3797ee13cad",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +31,35 @@const (\n\t// The revision annotation of a deployment's replication controllers which records its rollout sequence\n\tRevisionAnnotation = \"deployment.kubernetes.io/revision\"\n)\n"
  },
  {
    "id" : "54640304-14db-43b9-814b-eaa7ad517aa8",
    "prId" : 18321,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "684cf09a-3d0b-40ea-a4ef-cf6f154ad7af",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "`&oldRCs[i]` without the temporary variable also works :)\n",
        "createdAt" : "2015-12-08T04:06:16Z",
        "updatedAt" : "2015-12-08T04:06:16Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "524ec8b48b527138a94e6e09012d8c5569319d50",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +67,71 @@\tfor i := range oldRCs {\n\t\tvalue := oldRCs[i]\n\t\trequiredRCs = append(requiredRCs, &value)\n\t}\n\treturn requiredRCs, nil"
  },
  {
    "id" : "96c5ad24-c3e8-4a52-bc0f-8d3ab6b37a8c",
    "prId" : 18321,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bebe843-0dc9-4698-9c5e-300ac5ad34c2",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This is common enough that the comment is probably not necessary. It also doesn't hurt. Up to you!\n",
        "createdAt" : "2015-12-08T04:06:52Z",
        "updatedAt" : "2015-12-08T04:06:52Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "524ec8b48b527138a94e6e09012d8c5569319d50",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +64,68 @@\t// Note that go reuses the same memory location for every iteration,\n\t// which means the 'value' returned from range will have the same address.\n\t// Therefore, we should use the returned 'index' instead.\n\tfor i := range oldRCs {\n\t\tvalue := oldRCs[i]"
  },
  {
    "id" : "640a52af-965b-4eae-b829-9ea3423d11c6",
    "prId" : 18321,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddf64817-084a-4d2b-898b-87ba25986fc8",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "I would call this a key instead of an index since this is a map and not a slice.\n",
        "createdAt" : "2015-12-08T12:32:45Z",
        "updatedAt" : "2015-12-08T12:32:45Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      }
    ],
    "commit" : "524ec8b48b527138a94e6e09012d8c5569319d50",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +65,69 @@\t// which means the 'value' returned from range will have the same address.\n\t// Therefore, we should use the returned 'index' instead.\n\tfor i := range oldRCs {\n\t\tvalue := oldRCs[i]\n\t\trequiredRCs = append(requiredRCs, &value)"
  },
  {
    "id" : "9fb7e338-039c-42f9-877b-78e3e7ec01ce",
    "prId" : 17137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e694be1-2008-4afa-aba5-9b43e4a6e177",
        "parentId" : null,
        "authorId" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "body" : "There shouldnt be more than 1 ready condition, right?\nWe can break as soon as we find a ready condition.\nWe wont need readyCondition and validReadyConditions will then be a boolean instead of int.\n",
        "createdAt" : "2015-12-03T20:25:26Z",
        "updatedAt" : "2015-12-04T20:58:51Z",
        "lastEditedBy" : "f2369046-26b1-4b8c-a8cd-5671ab22066c",
        "tags" : [
        ]
      },
      {
        "id" : "011b30fd-9eaa-49b2-9b2a-69400a6d0853",
        "parentId" : "3e694be1-2008-4afa-aba5-9b43e4a6e177",
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "Fixed\n",
        "createdAt" : "2015-12-04T00:16:30Z",
        "updatedAt" : "2015-12-04T20:58:51Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "8fb0caa15ba82430924ecb8642b891cd30ee1f4e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +150,154 @@\t\t\tfor _, c := range pod.Status.Conditions {\n\t\t\t\t// we only care about pod ready conditions\n\t\t\t\tif c.Type == api.PodReady {\n\t\t\t\t\t// 2 cases that this ready condition is valid (passed minReadySeconds, i.e. the pod is ready):\n\t\t\t\t\t// 1. minReadySeconds <= 0"
  }
]
[
  {
    "id" : "dec025d3-b047-4b5d-b2e9-0055dd6c11a2",
    "prId" : 16950,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "955d2170-89d5-4542-a4d2-33ed78360dca",
        "parentId" : null,
        "authorId" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "body" : "At first this bugged me but now I see it does make the code easier to read (`osexec.ErrNotFound` isn't very descriptive). :+1: \n",
        "createdAt" : "2015-11-12T17:22:39Z",
        "updatedAt" : "2015-11-12T18:22:15Z",
        "lastEditedBy" : "e207abea-b610-4808-be75-0ad08ef4a235",
        "tags" : [
        ]
      },
      {
        "id" : "f7195b80-986f-4d35-9734-d707d3963492",
        "parentId" : "955d2170-89d5-4542-a4d2-33ed78360dca",
        "authorId" : null,
        "body" : "> osexec.ErrNotFound isn't very descriptive\n\nYeah. In addition this follows this package's general notion of abstracting away os/exec. Currently users of this package don't have to import os/exec at all.\n",
        "createdAt" : "2015-11-12T18:25:25Z",
        "updatedAt" : "2015-11-12T18:25:25Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "4d373b133a6cb4eaad21ff63c0dd22b6fdccbcce",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +23,27 @@\n// ErrExecutableNotFound is returned if the executable is not found.\nvar ErrExecutableNotFound = osexec.ErrNotFound\n\n// Interface is an interface that presents a subset of the os/exec API.  Use this"
  },
  {
    "id" : "dade6c31-8fda-4162-a522-7bb33d947820",
    "prId" : 1592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "690585dd-c1b9-47f0-a7fb-3f6a6f068b98",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Why do you need to wrap ExitError?\n",
        "createdAt" : "2014-10-06T20:50:25Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "4afe83fc-afae-4945-8581-a56abe612fa0",
        "parentId" : "690585dd-c1b9-47f0-a7fb-3f6a6f068b98",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "ExitError is an alias of *os.ProcessState.\n\nos.ProcessState has no public fields.\n\nThus, I can not mock exec errors.  Sigh.  Go's library is very nice in some regards and totally untestable in others.\n",
        "createdAt" : "2014-10-06T20:56:12Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "feaa48d4-5ad5-4440-bca7-0a5681008bd8",
        "parentId" : "690585dd-c1b9-47f0-a7fb-3f6a6f068b98",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Yeah, os/exec is nice to use but a testability disaster :(\n\nI think previously we've been testing things at a higher level (like the \"DockerPuller\" thing) instead of writing this generic exec testability wrapper. After seeing such a thing written out, I'm not convinced that's the wrong approach. But I'm not sure what you're going to do with this.\n",
        "createdAt" : "2014-10-06T21:31:37Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "42cd342b-f664-4b16-8aa0-2278aac0028d",
        "parentId" : "690585dd-c1b9-47f0-a7fb-3f6a6f068b98",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "This gets wrapped into the iptables runner, which then can be faked to make testing services possible.\n\nBut somewhere at the bottom of the stack, someone needs to exec().  I was surprised I did not find a pre-made lib for this.\n",
        "createdAt" : "2014-10-06T23:54:02Z",
        "updatedAt" : "2014-10-06T23:54:02Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "0c669683-7ed0-4403-9bba-92b18751102c",
        "parentId" : "690585dd-c1b9-47f0-a7fb-3f6a6f068b98",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Another approach would be to write an interface for iptables instead, with a real and fake implementation. For testing the real implementation, it'd be nice to actually run the commands (in a chroot/container or something?) and perform assertions on the iptables config file (that is what you're changing, right?). Otherwise, given this os/exec wrapping layer, I suspect you'll end up testing that some specific set of commands are called, which is better than nothing but is more of a change-detector than a correctness-detector.\n",
        "createdAt" : "2014-10-07T00:09:53Z",
        "updatedAt" : "2014-10-07T00:09:53Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "4c1bdd0a-5847-4994-85b4-4fa29df088f3",
        "parentId" : "690585dd-c1b9-47f0-a7fb-3f6a6f068b98",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "iptables makes a bunch of syscalls.  I literally need to make sure that some specific set of commands was run.  Deeper correctness testing will have to come from an e2e test, no way around it.\n",
        "createdAt" : "2014-10-07T00:14:05Z",
        "updatedAt" : "2014-10-07T00:14:05Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "20a1829dadaf48d31f65063a9219ed6fd6ed437b",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@// ExitError is an interface that presents an API similar to os.ProcessState, which is\n// what ExitError from os/exec is.  This is designed to make testing a bit easier and\n// probably loses some of the cross-platform properties of the underlying library.\ntype ExitError interface {\n\tString() string"
  },
  {
    "id" : "70e99d00-6913-48a8-88f8-5b667c76796c",
    "prId" : 1592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Consider changing this to `type cmdWrapper *osexec.Cmd`; this will make your conversions not require () which would make everything much more readable, IMO.\n",
        "createdAt" : "2014-10-06T20:58:31Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f413620e-614d-44c4-b30b-70fc8058d348",
        "parentId" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Well, it will help one conversion, anyway.\n",
        "createdAt" : "2014-10-06T21:00:43Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "b00c7509-bdc1-4c6c-afa7-eb2ddbc29bc7",
        "parentId" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "It fixed on site, trading one unreadable aspect for another, but sure.  Done.\n",
        "createdAt" : "2014-10-06T21:03:53Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "74ba7f03-af53-4174-b832-21afacc235a7",
        "parentId" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I take it back.  Go still confuses me here.\n\n```\ninvalid receiver type *cmdWrapper (cmdWrapper is a pointer type)\n```\n\nI guess I can't have pointers to pointer types?  Why the hell not?  This is staying as is.\n",
        "createdAt" : "2014-10-06T21:10:54Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "034bab02-54c1-43be-94e6-2fbd6307f0a4",
        "parentId" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Oh, you would change all the receiver types to not be pointers, it's already a pointer, no need to be redundant.\n",
        "createdAt" : "2014-10-06T21:16:42Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "4122bf29-5c5a-4815-bc1d-83e44063076f",
        "parentId" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "no can do.    I run afoul of one of the rules in go:\n\nCan't declare methods on pointer values\nhttp://play.golang.org/p/AP6v9EUtSW\n\nCan't have a value-receiver method for a pointer value\nhttp://play.golang.org/p/AP6v9EUtSW\n\nCmd is returned as a pointer, so unless I force users to deref it, which is different than the standard lib, it's stuck.  This is new territory in Go's spec, so maybe I am just mis-comprehending it.\n",
        "createdAt" : "2014-10-06T23:35:56Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "8c905773-c739-4644-a3f8-b98238efba81",
        "parentId" : "38c20a5f-b8e2-4eda-a13f-b047739aa291",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "_sigh_ Giving up on this, I'm sure there's some simple reason why go is so picky about what you can define receivers on but it is sure annoying.\n",
        "createdAt" : "2014-10-07T00:11:35Z",
        "updatedAt" : "2014-10-07T00:11:35Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "20a1829dadaf48d31f65063a9219ed6fd6ed437b",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +63,67 @@\n// Wraps exec.Cmd so we can capture errors.\ntype cmdWrapper osexec.Cmd\n\n// CombinedOutput is part of the Cmd interface."
  },
  {
    "id" : "e7801514-1615-421b-af74-e7de2e02c59a",
    "prId" : 1592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e198c8fc-5608-4867-89fe-88f57967fc6f",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Effectively you've got pointer-to-pointer-to thing here, just as a nit I wonder if the below isn't a bit simpler and less indirect.\n\n```\n...\n+       // Force a compile fail if exitErrorWrapper can't convert to ExitError.\n+       var x ExitError = exitErrorWrapper(ee)\n+       return out, x\n\n...\n\n+// exitErrorWrapper is an implementation of ExitError in terms of os/exec ExitError.\n+// Note: standard exec.ExitError is type *os.ProcessState, which already implements Exited().\n+type exitErrorWrapper *osexec.ExitError\n+\n+// ExitStatus is part of the ExitError interface.\n+func (eew exitErrorWrapper) ExitStatus() int {\n+   ws, ok := eew.Sys().(syscall.WaitStatus)\n+   if !ok {\n+       panic(\"can't call ExitStatus() on a non-WaitStatus exitErrorWrapper\")\n+   }\n+   return ws.ExitStatus()\n+}\n```\n",
        "createdAt" : "2014-10-06T21:24:56Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "014d5bb8-faf5-4af7-9bf6-06baa5560fa8",
        "parentId" : "e198c8fc-5608-4867-89fe-88f57967fc6f",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Then I don't inherit the Error() method, resulting net more code.\n",
        "createdAt" : "2014-10-06T23:40:52Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "b1c5883a-828b-4766-803b-2e0421ac13a5",
        "parentId" : "e198c8fc-5608-4867-89fe-88f57967fc6f",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I can make this a value receiver, if it makes you happier.  Done\n",
        "createdAt" : "2014-10-06T23:42:27Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "20a1829dadaf48d31f65063a9219ed6fd6ed437b",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +82,86 @@// exitErrorWrapper is an implementation of ExitError in terms of os/exec ExitError.\n// Note: standard exec.ExitError is type *os.ProcessState, which already implements Exited().\ntype exitErrorWrapper struct {\n\t*osexec.ExitError\n}"
  },
  {
    "id" : "ef5cf2e5-873d-4229-ade9-499343b54ded",
    "prId" : 1592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58ded73b-6493-4704-95e5-e61ca4ad2ba6",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is there any way to make calling code do the type assertion? This looks like a panic which could actually happen at run-time, I don't like adding those.\n",
        "createdAt" : "2014-10-06T21:26:47Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "948e1e92-ab87-4865-9d48-ea58e78293dc",
        "parentId" : "58ded73b-6493-4704-95e5-e61ca4ad2ba6",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Nope, because again this bounces through ProcessState which is opaque.  Docs say os.ProcessState.Sys() returns a WaitStatus on UNIX.  So this will break on windows, which is fine with me.\n",
        "createdAt" : "2014-10-06T23:51:41Z",
        "updatedAt" : "2014-10-06T23:52:29Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "20a1829dadaf48d31f65063a9219ed6fd6ed437b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +90,94 @@\tws, ok := eew.Sys().(syscall.WaitStatus)\n\tif !ok {\n\t\tpanic(\"can't call ExitStatus() on a non-WaitStatus exitErrorWrapper\")\n\t}\n\treturn ws.ExitStatus()"
  }
]
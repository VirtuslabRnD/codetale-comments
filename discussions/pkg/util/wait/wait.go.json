[
  {
    "id" : "88ec94f6-e81e-488a-986d-8960a1ab94c7",
    "prId" : 35382,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35382#pullrequestreview-5505193",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbb8bb94-c54b-4487-b696-5dcda3e11ecc",
        "parentId" : null,
        "authorId" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "body" : "Can you move these comments on top of the fields and switch them to follow the golint conventions? It would be nice to get them to show up in godoc.\n",
        "createdAt" : "2016-10-24T17:43:47Z",
        "updatedAt" : "2016-11-04T16:31:41Z",
        "lastEditedBy" : "11efe503-096f-46dd-a8c8-28ba38a0157a",
        "tags" : [
        ]
      },
      {
        "id" : "0a209f36-b99b-49f7-a950-708d7d7e293f",
        "parentId" : "cbb8bb94-c54b-4487-b696-5dcda3e11ecc",
        "authorId" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "body" : "`golint` didn't flag this.  In fact, this format is supported by `gofmt` and is used as an example in [Effective Go](https://golang.org/doc/effective_go.html#formatting).\n\nI'm happy to change, but this seems a bit pedantic.\n",
        "createdAt" : "2016-10-24T18:06:36Z",
        "updatedAt" : "2016-11-04T16:31:41Z",
        "lastEditedBy" : "e19009d8-ed5c-45bb-b5ce-4f8d956c6c45",
        "tags" : [
        ]
      }
    ],
    "commit" : "48d1505ba6f0b33b8ebf60fb5ed3b66f16338380",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +136,140 @@// Backoff holds parameters applied to a Backoff function.\ntype Backoff struct {\n\tDuration time.Duration // the base duration\n\tFactor   float64       // Duration is multipled by factor each iteration\n\tJitter   float64       // The amount of jitter applied each iteration"
  },
  {
    "id" : "672a3e14-8d8d-4ead-97fc-aa6ec9114835",
    "prId" : 32210,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9ae4ba6-dd7b-424a-84d1-6fccbdd47dd4",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "@sttts but does this look safe to you?\n",
        "createdAt" : "2016-09-09T15:17:13Z",
        "updatedAt" : "2016-09-12T15:01:49Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "962c4b39-4c2c-4ee0-a811-5217d78ebe5f",
        "parentId" : "c9ae4ba6-dd7b-424a-84d1-6fccbdd47dd4",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "a test case which closes the stopCh would be helpful.\n",
        "createdAt" : "2016-09-09T15:22:33Z",
        "updatedAt" : "2016-09-12T15:01:49Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "385831825bf1d2b2546988965a2f36b0cfd49e1f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +192,196 @@// PollUntil is like Poll, but it takes a stop change instead of total duration\nfunc PollUntil(interval time.Duration, condition ConditionFunc, stopCh <-chan struct{}) error {\n\treturn WaitFor(poller(interval, 0), condition, stopCh)\n}\n"
  },
  {
    "id" : "52831b12-70ee-4058-839b-23fbcd4ce97e",
    "prId" : 26301,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ac81353-1ecb-4919-9a6e-97cd8b2ba35a",
        "parentId" : null,
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "There is a race that can occur here when sliding is true, and jitterPeriod is 0, and a stopCh + t.C are triggered in close succession.  https://github.com/kubernetes/kubernetes/issues/26782#issue-158385551\n\n/cc @wojtek-t @mikedanese \n",
        "createdAt" : "2016-07-27T21:35:04Z",
        "updatedAt" : "2016-07-27T21:35:04Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ec25c54252568b0e3d97feffc9363c9f1e6ff1f",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +102,106 @@\t\tcase <-stopCh:\n\t\t\treturn\n\t\tcase <-t.C:\n\t\t}\n\t}"
  },
  {
    "id" : "248d6fd2-f56e-4468-89c9-fd4dea4c7544",
    "prId" : 16067,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7bb74a74-1b81-40f2-803b-ea69dda9b1ff",
        "parentId" : null,
        "authorId" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "body" : "am  now discussing the connection to  backoff.go with @smarterclayton  \n",
        "createdAt" : "2015-11-05T17:26:15Z",
        "updatedAt" : "2016-01-21T03:58:24Z",
        "lastEditedBy" : "a5be0b3b-3db2-4c99-a598-55f8708db5df",
        "tags" : [
        ]
      }
    ],
    "commit" : "29028a1332a71e7386c83a7d4b0229b3ed1b15c7",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +54,58 @@// If the condition never returns true, ErrWaitTimeout is returned. All other errors\n// terminate immediately.\nfunc ExponentialBackoff(backoff Backoff, condition ConditionFunc) error {\n\tduration := backoff.Duration\n\tfor i := 0; i < backoff.Steps; i++ {"
  },
  {
    "id" : "0e422697-459b-4f2e-9289-8bf7b5ddc1bc",
    "prId" : 1002,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1705479f-1208-43e0-96f5-25db5d4b6ec6",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Why make an after channel at all? Why not just count up every time you read from tick.C? By making an after channel, it becomes unpredictable how many times the poll function will be called.\n",
        "createdAt" : "2014-08-22T17:20:51Z",
        "updatedAt" : "2014-08-23T16:18:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "e074185c-4666-4020-a39f-c1e7d3ee8446",
        "parentId" : "1705479f-1208-43e0-96f5-25db5d4b6ec6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I'm going to argue that's a feature instead of a bug.  I _expect_ most users have an idea of how long they want to wait before their polling is done.  I _think_ they know that their operations take an implicit amount of time, and that logically the total time should be \"interval times number of iterations + time to do last request\".  To do polling, the interval is important, and the max timeout is important, and that you get called at least once at the end.  I was assuming that the number of times you _actually_ poll is less important than that max timeout.  If that's the contract people write to, then we have the flexibility to offer more sophisticated timeout of individual condition checking in the future.  If you give us an insane poll period and cycles (below the level the OS allows) then the contract still holds.\n\nAdmittedly explaining it seems complicated, but I figured you could do the straight up interval times count calculation in your head and then trust it'll do the right thing.\n",
        "createdAt" : "2014-08-22T17:43:41Z",
        "updatedAt" : "2014-08-23T16:18:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "ee350af8-e6b4-4d34-9eac-64dd6c9e5bca",
        "parentId" : "1705479f-1208-43e0-96f5-25db5d4b6ec6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "> To do polling, the interval is important, and the max timeout is important, and that you get called at least once at the end. I was assuming that the number of times you actually poll is less important than that max timeout. \n\nIf that's the model, that's fine-- but then I think the interface should be two time.Durations, the between cycle time and the timeout time. I think the interface currently gives the wrong impression about the implementation.\n",
        "createdAt" : "2014-08-22T17:53:23Z",
        "updatedAt" : "2014-08-23T16:18:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a733406a-2143-4d2c-a3c4-9b7c62760059",
        "parentId" : "1705479f-1208-43e0-96f5-25db5d4b6ec6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I assumed math was easier than figuring out two durations.  But I'm fine changing it.\n",
        "createdAt" : "2014-08-22T18:01:55Z",
        "updatedAt" : "2014-08-23T16:18:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "49220709-dfca-4fcc-8df0-c9c814a746e0",
        "parentId" : "1705479f-1208-43e0-96f5-25db5d4b6ec6",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Maybe I'm alone in my interpretation of the interface-- @brendandburns?\n",
        "createdAt" : "2014-08-22T18:05:21Z",
        "updatedAt" : "2014-08-23T16:18:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "7a7085d1-9f8c-467c-8a21-ce7370853c4c",
        "parentId" : "1705479f-1208-43e0-96f5-25db5d4b6ec6",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I switched - I think you're right, it's cleaner (interval, timeout, condition).\n",
        "createdAt" : "2014-08-22T18:16:59Z",
        "updatedAt" : "2014-08-23T16:18:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "286c3c543c780485072a8d1b9588e046aea9479c",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +76,80 @@\t\t\ttick := time.NewTicker(interval)\n\t\t\tdefer tick.Stop()\n\t\t\tvar after <-chan time.Time\n\t\t\tif timeout != 0 {\n\t\t\t\tafter = time.After(timeout)"
  }
]
[
  {
    "id" : "865ea9d5-1d74-454a-8975-bec9a25cdda5",
    "prId" : 16980,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9dbcddda-ac19-47c0-ae9d-e2a645b3f320",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "This comment looks almost identical to https://github.com/kubernetes/kubernetes/blob/master/pkg/util/strategicpatch/patch.go#L930.  What's the difference?\n",
        "createdAt" : "2015-11-12T13:26:57Z",
        "updatedAt" : "2015-12-07T01:54:41Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "2816f94b-5313-4fee-8afa-ca75c69b8efe",
        "parentId" : "9dbcddda-ac19-47c0-ae9d-e2a645b3f320",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "This method supports merging lists (i.e., strategic merge path semantics), while the other one doesn't (i.e., json merge patch semantics). Will update to make the distinction clear.\n",
        "createdAt" : "2015-11-12T13:31:31Z",
        "updatedAt" : "2015-12-07T01:54:41Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "2faec2d3-9f45-4cad-a7fe-8e449fcaf588",
        "parentId" : "9dbcddda-ac19-47c0-ae9d-e2a645b3f320",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This method supports merging lists (i.e., strategic merge path semantics), while the other one doesn't (i.e., json merge patch semantics). Will update to make the distinction clear.\n\nIf this is a superset, should you simply replace the existing one?\n",
        "createdAt" : "2015-11-12T13:39:01Z",
        "updatedAt" : "2015-12-07T01:54:41Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "8d5264b8-3198-4d9c-bbf3-126122c453d6",
        "parentId" : "9dbcddda-ac19-47c0-ae9d-e2a645b3f320",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "The implementation started out that way, but it quickly became unmanageable. Also, the existing method is being used in its current form, so going that route meant create a stub that offered the old API over the new one, passing in a nil structure for type information, and then plumbing that through the implementation. In the end, it was simpler and cleaner to leave the existing method unchanged, and to write the new one straightforwardly using strategic merge patch semantics.\n",
        "createdAt" : "2015-11-13T19:56:58Z",
        "updatedAt" : "2015-12-07T01:54:41Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "b11dec7aec5a5247bc78da1127d6c2b36b960f49",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +974,978 @@}\n\n// MergingMapsHaveConflicts returns true if the left and right JSON interface\n// objects overlap with different values in any key. All keys are required to be\n// strings. Since patches of the same Type have congruent keys, this is valid"
  },
  {
    "id" : "21c0029b-aec6-4681-b9f9-210b21ccc1d4",
    "prId" : 16980,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "489adf70-a1bf-453b-962b-1fced9820eac",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "If I'm reading this right, it goes like this:\n1. if leftMarker != rightMarker, return conflict\n2. if okLeft != okRight, return no conflict\n3. otherwise, check the maps.\n",
        "createdAt" : "2015-11-12T13:43:03Z",
        "updatedAt" : "2015-12-07T01:54:41Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "74a10f27-7d5f-497d-9d35-493fdef4c568",
        "parentId" : "489adf70-a1bf-453b-962b-1fced9820eac",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I think of it like this:\n1. if one or the other has a directive marker, then we need to consider that before looking at the individual keys, since a directive operates on the whole map.\n2. if one has a directive marker and the other doesn't, then we have a conflict, since one is deleting or replacing the whole map, and the other is doing things to individual keys.\n3. if they both have markers, but they are not the same directive, then we have a conflict because they're doing different things to the map.\n4. if they both have the same directive, then there's no conflict here, and we're done looking at this map.\n5. otherwise, check the individual keys.\n\nThis seems obtuse enough to warrant a comment.\n",
        "createdAt" : "2015-11-13T20:14:18Z",
        "updatedAt" : "2015-12-07T01:54:41Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "b11dec7aec5a5247bc78da1127d6c2b36b960f49",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1001,1005 @@\t\t\t// then we need to consider that before looking at the individual keys,\n\t\t\t// since a directive operates on the whole map.\n\t\t\tif okLeft || okRight {\n\t\t\t\t// if one has a directive marker and the other doesn't,\n\t\t\t\t// then we have a conflict, since one is deleting or replacing the whole map,"
  },
  {
    "id" : "2f301687-93d1-4373-b915-12634b0d89a2",
    "prId" : 13820,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e68de505-fe8a-4d41-a3d7-413aaa8e6c80",
        "parentId" : null,
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "My understanding is that the \"delete-decorator\" method I was describing would take \"patch\" (the local config file given to `kubectl apply`) and \"previous\" (i.e. the content of the annotation) to produce a new strategic merge patch with delete directives for missing fields. That patch then gets sent directly to the server which applies it with the pre-existing StrategicMergePatch method. Why do we need a method that is creating its own patch from scratch using original and modified?\n",
        "createdAt" : "2015-09-28T05:42:57Z",
        "updatedAt" : "2015-10-08T00:14:10Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      },
      {
        "id" : "ebaaa686-0e0b-4aba-8fec-9e6b7658f8cc",
        "parentId" : "e68de505-fe8a-4d41-a3d7-413aaa8e6c80",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "This approach reuses existing proven code, instead of adding a whole new set of recursive methods, and has exactly the same semantics, except that the patch does not update fields that are already set correctly, making it smaller. Bottom line... less code and more efficient.\n",
        "createdAt" : "2015-09-28T17:33:03Z",
        "updatedAt" : "2015-10-08T00:14:10Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddda379b1b20ef59a9699237ef36afc83f8fe39c",
    "line" : 507,
    "diffHunk" : "@@ -1,1 +971,975 @@// configuration, or, if force is false and there are conflicts between the modified and current\n// configurations.\nfunc CreateThreeWayMergePatch(original, modified, current []byte, dataStruct interface{}, force bool, fns ...PreconditionFunc) ([]byte, error) {\n\toriginalMap := map[string]interface{}{}\n\tif len(original) > 0 {"
  },
  {
    "id" : "d603502b-dd4b-408f-9076-796599968964",
    "prId" : 13007,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb215abd-6152-4594-80eb-dd3b6f33b35e",
        "parentId" : null,
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "+1 on rename. Hangover from early iterations of the library.\n",
        "createdAt" : "2015-08-21T03:25:07Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ecb1bac83aeb705f26f4f9d9ee71fa18b0d074c",
    "line" : 336,
    "diffHunk" : "@@ -1,1 +355,359 @@\n// StrategicMergePatchData applies a patch using strategic merge patch semantics.\n// Deprecated: StrategicMergePatchData is deprecated. Use the synonym StrategicMergePatch,\n// instead, which follows the naming convention of evanphx/json-patch.\nfunc StrategicMergePatchData(original, patch []byte, dataStruct interface{}) ([]byte, error) {"
  },
  {
    "id" : "0b28b7f1-4e3f-4d94-b523-790cd97628da",
    "prId" : 13007,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d373b3e-2dad-4e17-8ceb-8757e1feed8e",
        "parentId" : null,
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Any reason to change this? I think I made it panic deliberately since it should be indicating programmer error, not user error, since it should not be possible based on its surrounding code to call it with a slice that has a different type than `value`.\n",
        "createdAt" : "2015-08-21T03:27:48Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      },
      {
        "id" : "30db9b76-f90e-4e50-8888-dc5b3dbeb777",
        "parentId" : "3d373b3e-2dad-4e17-8ceb-8757e1feed8e",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "I wanted to remove all possibility of bad data causing a panic. If this library is linked into the api server, then the cluster could potentially be brought down by submitting bad configuration, unless the panic is removed.\n",
        "createdAt" : "2015-08-21T15:40:24Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      },
      {
        "id" : "427bd687-8a5f-4a87-9d4e-1f4b46d0efcb",
        "parentId" : "3d373b3e-2dad-4e17-8ceb-8757e1feed8e",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Okay, in that case I would recommend extending the function to return an error. Otherwise it may create some hard-to-find bugs if this error case is hidden, since the function would act like the value is not found when in fact it may be encountering an element of the wrong type.\n\nI did think that panics were generally logged and recovered in our daemons, but not sure if we want to depend on that kind of handling. @bgrant0607 is there an expectation for how severely panics can affect daemons like apiserver that can be depended on?\n",
        "createdAt" : "2015-08-21T17:40:23Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      },
      {
        "id" : "36f7828e-93be-4a25-9a0b-8335b61b7685",
        "parentId" : "3d373b3e-2dad-4e17-8ceb-8757e1feed8e",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I don't know what the impact of panics is.\n\nI agree that if we don't panic, this needs to return an error.\n",
        "createdAt" : "2015-08-25T22:06:45Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "ca4518f2-0421-4c51-99e2-c68d840526b0",
        "parentId" : "3d373b3e-2dad-4e17-8ceb-8757e1feed8e",
        "authorId" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "body" : "Agreed.\n",
        "createdAt" : "2015-08-28T13:25:48Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "8f7fe7a6-7bc9-4dfb-b9c0-a2f808baa9d1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ecb1bac83aeb705f26f4f9d9ee71fa18b0d074c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +598,602 @@}\n\n// This method no longer panics if any element of the slice is not a map.\nfunc findMapInSliceBasedOnKeyValue(m []interface{}, key string, value interface{}) (map[string]interface{}, int, bool, error) {\n\tfor k, v := range m {"
  },
  {
    "id" : "c6567d90-6587-44b1-82fd-76b7ab390e64",
    "prId" : 13007,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9443a36-e184-4017-b9c9-bd244229729d",
        "parentId" : null,
        "authorId" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "body" : "docs/devel/api-conventions.md\n",
        "createdAt" : "2015-09-08T17:02:41Z",
        "updatedAt" : "2015-09-10T21:01:22Z",
        "lastEditedBy" : "01c14569-b640-48af-98cc-aa9dd12da7b6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ecb1bac83aeb705f26f4f9d9ee71fa18b0d074c",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +31,35 @@// lists should be merged or replaced.\n//\n// For more information, see the PATCH section of docs/api-conventions.md.\n//\n// Some of the content of this package was borrowed with minor adaptations from"
  },
  {
    "id" : "0e23a2d2-51d6-4187-8037-c234dd7436ca",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88cbdaf9-3133-44b7-adab-60439c58ca9c",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Does a \"null\" json/yaml value translate to nil?\n",
        "createdAt" : "2015-04-01T22:58:49Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "4e1ba039-5304-42e9-8045-0beca9ad6cf6",
        "parentId" : "88cbdaf9-3133-44b7-adab-60439c58ca9c",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Yes - in JSON, `null` without quotes translates to nil. In YAML, `null` without quotes is converted from a string to nil.\n",
        "createdAt" : "2015-04-03T01:00:06Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +88,92 @@\t\t// If the value of this key is null, delete the key if it exists in the\n\t\t// original. Otherwise, skip it.\n\t\tif patchV == nil {\n\t\t\tif _, ok := original[k]; ok {\n\t\t\t\tdelete(original, k)"
  },
  {
    "id" : "d81e7854-c8d3-4ddd-a466-a592a66816da",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d0ecd5e-0836-41dd-bd15-95aef9928710",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We're returning original and also mutating it? Perhaps we should just do one or the other?\n",
        "createdAt" : "2015-04-01T23:01:59Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "c64e55c3-7fc8-422d-909a-20e9a4ef6281",
        "parentId" : "9d0ecd5e-0836-41dd-bd15-95aef9928710",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "We need to mutate because deep-copying a slice or map in golang to then work on the copy is very difficult. (I added a comment to the function to clarify this.)\n\nI tried just now to refactor to only mutate and not return, but sometimes we just return the patch value directly (e.g. in the \"strict\" case) or generate a new value, and trying to mutate the original in that case would add a good amount of complexity. Hence, both mutating and returning. Given these are private functions with very specific use, I think it's not great but okay.\n",
        "createdAt" : "2015-04-03T01:12:01Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : null,
    "diffHunk" : "@@ -1,1 +139,143 @@\t}\n\n\treturn original, nil\n}\n"
  },
  {
    "id" : "96428018-849d-4708-b18d-901d93739d31",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f47c56c-df97-4d0d-b232-232add5f491e",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "I'd just put `continue` after this, like you do for the other cases.\n",
        "createdAt" : "2015-04-01T23:03:25Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "166cc9d6-3185-4f3a-ab24-3b316ddf06c2",
        "parentId" : "0f47c56c-df97-4d0d-b232-232add5f491e",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Done. Also lets me remove the \"else\" on the next line.\n",
        "createdAt" : "2015-04-03T01:18:17Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : null,
    "diffHunk" : "@@ -1,1 +97,101 @@\t\tif !ok {\n\t\t\t// If it's not in the original document, just take the patch value.\n\t\t\toriginal[k] = patchV\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "1ccae551-8652-4d47-9f64-8b6be54bcb3c",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2479f671-600c-4f71-96ab-7ed3f165a7e4",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "If we did support merging of lists of lists, where would the merge key be specified?\n",
        "createdAt" : "2015-04-01T23:15:44Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "127d9651-0e46-4cbf-b813-bd71c17a5ddc",
        "parentId" : "2479f671-600c-4f71-96ab-7ed3f165a7e4",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "In the struct tag model, you'd probably just put patchStrategy:merge on a list of list and it would just handle it correctly, and the mergeKey would just apply to the inner list vs the outer list.\n",
        "createdAt" : "2015-04-03T01:35:32Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 158,
    "diffHunk" : "@@ -1,1 +156,160 @@\t}\n\tif t.Kind() == reflect.Slice {\n\t\treturn nil, fmt.Errorf(\"not supporting merging lists of lists yet\")\n\t}\n\t// If the elements are not maps, merge the slices of scalars."
  },
  {
    "id" : "1c24b354-8a03-4c63-b777-062b679cf417",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9791bfcf-a335-4b73-a6e8-f9f5dccfe7e5",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "The uniquification behavior should be documented. \n",
        "createdAt" : "2015-04-01T23:17:48Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "cf762c98-9902-4bcc-aaba-71b659315c87",
        "parentId" : "9791bfcf-a335-4b73-a6e8-f9f5dccfe7e5",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "I added a note to api-conventions.md.\n",
        "createdAt" : "2015-04-03T01:36:53Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +160,164 @@\t// If the elements are not maps, merge the slices of scalars.\n\tif t.Kind() != reflect.Map {\n\t\t// Maybe in the future add a \"concat\" mode that doesn't\n\t\t// uniqify.\n\t\tboth := append(original, patch...)"
  },
  {
    "id" : "c7c853a3-e285-4819-a39e-c61f8137acb7",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5565d414-b3c7-48fd-b8c5-d989b6e50a57",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Users might expect to be able to specify `__patch: merge`, so we probably should generate a specific error message for that.\n",
        "createdAt" : "2015-04-01T23:26:13Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "fee1d531-7eb6-4af5-b6b1-ef4dd0caa492",
        "parentId" : "5565d414-b3c7-48fd-b8c5-d989b6e50a57",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Good point - added.\n",
        "createdAt" : "2015-04-03T01:38:25Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : null,
    "diffHunk" : "@@ -1,1 +194,198 @@\t\t\t\treturn nil, fmt.Errorf(\"merging lists cannot yet be specified in the patch\")\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"unknown patch type found: %s\", patchType)\n\t\t\t}\n\t\t} else {"
  },
  {
    "id" : "f7aebede-899a-4581-9c8d-eddd69ed4059",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "268669c2-0c7e-4a57-930f-dabb4f07203e",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Another approach is that we could build a map in the loop above. We'd just lose all ordering. I personally don't think that should matter for lists being merged as maps.\n",
        "createdAt" : "2015-04-01T23:28:25Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "bcbc5a70-0274-4f7e-b715-2dbbc4af00d0",
        "parentId" : "268669c2-0c7e-4a57-930f-dabb4f07203e",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Once a list is marked as merge, we are intentionally considering order insignificant. But I don't understand what you're proposing here. We have to recursively merge because we have to treat this map merging just as if it's a top-level map - we have to respect other merge lists that might be inside, etc.\n",
        "createdAt" : "2015-04-03T01:48:17Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 219,
    "diffHunk" : "@@ -1,1 +217,221 @@\t\t// If we find a value with this merge key value in original, merge the\n\t\t// maps. Otherwise append onto original.\n\t\toriginalMap, originalKey, found := findMapInSliceBasedOnKeyValue(original, mergeKey, mergeValue)\n\t\tif found {\n\t\t\tvar mergedMaps interface{}"
  },
  {
    "id" : "94f79f0b-fe3d-4350-a3fb-8a515f44401c",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09e0e687-b6e2-4bc9-aa47-4bcad7dd7cf1",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Why panic rather than return an error?\n",
        "createdAt" : "2015-04-01T23:34:32Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "622de3c4-dd3b-463b-8250-c028c5eabfa2",
        "parentId" : "09e0e687-b6e2-4bc9-aa47-4bcad7dd7cf1",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Because it's more like an \"unreachable\", not \"bad input\". A slice of anything but all maps should never be able to reach this function. Given that if you still think it's better as an error I can convert.\n",
        "createdAt" : "2015-04-03T01:54:09Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 237,
    "diffHunk" : "@@ -1,1 +235,239 @@}\n\n// This panics if any element of the slice is not a map.\nfunc findMapInSliceBasedOnKeyValue(m []interface{}, key string, value interface{}) (map[string]interface{}, int, bool) {\n\tfor k, v := range m {"
  },
  {
    "id" : "ed70e2d4-c004-41f1-9c44-de7f14d6d5d6",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85a7082a-a547-48a0-878c-81e296c17eba",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "FYI, we're going to need a \"diff\" functionality that has the same matching logic as strategic merge. Many people want to review just what's changed when performing a config merge.\n",
        "createdAt" : "2015-04-01T23:36:20Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "18855422-e53c-4979-8b93-a9177142dd8a",
        "parentId" : "85a7082a-a547-48a0-878c-81e296c17eba",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "Yes - this function may play a role in that.\n",
        "createdAt" : "2015-04-03T01:55:36Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 252,
    "diffHunk" : "@@ -1,1 +250,254 @@// by key. This is needed by tests because in JSON, list order is significant,\n// but in Strategic Merge Patch, merge lists do not have significant order.\n// Sorting the lists allows for order-insensitive comparison of patched maps.\nfunc sortMergeListsByName(mapJSON []byte, dataStruct interface{}) ([]byte, error) {\n\tvar m map[string]interface{}"
  },
  {
    "id" : "0af594ad-15b4-4775-968d-68b95913d1de",
    "prId" : 6027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6c7dcfd7-1c55-4115-9caa-342a24a756b4",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "Where is this used? Could we sort in the merge pass so as not to duplicate the logic?\n",
        "createdAt" : "2015-04-01T23:40:41Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "08c31e2c-bc23-4aed-a6bb-0bd206574bcd",
        "parentId" : "6c7dcfd7-1c55-4115-9caa-342a24a756b4",
        "authorId" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "body" : "It's used in the tests.\n\nIt needs to be separate because in the tests you're comparing expected result to output. You can control how output is produced, but you can't control how someone writes their expected result (e.g. out of order), and you need to do an order-insensitive comparison between them.\n\nWhen we build dry-run I'll revisit how some components of this might be able to be refactored/cleaned up.\n",
        "createdAt" : "2015-04-03T01:58:59Z",
        "updatedAt" : "2015-04-03T18:51:04Z",
        "lastEditedBy" : "f22a9095-b804-4932-8c62-ecb134b86477",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c977db1b3af70fd60e0d111e6b6ac9dfe80e0ff",
    "line" : 253,
    "diffHunk" : "@@ -1,1 +251,255 @@// but in Strategic Merge Patch, merge lists do not have significant order.\n// Sorting the lists allows for order-insensitive comparison of patched maps.\nfunc sortMergeListsByName(mapJSON []byte, dataStruct interface{}) ([]byte, error) {\n\tvar m map[string]interface{}\n\terr := json.Unmarshal(mapJSON, &m)"
  }
]
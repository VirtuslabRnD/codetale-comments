[
  {
    "id" : "3871417c-e45f-4c4e-80af-8ff840fc189a",
    "prId" : 465,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9a1d42e-bfef-45a6-bc10-f237ae086a17",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I think this is safe, but only because you can't remove a listener. Consider doing the loop while locked, and doing `go OnUpdate()`?\n",
        "createdAt" : "2014-07-15T16:48:12Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "af1d6bde-a28f-408f-afcf-a474025fa09d",
        "parentId" : "a9a1d42e-bfef-45a6-bc10-f237ae086a17",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Want to guarantee in order delivery of updates, so go OnUpdate() would break that.  Also, removal should be a slice change (create new slice and copy old elements in) - so you'd implicitly not need to sync on the list during access (CoW)\n",
        "createdAt" : "2014-07-15T17:25:27Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "685f21da-bb6b-4794-b656-113dba709ce3",
        "parentId" : "a9a1d42e-bfef-45a6-bc10-f237ae086a17",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Ah, yeah, I think it is safe if you implement remove like that. I guess it's a moot point since there's not really a way to remove a specific listener at all, as the listener interface doesn't have any way to check equality...\n",
        "createdAt" : "2014-07-15T17:43:52Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "021cf6480857086135faf36ee8e1078f227a7cda",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +133,137 @@func (m *Watcher) Notify(instance interface{}) {\n\tm.listenerLock.RLock()\n\tlisteners := m.listeners\n\tm.listenerLock.RUnlock()\n\tfor _, listener := range listeners {"
  },
  {
    "id" : "1d8041f4-5d37-4a0d-bc39-5654f887744a",
    "prId" : 465,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2729f799-0bfe-41ea-abba-ec3c4f07cea3",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "interface comment?\n",
        "createdAt" : "2014-07-15T23:19:34Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "021cf6480857086135faf36ee8e1078f227a7cda",
    "line" : null,
    "diffHunk" : "@@ -1,1 +86,90 @@\n// Accessor is an interface for retrieving the current merge state.\ntype Accessor interface {\n\t// MergedState returns a representation of the current merge state.\n\t// Must be reentrant when more than one source is defined."
  },
  {
    "id" : "28d7058c-d2d4-442e-86f1-763b6a75d6e1",
    "prId" : 465,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e82578e-1964-4ec9-8c4e-8f03adee9070",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "use defer?\n",
        "createdAt" : "2014-07-15T23:20:26Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "6baf36d6-086b-45dd-91a4-12ad5804274b",
        "parentId" : "4e82578e-1964-4ec9-8c4e-8f03adee9070",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Updates are outside the scope of the lock, just because we don't need to hold the read lock and those operations could be long running.\n",
        "createdAt" : "2014-07-16T16:59:16Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "6d0c902f-9dcf-4563-920f-b20fbc895374",
        "parentId" : "4e82578e-1964-4ec9-8c4e-8f03adee9070",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I like to write an accessor function to do things like this, specifically so that it can use defer. But I don't have a strong opinion.\n",
        "createdAt" : "2014-07-16T18:12:39Z",
        "updatedAt" : "2014-07-16T18:13:28Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "5a4c05bb-f541-454f-88d9-9436687750f3",
        "parentId" : "4e82578e-1964-4ec9-8c4e-8f03adee9070",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "The locks here are close enough that I'd argue that defer doesn't significantly improve readability (in the absence of a branch).  Will bow to strong opinions though :)\n",
        "createdAt" : "2014-07-16T18:16:11Z",
        "updatedAt" : "2014-07-16T18:16:22Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "021cf6480857086135faf36ee8e1078f227a7cda",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +134,138 @@\tm.listenerLock.RLock()\n\tlisteners := m.listeners\n\tm.listenerLock.RUnlock()\n\tfor _, listener := range listeners {\n\t\tlistener.OnUpdate(instance)"
  }
]
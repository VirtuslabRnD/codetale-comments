[
  {
    "id" : "21c5e132-ed38-4aee-8c30-65df03c8a532",
    "prId" : 7721,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9da53eed-08d3-44ed-81be-9b7451040879",
        "parentId" : null,
        "authorId" : null,
        "body" : "minor nit: Any reason not to collapse the not nil check and the assignment into a single if statement? i.e. single call to To4().\n",
        "createdAt" : "2015-05-04T20:24:19Z",
        "updatedAt" : "2015-05-04T20:24:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "dda41be5-1056-4224-85aa-176db117af43",
        "parentId" : "9da53eed-08d3-44ed-81be-9b7451040879",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Long if line is probably the reason.  Agree the nesting is really high.\n",
        "createdAt" : "2015-05-04T20:32:07Z",
        "updatedAt" : "2015-05-04T20:32:07Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "166021e7651d53722ac0fb5bb5a45671227f521a",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +408,412 @@\t\t\t\tfor _, addr := range addrs {\n\t\t\t\t\tif addrIP, _, err := net.ParseCIDR(addr.String()); err == nil {\n\t\t\t\t\t\tif addrIP.To4() != nil {\n\t\t\t\t\t\t\tip = addrIP.To4()\n\t\t\t\t\t\t\tbreak"
  },
  {
    "id" : "5514d1b5-83ab-410f-94c3-66971f652048",
    "prId" : 7721,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de9048ff-5a9f-48b3-860f-0c0085eb4957",
        "parentId" : null,
        "authorId" : null,
        "body" : "I think that this dead code.  I think that the only way for ip to be non-nil here would be with the above assignment stmt, in which case we would have break'd already.\n",
        "createdAt" : "2015-05-04T20:29:48Z",
        "updatedAt" : "2015-05-04T20:29:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "7902673b-2198-412f-ac7f-809e7c6e6ca6",
        "parentId" : "de9048ff-5a9f-48b3-860f-0c0085eb4957",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "There are two loops - break takes you to the parent loop (the interface loop)\n",
        "createdAt" : "2015-05-04T20:31:35Z",
        "updatedAt" : "2015-05-04T20:31:35Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "cc712dac-0214-471d-84db-ae787933d387",
        "parentId" : "de9048ff-5a9f-48b3-860f-0c0085eb4957",
        "authorId" : null,
        "body" : "Doh!  You're right :-)\n",
        "createdAt" : "2015-05-04T21:09:02Z",
        "updatedAt" : "2015-05-04T21:09:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "166021e7651d53722ac0fb5bb5a45671227f521a",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +414,418 @@\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ip != nil {\n\t\t\t\t\t// This interface should suffice.\n\t\t\t\t\tbreak"
  },
  {
    "id" : "ca1a02db-2509-4d41-a0b8-80b04f1ceb9a",
    "prId" : 7704,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15856aaf-75b9-4f6e-8f59-9f4d5cc98039",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "do these changes belong in this PR?\n",
        "createdAt" : "2015-05-04T23:15:44Z",
        "updatedAt" : "2015-05-08T20:04:16Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a1427835-272e-4c33-9795-35e95303e507",
        "parentId" : "15856aaf-75b9-4f6e-8f59-9f4d5cc98039",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "See the comment about them being covered by other pulls (already merged)\n\n> On May 4, 2015, at 7:15 PM, Daniel Smith notifications@github.com wrote:\n> \n> In pkg/util/util.go:\n> \n> > @@ -397,6 +397,7 @@ func chooseHostInterfaceNativeGo() (net.IP, error) {\n> >         return nil, err\n> >     }\n> >     i := 0\n> > -   var ip net.IP\n> >   do these changes belong in this PR?\n> \n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2015-05-04T23:26:51Z",
        "updatedAt" : "2015-05-08T20:04:16Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "8bbb64cd8bb225bc725e8577b66264a867280502",
    "line" : null,
    "diffHunk" : "@@ -1,1 +398,402 @@\t}\n\ti := 0\n\tvar ip net.IP\n\tfor i = range intfs {\n\t\tif flagsSet(intfs[i].Flags, net.FlagUp) && flagsClear(intfs[i].Flags, net.FlagLoopback|net.FlagPointToPoint) {"
  },
  {
    "id" : "8ff7d038-6fe6-4e31-98f6-1bf902369e1f",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6217468-b473-4c92-8280-e3868bcabc58",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "nit: I think I'd prefer\n\n``` go\nfor line, err := scanner.ReadString('\\n'); err != io.EOF; line, err:= scanner.ReadString('\\n') {\n...\n}\n```\n\nbut I don't care that much.\n",
        "createdAt" : "2015-02-26T22:19:18Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : null,
    "diffHunk" : "@@ -1,1 +261,265 @@\tfor {\n\t\tline, err := scanner.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}"
  },
  {
    "id" : "23de4f6a-cdea-4f97-9e92-41ed2efc043b",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "171a2e05-5a83-4bb0-ad21-91920b088420",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "move before usage of 'line'\n",
        "createdAt" : "2015-03-02T06:39:58Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : null,
    "diffHunk" : "@@ -1,1 +261,265 @@\tfor {\n\t\tline, err := scanner.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}"
  },
  {
    "id" : "296b61c5-62eb-4afb-8b6d-a4585a0bdbed",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d102ed60-0891-4fc3-a31c-5042849e01b3",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "nit: personally, I think this is cleaner as:\n\n``` go\nline, err := scanner.ReadString('\\n')\nfor err != io.EOF {\n  ...\n  line, err = scanner.ReadString('\\n')\n}\n```\n",
        "createdAt" : "2015-03-03T22:13:50Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : null,
    "diffHunk" : "@@ -1,1 +259,263 @@\t}\n\tscanner := bufio.NewReader(input)\n\tfor {\n\t\tline, err := scanner.ReadString('\\n')\n\t\tif err == io.EOF {"
  },
  {
    "id" : "7fd744ce-238e-46c5-8c2d-59018634ffb2",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "139a00dd-8310-43d5-9a80-a374b03f2936",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "For throughness of testing I'd like to see this as:\n\n```\nfunc ChooseHostInterface() (net.IP, error) {\n    inFile, err := os.Open(\"/proc/net/route\")\n    if err != nil {\n        return nil, err\n    }\n    defer inFile.Close()\n    nw := NetworkInterface{}\n    return chooseHostIntfInternal(inFile, nw)\n}\n```\n\nThat way ALL of the logic can be tested together.\n",
        "createdAt" : "2015-03-05T07:11:32Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "745bd0ec-c115-43c8-809a-556aa1effbbc",
        "parentId" : "139a00dd-8310-43d5-9a80-a374b03f2936",
        "authorId" : "955a1a53-be89-4d06-9d67-c02d55287906",
        "body" : "this is done\n",
        "createdAt" : "2015-03-05T08:51:46Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "955a1a53-be89-4d06-9d67-c02d55287906",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +370,374 @@//For a node with no internet connection ,it returns error\n//For a multi n/w interface node it returns the IP of the interface with gateway on it.\nfunc ChooseHostInterface() (net.IP, error) {\n\tinFile, err := os.Open(\"/proc/net/route\")\n\tif err != nil {"
  },
  {
    "id" : "44034b6a-a799-4fa0-91ab-01d209b1dac5",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c7eeb56-a145-434e-8fa4-b948d26455fa",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Why do this rather than define a simple netDevice interface that has exactly the methods we need on it? \n",
        "createdAt" : "2015-03-05T07:16:11Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "cd668c3f-bd84-4fea-9c05-e6a1b30d7f88",
        "parentId" : "5c7eeb56-a145-434e-8fa4-b948d26455fa",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "To be clear, this is OK, just not what I would expect..\n",
        "createdAt" : "2015-03-05T07:16:33Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : null,
    "diffHunk" : "@@ -1,1 +382,386 @@type networkInterfacer interface {\n\tInterfaceByName(intfName string) (*net.Interface, error)\n\tAddrs(intf *net.Interface) ([]net.Addr, error)\n}\n"
  },
  {
    "id" : "0eb5d0c2-19db-40d6-aa6d-ddb33c788693",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "490f46a1-12c1-4725-a3c9-84b59c600f17",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Could you possibly add a comment about what the \"final\" IP is?  Right now it looks more like getFirstNonLoopbackIpv4, but that's a bit of a mouthful :-)\n",
        "createdAt" : "2015-03-10T12:57:06Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : null,
    "diffHunk" : "@@ -1,1 +316,320 @@//and returns a nil if the address is Loopback , Ipv6  or nil.\n//It returns a valid IPv4 if an Ipv4 address is found in the array.\nfunc getFinalIP(addrs []net.Addr) (net.IP, error) {\n\tif len(addrs) > 0 {\n\t\tfor i := range addrs {"
  },
  {
    "id" : "e5cd2c6c-eb92-495e-b59a-c3e91c0c8591",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d4f4f1d2-5429-4402-8cff-685312959ae4",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Maybe add comment that this is the header line we're skipping\n",
        "createdAt" : "2015-03-10T12:58:13Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : null,
    "diffHunk" : "@@ -1,1 +265,269 @@\t\t}\n\t\t//ignore the headers in the route info\n\t\tif strings.HasPrefix(line, \"Iface\") {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "fde0969e-9880-48c5-a00d-8563eaf48263",
    "prId" : 4865,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c247cfaf-a75a-4057-816f-96fe10456ddb",
        "parentId" : null,
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "I'm not familiar with this idiom.  Is there a reason you don't just build the Route and then append it?  (Efficiency?)\n",
        "createdAt" : "2015-03-10T12:59:39Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "191a251d-ea29-40a1-923e-fb3043a5f1f9",
        "parentId" : "c247cfaf-a75a-4057-816f-96fe10456ddb",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I think that was a me-ism, and it was just because extra copies annoy me.\nI don't much care either way.\n\nOn Tue, Mar 10, 2015 at 6:00 AM, Justin Santa Barbara <\nnotifications@github.com> wrote:\n\n> In pkg/util/util.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/4865#discussion_r26118728\n> :\n> \n> > +func getRoutes(input io.Reader) ([]Route, error) {\n> > -   routes := []Route{}\n> > -   if input == nil {\n> > -       return nil, fmt.Errorf(\"input is nil\")\n> > -   }\n> > -   scanner := bufio.NewReader(input)\n> > -   for {\n> > -       line, err := scanner.ReadString('\\n')\n> > -       if err == io.EOF {\n> > -           break\n> > -       }\n> > -       if strings.HasPrefix(line, \"Iface\") {\n> > -           continue\n> > -       }\n> > -       fields := strings.Fields(line)\n> > -       routes = append(routes, Route{})\n> \n> I'm not familiar with this idiom. Is there a reason you don't just build\n> the Route and then append it? (Efficiency?)\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/4865/files#r26118728\n> .\n",
        "createdAt" : "2015-03-10T13:02:38Z",
        "updatedAt" : "2015-03-11T08:33:11Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "b8c91e7344923e48a6905d642c843cdd86ba5793",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +269,273 @@\t\t}\n\t\tfields := strings.Fields(line)\n\t\troutes = append(routes, Route{})\n\t\troute := &routes[len(routes)-1]\n\t\troute.Interface = fields[0]"
  },
  {
    "id" : "5f5f5b0c-1f35-491a-8912-17826a3da78e",
    "prId" : 4115,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c179ed49-8494-4263-aaa1-9cf448b4cbda",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Prefer to check the error before looking at the result.  I.e. flip these 2 blocks.\n",
        "createdAt" : "2015-03-02T06:20:51Z",
        "updatedAt" : "2015-03-16T18:07:33Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "1138045185a3a9a71f46421355cdef19af267bf3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +274,278 @@\tfor {\n\t\tline, err := scanner.ReadString('\\n')\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}"
  },
  {
    "id" : "94126dc3-c698-4583-aae1-f755bb64e58b",
    "prId" : 3178,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4783b1c-9e20-4dcd-8819-db00c7d2d7b5",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "check for v.IsValid() before checking kind\n",
        "createdAt" : "2014-12-30T22:39:27Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "7c6d079b-46db-4ec7-92cb-ffa446e0232a",
        "parentId" : "b4783b1c-9e20-4dcd-8819-db00c7d2d7b5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "And do what if it is not?  What could cause IsValid() to ever return false here?  I'd rather avoid returning an error here, if possible.\n",
        "createdAt" : "2014-12-30T22:46:18Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "50dda388-2566-4070-9541-1e1f45a38005",
        "parentId" : "b4783b1c-9e20-4dcd-8819-db00c7d2d7b5",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I believe a nil obj might cause that. If it's not valid, the below lines will crash. I don't care if you round that off to true or false instead of returning an error. Or just crash if that doesn't bother you and people shouldn't use this like that.\n",
        "createdAt" : "2014-12-30T22:56:52Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "e13184ee-0046-4be8-ad73-1165c1b40778",
        "parentId" : "b4783b1c-9e20-4dcd-8819-db00c7d2d7b5",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "will crash and see if it ever triggers\n",
        "createdAt" : "2014-12-30T23:08:10Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d239cbb1e9ba84ac87d14ae692adc26e5fdd75",
    "line" : null,
    "diffHunk" : "@@ -1,1 +159,163 @@// type will cause a panic.  Passing a typed nil pointer will return true.\nfunc AllPtrFieldsNil(obj interface{}) bool {\n\tv := reflect.ValueOf(obj)\n\tif !v.IsValid() {\n\t\tpanic(fmt.Sprintf(\"reflect.ValueOf() produced a non-valid Value for %#v\", obj))"
  },
  {
    "id" : "9d14b812-1e17-40b7-ba3f-5e01aea66cc7",
    "prId" : 3178,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27d65694-5652-4ae9-9613-33eae3b4d097",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Check not nil before v.Elem\n",
        "createdAt" : "2014-12-30T22:39:39Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "03cd786a-280a-40d2-980f-132af63618a4",
        "parentId" : "27d65694-5652-4ae9-9613-33eae3b4d097",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Sure, I'll return true.\n",
        "createdAt" : "2014-12-30T22:48:57Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "3aed70c5-2735-495f-acd0-06736e0593c3",
        "parentId" : "27d65694-5652-4ae9-9613-33eae3b4d097",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Consider doing this in a loop-- what do you want to happen if someone passes a **struct{Foo *int}?\n",
        "createdAt" : "2014-12-30T22:54:25Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f5b6d525-a0c9-44e4-a8fa-60abaafd4927",
        "parentId" : "27d65694-5652-4ae9-9613-33eae3b4d097",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Documented constraints on the function - structs or pointers to structs.\n",
        "createdAt" : "2014-12-30T23:09:29Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d239cbb1e9ba84ac87d14ae692adc26e5fdd75",
    "line" : null,
    "diffHunk" : "@@ -1,1 +163,167 @@\t\tpanic(fmt.Sprintf(\"reflect.ValueOf() produced a non-valid Value for %#v\", obj))\n\t}\n\tif v.Kind() == reflect.Ptr {\n\t\tif v.IsNil() {\n\t\t\treturn true"
  },
  {
    "id" : "9252684a-1058-45ea-a311-fd1dd06fcbc5",
    "prId" : 3178,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84a15b3f-d61f-48a4-a3c7-75fb80956361",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Check that kind is struct before looping through fields.\n",
        "createdAt" : "2014-12-30T22:53:17Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "cff4f85a-4a49-49cb-90f6-69e2636acdb7",
        "parentId" : "84a15b3f-d61f-48a4-a3c7-75fb80956361",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Documented\n",
        "createdAt" : "2014-12-30T23:10:14Z",
        "updatedAt" : "2015-01-04T07:57:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d239cbb1e9ba84ac87d14ae692adc26e5fdd75",
    "line" : null,
    "diffHunk" : "@@ -1,1 +168,172 @@\t\t}\n\t\tv = v.Elem()\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tif v.Field(i).Kind() == reflect.Ptr && !v.Field(i).IsNil() {"
  },
  {
    "id" : "7355b82f-468e-4a31-bb00-bb4ba6238e1d",
    "prId" : 2661,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "17d33adf-5c16-4b2c-bb73-361741e5d4bd",
        "parentId" : null,
        "authorId" : "473c3a16-cb87-4189-9496-af8b26ead122",
        "body" : "every `period`?\n",
        "createdAt" : "2014-11-28T20:20:15Z",
        "updatedAt" : "2014-11-28T20:20:15Z",
        "lastEditedBy" : "473c3a16-cb87-4189-9496-af8b26ead122",
        "tags" : [
        ]
      },
      {
        "id" : "a7753400-914b-4225-8f64-d513a95cced0",
        "parentId" : "17d33adf-5c16-4b2c-bb73-361741e5d4bd",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "Doc is the same as the other Forever.\n",
        "createdAt" : "2014-11-28T20:51:08Z",
        "updatedAt" : "2014-11-28T20:51:08Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "43c7de6d-2726-42ee-ab09-4f3eddc0c3f9",
        "parentId" : "17d33adf-5c16-4b2c-bb73-361741e5d4bd",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Doc should probably match actual variable names in both places.\n",
        "createdAt" : "2014-12-02T01:44:51Z",
        "updatedAt" : "2014-12-02T01:44:51Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "740b824ac2ebdf64c11acd585f6e5a896f8241d5",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +55,59 @@}\n\n// Until loops until stop channel is closed, running f every d.\n// Catches any panics, and keeps going. f may not be invoked if\n// stop channel is already closed."
  },
  {
    "id" : "05564581-3468-4132-8484-59fdb7b9d59e",
    "prId" : 2661,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12be7958-70c7-4fab-9144-c1af5c00c680",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I would love it if you made the syntax to use this work like `defer util.Until(f, d).Stop()`\n",
        "createdAt" : "2014-12-02T01:41:11Z",
        "updatedAt" : "2014-12-02T01:41:11Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "395408d9-5b88-4252-b28e-8b5d00a9aa76",
        "parentId" : "12be7958-70c7-4fab-9144-c1af5c00c680",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "So return an interface that can be stopped?  Since Until is usually in a goroutine, you'd end up having to pass that object back out via some mechanism, so I don't know how that would work.  Or are you envisioning a different use case?\n\nNormative\n\n```\nfunc Run() {\n  go util.Until(func() { // almost forever }, 0, stop)\n}\n```\n\n----- Original Message -----\n\n> > @@ -51,7 +51,19 @@ func HandleCrash() {\n> > \n> >  // Forever loops forever running f every d.  Catches any panics, and keeps\n> >  going.\n> >  func Forever(f func(), period time.Duration) {\n> > -   Until(f, period, nil)\n> >   +}\n> >   +\n> >   +// Until loops until stop channel is closed, running f every d.\n> >   +// Catches any panics, and keeps going. f may not be invoked if\n> >   +// stop channel is already closed.\n> >   +func Until(f func(), period time.Duration, stopCh <-chan struct{}) {\n> \n> I would love it if you made the syntax to use this work like `defer\n> util.Until(f, d).Stop()`\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/2661/files#r21135539\n",
        "createdAt" : "2014-12-02T18:51:13Z",
        "updatedAt" : "2014-12-02T18:51:13Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "1f7d7ef4-c6ca-4b99-ab78-d5e0cbbd357a",
        "parentId" : "12be7958-70c7-4fab-9144-c1af5c00c680",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Something like this should take care of it, no?\n\n```\ntype stopper chan struct{}\nfunc (s stopper) Stop() { close(s) }\n\nfunc Until(f func(), period time.Duration) stopper {\n  ...\n  ch := make(stopper)\n  ...\n  return ch\n}\n```\n",
        "createdAt" : "2014-12-02T19:16:45Z",
        "updatedAt" : "2014-12-02T19:16:45Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a9da572a-2a7a-49ae-ade8-2435cd78dbc6",
        "parentId" : "12be7958-70c7-4fab-9144-c1af5c00c680",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "That assumes the channel is defined at the call site - my use case was a stop channel provided by the caller (ie a google context) where the caller wants the loop to stop at his convenience (and the channel might be passed to many goroutines).   I should have included an example before\n\n> On Dec 2, 2014, at 2:17 PM, Daniel Smith notifications@github.com wrote:\n> \n> In pkg/util/util.go:\n> \n> > @@ -51,7 +51,19 @@ func HandleCrash() {\n> > \n> >  // Forever loops forever running f every d.  Catches any panics, and keeps going.\n> >  func Forever(f func(), period time.Duration) {\n> > -   Until(f, period, nil)\n> >   +}\n> >   +\n> >   +// Until loops until stop channel is closed, running f every d.\n> >   +// Catches any panics, and keeps going. f may not be invoked if\n> >   +// stop channel is already closed.\n> >   +func Until(f func(), period time.Duration, stopCh <-chan struct{}) {\n> >   Something like this should take care of it, no?\n> \n> type stopper chan struct{}\n> func (s stopper) Stop() { close(s) }\n> \n> func Until(f func(), period time.Duration) stopper {\n>   ...\n>   ch := make(stopper)\n>   ...\n>   return ch\n> }\n> —\n> Reply to this email directly or view it on GitHub.\n",
        "createdAt" : "2014-12-02T19:20:58Z",
        "updatedAt" : "2014-12-02T19:20:58Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "91ebee9e-3cb4-411b-8958-7b36f6cc28c2",
        "parentId" : "12be7958-70c7-4fab-9144-c1af5c00c680",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Oh, I see. Nevermind, then.\n",
        "createdAt" : "2014-12-02T19:23:00Z",
        "updatedAt" : "2014-12-02T19:23:00Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "740b824ac2ebdf64c11acd585f6e5a896f8241d5",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +58,62 @@// Catches any panics, and keeps going. f may not be invoked if\n// stop channel is already closed.\nfunc Until(f func(), period time.Duration, stopCh <-chan struct{}) {\n\tfor {\n\t\tselect {"
  },
  {
    "id" : "03f1b02e-ece2-4f9d-aabf-4dce19392184",
    "prId" : 395,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a886c720-8537-481a-871a-812fd6f2c75e",
        "parentId" : null,
        "authorId" : "6001b825-f0f9-4fc3-b624-34a076b031e1",
        "body" : "is `tag` always empty?\n",
        "createdAt" : "2014-07-10T18:52:05Z",
        "updatedAt" : "2014-07-10T18:52:05Z",
        "lastEditedBy" : "6001b825-f0f9-4fc3-b624-34a076b031e1",
        "tags" : [
        ]
      },
      {
        "id" : "cbc48f8c-0112-42f9-8606-7b05cda00674",
        "parentId" : "a886c720-8537-481a-871a-812fd6f2c75e",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "To be honest the YAML docs around this _suck_.  I trawled the code and saw\ninternal examples using \"\", so I tried it.  Empirically it works.\n\nOn Thu, Jul 10, 2014 at 11:52 AM, Johan Euphrosine <notifications@github.com\n\n> wrote:\n> \n> In pkg/util/util.go:\n> \n> > -       intstr.StrVal = strVal\n> > -       return true\n> > -   }\n> > -   return false\n> >   +}\n> >   +\n> >   +func (intstr IntOrString) GetYAML() (tag string, value interface{}) {\n> > -   switch intstr.Kind {\n> > -   case IntstrInt:\n> > -       value = intstr.IntVal\n> > -   case IntstrString:\n> > -       value = intstr.StrVal\n> > -   default:\n> > -       panic(\"impossible IntOrString.Kind\")\n> > -   }\n> > -   return\n> \n> is tag always empty?\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/395/files#r14785218\n> .\n",
        "createdAt" : "2014-07-10T19:04:19Z",
        "updatedAt" : "2014-07-10T19:04:19Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "85effbbc3f012f30d98b900d3fe48ec4dcf7c7cd",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +106,110 @@\t\tpanic(\"impossible IntOrString.Kind\")\n\t}\n\treturn\n}\n"
  },
  {
    "id" : "301353ec-2b1b-4a16-a218-f4ba1694372d",
    "prId" : 395,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf3bd6ac-06c8-4efb-94be-0accb641b608",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Instead of trying to cast the value to an int and then a string, you can use Go's type switch:\n\nswitch t := value.(type) {\ncase int:\n    ... return true\ncase string:\n    ... return true\ndefault:\n    return false\n}\n",
        "createdAt" : "2014-07-11T05:57:31Z",
        "updatedAt" : "2014-07-11T05:57:31Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "85effbbc3f012f30d98b900d3fe48ec4dcf7c7cd",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +84,88 @@\nfunc (intstr *IntOrString) SetYAML(tag string, value interface{}) bool {\n\tif intVal, ok := value.(int); ok {\n\t\tintstr.Kind = IntstrInt\n\t\tintstr.IntVal = intVal"
  },
  {
    "id" : "fdc1738c-b86e-4412-9cab-3e77f4f76f9c",
    "prId" : 395,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb71868b-5cbe-4277-be5c-6900739bafc9",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "panicing in the middle of a library is generally frowned upon. The function signature has an error return value; this would be a good place to use it. \n",
        "createdAt" : "2014-07-11T06:00:09Z",
        "updatedAt" : "2014-07-11T06:00:09Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "51678bd0-e5c2-4bf3-9b92-47c025ee7242",
        "parentId" : "fb71868b-5cbe-4277-be5c-6900739bafc9",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Except in the YAML case there is no error, so I still have to panic, I guess.  It's supposed to be an impossible case...\n",
        "createdAt" : "2014-07-11T16:55:22Z",
        "updatedAt" : "2014-07-11T16:55:22Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "4e7ae666-b54a-4b87-af20-1a4dad9d562c",
        "parentId" : "fb71868b-5cbe-4277-be5c-6900739bafc9",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Yeah, I wasn't sure what to recommend there. It's impossible now, but if you ever extended IntstrKind to have a third kind and forgot to update the yaml conversion code, we wouldn't notice during compilation and we'd start seeing programs crashing with panics. \n",
        "createdAt" : "2014-07-11T17:00:43Z",
        "updatedAt" : "2014-07-11T17:00:43Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "60f10cdb-04be-427d-8417-43ec210a28b7",
        "parentId" : "fb71868b-5cbe-4277-be5c-6900739bafc9",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Arguably a panic is better than an error - more obvious.  It's as close to\na compile error as it can get.  Still, if you guys say returning an error\nis better, so be it.\n\n:)\n\nOn Fri, Jul 11, 2014 at 10:00 AM, roberthbailey notifications@github.com\nwrote:\n\n> In pkg/util/util.go:\n> \n> > -   if value[0] == '\"' {\n> > -       intstr.Kind = IntstrString\n> > -       return json.Unmarshal(value, &intstr.StrVal)\n> > -   }\n> > -   intstr.Kind = IntstrInt\n> > -   return json.Unmarshal(value, &intstr.IntVal)\n> >   +}\n> >   +\n> >   +func (intstr IntOrString) MarshalJSON() ([]byte, error) {\n> > -   switch intstr.Kind {\n> > -   case IntstrInt:\n> > -       return json.Marshal(intstr.IntVal)\n> > -   case IntstrString:\n> > -       return json.Marshal(intstr.StrVal)\n> > -   default:\n> > -       panic(\"impossible IntOrString.Kind\")\n> \n> Yeah, I wasn't sure what to recommend there. It's impossible now, but if\n> you ever extended IntstrKind to have a third kind and forgot to update the\n> yaml conversion code, we wouldn't notice during compilation and we'd start\n> seeing programs crashing with panics.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/395/files#r14831291\n> .\n",
        "createdAt" : "2014-07-11T18:00:47Z",
        "updatedAt" : "2014-07-11T18:00:47Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "85effbbc3f012f30d98b900d3fe48ec4dcf7c7cd",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +125,129 @@\t\treturn json.Marshal(intstr.StrVal)\n\tdefault:\n\t\tpanic(\"impossible IntOrString.Kind\")\n\t}\n}"
  }
]
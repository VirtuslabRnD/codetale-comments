[
  {
    "id" : "49b2d62a-5833-4b76-8054-562de3d9f69d",
    "prId" : 11285,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "I'm not sure we want to make all self signed certs into CA certs that have signing powers. That seems a bit overly broad. \n\nSince this is running a local cluster, can you not just generate certs locally (outside of the apiserver) and put them on the right spot in the filesystem? This is essentially what we do for GCE except that we push them onto the remote nodes via the metadata server. It'd be way easier if we just moved them to a local directory or passed a flag to the apiserver instead. \n",
        "createdAt" : "2015-07-20T21:54:23Z",
        "updatedAt" : "2015-07-24T14:16:13Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "e6cc9610-6442-417d-aa5a-15f1ee7954f6",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Sounds like a configuration knob to me... \n\nself-signed-certs are useful for stand-alone testing. \n",
        "createdAt" : "2015-07-21T21:51:22Z",
        "updatedAt" : "2015-07-24T14:16:13Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "26a85633-cb12-410d-8f3a-22efd11915d3",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "No disagreement about self signed certs being useful. My point was that making all callers of this function that generate a self signed cert instead generate a self signed **certificate authority** cert doesn't seem right. If we want to do this just for the local cluster up case, then we'd need to plumb through a config switch so that we don't automatically inherit it for all callers of this function (for example, the kubelet currently generates a self signed cert for its https endpoint if it doesn't find one in the default location -- that cert shouldn't need to be a CA). \n",
        "createdAt" : "2015-07-21T21:57:28Z",
        "updatedAt" : "2015-07-24T14:16:13Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "d219172c-ffb8-4585-9221-2cc2837debf9",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "A self signed cert is acting as a CA (it signed a cert). Why wouldn't it have the appropriate flag set so it could be verified?\n",
        "createdAt" : "2015-07-21T22:13:38Z",
        "updatedAt" : "2015-07-24T14:16:13Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "8440060d-5997-40bc-a314-1da5be89bcd5",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "I'm with @liggitt  isn't what we are doing now non-sensicle and the underlying library should have complained at some point?\n",
        "createdAt" : "2015-07-23T15:14:11Z",
        "updatedAt" : "2015-07-24T14:16:13Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      },
      {
        "id" : "ecf1e07f-7073-46a8-be24-f64fa60ea203",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "@stephenR can you comment here? If you don't have any concerns then I'm happy to accept this PR. \n",
        "createdAt" : "2015-07-24T07:02:51Z",
        "updatedAt" : "2015-07-24T14:16:13Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "0a2e0a91-0483-482c-94bd-1391370c599d",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "25c2868e-5ff1-41e7-95a6-694e49e42e3d",
        "body" : "It depends on how this certificate will be used. As long as it's only used as a self-signed cert I don't see any issues.\nMy only concern would be that someone could use this function by accident to generate a cert and then sign it with a CA.\n",
        "createdAt" : "2015-07-27T04:56:24Z",
        "updatedAt" : "2015-07-27T04:56:24Z",
        "lastEditedBy" : "25c2868e-5ff1-41e7-95a6-694e49e42e3d",
        "tags" : [
        ]
      },
      {
        "id" : "13a62a71-67b9-4e1f-8f67-16d949a1f44f",
        "parentId" : "3cc3b44a-330c-48c2-9d5b-327571d31b86",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "The name of the function is pretty explicit. Using the output as a CSR for a different CA to sign would beâ€¦ unexpected. \n",
        "createdAt" : "2015-07-27T06:15:30Z",
        "updatedAt" : "2015-07-27T06:15:30Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "5893f1c5b67b97b8bad794828af461ba3e1cd6c1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +54,58 @@\t\tNotAfter:  time.Now().Add(time.Hour * 24 * 365),\n\n\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,"
  },
  {
    "id" : "2f26b08f-97c9-46c4-836d-d2cbe74142a4",
    "prId" : 10643,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d906786e-7cd9-41b2-abd9-01569188b02c",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "This function isn't just used by the apiserver. It's also used by the kubelet. By not passing in the Subject alternate names, the self signed certs used by the kubelet will now also have 'kubernetes.default.svc', 'kubernetes.default', and 'kubernetes' on the cert, which isn't ideal. \n",
        "createdAt" : "2015-07-03T03:24:37Z",
        "updatedAt" : "2015-07-03T03:24:37Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "84bd1e94-f53a-4e4f-bae1-9262169502f3",
        "parentId" : "d906786e-7cd9-41b2-abd9-01569188b02c",
        "authorId" : "766f642e-1622-4803-803b-05ce306fc30e",
        "body" : "I figured it didn't really hurt, but I'll do a PR passing a slice or IPs and a slice of DNS names.  Sounds better?\n",
        "createdAt" : "2015-07-03T17:01:34Z",
        "updatedAt" : "2015-07-03T17:01:34Z",
        "lastEditedBy" : "766f642e-1622-4803-803b-05ce306fc30e",
        "tags" : [
        ]
      }
    ],
    "commit" : "7a29af4d2cff1fdd986f7726e8a656055d33841e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +39,43 @@// If the certificate or key files already exist, they will be overwritten.\n// Any parent directories of the certPath or keyPath will be created as needed with file mode 0755.\nfunc GenerateSelfSignedCert(host, certPath, keyPath string, ServiceReadWriteIP net.IP) error {\n\tpriv, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {"
  },
  {
    "id" : "768941bc-2f1d-4189-ad45-36401f9181e1",
    "prId" : 6190,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "36ed6b8c-e780-4ee9-b696-1e66a1e653eb",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "What does it mean if there are no headers? You don't use the headers anywhere below. \n\nCan you add a comment why we skip blocks w/o headers?\n",
        "createdAt" : "2015-03-30T23:25:19Z",
        "updatedAt" : "2015-04-01T17:42:31Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      },
      {
        "id" : "89a717a1-4025-4ccc-a869-d73ac96a2642",
        "parentId" : "36ed6b8c-e780-4ee9-b696-1e66a1e653eb",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "It means that CertPool#AppendCertsFromPEM would not add it :)\nhttp://golang.org/src/crypto/x509/cert_pool.go?s=2159:2223#L75\n\nIt means that only PEM \"CERTIFICATE\" blocks without extra headers get parsed as CA certificates\n",
        "createdAt" : "2015-03-31T00:00:27Z",
        "updatedAt" : "2015-04-01T17:42:31Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "c797a91e3605ff4dfa5401cfa5c2f61276765fd0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +143,147 @@\t\t}\n\t\t// Only use PEM \"CERTIFICATE\" blocks without extra headers\n\t\tif block.Type != \"CERTIFICATE\" || len(block.Headers) != 0 {\n\t\t\tcontinue\n\t\t}"
  },
  {
    "id" : "907244e3-96d9-44f8-92e0-b9d5df6121f9",
    "prId" : 6190,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40dcc35e-41b5-454b-9591-44713ad684db",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "If no file is specified, I would expect you to return an error, since the function doc says that there will be an error if the file cannot be read (and you can't read a non-existent file). \n",
        "createdAt" : "2015-03-30T23:27:30Z",
        "updatedAt" : "2015-04-01T17:42:31Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c797a91e3605ff4dfa5401cfa5c2f61276765fd0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +117,121 @@// Returns an error if the file could not be read, a certificate could not be parsed, or if the file does not contain any certificates\nfunc certificatesFromFile(file string) ([]*x509.Certificate, error) {\n\tif len(file) == 0 {\n\t\treturn nil, errors.New(\"error reading certificates from an empty filename\")\n\t}"
  },
  {
    "id" : "6c0dc0b1-660e-4f32-9b55-5cee10aaa329",
    "prId" : 6190,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97732306-d2c4-4af3-925f-bbc1d8bbd878",
        "parentId" : null,
        "authorId" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "body" : "Right now only this function is used outside the util package. Why not restrict the visibility of the helper functions until it's necessary for outside code to call them directly?\n",
        "createdAt" : "2015-03-30T23:29:47Z",
        "updatedAt" : "2015-04-01T17:42:31Z",
        "lastEditedBy" : "c2b5c827-efcd-438f-8db5-52d917b1cde9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c797a91e3605ff4dfa5401cfa5c2f61276765fd0",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +102,106 @@// CertPoolFromFile returns an x509.CertPool containing the certificates in the given PEM-encoded file.\n// Returns an error if the file could not be read, a certificate could not be parsed, or if the file does not contain any certificates\nfunc CertPoolFromFile(filename string) (*x509.CertPool, error) {\n\tcerts, err := certificatesFromFile(filename)\n\tif err != nil {"
  }
]
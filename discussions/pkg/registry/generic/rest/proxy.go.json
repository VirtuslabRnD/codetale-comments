[
  {
    "id" : "cede8e04-4f7f-4c43-9f27-74c72c9d0544",
    "prId" : 34987,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34987#pullrequestreview-7044949",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1911fb59-6561-4fae-bd06-2be59e3f8e26",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "doesn't this consume and close the original `req.Body`?\n",
        "createdAt" : "2016-11-01T21:07:52Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "40c49cef-bf70-450c-910c-30f93a954c0b",
        "parentId" : "1911fb59-6561-4fae-bd06-2be59e3f8e26",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "it proxies the original request's body to the backend. So that's the intention, isn't it?\n",
        "createdAt" : "2016-11-03T16:06:39Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "22ac4441-8411-4728-8826-f85e75226347",
        "parentId" : "1911fb59-6561-4fae-bd06-2be59e3f8e26",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "yes, but connectBackend() is called repeatedly with the same request in cases where the backend returns a redirect\n",
        "createdAt" : "2016-11-03T16:19:00Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e0702a50d3a9e5d919d4f9333ae31af2ab27a5b",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +234,238 @@\t}\n\n\tif err = beReq.Write(conn); err != nil {\n\t\treturn conn, fmt.Errorf(\"error sending request: %v\", err)\n\t}"
  },
  {
    "id" : "74c3573b-71a9-478a-b2e5-3cc1b13835f8",
    "prId" : 34987,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34987#pullrequestreview-7089094",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "how does this react if maxResponseSize falls in the middle of the headers, or in the middle of the response body where the response also sends a content-length header?\n",
        "createdAt" : "2016-11-03T19:07:16Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3bc2f5ec-cd0d-4638-bcb6-a74e813df288",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "If the maxResponseSize is hit, `ReadResponse` would return an error, which would cause the whole response to be sent to the client (i.e. no redirects followed). We don't read the body, so if it lands in the middle of the body it would be a non-issue.\n",
        "createdAt" : "2016-11-03T19:15:03Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "714ccfa0-b1e8-4d98-beb8-c6e27a4a3ab4",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "looks like it reads the HTTP protocol line, reads the headers, and wraps the remainder in a `Body` reader in the returned response, so the only issue would be if maxResponseSize fell in the headers portion of the response\n",
        "createdAt" : "2016-11-03T19:15:23Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "6d2d36f8-1ecf-4251-895d-89d658011f45",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is 1024 bytes sufficient for reading the headers?\n",
        "createdAt" : "2016-11-03T19:18:15Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "060e8090-ad1a-4b6b-a388-deb252c3712d",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Hmm, I'm not positive, but I think if the maxResponseSize fell at just the right point between headers, it could look like a complete response and drop some headers. The worst case scenario would be that it was a redirect response (302), and the \"Location\" header was dropped. In this case, an error would be returned to the client instead: `302 response missing Location header`.\n\nI think options here are to ignore this case, or always forward the raw response to the client in the case of an error following a redirect.\n",
        "createdAt" : "2016-11-03T19:24:05Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "54fdd8e6-f04c-4922-bc18-b1442c7ea85d",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "probably fine, maybe worth a comment explaining the assumptions\n\ndepending on how the kubelet redirects, I could see the headers exceeding 1024 bytes. The exec/attach command and params are in query params, so if the kubelet just redirects those, the length is user-controlled. If the kubelet consumes those when setting up the shim and redirects with a session/nonce query param, that could also be longish.\n",
        "createdAt" : "2016-11-03T19:34:48Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "d8c0adcc-7662-4365-9a71-841628183831",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "I issued a bunch of exec/attach/portforward calls, and logged the length of the responses. They were all < 200 bytes. I arbitrarily picked 1024 as a permissive upper bound that should still have minimal impact on memory if it's hit.\n",
        "createdAt" : "2016-11-03T19:37:36Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "1ee482fe-feeb-422c-80bb-6fd4a33e7a5d",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "From out of band conversation: this imposes an artificial limit on the length of the exec command, since it is included in the Location header.\n",
        "createdAt" : "2016-11-03T19:50:05Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      },
      {
        "id" : "cd42edc9-1087-4228-b8a2-c1f4db03f02b",
        "parentId" : "d1034fd5-3d24-4358-b76b-893ce1f63cf9",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "talked offline, those < 200 byte responses are for the current kublet, without redirects. once the kubelet starts redirecting, if it includes the original query (containing exec/attach command and params) that's arbitrary-length user-data. That probably rules out that method. This is fine for alpha, but might require rethinking as the kubelet pieces get built out.\n",
        "createdAt" : "2016-11-03T19:50:17Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e0702a50d3a9e5d919d4f9333ae31af2ab27a5b",
    "line" : 175,
    "diffHunk" : "@@ -1,1 +285,289 @@\t\t\tio.LimitReader(intermediateConn, maxResponseSize), // Don't read more than maxResponseSize bytes.\n\t\t\trawResponse)) // Save the raw response.\n\t\tresp, err := http.ReadResponse(respReader, req)\n\t\tif err != nil {\n\t\t\t// Unable to read the backend response; let the client handle it."
  },
  {
    "id" : "c72e5297-c2b2-4eed-b0ed-5709527157c3",
    "prId" : 34987,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34987#pullrequestreview-7086253",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a5b318a-7be9-40d6-b2c8-c64fe7bc20f1",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "return nil in error scenarios? otherwise we try to double close it, right? (in the defer here, and in the defer in connectBackendWithRedirects())\n",
        "createdAt" : "2016-11-03T19:22:58Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "fcef9ad9-a1a4-449c-bece-809cf7e0a6fa",
        "parentId" : "6a5b318a-7be9-40d6-b2c8-c64fe7bc20f1",
        "authorId" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "body" : "Good catch. Done.\n",
        "createdAt" : "2016-11-03T19:34:13Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "0adf587c-aaa2-4e47-be0f-a26d4fde14ac",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e0702a50d3a9e5d919d4f9333ae31af2ab27a5b",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +231,235 @@\tconn, err = proxy.DialURL(location, h.Transport)\n\tif err != nil {\n\t\treturn conn, fmt.Errorf(\"error dialing backend: %v\", err)\n\t}\n"
  },
  {
    "id" : "f9a25ebb-03ee-475f-ad9c-f99e0aee9978",
    "prId" : 34987,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/34987#pullrequestreview-7089851",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7803c3e-f0e1-42a7-998a-18b9342fc16e",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "assigning nil here doesn't change the returned value (https://play.golang.org/p/q5dnDAYsL6). actually do `return nil, ...` in error cases.\n\nedit: I'm wrong, named returns make this work correctly. your call whether you want to switch it to clean up inline and return nil\n",
        "createdAt" : "2016-11-03T19:54:21Z",
        "updatedAt" : "2016-11-04T19:26:41Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e0702a50d3a9e5d919d4f9333ae31af2ab27a5b",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +219,223 @@\t\tif err != nil && conn != nil {\n\t\t\tconn.Close()\n\t\t\tconn = nil\n\t\t}\n\t}()"
  },
  {
    "id" : "54baeda0-1c10-434a-bb7d-3bcea88a7b03",
    "prId" : 16400,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "674253ad-babf-419e-875a-00be23cae0d4",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@liggitt I added back this for future-proofing.\n",
        "createdAt" : "2015-11-18T19:19:09Z",
        "updatedAt" : "2015-11-20T17:57:54Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      }
    ],
    "commit" : "32f2ec71a8b854d070df11a78070fe96939829e4",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +118,122 @@\t// Copy the TransferEncoding is for future-proofing. Currently Go only supports \"chunked\" and\n\t// it can determine the TransferEncoding based on ContentLength and the Body.\n\tnewReq.TransferEncoding = req.TransferEncoding\n\n\tproxy := httputil.NewSingleHostReverseProxy(&url.URL{Scheme: h.Location.Scheme, Host: h.Location.Host})"
  },
  {
    "id" : "dcd18895-8d43-45b0-827d-d462d840e842",
    "prId" : 10529,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b03a219b-811c-4589-9d30-ad302dfacc35",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Can't you set this to be net.dial and lose all the conditionals?\n",
        "createdAt" : "2015-06-30T23:09:49Z",
        "updatedAt" : "2015-07-01T17:57:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8bed2d60-dd5c-449a-b68d-64dff7ef502f",
        "parentId" : "b03a219b-811c-4589-9d30-ad302dfacc35",
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Not without subtly changing the behavior in the https case. `tls.Dial` allows tlsConfig to be nil and will treat as the zero config. `tls.Client` requires non-nil tlsConfig, with either `InsecureSkipVerify: true` or `ServerName` provided.\n",
        "createdAt" : "2015-06-30T23:13:14Z",
        "updatedAt" : "2015-07-01T17:57:07Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      },
      {
        "id" : "471f8a7d-e896-4ba5-ae52-9df0d6dcc971",
        "parentId" : "b03a219b-811c-4589-9d30-ad302dfacc35",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "hrm, I'm sorry to be so pedantic about this, but how can tls.Dial take a nil config? does it set ServerAddress based on dialAddr?\n",
        "createdAt" : "2015-07-01T00:31:33Z",
        "updatedAt" : "2015-07-01T17:57:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "1f58041f-d1fd-433c-8a19-6e95219fc1ac",
        "parentId" : "b03a219b-811c-4589-9d30-ad302dfacc35",
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Per tls [documentation](https://golang.org/pkg/crypto/tls/#Dial):\n\n> Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.\n\nI don't know whether that code path is actually ever hit. I would expect we either have a transport with a valid tlsConfig or we are in the http case.\n",
        "createdAt" : "2015-07-01T00:41:30Z",
        "updatedAt" : "2015-07-01T17:57:07Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      },
      {
        "id" : "f8b26cf0-3a36-4d67-b9d2-451f06f9c5bb",
        "parentId" : "b03a219b-811c-4589-9d30-ad302dfacc35",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Can you add a \n\n// TODO: this TLS logic can probably be cleaned up; it's messy in an attempt to preserve behavior that we don't know for sure is exercised.\n\nAnd then I will stop bothering you about it :)\n",
        "createdAt" : "2015-07-01T17:53:23Z",
        "updatedAt" : "2015-07-01T17:57:07Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "2682455e-cb56-45eb-8095-c4c4ccad4afe",
        "parentId" : "b03a219b-811c-4589-9d30-ad302dfacc35",
        "authorId" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "body" : "Added.\n",
        "createdAt" : "2015-07-01T17:57:24Z",
        "updatedAt" : "2015-07-01T17:57:24Z",
        "lastEditedBy" : "8076e56f-768c-4f89-90e6-045ef34e1525",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b36b421aaf975b5085804c07a15a457c177e959",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +175,179 @@\tdialAddr := netutil.CanonicalAddr(h.Location)\n\n\tvar dialer func(network, addr string) (net.Conn, error)\n\tif httpTransport, ok := h.Transport.(*http.Transport); ok && httpTransport.Dial != nil {\n\t\tdialer = httpTransport.Dial"
  },
  {
    "id" : "3c62dc0b-d209-48c4-b576-0400098b4335",
    "prId" : 8886,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb318289-878f-4ea6-9023-12d5ef68d498",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This loses the scheme part of the URL-- this is bad because the client might default to HTTP instead of HTTPS. Would be better to actually copy req.URL, modify its Path, and then use .String() to construct the final URL.\n",
        "createdAt" : "2015-05-29T20:24:41Z",
        "updatedAt" : "2015-05-29T20:24:41Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "bfaf57ba-b662-4203-b5fc-16866cdbd326",
        "parentId" : "eb318289-878f-4ea6-9023-12d5ef68d498",
        "authorId" : "3a60a43e-3e3d-40f9-b82d-24959d7af0d3",
        "body" : "hmm,  I think this may be better given the scheme/host that we receive in the URL may not be what the client is using. (may be going through proxy/load balancer/etc) If we only send back the path, then the client should retry with whatever it scheme/host it used at first.\n",
        "createdAt" : "2015-05-29T20:37:20Z",
        "updatedAt" : "2015-05-29T20:37:20Z",
        "lastEditedBy" : "3a60a43e-3e3d-40f9-b82d-24959d7af0d3",
        "tags" : [
        ]
      },
      {
        "id" : "3dbe2553-5acb-4c78-82e5-a00a71a700c3",
        "parentId" : "eb318289-878f-4ea6-9023-12d5ef68d498",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Well, this redirection is including the part of the URL that got the user to apiserver's proxy. So it should have everything the user just used to get here.\n\nE.g. the user asked for `https://apiserver.com/api/v1beta3/namespaces/default/services/foo/proxy?param=blah` and we want to redirect to `https://apiserver.com/api/v1beta3/namespaces/default/services/foo/proxy/?param=blah`, not `apiserver.com/api/v1beta3/namespaces/default/services/foo/proxy/?param=blah`.\n",
        "createdAt" : "2015-05-29T20:43:24Z",
        "updatedAt" : "2015-05-29T20:43:24Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "2f68bc75-301f-4ccf-9668-92840b33f6d0",
        "parentId" : "eb318289-878f-4ea6-9023-12d5ef68d498",
        "authorId" : "3a60a43e-3e3d-40f9-b82d-24959d7af0d3",
        "body" : "we're not including a host in the Location... and from what I can tell, that is a valid relative URL (http://en.wikipedia.org/wiki/HTTP_location)\nIt's also what we use in the original proxy code: https://github.com/GoogleCloudPlatform/kubernetes/blob/master/pkg/apiserver/proxy.go#L166\n\nYou'd also be relying on the reverse proxy or whatever's in front of your server to translate the header properly and not expose the name of your internal server. So for example your might hit a load balancer at http://foo/api/v1beta3/namespaces/default/services/foo/proxy, but the URL api server sees is http://bar/api/v1beta3/namespaces/default/services/foo/proxy, so we redirect to http://bar/api/v1beta3/namespaces/default/services/foo/proxy/ and if it comes back unfiltered to the client, the client may not know how to access http://bar/...\n",
        "createdAt" : "2015-05-29T21:09:21Z",
        "updatedAt" : "2015-05-29T21:09:21Z",
        "lastEditedBy" : "3a60a43e-3e3d-40f9-b82d-24959d7af0d3",
        "tags" : [
        ]
      },
      {
        "id" : "757d9d06-91a2-46ed-937c-fa554fb2bbc1",
        "parentId" : "eb318289-878f-4ea6-9023-12d5ef68d498",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Ah, it's relative. Thanks, I missed that.\n",
        "createdAt" : "2015-05-29T23:01:08Z",
        "updatedAt" : "2015-05-29T23:01:08Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "684dcd430717f5d184544c821682ba37eb1747da",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +95,99 @@\t\t\tqueryPart = \"?\" + req.URL.RawQuery\n\t\t}\n\t\tw.Header().Set(\"Location\", req.URL.Path+\"/\"+queryPart)\n\t\tw.WriteHeader(http.StatusMovedPermanently)\n\t\treturn"
  },
  {
    "id" : "814e8bfd-c3c4-44c6-8203-7edad1fed207",
    "prId" : 8886,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08dc07f7-edce-4822-9812-4305d0fcf3f5",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "if h.Location.Path==\"/\", then this will remove a trailing \"/\" from url.Path. Is that intentional?\n",
        "createdAt" : "2015-05-29T20:29:00Z",
        "updatedAt" : "2015-05-29T20:29:00Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "74e3e0c9-1756-44c7-ab81-4a82eea1a2bf",
        "parentId" : "08dc07f7-edce-4822-9812-4305d0fcf3f5",
        "authorId" : "3a60a43e-3e3d-40f9-b82d-24959d7af0d3",
        "body" : "It's ok for the pathPrepend not to end in a \"/\", since it will only be used in to path.Join with relative URLs in the markup: https://github.com/GoogleCloudPlatform/kubernetes/blob/master/pkg/util/proxy/transport.go#L128-L131. The flipside is that if url.Path is something like /a/b/c/ and suffix (or h.Location.Path) is /b/c, the proper prefix won't be calculated unless I add a '/' to the suffix\n",
        "createdAt" : "2015-05-29T20:52:57Z",
        "updatedAt" : "2015-05-29T20:52:57Z",
        "lastEditedBy" : "3a60a43e-3e3d-40f9-b82d-24959d7af0d3",
        "tags" : [
        ]
      }
    ],
    "commit" : "684dcd430717f5d184544c821682ba37eb1747da",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +213,217 @@\tif strings.HasSuffix(url.Path, \"/\") && !strings.HasSuffix(suffix, \"/\") {\n\t\tsuffix += \"/\"\n\t}\n\tpathPrepend := strings.TrimSuffix(url.Path, suffix)\n\treturn &proxy.Transport{"
  }
]
[
  {
    "id" : "5200980a-06bd-43a3-8e3b-91fd953071e1",
    "prId" : 2147,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fbb9eb1c-e72a-4c2b-b823-439c12a34c76",
        "parentId" : null,
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "Is the random aspect of this important or just easy?\n",
        "createdAt" : "2014-11-17T17:19:13Z",
        "updatedAt" : "2014-11-17T17:19:13Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "83c74336-1c71-4650-ab68-3c29d388748f",
        "parentId" : "fbb9eb1c-e72a-4c2b-b823-439c12a34c76",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Keeping a full bitmap is out of the question for e.g. a /64, which is what motivated the change.\n\nThis should be more efficient than a linear scan, if we expect the address space to be sparsely populated.  But there are also correctness aspects:\n\nI've had problems with IP address reuse in the past:\n- where ARP or the ipv6 equivalents got confused (surmountable with unsolicited ARP and equivalents)\n- where the kernel cgroups or bridge got confused (particularly with IPv6; the symptom was that attempting to assign the IPv6 address to the LXC instance would just fail, but after a few instance restarts / time-delay it would eventually work.  I don't know if this still happens, or whether I was just doing something wrong.)\n\nAlso, it seems a little risky to assign an IP address immediately to the next requester, in case that is a different tenant.  Having an LRU queue would probably be better.\n\nOf course, these are real problems, and randomizing just buries them in the long-tails.  We can change randomAttempts to 0 or just remove the randomizing code, to see if any of these problems still occur.\n",
        "createdAt" : "2014-11-17T17:41:52Z",
        "updatedAt" : "2014-11-17T17:41:52Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      },
      {
        "id" : "c5d9ac98-e26f-45e9-8086-76947221e824",
        "parentId" : "fbb9eb1c-e72a-4c2b-b823-439c12a34c76",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "I was specifically asking if it random is what mattered or if \"don't reuse\"\nis what matters.  I agree with the latter, the former causes me a very\nsmall but of angst wrt static addresses for cluster services like DNS.\n\nOn Mon, Nov 17, 2014 at 9:42 AM, Justin Santa Barbara <\nnotifications@github.com> wrote:\n\n> In pkg/registry/service/ip_allocator.go:\n> \n> > -           nextBit, err := ffs(freeMask)\n> > -           if err != nil {\n> > -               // If this happens, something really weird is going on.\n> > -               glog.Errorf(\"ffs(%#x) had an unexpected error: %s\", freeMask, err)\n> > -               return nil, err\n> > -           }\n> > -           ipa.used[i] |= 1 << nextBit\n> > -           offset := (i \\* 8) + int(nextBit)\n> > -           ip := ipAdd(ipa.subnet.IP, offset)\n> > -   if int64(ipa.used.Size()) == ipa.ipSpaceSize {\n> > -       return nil, fmt.Errorf(\"can't find a free IP in %s\", ipa.subnet)\n> > -   }\n> >   +\n> > -   // Try randomly first\n> > -   for i := 0; i < ipa.randomAttempts; i++ {\n> > -       ip := ipa.createRandomIp()\n> \n> Keeping a full bitmap is out of the question for e.g. a /64, which is what\n> motivated the change.\n> \n> This should be more efficient than a linear scan, if we expect the address\n> space to be sparsely populated. But there are also correctness aspects:\n> \n> I've had problems with IP address reuse in the past:\n> - where ARP or the ipv6 equivalents got confused (surmountable with\n>   unsolicited ARP and equivalents)\n> - where the kernel cgroups or bridge got confused (particularly with\n>   IPv6; the symptom was that attempting to assign the IPv6 address to the LXC\n>   instance would just fail, but after a few instance restarts / time-delay it\n>   would eventually work. I don't know if this still happens, or whether I was\n>   just doing something wrong.)\n> \n> Also, it seems a little risky to assign an IP address immediately to the\n> next requester, in case that is a different tenant. Having an LRU queue\n> would probably be better.\n> \n> Of course, these are real problems, and randomizing just buries them in\n> the long-tails. We can change randomAttempts to 0 or just remove the\n> randomizing code, to see if any of these problems still occur.\n> \n> ## \n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/2147/files#r20450818\n> .\n",
        "createdAt" : "2014-11-17T17:46:34Z",
        "updatedAt" : "2014-11-17T17:46:34Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      },
      {
        "id" : "ba1c670d-90bc-4e71-9931-6a953c71e00c",
        "parentId" : "fbb9eb1c-e72a-4c2b-b823-439c12a34c76",
        "authorId" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "body" : "Ah - gotcha!  Yes, random is just a cheap-and-cheerful way of implementing (probably) don't-reuse\n\nThe only other thing is that random also avoids trivially disclosing how many other instances are running, which is important in some shared environments.\n",
        "createdAt" : "2014-11-17T17:50:08Z",
        "updatedAt" : "2014-11-17T17:50:08Z",
        "lastEditedBy" : "8fc8f958-3c0e-47dd-a0fb-b8cc483b4efb",
        "tags" : [
        ]
      }
    ],
    "commit" : "b19170f33576c7d0dc64f9ff70faa44718bf2ba8",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +157,161 @@\t// Try randomly first\n\tfor i := 0; i < ipa.randomAttempts; i++ {\n\t\tip := ipa.createRandomIp()\n\n\t\tif ipa.used.Add(ip) {"
  },
  {
    "id" : "a491f3ae-121c-4059-8949-c9cf85e76c84",
    "prId" : 1594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f50f928a-9c36-4d60-914a-deb1020b7316",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "inconsistent w/ `numIps/8` (no spaces) above\n",
        "createdAt" : "2014-10-06T20:33:06Z",
        "updatedAt" : "2014-10-06T20:33:06Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "cbd90c67-f82a-42cc-b3c1-e9a5a500ec1a",
        "parentId" : "f50f928a-9c36-4d60-914a-deb1020b7316",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "gofmt did this\n",
        "createdAt" : "2014-10-06T20:35:28Z",
        "updatedAt" : "2014-10-06T20:35:28Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "8131a5ca6a953f1df375fe8a6424cd6caa4d9989",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +59,63 @@\t}\n\toffset := ipSub(ip, ipa.subnet.IP)\n\ti := offset / 8\n\tm := byte(1 << byte(offset%8))\n\tif ipa.used[i]&m != 0 {"
  },
  {
    "id" : "fecd7a04-ebf8-4b0b-a178-a28f9c5c5227",
    "prId" : 1594,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b519b5cc-4ac3-4944-ac2d-0cfbb576b18d",
        "parentId" : null,
        "authorId" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "body" : "as above wrt to spaces around shift operator.\n",
        "createdAt" : "2014-10-06T20:33:23Z",
        "updatedAt" : "2014-10-06T20:33:23Z",
        "lastEditedBy" : "d0e97b49-eba2-4b22-8695-df4f8a6776ad",
        "tags" : [
        ]
      },
      {
        "id" : "31add9e4-348b-46d0-977b-6f3258db7e4a",
        "parentId" : "b519b5cc-4ac3-4944-ac2d-0cfbb576b18d",
        "authorId" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "body" : "gofmt has an opinion on this, and AFAIK we take gofmt as gospel\n",
        "createdAt" : "2014-10-06T20:35:54Z",
        "updatedAt" : "2014-10-06T20:35:54Z",
        "lastEditedBy" : "f87fe7d3-581c-4cb6-b17e-b807c6f2c789",
        "tags" : [
        ]
      }
    ],
    "commit" : "8131a5ca6a953f1df375fe8a6424cd6caa4d9989",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +60,64 @@\toffset := ipSub(ip, ipa.subnet.IP)\n\ti := offset / 8\n\tm := byte(1 << byte(offset%8))\n\tif ipa.used[i]&m != 0 {\n\t\treturn fmt.Errorf(\"IP %s is already allocated\", ip)"
  }
]
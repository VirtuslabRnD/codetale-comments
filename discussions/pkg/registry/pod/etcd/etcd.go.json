[
  {
    "id" : "651bd159-4cc5-4b7e-a4ef-e0cd149b45b0",
    "prId" : 31033,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3210094c-39ee-4abf-8f89-0e270c042d40",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "I guess 503 would also be a possible error code. But 429 also makes sense.\n\nMaybe add a TODO to add a Retry-After header?\n",
        "createdAt" : "2016-08-20T06:32:28Z",
        "updatedAt" : "2016-08-22T23:38:51Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "d82a5914da86b7425971b87ba2a895f43b1ccc3f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +173,177 @@\t\t\t\t// Ideally any such text is generated by the DisruptionController (offline).\n\t\t\t\tMessage: \"Cannot evict pod as it would violate the pod's disruption budget.\",\n\t\t\t\tCode:    429,\n\t\t\t\t// TODO(mml): Add a Retry-After header.  Once there are time-based\n\t\t\t\t// budgets, we can sometimes compute a sensible suggested value.  But"
  },
  {
    "id" : "c026fac9-60fb-45bd-ad82-7b255fc6daf2",
    "prId" : 31033,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9bb0fafe-853b-4e98-81be-2d46a9cef9fc",
        "parentId" : null,
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "I didn't understand the \"429 maybe\" -- you _are_ returning a 429, right?\n",
        "createdAt" : "2016-08-23T00:10:31Z",
        "updatedAt" : "2016-08-23T00:10:31Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      },
      {
        "id" : "2fc1bd61-983d-499d-8bde-50464779fd15",
        "parentId" : "9bb0fafe-853b-4e98-81be-2d46a9cef9fc",
        "authorId" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "body" : "(please fix in a followup)\n",
        "createdAt" : "2016-08-23T00:13:01Z",
        "updatedAt" : "2016-08-23T00:13:01Z",
        "lastEditedBy" : "82da2b23-9f40-4abd-8af5-56ba07c1fc0a",
        "tags" : [
        ]
      }
    ],
    "commit" : "d82a5914da86b7425971b87ba2a895f43b1ccc3f",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +161,165 @@\n\t\t// If it was false already, or if it becomes false during the course of our retries,\n\t\t// raise an error marked as a ... 429 maybe?\n\t\tok, err := r.checkAndDecrement(ctx, pdb)\n\t\tif err != nil {"
  },
  {
    "id" : "67893bea-65f7-44ef-b896-e71e496d0fb1",
    "prId" : 12919,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7f01e72-43ce-4eb8-9c80-00b0d35c85ec",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "we're already passing in kubeletConn, which should be responsible for determining the port for a kubelet\n",
        "createdAt" : "2015-10-23T05:08:33Z",
        "updatedAt" : "2015-10-23T05:08:33Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "64a3ee9d-e111-47f2-8bcf-379ae5410817",
        "parentId" : "a7f01e72-43ce-4eb8-9c80-00b0d35c85ec",
        "authorId" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "body" : "Ideally it should, but it would require large refactoring. As I mentioned earlier, when we move information about KubeletPort (and possibly other stuff in the future, like tokens or sth.) to the etcd we need query it before creating a connection. In this solution hostLocator is passed to kubeletConn, so that it's able to read a Port from etcd, which makes client simple (etcd is abstracted away). Other option, which is adding etcd handling to the client is much worse.\n",
        "createdAt" : "2015-10-23T08:06:04Z",
        "updatedAt" : "2015-10-23T08:06:04Z",
        "lastEditedBy" : "3c437914-616b-4cfb-88a0-28dc812ff2b2",
        "tags" : [
        ]
      }
    ],
    "commit" : "60404a55fc2448476c58cb27385a2f38e517ccb6",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +124,128 @@\t\tLog:         &podrest.LogREST{Store: store, HostLocator: hostLocator, KubeletConn: k},\n\t\tProxy:       &ProxyREST{store: store, proxyTransport: proxyTransport},\n\t\tExec:        &ExecREST{store: store, hostLocator: hostLocator, kubeletConn: k},\n\t\tAttach:      &AttachREST{store: store, hostLocator: hostLocator, kubeletConn: k},\n\t\tPortForward: &PortForwardREST{store: store, hostLocator: hostLocator, kubeletConn: k},"
  },
  {
    "id" : "989955cd-aa94-4ccf-890d-57decce96d79",
    "prId" : 5534,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e96dd5dd-aadf-4cf2-a38c-67dcbd79e3aa",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We get to use all the pointers :)\n",
        "createdAt" : "2015-03-18T23:58:45Z",
        "updatedAt" : "2015-03-18T23:58:45Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      }
    ],
    "commit" : "960e16c3972ba061565e10757bba22be6fbf0798",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +71,75 @@\tstatusStore.UpdateStrategy = pod.StatusStrategy\n\n\treturn &REST{*store}, &BindingREST{store: store}, &StatusREST{store: &statusStore}\n}\n"
  },
  {
    "id" : "801264cc-61d5-4515-aaf4-bbb402ff74f1",
    "prId" : 5054,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bf377f1-34f0-4da2-b483-f13bd2e55c43",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "How hard would it be to eliminate the separate etcd object and just write/read the pod? To make the separate object work, we really need atomic deletion of the pod and binding (or a background reconciliation loop, which I'd like to avoid).\n",
        "createdAt" : "2015-03-05T20:39:48Z",
        "updatedAt" : "2015-03-09T19:45:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "40716bb2-f478-46bb-9b67-f7e64223f57b",
        "parentId" : "2bf377f1-34f0-4da2-b483-f13bd2e55c43",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I think it's\n- kubelet needs to validate constraints and report failed\n- scheduler / rc need to handle failed correctly\n- we remove the atomic check and replace it with a query\n- we remove setting the bindings and replace it with writing status.Host\n\n----- Original Message -----\n\n> > @@ -142,7 +143,14 @@ func (r _BindingREST) New() runtime.Object {\n> >  // Create ensures a pod is bound to a specific host.\n> >  func (r *BindingREST) Create(ctx api.Context, obj runtime.Object) (out\n> >  runtime.Object, err error) {\n> >     binding := obj.(_api.Binding)\n> > -   err = r.assignPod(ctx, binding.PodID, binding.Host)\n> > -   // TODO: move me to a binding strategy\n> > -   if len(binding.Target.Kind) != 0 && (binding.Target.Kind != \"Node\" &&\n> >   binding.Target.Kind != \"Minion\") {\n> \n> How hard would it be to eliminate the separate etcd object and just\n> write/read the pod? To make the separate object work, we really need atomic\n> deletion of the pod and binding (or a background reconciliation loop, which\n> I'd like to avoid).\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5054/files#r25899370\n",
        "createdAt" : "2015-03-05T20:47:38Z",
        "updatedAt" : "2015-03-09T19:45:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "47187102-c564-4146-9e3d-102a1d202dff",
        "parentId" : "2bf377f1-34f0-4da2-b483-f13bd2e55c43",
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "We need to do this for host ports, out-of-disk, and other scenarios/resources, also.\n\n@erictune @dchen1107 @rjnagal @vishh Is someone working on implementing this protocol?\n",
        "createdAt" : "2015-03-06T00:24:10Z",
        "updatedAt" : "2015-03-09T19:45:09Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "dfc19185f5de9325bb2c3cbfc2ffc3ea8f9490f0",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +149,153 @@\tbinding := obj.(*api.Binding)\n\t// TODO: move me to a binding strategy\n\tif len(binding.Target.Kind) != 0 && (binding.Target.Kind != \"Node\" && binding.Target.Kind != \"Minion\") {\n\t\treturn nil, errors.NewInvalid(\"binding\", binding.Name, errors.ValidationErrorList{errors.NewFieldInvalid(\"to.kind\", binding.Target.Kind, \"must be empty, 'Node', or 'Minion'\")})\n\t}"
  },
  {
    "id" : "64eea7f4-a54f-48c8-94cd-78c42e93100f",
    "prId" : 5005,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08d677a0-e8c3-413e-b48b-7377555f2737",
        "parentId" : null,
        "authorId" : "7be32503-562e-4caa-838d-bba025e626b5",
        "body" : "You'll need to rebase this FYI.\n",
        "createdAt" : "2015-03-11T22:33:13Z",
        "updatedAt" : "2015-03-13T12:17:41Z",
        "lastEditedBy" : "7be32503-562e-4caa-838d-bba025e626b5",
        "tags" : [
        ]
      },
      {
        "id" : "e163f177-f0ac-4693-b99b-f49c2770c734",
        "parentId" : "08d677a0-e8c3-413e-b48b-7377555f2737",
        "authorId" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "body" : "done\n\nOn Wed, Mar 11, 2015 at 6:33 PM, Brian Grant notifications@github.com\nwrote:\n\n> In pkg/registry/pod/etcd/etcd.go\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5005#discussion_r26263030\n> :\n> \n> > @@ -176,6 +176,12 @@ func (r *BindingREST) setPodHostTo(ctx api.Context, podID, oldMachine, machine s\n> >             return nil, fmt.Errorf(\"pod %v is already assigned to host %v\", pod.Name, pod.Status.Host)\n> >         }\n> >         pod.Status.Host = machine\n> \n> You'll need to rebase this FYI.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/GoogleCloudPlatform/kubernetes/pull/5005/files#r26263030\n> .\n\n## \n\nJames DeFelice\n585.241.9488 (voice)\n650.649.6071 (fax)\n",
        "createdAt" : "2015-03-12T23:23:31Z",
        "updatedAt" : "2015-03-13T12:17:41Z",
        "lastEditedBy" : "aefa6d0d-0ad0-4062-966c-ddc56e70652b",
        "tags" : [
        ]
      }
    ],
    "commit" : "20eb3c49c5a233a979de62f93274339a8c502ff4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +171,175 @@\t\t}\n\t\tpod.Spec.Host = machine\n\t\tpod.Status.Host = machine\n\t\tif pod.Annotations == nil {\n\t\t\tpod.Annotations = make(map[string]string)"
  },
  {
    "id" : "190a9d86-0426-47b3-a4e4-211a7b396744",
    "prId" : 4779,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f65e1d5f-3091-47a3-bfc4-e3731030e306",
        "parentId" : null,
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Does it work? StatusStrategy does not implement some methods from RESTUpdateStrategy:\n1. NamespaceScoped() bool\n2. AllowCreateOnUpdate() bool\n",
        "createdAt" : "2015-02-25T12:21:23Z",
        "updatedAt" : "2015-03-02T03:35:22Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      },
      {
        "id" : "7b5ec21a-9963-4d9c-b215-a92eb245f403",
        "parentId" : "f65e1d5f-3091-47a3-bfc4-e3731030e306",
        "authorId" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "body" : "Forget that! I've missed that you have anonymous field Strategy.\n",
        "createdAt" : "2015-02-25T12:27:23Z",
        "updatedAt" : "2015-03-02T03:35:22Z",
        "lastEditedBy" : "df06b0d6-fd6c-44d1-8008-efeaccd16cd5",
        "tags" : [
        ]
      }
    ],
    "commit" : "3d290089ae97098e10c0afe83ff4d1cf987a5f06",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +67,71 @@\tstore.AfterDelete = bindings.AfterDelete\n\n\tstatusStore.UpdateStrategy = pod.StatusStrategy\n\n\treturn &REST{store: store}, &BindingREST{store: store, factory: factory}, &StatusREST{store: &statusStore}"
  }
]
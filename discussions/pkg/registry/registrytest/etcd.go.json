[
  {
    "id" : "31ac6be7-a2b1-4bcd-b155-d526ed0eec36",
    "prId" : 51239,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/51239#pullrequestreview-61316102",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f450bd0e-ae5e-468d-9743-6943c7685ea8",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This would make sense (fix a shadowing bug) if it weren't for the if statement on the line below. This appears to be a no-op as it is.",
        "createdAt" : "2017-09-07T18:42:04Z",
        "updatedAt" : "2017-09-07T18:42:04Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "863b95f7-40f9-4aaa-92fd-3c297b5922aa",
        "parentId" : "f450bd0e-ae5e-468d-9743-6943c7685ea8",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Ah, I see. It is about the subsequent usage (github hid that diff)",
        "createdAt" : "2017-09-07T18:44:15Z",
        "updatedAt" : "2017-09-07T18:44:15Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "d73b3d049d66475968ecf10fa2769b747e38a207",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +219,223 @@\tcase etcdstorage.EtcdDelete:\n\t\tvar accessor metav1.Object\n\t\taccessor, err = meta.Accessor(obj)\n\t\tif err != nil {\n\t\t\treturn err"
  },
  {
    "id" : "5d0f85d4-e69a-4417-b1c3-aa16812cd4c2",
    "prId" : 17469,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e39fcb87-ddd6-4e96-ac7d-92e8dfbbee7c",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "return err\n",
        "createdAt" : "2015-11-19T11:01:35Z",
        "updatedAt" : "2015-11-19T16:34:55Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "57b1f21a-497d-4bc1-9587-69da6e1d0136",
        "parentId" : "e39fcb87-ddd6-4e96-ac7d-92e8dfbbee7c",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "oops - no; I was wrong\nWe should handle the error somehow - something like:\n\nt.tester.Errorf(...\")\n",
        "createdAt" : "2015-11-19T11:02:53Z",
        "updatedAt" : "2015-11-19T16:34:55Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "b0635b79-8970-4e9d-bf93-a21bc272a622",
        "parentId" : "e39fcb87-ddd6-4e96-ac7d-92e8dfbbee7c",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "Done.  \n\nYeah in general I don't like the mechanics of this testing structure.  But... \"when in rome\" \n",
        "createdAt" : "2015-11-19T16:03:41Z",
        "updatedAt" : "2015-11-19T16:34:55Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "02851dd1b78cc7659f639b827a215531e356f197",
    "line" : null,
    "diffHunk" : "@@ -1,1 +197,201 @@\tif err := storagetesting.CreateObjList(key, t.storage.Storage, objects); err != nil {\n\t\tt.tester.Errorf(\"unexpected error: %v\", err)\n\t\treturn nil\n\t}\n\treturn objects"
  },
  {
    "id" : "9fac5efd-5c4e-44ee-aefd-5fd2bafafe57",
    "prId" : 17469,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df9b7b8f-63aa-4ad1-8125-187221395d8b",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "You should also add \"etcdstorage.EtcdUpdate\".\n",
        "createdAt" : "2015-11-19T11:04:22Z",
        "updatedAt" : "2015-11-19T16:34:55Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "33a6f29b-7b14-492f-aa9f-7e52b6459196",
        "parentId" : "df9b7b8f-63aa-4ad1-8125-187221395d8b",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "So before there was a CAS, and there exists other Update tests, as you can see.  The watch emitter imho is kind of a farce to begin with, b/c it's not really testing what it may imply here. \n",
        "createdAt" : "2015-11-19T16:07:05Z",
        "updatedAt" : "2015-11-19T16:34:55Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      },
      {
        "id" : "9c1aca2f-8680-4cab-877f-9b178ef61953",
        "parentId" : "df9b7b8f-63aa-4ad1-8125-187221395d8b",
        "authorId" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "body" : "So I validated it again, the only reason we got away with the it before was due to the implied semantics of the fakeClient.  IMHO we the test is still testing the primary filtering operations which is the intention and coverage exists in the storage layer for such detailed operations as CAS.  \n",
        "createdAt" : "2015-11-19T16:29:26Z",
        "updatedAt" : "2015-11-19T16:34:55Z",
        "lastEditedBy" : "f81960f6-a033-4403-bebf-c8ebb484e444",
        "tags" : [
        ]
      }
    ],
    "commit" : "02851dd1b78cc7659f639b827a215531e356f197",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +207,211 @@\n\tswitch action {\n\tcase etcdstorage.EtcdCreate:\n\t\terr = t.setObject(ctx, obj)\n\tcase etcdstorage.EtcdDelete:"
  },
  {
    "id" : "d25bf7a0-a281-4505-b9dd-e8cc9d8a1209",
    "prId" : 13581,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43d0edb1-8d32-4fa7-89ff-9bbd8e5741b3",
        "parentId" : null,
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "@lavalamp, have you reviewed changes here?\n",
        "createdAt" : "2015-09-04T21:10:43Z",
        "updatedAt" : "2015-09-05T01:02:22Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "b3dc59f8-7a59-43d2-a01c-32bd042e72e0",
        "parentId" : "43d0edb1-8d32-4fa7-89ff-9bbd8e5741b3",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This looks fine, at least temporarily.\n",
        "createdAt" : "2015-09-04T21:19:04Z",
        "updatedAt" : "2015-09-05T01:02:22Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fc79e9d99c0db4c75ba8b5c3b1065b958353999",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +152,156 @@// =============================================================================\n// get codec based on runtime.Object\nfunc getCodec(obj runtime.Object) (runtime.Codec, error) {\n\t_, kind, err := api.Scheme.ObjectVersionAndKind(obj)\n\tif err != nil {"
  },
  {
    "id" : "99f491a7-f4ec-4431-8175-658148480580",
    "prId" : 13581,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f3b97e5-485a-4fdd-a75c-cb0e3fce9f99",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "If we end up with kinds that are registered in multiple groups, then we'll need to actually store the group in every object. But I don't think we're going to have that case. At any rate, soon we'll make api.Scheme keep a map so it will just know what group an object is from.\n",
        "createdAt" : "2015-09-04T21:20:19Z",
        "updatedAt" : "2015-09-05T01:02:22Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "96749568-d955-4602-9397-a698d0cf10cb",
        "parentId" : "2f3b97e5-485a-4fdd-a75c-cb0e3fce9f99",
        "authorId" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "body" : "Once we have internal objects register to the scheme with their group name, i.e.,\n\n```\n AddKnownTypes(\"group\", ...)\n```\n\nThen the version returned by api.Scheme.ObjectVersionAndKind(obj) will contain the \"group\" for internal objects.\n",
        "createdAt" : "2015-09-04T21:26:44Z",
        "updatedAt" : "2015-09-05T01:02:22Z",
        "lastEditedBy" : "ca7e5a52-cab7-4f09-8ff8-da79f43339d4",
        "tags" : [
        ]
      },
      {
        "id" : "90363583-b595-452f-b83a-614ead0218b3",
        "parentId" : "2f3b97e5-485a-4fdd-a75c-cb0e3fce9f99",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Sounds great.\n",
        "createdAt" : "2015-09-04T21:47:40Z",
        "updatedAt" : "2015-09-05T01:02:22Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fc79e9d99c0db4c75ba8b5c3b1065b958353999",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +162,166 @@\t// TODO: caesarxuchao: we should add a map from kind to group in Scheme.\n\tvar codec runtime.Codec\n\tif api.Scheme.Recognizes(testapi.Default.GroupAndVersion(), kind) {\n\t\tcodec = testapi.Default.Codec()\n\t} else if api.Scheme.Recognizes(testapi.Experimental.GroupAndVersion(), kind) {"
  }
]
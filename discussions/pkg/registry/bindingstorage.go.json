[
  {
    "id" : "2f8a26a3-bdab-4c26-b74d-67d9b27e074c",
    "prId" : 592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4a7d3e7-711c-4c4d-a6ea-e61620f2bab7",
        "parentId" : null,
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "nit: Underscore the name \"binding_storage.go\"\n",
        "createdAt" : "2014-07-24T01:34:23Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "3c69d9cd-1d4e-44c6-8024-52589da8499b",
        "parentId" : "f4a7d3e7-711c-4c4d-a6ea-e61620f2bab7",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Hehe, it's on my list to rename the files in this directory.\n\ne.g., pod_registry.go should actually be podstorage.go.\n\nI think it was @proppy that was making the argument that _ shouldn't be in the names of go files. Browsing through the standard library a bit, it looks like they're exclusively used for *_test.go and *_decl.go files.\n",
        "createdAt" : "2014-07-24T01:39:01Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d605467dc0926f07fd9825e754589d4c026b3ce",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +-1,3 @@/*\nCopyright 2014 Google Inc. All rights reserved.\n"
  },
  {
    "id" : "afcad18e-063e-4e90-9547-d5b1cc29707f",
    "prId" : 592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f37d49c8-ef18-4d85-af66-030abdc7dc8e",
        "parentId" : null,
        "authorId" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "body" : "Again, in a Mesos scheduler, a binding being written doesn't directly drive a change of the location of the pod, although it may indicate that a change of location is taking place or has taken place.\n",
        "createdAt" : "2014-08-01T09:13:37Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "tags" : [
        ]
      },
      {
        "id" : "239b4070-bc0a-4aa8-9ca6-85344027e79b",
        "parentId" : "f37d49c8-ef18-4d85-af66-030abdc7dc8e",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "From your description, it sounds like what I've phrased here as \"writing a binding\" is analogous to Mesos' \"call runTask/launchTask on master\".\n\nIf we're trying to run a k8s master and a Mesos master at the same time, I can think of a couple ways in which that might be possible:\n1. k8s master defines an onBind hook, which Mesos master subscribes to.\n2. Mesos scheduler starts tasks via Mesos master, which pushes containers to kubelet via its http interface instead of via its etcd interface.\n\nI'm not sure if we'd really want to fragment the mechanisms as in 2, but it's possible.\n",
        "createdAt" : "2014-08-01T17:21:46Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "8ddf6ba2-de61-430c-8e44-ee710039f92c",
        "parentId" : "f37d49c8-ef18-4d85-af66-030abdc7dc8e",
        "authorId" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "body" : "Since the Mesos master may need to do its resource accounting before the Kubelet launches the pod (to prevent other frameworks from claiming the same resources), and the Kubelet may not even be running yet, I don't think the onBind mechanism would work for us.\n\nIs the http interface you mention an abstraction over etcd, or a kubelet-only (etcd-free) interface for launching a pod?\nEven if it's just an abstraction over etcd, we would greatly appreciate such a non-etcd-specific interface to the shared state, so we could potentially make use of our existing Zookeeper or MesosReplicatedLog storage. \n",
        "createdAt" : "2014-08-05T09:15:22Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "tags" : [
        ]
      },
      {
        "id" : "12affb11-d544-4a94-88b3-37acd29fed50",
        "parentId" : "f37d49c8-ef18-4d85-af66-030abdc7dc8e",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "The http interface doesn't go over etcd, you can talk directly to kubelet. However, it would make some things really tricky, so I'm not sure I'm a big fan. I think I can come up with more alternatives; if you're up for it, a videocall or something might be easier than hashing this out in a PR, though. Some time next week, maybe?\n",
        "createdAt" : "2014-08-05T17:50:34Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "a436099d-aa4e-4c9b-abf5-16b9e732a069",
        "parentId" : "f37d49c8-ef18-4d85-af66-030abdc7dc8e",
        "authorId" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "body" : "Would love to discuss this more in-real-time over a call. Please email me (adam-at-mesosphere.io) so we can schedule a time and I can invite others working on our Kubernetes-Mesos framework.\n",
        "createdAt" : "2014-08-07T01:40:24Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d605467dc0926f07fd9825e754589d4c026b3ce",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +28,32 @@// changes the location of the affected pods. This information is eventually reflected\n// in the pod's CurrentState.Host field.\ntype BindingStorage struct {\n\tpodRegistry PodRegistry\n}"
  },
  {
    "id" : "bc111722-90c2-427f-9d6f-966c9ec1632b",
    "prId" : 592,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4ed78f1-6a61-4f35-b031-b0e71702a633",
        "parentId" : null,
        "authorId" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "body" : "Seems strange that bindings cannot be listed, read, or deleted. Or is the BindingStorage object just supposed to be a log of bindings that were made/attempted/announced? And if it's write-only, then who (if anybody) will actually consume this information?\n",
        "createdAt" : "2014-08-01T09:16:04Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "tags" : [
        ]
      },
      {
        "id" : "aaed5bd4-a214-4e53-a043-980ae171d5ea",
        "parentId" : "b4ed78f1-6a61-4f35-b031-b0e71702a633",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "The method I'm proposing here is that bindings will be write-only. They needn't be stored anywhere--the Host field of the binding will be reflected in the host of the pod once the binding is accepted.\n\nThe BindingStorage object here is just going to implement the application logic. It's not actually going to store the binding. Admittedly this is confusing, but the *Storage suffix is here for consistency to indicate that this implement's our apiserver's RESTStorage interface.\n",
        "createdAt" : "2014-08-01T17:09:00Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "9ff2d231-9a8e-4941-bae6-2cad478cfa23",
        "parentId" : "b4ed78f1-6a61-4f35-b031-b0e71702a633",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Note that it's easy to start storing bindings in the future. I'm not intending to store them at the moment because I'm implementing only the barest set of features to get this to work.\n",
        "createdAt" : "2014-08-01T17:11:50Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "35bb80c4-a0f9-4063-9c8d-5f7a2d8aeb16",
        "parentId" : "b4ed78f1-6a61-4f35-b031-b0e71702a633",
        "authorId" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "body" : "So, is the idea that you write a Binding (to etcd) and then etcd/whatever passes it on to any Watcher on the onBind hook? That's what I was trying to get at when asking about the consumer. I'm now understanding that once written, the Binding is not directly accessible through the etcd/shared-state Get/List/Delete interface, but is internally passed on to any Watchers who will consume that data as they like, with AssignPod in particular updating the 'host' field in the actual Pod entry.\n",
        "createdAt" : "2014-08-05T09:22:52Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "911fae49-4bfc-49cb-815b-bf168e470d24",
        "tags" : [
        ]
      },
      {
        "id" : "b269a927-06d6-489d-bf4c-904b67353718",
        "parentId" : "b4ed78f1-6a61-4f35-b031-b0e71702a633",
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "I was actually thinking that it would call AssignPod directly; consumers of this information would get it by watching pods--their Host field will change, and the reason that they're waiting would change. More layers of indirection can be added, but it's hard to remove them later, so I'd rather start simpler.\n",
        "createdAt" : "2014-08-05T17:49:52Z",
        "updatedAt" : "2014-08-11T02:06:09Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d605467dc0926f07fd9825e754589d4c026b3ce",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +50,54 @@\n// Delete returns an error because bindings are write-only objects.\nfunc (*BindingStorage) Delete(id string) (<-chan interface{}, error) {\n\treturn nil, apiserver.NewNotFoundErr(\"binding\", id)\n}"
  }
]
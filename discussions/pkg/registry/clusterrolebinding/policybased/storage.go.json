[
  {
    "id" : "29638c53-fc02-43fb-bcaf-0ec1f2ce00cc",
    "prId" : 25634,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "parentId" : null,
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "To do complex validation for job, I put that in the Strategy's Validate function.\nWhy is this implemented as a Storage rather than a Strategy?\n",
        "createdAt" : "2016-05-17T19:28:28Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "ac7ee35a-575b-4595-8fa1-4dbc907e0df8",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "I don't see any other types that have their own `storage.go`, but I see many that define a custom Strategy.  I think you should use that approach if possible.  See `pkg/registry/secret/strategy.go` for example.  Unless there is some reason it needs to be at the Storage layer. \n",
        "createdAt" : "2016-05-17T19:46:42Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "53d03c6f-210a-445e-bca4-0334eb2a3874",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "The AuthorizationRuleResolver needs a storage, so it's hard to initialize a storage without and existing one. That's the main logic for having this logic separated.\n",
        "createdAt" : "2016-05-17T20:00:41Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "d8cd69ba-f494-46a3-9810-ad5161a6cd09",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "This is also what openshift does (not to say that that makes it appropriate for kubernetes) https://github.com/openshift/origin/blob/388478c40e751c4295dcb9a44dd69e5ac65d0e3b/pkg/authorization/registry/role/policybased/virtual_storage.go\n",
        "createdAt" : "2016-05-17T20:02:30Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "d7d8926c-a355-4457-b4da-dd20c620fc96",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> This is also what openshift does (not to say that that makes it appropriate for kubernetes) https://github.com/openshift/origin/blob/388478c40e751c4295dcb9a44dd69e5ac65d0e3b/pkg/authorization/registry/role/policybased/virtual_storage.go\n\nWe created our storage long before strategies existed.  Without virtual resources, I don't see a strong case for keeping them.  I think that `Validate` and `ValidateUpdate` provide sufficient power to express the `ConfirmNoEscalation` case.  The cyclical dependency problem due to a lack of separation between a read-only storage and a read-write storage is problematic though.\n",
        "createdAt" : "2016-05-17T20:09:10Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "379c0861-9c90-4f62-bb86-07ba24ebdc74",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "Is this because you need to have a registry defined in pkg/master/master.go to pass to the rbacvalidation.AuthorizationRuleResolver prior to creating the Storage for the rbac objects, and there is not a way to do that with Strategy?\n",
        "createdAt" : "2016-05-17T20:57:10Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "e6e7037a-2367-4092-b662-9fff6fefa18d",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Correct. AuthorizationRuleResolver requires something that can get/list roles/rolebindings.\n",
        "createdAt" : "2016-05-17T20:58:45Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "6c044c74-57ba-4775-b21c-12bdd381c9af",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Correct. AuthorizationRuleResolver requires something that can get/list roles/rolebindings.\n\nAnd it requires that something to bypass any authorization checks so you don't end up in infinite loops, so you can't pass it a normal client.\n",
        "createdAt" : "2016-05-17T21:01:36Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "1ef6261b-773c-40d0-badd-856bc882c8ea",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@kubernetes/sig-api-machinery does anyone want to comment on how to make a Strategy which accesses other registries in order to do Validation, and more specifically with this thread.\n",
        "createdAt" : "2016-05-17T21:11:10Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "05abd45b-c0d7-48ee-b123-39ef10ed10e8",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> And it requires that something to bypass any authorization checks so you don't end up in infinite loops, so you can't pass it a normal client.\n\nOh, and either way you do it, you'll need a path that bypasses the escalation check to be able to prime your etcd with initial data that is by nature escalating.  In openshift, we have a Registry sort of interface with an `CreateRoleWithEscalation` kind of method to make that work (https://github.com/openshift/origin/blob/master/pkg/authorization/registry/role/policybased/virtual_storage.go#L108).\n",
        "createdAt" : "2016-05-17T21:17:20Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "542c399e-2752-484c-adc4-6bf9ff410164",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Yeah I saw those.\n\nWas thinking that if you wanted to create a storage with checking you'd use the policybased storage, and for bootstrapping we'd use the storage in the etcd package, since both can be used to create a {{ objecttype }}.Registry\n",
        "createdAt" : "2016-05-17T21:25:13Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "7fcc1e63-024d-446a-a8b4-4f6bedff0f60",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "In Kubernetes, we have an \"insecure port\".  I was thinking that the initial policy would be created via the insecure port.  The insecure port currently does not do any authentication or authorization.  However, we could change the handler path for the insecure port so that it sets the username to a reserved field, like: `system:apiserver-insecure-port-user`, and special case that user in the validation logic?  \n",
        "createdAt" : "2016-05-17T21:27:43Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "ef49cca4-5406-4f00-a8ab-8c66a4aa7830",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "> Yeah I saw those.\n> \n> Was thinking that if you wanted to create a storage with checking you'd use the policybased storage, and for bootstrapping we'd use the storage in the etcd package, since both can be used to create a {{ objecttype }}.Registry\n\nWe were worried about overlapping interfaces allowing someone to accidentally use the wrong method somewhere.  Non-overlapping interface for making changes without escalation prevents that from happening.\n",
        "createdAt" : "2016-05-18T20:33:09Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "48047873-564b-473f-b7ad-681c2267d049",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "To clean this up, can we just perform these escalation checks in the authorizer itself? That would avoid having a separate registry  \n",
        "createdAt" : "2016-05-19T23:06:00Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "67e5b477-e27a-4282-981d-eefb8e9435c6",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "body" : "I am trying to understand the escalation check logic during RoleBinding creation. If I understand it correctly, the idea here is that user cannot add themselves into a role that has more privileges that they already have. But since there is no similar check on Role update, they might as well add these extra permissions directly to one of their existing roles (if they can update roles). Is that the intended behavior?\n\nAlso, if they can't elevate their own privileges by adding a RoleBinding, but can do it for someone else, two users who can both create RoleBindings might just conspire so that one adds another to any role.\n\nIt seems that scenarios like this make the usefulness of the escalation check on RoleBinding creation somewhat limited. E.g. if someone already has enough permissions to map users to roles in a given namespace, they might as well be able to do it for themselves.\n",
        "createdAt" : "2016-05-20T22:14:51Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "tags" : [
        ]
      },
      {
        "id" : "829be66e-99c1-40b0-9abb-c5bacea9826b",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "I would describe this as \"you can't assign privileges you don't have\"\n\nIf you attempt to create a role binding, the storage checks all of the role bindings that point to you and ensures that the permissions you currently have encompass the role the role binding your attempt to create references.\n\nIt doesn't matter if the role binding is assigning to yourself or another user, you cannot assign roles you don't already have.\n\nDoes this make sense?\n",
        "createdAt" : "2016-05-20T22:28:02Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "60cda8a9-e1fb-4107-a8b6-e52db4260ae7",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "body" : "Ah I see, that makes sense. It is still possible to extend your privileges by updating the role itself, but it seems the intent here is to make it possible to delegate permission management to a user who can create/update role bindings, but not roles themselves, is that correct?\n",
        "createdAt" : "2016-05-20T22:48:33Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "tags" : [
        ]
      },
      {
        "id" : "48b6df85-b0f4-4553-835b-906f48cfb7dc",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "In OpenShift, we actually do escalate checks on role editing as well\n",
        "createdAt" : "2016-05-20T22:56:09Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "3a1e3b6e-3aa6-4bd2-8bd4-d629c54f7591",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "body" : "Should there be a similar check on deletes to prevent stripping permissions from others? E.g. if someone gave me a 'read-only' in a namespace and an ability to manage RoleBindings in that namespace, I probably shouldn't be able to remove a RoleBinding with an 'admin' roleRef. There is a validation to prevent roleRef change on update, but I can't find anything preventing deletes.\n",
        "createdAt" : "2016-05-20T23:11:23Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "tags" : [
        ]
      },
      {
        "id" : "71971489-a3e5-417b-bb6d-8a629a5ee3c5",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Hmm, I could see both the edit, and delete checks making sense here.\n\nMight it be better separate this logic in to an admission controller? It'd give us a centralized place to debate and update these checks.\n",
        "createdAt" : "2016-05-20T23:20:48Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "51f109f9-90df-48d6-b3d3-1367d2cad548",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "We didn't think that was necessary, we were really only interested in preventing escalation. \"ReadOnly+Role management\" is a weird mix of permissions. \n\nSeparating escalation checks into admission allows them to be accidentally bypassed by anything working directly against the storage once inside the admission boundary. That was scary enough to make us bake it into storage. \n",
        "createdAt" : "2016-05-20T23:28:54Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "fc90525d-35d3-4bc4-84c6-d2e5c4503577",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "body" : "Yeah, admission controller seems like a natural choice for this. If the goal is to prevent any operation that can end up in granting or removing more privileges than the requester already has, that admission controller needs to work with all of RBAC resources on creates, updates, and deletes. I could be wrong though, as I only started looking at this change and might be missing some context.\n",
        "createdAt" : "2016-05-20T23:31:42Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "1cb05d99-3dec-4446-a1fa-4aeb956021e5",
        "tags" : [
        ]
      },
      {
        "id" : "308a0804-506f-4441-ba43-34a96f26fb84",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "@olegshaldybin yeah thanks for bring this up. This is precarious stuff trying to think of all the ways users can exploit this.\n\nWe could probably avoid a whole class of issues by not allow namespaced role bindings to reference cluster level roles. But I understand that this is wanted for convenience.\n",
        "createdAt" : "2016-05-21T00:14:23Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "3811f704-7f5d-4854-8bc3-dd6aa610fa17",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@olegshaldybin The assumption is that only cluster-admins can define roles.  \n\nThe covers check is done in the storage rather than in an admission controller.  I assume this is because you would not ever want to make it optional.  Is that right @liggitt?  Asking about doing covers check in storage vs admission.\n",
        "createdAt" : "2016-05-23T17:30:04Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "0978d6ca-cfd4-44f0-8ab4-008a0e8e4467",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@liggitt never mind I see you just explained that above.\n",
        "createdAt" : "2016-05-23T17:31:08Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "3f743d66-8690-402a-bc62-5b55f7a7522c",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "@ericchiang If we wanted to make it so that NamespacedRoleBindings could not reference a ClusterRole, then we could have a controller that watches for new namespace (like token controller does) and then automatically creates Roles in each new namespace when the namespace.  Those roles would explicitly include the namespace that they are restricted to, rather than it being implied, which might somewhat reduce the chance of bugs.  This would have about the same level of convenience.  It would also have the property that the per-namespace default policy would not automatically update when the cluster is upgraded, which could be good, but could also be bad if it means that you have to update each namespace's policy when a new Kind is added to the system that you want to add for certain roles.\n",
        "createdAt" : "2016-05-23T17:43:22Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "24a546d2-bb41-42de-95f0-0a6a59b7dcee",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "@erictune after more thinking, I think the inherent promise that role bindings don't apply at the cluster level gets us most of this behavior we want.\n\nThe mutability of roles, means we have to address @olegshaldybin's comments. And in this case, I'm having trouble figuring out how to centralize all of this logic since there's no good example of existing storage validation requiring API access.\n\nMaking these checks an admission controller means we have to deal with @liggitt's comments of unintentional escalation, but it also gets us the localhost without escalation checks we talked about earlier.\n\nWondering if there's some way we can deal with this after we merge the API group and authorizer.\n",
        "createdAt" : "2016-05-23T18:18:54Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "d22d631a-4c73-468e-b6f0-337705b61ce7",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "We definitely do not make API calls in validation - we would do so in the\nstrategy at worst.\n\nOn Mon, May 23, 2016 at 2:41 PM, Eric Chiang notifications@github.com\nwrote:\n\n> In pkg/registry/clusterrolebinding/policybased/storage.go\n> https://github.com/kubernetes/kubernetes/pull/25634#discussion_r64263097\n> :\n> \n> > @@ -0,0 +1,59 @@\n> > +/*\n> \n> @erictune https://github.com/erictune after more thinking, I think the\n> inherent promise that role bindings don't apply at the cluster level gets\n> us most of this behavior we want.\n> \n> The mutability of roles, means we have to address @olegshaldybin\n> https://github.com/olegshaldybin's comments. And in this case, I'm\n> having trouble figuring out how to centralize all of this logic since\n> there's no good example of existing storage validation requiring API access.\n> \n> Making these checks an admission controller means we have to deal with\n> @liggitt https://github.com/liggitt's comments of unintentional\n> escalation, but it also gets us the localhost without escalation checks we\n> talked about earlier.\n> \n> Wondering if there's some way we can deal with this after we merge the API\n> group and authorizer.\n> \n> —\n> You are receiving this because you are on a team that was mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/kubernetes/kubernetes/pull/25634/files/82fa2c3b354a84fa2f9be6d9420701df6b36fe2b..17bffb41bd5a5687d7bda2d30f26159071e51cab#r64263097\n",
        "createdAt" : "2016-05-23T18:53:14Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "a93acc10-880f-48e6-a380-970a45a5aa13",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "body" : "yeah, my mistake, s/validation/storage/\n",
        "createdAt" : "2016-05-23T20:01:14Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "020e031c-c298-4e7e-a533-9a04439c203c",
        "tags" : [
        ]
      },
      {
        "id" : "e370d1ec-523e-4a0f-9e29-ab0dcdd68468",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "body" : "I haven't been following this PR terribly closely, but I think one\nsignificant disadvantage is that you can't be certain a role change takes\neffect across the entire cluster easily (can't manage centrally).  That's\ncertainly worrying for an administrator.\n\nMultilevel security policy is not uncommon - I would hesitate to say that a\ntested multilevel system is no more at risk than a tested flattened system.\n\nAre there other advantages to propagation that inclines you to prefer it?\n\n> If we wanted to make it so that NamespacedRoleBindings could not reference a ClusterRole, then we could have a controller that watches for new namespace (like token controller does) and then automatically creates Roles in each new namespace when the namespace. Those roles would explicitly include the namespace that they are restricted to, rather than it being implied, which might somewhat reduce the chance of bugs. This would have about the same level of convenience. It would also have the property that the per-namespace default policy would not automatically update when the cluster is upgraded, which could be good, but could also be bad if it means that you have to update each namespace's policy when a new Kind is added to the system that you want to add for certain roles.\n",
        "createdAt" : "2016-05-23T23:32:35Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "6e2b5eda-1533-4798-a56c-432faaf38480",
        "tags" : [
        ]
      },
      {
        "id" : "3cfebfab-5c14-4995-8e23-0a5aad70245b",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "#25787 seems to have broken the ability to make the type assertions these checks rely on[0] since the `runtime.Object` is now a `rest.UpdatedObjectInfo` which hides the underlying object being updated to.\n\nWould it be reasonable to pull the privilege escalation checks from this PR and revisit a more robust multilevel security system for beta? Based on the conversation here (and the above issue) it seems like there might be a better home for these checks anyway.\n\ncc @erictune \n\n[0] https://github.com/kubernetes/kubernetes/pull/25634/files#diff-0ddbb384845118d5b907e3498b76455cR66\n",
        "createdAt" : "2016-05-25T01:53:44Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      },
      {
        "id" : "a7bfefc9-c7ba-4705-8a3b-c3759071e26c",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "The object is still available, it just has to be obtained by passing in the existing object (which should be done inside the innermost storage during the GuaranteedUpdate call).\n\nWanting to add checks/transformations/behavior on the new object seems like a common enough pattern that I opened https://github.com/kubernetes/kubernetes/pull/26240 to add a helper for it. If you want to use that, you could do something like this, which just moves your checks into a function that gets chained onto the end of the call that retrieves the new object:\n\n```\nfunc (s *Storage) Update(ctx api.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {\n    if user, ok := api.UserFrom(ctx); ok {\n        if s.superUser != \"\" && user.GetName() == s.superUser {\n            return s.StandardStorage.Update(ctx, name, objInfo)\n        }\n    }\n\n    nonescalatingInfo := rest.WrapUpdatedObjectInfo(objInfo, func(ctx api.Context, obj, oldObj runtime.Object) (runtime.Object, error) {\n        clusterRoleBinding, ok := obj.(*rbac.ClusterRoleBinding)\n        if !ok {\n            ... return internal cast error ...\n        }\n        rules, err := s.ruleResolver.GetRoleReferenceRules(ctx, clusterRoleBinding.RoleRef, clusterRoleBinding.Namespace)\n        if err != nil {\n            return nil, err\n        }\n        if err := validation.ConfirmNoEscalation(ctx, s.ruleResolver, rules); err != nil {\n            return nil, err\n        }\n        return obj, nil\n    })\n\n    return s.StandardStorage.Update(ctx, name, nonescalatingInfo)\n}\n```\n\nThat also has the benefit of giving you the old object, so in the future, escalation checks could take into account whether you were actually adding any bindings, or just removing/annotating, etc.\n\n> Would it be reasonable to pull the privilege escalation checks from this PR and revisit a more robust multilevel security system for beta? Based on the conversation here (and the above issue) it seems like there might be a better home for these checks anyway.\n\nI still think storage (or something connected to it, like the strategy) is the best place for it. I'd prefer we start with it here or in the strategy, not punted to admission or omitted.\n",
        "createdAt" : "2016-05-25T02:40:32Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "1a9ae7b9-7d4c-44f6-8649-4cfacc35cc2e",
        "parentId" : "f1a3eb82-6f74-4f43-aeb1-d098cf380278",
        "authorId" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "body" : "Ah that would work. Thanks, I'll update this in the morning.\n",
        "createdAt" : "2016-05-25T04:38:58Z",
        "updatedAt" : "2016-05-25T21:26:24Z",
        "lastEditedBy" : "0af48e59-4be9-46ce-9275-aa218813b6fd",
        "tags" : [
        ]
      }
    ],
    "commit" : "36ecec58f002a55a0ddc3a1fb592d1c9e19f22f0",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +-1,3 @@/*\nCopyright 2016 The Kubernetes Authors All rights reserved.\n"
  }
]
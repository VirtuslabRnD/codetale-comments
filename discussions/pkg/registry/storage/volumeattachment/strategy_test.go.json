[
  {
    "id" : "4e0a2f52-3e2f-4469-a85e-64ae23cc7246",
    "prId" : 77703,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/77703#pullrequestreview-239058253",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dd73704-c737-4a75-b3ea-5b1ba1287dbf",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I think we need a test that PrepareForUpdate preserves the field if the old object had data in the field, even when the feature is disabled",
        "createdAt" : "2019-05-17T16:58:00Z",
        "updatedAt" : "2019-05-30T09:35:54Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "f21d5590-a9e7-44d5-8743-d313762fdc59",
        "parentId" : "4dd73704-c737-4a75-b3ea-5b1ba1287dbf",
        "authorId" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "body" : "Just for my own understanding: given in PrepareForCreate, we set InlineVolumeSpec to nil (if feature flag is disabled), there should not be a realistic scenario where PrepareForUpdate encounters an old volumeAttachment with InlineVolumeSpec populated (if feature flag is disabled), right?\r\n\r\nOr can a scenario arise if the admin decides to disable the feature-flag on a cluster at some point after enabling it and volumeAttachments were created in between with InlineVolumeSpec populated?",
        "createdAt" : "2019-05-17T17:47:14Z",
        "updatedAt" : "2019-05-30T09:35:54Z",
        "lastEditedBy" : "98986d5f-c846-4478-8363-8a016e3d6b89",
        "tags" : [
        ]
      },
      {
        "id" : "79a93ae8-cdc8-40e8-9249-a3d0f5a6f12e",
        "parentId" : "4dd73704-c737-4a75-b3ea-5b1ba1287dbf",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "> Or can a scenario arise if the admin decides to disable the feature-flag on a cluster at some point after enabling it and volumeAttachments were created in between with InlineVolumeSpec populated?\r\n\r\nExactly. Enable, populate, disable, update. Also, during a rollback or an HA apiserver upgrade from 1.15 to 1.16, a 1.15 apiserver could encounter this",
        "createdAt" : "2019-05-17T17:56:33Z",
        "updatedAt" : "2019-05-30T09:35:54Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "de7be9d6133bb985d9f1d0fa029e03166f6cd0f4",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +157,161 @@\t\tt.Errorf(\"InlineVolumeSpec unexpectedly not dropped during PrepareForUpdate\")\n\t}\n}\n\nfunc TestVolumeAttachmentStatusStrategy(t *testing.T) {"
  },
  {
    "id" : "d014ff1e-a1e1-48ea-9989-13f9ef7b212d",
    "prId" : 69929,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/69929#pullrequestreview-174675377",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86faaa60-253b-4e63-8af8-de83e125e9f6",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "add a label, annotation, finalizer, and ownerRef as well and make sure they are ignored\r\n\r\nedit: can add this in the same follow-up as above",
        "createdAt" : "2018-11-14T03:26:23Z",
        "updatedAt" : "2018-11-14T22:58:11Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "eaff4fd4d227321b69616f264d86dcf785d1b5ae",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +116,120 @@\t// modifying spec should be dropped\n\tnewVolumeAttachment := volumeAttachment.DeepCopy()\n\tnewVolumeAttachment.Spec.NodeName = \"valid-node-2\"\n\n\tStatusStrategy.PrepareForUpdate(ctx, newVolumeAttachment, volumeAttachment)"
  }
]
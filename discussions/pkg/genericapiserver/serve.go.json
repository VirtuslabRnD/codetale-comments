[
  {
    "id" : "1b2bfdae-bcae-4c22-935b-f71642048799",
    "prId" : 35109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35109#pullrequestreview-6015028",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88c804e8-0f28-405c-969e-e9c59d26efdc",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "is there anything else http2-related we miss by setting up our own listener?\n",
        "createdAt" : "2016-10-27T02:46:30Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "2aeb768a-182f-4734-9207-96dfbc1d57e5",
        "parentId" : "88c804e8-0f28-405c-969e-e9c59d26efdc",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Luckily there is golang.org/x/net/http2 which exports everything that is done by `ListenAndServeTLS`.\n",
        "createdAt" : "2016-10-27T07:35:12Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "9b407b7b-c755-4859-b880-32f66d1bce0f",
        "parentId" : "88c804e8-0f28-405c-969e-e9c59d26efdc",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Actually, `Server.Serve(listener)` does the http2 setup. The setup call in `ListenAndServeTLS` is superfluous IMO.\n",
        "createdAt" : "2016-10-27T08:45:48Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c5e354e82a125905e59d822ef3a63d0765465f8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +57,61 @@\t\t\tMinVersion: tls.VersionTLS12,\n\t\t\t// enable HTTP2 for go's 1.7 HTTP Server\n\t\t\tNextProtos: []string{\"h2\", \"http/1.1\"},\n\t\t},\n\t}"
  },
  {
    "id" : "bcf4deea-c896-4693-bfa2-efa456095c19",
    "prId" : 35109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35109#pullrequestreview-6005029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "013978db-e82e-4382-871e-1d8ef6ec9fb5",
        "parentId" : null,
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "comment where this came from\n",
        "createdAt" : "2016-10-27T02:54:25Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      },
      {
        "id" : "e7f62f33-a40a-42b7-980d-909ded00e31b",
        "parentId" : "013978db-e82e-4382-871e-1d8ef6ec9fb5",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "done\n",
        "createdAt" : "2016-10-27T07:42:16Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c5e354e82a125905e59d822ef3a63d0765465f8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +248,252 @@//\n// Copied from Go 1.7.2 net/http/server.go\ntype tcpKeepAliveListener struct {\n\t*net.TCPListener\n}"
  },
  {
    "id" : "6c0d9c2d-7816-4a63-8176-0620a4eaec18",
    "prId" : 35109,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/35109#pullrequestreview-24294443",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f5fee73a-ae48-49e0-969f-2783ee5c9f23",
        "parentId" : null,
        "authorId" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "body" : "Why are we still trying multiple times?  Didn't we decide we preferred crashlooping?  I'm ok as a followup.\n",
        "createdAt" : "2016-10-31T20:16:01Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "fa477146-9a47-4754-b38c-de8062e65e13",
        "tags" : [
        ]
      },
      {
        "id" : "9f15d104-99e7-42ff-9ab7-1e1f98b0edea",
        "parentId" : "f5fee73a-ae48-49e0-969f-2783ee5c9f23",
        "authorId" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "body" : "Only after the first synchronous try which worked. That was my understanding from our small irc discussion. A follow-up is fine. I prefer a hard crash in such a case such that the outer orchestrator (e.g. systemd or kubelet) can do its job.\n",
        "createdAt" : "2016-11-01T07:29:35Z",
        "updatedAt" : "2016-11-01T08:51:04Z",
        "lastEditedBy" : "f0985d19-4073-49b4-832a-0b89b15a1431",
        "tags" : [
        ]
      },
      {
        "id" : "2e9f59ca-18c0-494a-a25b-0f76c650fdda",
        "parentId" : "f5fee73a-ae48-49e0-969f-2783ee5c9f23",
        "authorId" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "body" : "I can't think of a good reason to retry such a fundamental failure internally",
        "createdAt" : "2017-02-28T17:12:39Z",
        "updatedAt" : "2017-02-28T17:12:39Z",
        "lastEditedBy" : "8be927c4-cfb4-4077-b355-f4f3d84849b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c5e354e82a125905e59d822ef3a63d0765465f8",
    "line" : 142,
    "diffHunk" : "@@ -1,1 +140,144 @@\t\tdefer utilruntime.HandleCrash()\n\n\t\tfor {\n\t\t\tvar listener net.Listener\n\t\t\tlistener = tcpKeepAliveListener{ln.(*net.TCPListener)}"
  }
]
[
  {
    "id" : "9378f554-3402-408a-8529-b46eec41d293",
    "prId" : 8152,
    "prUrl" : "https://github.com/digital-asset/daml/pull/8152",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db3ff025-3b77-4fb5-9160-ccbab45bf309",
        "parentId" : null,
        "authorId" : "c83a17a2-0c0d-4811-9fe5-e560bb3ad87a",
        "body" : "A few notes:\r\n\r\n## Correctness\r\n\r\n`#$contractsTable` expands to `participant_contracts natural join participant_contract_witnesses`.\r\n\r\nPreviously the query returned exactly one row, after changing the `=` check to a `in` check, it should return multiple rows if the intersection of witnesses and readers has more than one element. All of those rows will have the same `(contract_id, template_id, create_argument)` values, hence the `limit 1` at the end.\r\n\r\n## Performance\r\n\r\n`in` checks cannot be accelerated using btree indices, so this change could potentially slow down the query. However, I have seen that Postgresql optimizes the `in` operator to an equality check if it can statically show that the array only contains one element, so I would expect the change to not have any impact. I would still inspect in detail what happens, see for example https://github.com/digital-asset/daml/pull/8035#issuecomment-738826144",
        "createdAt" : "2020-12-07T09:21:12Z",
        "updatedAt" : "2020-12-10T20:25:07Z",
        "lastEditedBy" : "c83a17a2-0c0d-4811-9fe5-e560bb3ad87a",
        "tags" : [
        ]
      },
      {
        "id" : "ed55ec6f-1378-4c99-854e-d8c7bd952d63",
        "parentId" : "db3ff025-3b77-4fb5-9160-ccbab45bf309",
        "authorId" : "5f6b922a-83eb-4419-97b1-13c757c1e583",
        "body" : "### Performance impact analysis\r\n#### `def lookupActiveContractAndLoadArgument()`\r\n**Before changes:**\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id, template_id, create_argument from participant_contracts natural join participant_contract_witnesses where contract_witness = '00001' and participant_contracts.contract_id = '#0000000000000018:11';\r\n                                                                                   QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Nested Loop  (cost=0.85..12.90 rows=1 width=989) (actual time=0.031..0.034 rows=1 loops=1)\r\n   ->  Index Scan using participant_contracts_pkey on participant_contracts  (cost=0.43..8.45 rows=1 width=989) (actual time=0.018..0.018 rows=1 loops=1)\r\n         Index Cond: ((contract_id)::text = '#0000000000000018:11'::text)\r\n   ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.45 rows=1 width=21) (actual time=0.011..0.012 rows=1 loops=1)\r\n         Index Cond: ((contract_id = '#0000000000000018:11'::text) AND (contract_witness = '00001'::text))\r\n         Heap Fetches: 0\r\n Planning Time: 0.113 ms\r\n Execution Time: 0.056 ms\r\n(8 rows)\r\n```\r\n\r\n**After changes**\r\nMultiple readers:\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id, template_id, create_argument from participant_contracts natural join participant_contract_witnesses where contract_witness in ('00001', '00002') and participant_contracts.contract_id = '#0000000000000018:11' limit 1;;\r\n                                                                                      QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Limit  (cost=0.85..6.89 rows=1 width=989) (actual time=0.030..0.031 rows=1 loops=1)\r\n   ->  Nested Loop  (cost=0.85..12.93 rows=2 width=989) (actual time=0.029..0.029 rows=1 loops=1)\r\n         ->  Index Scan using participant_contracts_pkey on participant_contracts  (cost=0.43..8.45 rows=1 width=989) (actual time=0.016..0.016 rows=1 loops=1)\r\n               Index Cond: ((contract_id)::text = '#0000000000000018:11'::text)\r\n         ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.47 rows=2 width=21) (actual time=0.011..0.011 rows=1 loops=1)\r\n               Index Cond: (contract_id = '#0000000000000018:11'::text)\r\n               Filter: ((contract_witness)::text = ANY ('{00001,00002}'::text[]))\r\n               Heap Fetches: 0\r\n Planning Time: 0.144 ms\r\n Execution Time: 0.055 ms\r\n(10 rows)\r\n```\r\n\r\nSingle reader:\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id, template_id, create_argument from participant_contracts natural join participant_contract_witnesses where contract_witness in ('00001') and participant_contracts.contract_id = '#0000000000000018:11' limit 1;\r\n                                                                                      QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Limit  (cost=0.85..12.90 rows=1 width=989) (actual time=0.034..0.035 rows=1 loops=1)\r\n   ->  Nested Loop  (cost=0.85..12.90 rows=1 width=989) (actual time=0.033..0.034 rows=1 loops=1)\r\n         ->  Index Scan using participant_contracts_pkey on participant_contracts  (cost=0.43..8.45 rows=1 width=989) (actual time=0.017..0.018 rows=1 loops=1)\r\n               Index Cond: ((contract_id)::text = '#0000000000000018:11'::text)\r\n         ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.45 rows=1 width=21) (actual time=0.014..0.014 rows=1 loops=1)\r\n               Index Cond: ((contract_id = '#0000000000000018:11'::text) AND (contract_witness = '00001'::text))\r\n               Heap Fetches: 0\r\n Planning Time: 0.125 ms\r\n Execution Time: 0.060 ms\r\n(9 rows)\r\n```\r\n\r\n#### `def lookupActiveContractWithCachedArgument()`\r\n**Before changes**\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id, template_id from participant_contracts natural join participant_contract_witnesses where contract_witness = '00001' and participant_contracts.contract_id = '#0000000000000018:11';\r\n                                                                                   QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Nested Loop  (cost=0.85..12.90 rows=1 width=166) (actual time=0.029..0.031 rows=1 loops=1)\r\n   ->  Index Scan using participant_contracts_pkey on participant_contracts  (cost=0.43..8.45 rows=1 width=166) (actual time=0.016..0.017 rows=1 loops=1)\r\n         Index Cond: ((contract_id)::text = '#0000000000000018:11'::text)\r\n   ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.45 rows=1 width=21) (actual time=0.010..0.011 rows=1 loops=1)\r\n         Index Cond: ((contract_id = '#0000000000000018:11'::text) AND (contract_witness = '00001'::text))\r\n         Heap Fetches: 0\r\n Planning Time: 0.113 ms\r\n Execution Time: 0.055 ms\r\n(8 rows)\r\n```\r\n\r\n**After changes**\r\nMultiple readers:\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id, template_id from participant_contracts natural join participant_contract_witnesses where contract_witness in ('00001', '00002') and participant_contracts.contract_id = '#0000000000000018:11' limit 1;\r\n                                                                                      QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Limit  (cost=0.85..6.89 rows=1 width=166) (actual time=0.031..0.033 rows=1 loops=1)\r\n   ->  Nested Loop  (cost=0.85..12.93 rows=2 width=166) (actual time=0.030..0.031 rows=1 loops=1)\r\n         ->  Index Scan using participant_contracts_pkey on participant_contracts  (cost=0.43..8.45 rows=1 width=166) (actual time=0.017..0.017 rows=1 loops=1)\r\n               Index Cond: ((contract_id)::text = '#0000000000000018:11'::text)\r\n         ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.47 rows=2 width=21) (actual time=0.012..0.012 rows=1 loops=1)\r\n               Index Cond: (contract_id = '#0000000000000018:11'::text)\r\n               Filter: ((contract_witness)::text = ANY ('{00001,00002}'::text[]))\r\n               Heap Fetches: 0\r\n Planning Time: 0.139 ms\r\n Execution Time: 0.056 ms\r\n(10 rows)\r\n```\r\n\r\nSingle reader:\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id, template_id from participant_contracts natural join participant_contract_witnesses where contract_witness in ('00001') and participant_contracts.contract_id = '#0000000000000018:11' limit 1;\r\n                                                                                      QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Limit  (cost=0.85..12.90 rows=1 width=166) (actual time=0.030..0.032 rows=1 loops=1)\r\n   ->  Nested Loop  (cost=0.85..12.90 rows=1 width=166) (actual time=0.029..0.030 rows=1 loops=1)\r\n         ->  Index Scan using participant_contracts_pkey on participant_contracts  (cost=0.43..8.45 rows=1 width=166) (actual time=0.016..0.017 rows=1 loops=1)\r\n               Index Cond: ((contract_id)::text = '#0000000000000018:11'::text)\r\n         ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.45 rows=1 width=21) (actual time=0.011..0.011 rows=1 loops=1)\r\n               Index Cond: ((contract_id = '#0000000000000018:11'::text) AND (contract_witness = '00001'::text))\r\n               Heap Fetches: 0\r\n Planning Time: 0.127 ms\r\n Execution Time: 0.056 ms\r\n(9 rows)\r\n```\r\n\r\n#### `def lookupContractKey()`\r\n**Before changes**\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id from participant_contracts natural join participant_contract_witnesses where '00001' =ANY(create_stakeholders) and contract_witness = '00001' and create_key_hash = '\\x000014280996d8691e36119db7751882caaef37ddf38d915de415c303c0a8856';\r\n                                                                                   QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Nested Loop  (cost=0.85..12.91 rows=1 width=21) (actual time=0.024..0.026 rows=1 loops=1)\r\n   ->  Index Scan using participant_contracts_create_key_hash_idx on participant_contracts  (cost=0.43..8.46 rows=1 width=21) (actual time=0.014..0.015 rows=1 loops=1)\r\n         Index Cond: (create_key_hash = '\\x000014280996d8691e36119db7751882caaef37ddf38d915de415c303c0a8856'::bytea)\r\n         Filter: ('00001'::text = ANY ((create_stakeholders)::text[]))\r\n   ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.45 rows=1 width=21) (actual time=0.009..0.009 rows=1 loops=1)\r\n         Index Cond: ((contract_id = (participant_contracts.contract_id)::text) AND (contract_witness = '00001'::text))\r\n         Heap Fetches: 0\r\n Planning Time: 0.280 ms\r\n Execution Time: 0.050 ms\r\n(9 rows)\r\n```\r\n\r\n**After changes**\r\nMultiple readers:\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id from participant_contracts natural join participant_contract_witnesses where create_stakeholders && array['00001', '00002']::varchar[] and contract_witness in ('00001', '00002') and create_key_hash = '\\x000014280996d8691e36119db7751882caaef37ddf38d915de415c303c0a8856' limit 1;\r\n                                                                                      QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Limit  (cost=0.85..12.93 rows=1 width=21) (actual time=0.027..0.028 rows=1 loops=1)\r\n   ->  Nested Loop  (cost=0.85..12.93 rows=1 width=21) (actual time=0.026..0.027 rows=1 loops=1)\r\n         ->  Index Scan using participant_contracts_create_key_hash_idx on participant_contracts  (cost=0.43..8.45 rows=1 width=21) (actual time=0.016..0.017 rows=1 loops=1)\r\n               Index Cond: (create_key_hash = '\\x000014280996d8691e36119db7751882caaef37ddf38d915de415c303c0a8856'::bytea)\r\n               Filter: (create_stakeholders && '{00001,00002}'::character varying[])\r\n         ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.47 rows=2 width=21) (actual time=0.008..0.008 rows=1 loops=1)\r\n               Index Cond: (contract_id = (participant_contracts.contract_id)::text)\r\n               Filter: ((contract_witness)::text = ANY ('{00001,00002}'::text[]))\r\n               Heap Fetches: 0\r\n Planning Time: 0.315 ms\r\n Execution Time: 0.059 ms\r\n(11 rows)\r\n```\r\n\r\nSingle reader:\r\n```\r\nasx100k=# explain analyze select participant_contracts.contract_id from participant_contracts natural join participant_contract_witnesses where create_stakeholders && array['00001']::varchar[] and contract_witness in ('00001') and create_key_hash = '\\x000014280996d8691e36119db7751882caaef37ddf38d915de415c303c0a8856' limit 1;\r\n                                                                                      QUERY PLAN\r\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n Limit  (cost=0.85..12.90 rows=1 width=21) (actual time=0.039..0.040 rows=1 loops=1)\r\n   ->  Nested Loop  (cost=0.85..12.90 rows=1 width=21) (actual time=0.038..0.039 rows=1 loops=1)\r\n         ->  Index Scan using participant_contracts_create_key_hash_idx on participant_contracts  (cost=0.43..8.45 rows=1 width=21) (actual time=0.013..0.014 rows=1 loops=1)\r\n               Index Cond: (create_key_hash = '\\x000014280996d8691e36119db7751882caaef37ddf38d915de415c303c0a8856'::bytea)\r\n               Filter: (create_stakeholders && '{00001}'::character varying[])\r\n         ->  Index Only Scan using participant_contract_witnesses_pkey on participant_contract_witnesses  (cost=0.43..4.45 rows=1 width=21) (actual time=0.023..0.023 rows=1 loops=1)\r\n               Index Cond: ((contract_id = (participant_contracts.contract_id)::text) AND (contract_witness = '00001'::text))\r\n               Heap Fetches: 0\r\n Planning Time: 0.278 ms\r\n Execution Time: 0.065 ms\r\n(10 rows)\r\n```\r\n\r\n#### Conclusion\r\nSpecifying multiple readers with `IN ()` clause doesn't prevent the database from using `participant_contract_witnesses_pkey` - this means that the proposed changes is not expected to have significant impact on the performance of the listed queries.\r\nSpecifying a single readers with `IN ()` clause is translated to a regular equality comparison and doesn't change the execution plan.",
        "createdAt" : "2020-12-10T16:16:44Z",
        "updatedAt" : "2020-12-10T20:25:07Z",
        "lastEditedBy" : "5f6b922a-83eb-4419-97b1-13c757c1e583",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7e15b0aae02655614cec3af2274073dc75cd1b7",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +51,55 @@    dispatcher\n      .executeSql(metrics.daml.index.db.lookupActiveContractDbMetrics) { implicit connection =>\n        SQL\"select participant_contracts.contract_id, template_id, create_argument from #$contractsTable where contract_witness in ($readers) and participant_contracts.contract_id = $contractId limit 1\"\n          .as(contractRowParser.singleOpt)\n      }"
  }
]
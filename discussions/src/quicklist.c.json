[
  {
    "id" : "a33bf170-4490-4e82-a8c1-566c3896424c",
    "prId" : 8915,
    "prUrl" : "https://github.com/redis/redis/pull/8915#pullrequestreview-655036148",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c9cf7cb-338f-4333-ad08-a95dff2dbb6e",
        "parentId" : null,
        "authorId" : "c6fac63b-ee5a-4181-b121-48bfacc74a59",
        "body" : "Interesting. Without the semicolon works in the normal case, but if REDIS_TEST_VERBOSE is defined, D expands to a `do { ... } while(0)` and it wouldn't compile here, so the verbose testing was broken (until now).\r\n\r\nTo make sure D without semicolon isn't added again, we can define D as something which needs to be followed by a semicolon, such as `do {} while(0)`. Just an idea.",
        "createdAt" : "2021-05-09T02:56:30Z",
        "updatedAt" : "2021-05-09T02:56:30Z",
        "lastEditedBy" : "c6fac63b-ee5a-4181-b121-48bfacc74a59",
        "tags" : [
        ]
      }
    ],
    "commit" : "bad2db77c021f17efa7820b18c20757f107bfeb2",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +1140,1144 @@    if (!iter->current) {\n        D(\"Returning because current node is NULL\");\n        return 0;\n    }\n"
  },
  {
    "id" : "0478d8c6-649e-4986-baa3-d83c962bab9b",
    "prId" : 8570,
    "prUrl" : "https://github.com/redis/redis/pull/8570#pullrequestreview-606865641",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "454484c7-0aee-4753-bdb7-218033fe40e3",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "i guess this was meant to be run in the last iteration (`f==fill_count`), not when the value is 32.\r\nam i wrong?",
        "createdAt" : "2021-03-08T18:40:59Z",
        "updatedAt" : "2021-03-10T06:59:16Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "20c743b5-3f6c-4ebf-83df-7b9409361110",
        "parentId" : "454484c7-0aee-4753-bdb7-218033fe40e3",
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "I found out that the original test will never go in, because f will never equal 32.\r\nThe original test wanted to verify that the length of quicklist doesn't become 2 when fill>5, and doesn't necessarily need to run to the end, but I think it could be changed to `if (fils[f] >= 5)`",
        "createdAt" : "2021-03-09T01:52:36Z",
        "updatedAt" : "2021-03-10T06:59:16Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c1790aaa717194a46de554121be00adc8adf051",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +1763,1767 @@                if (ql->count != 5)\n                    ERROR;\n                if (fills[f] == 32)\n                    ql_verify(ql, 1, 5, 5, 5);\n                quicklistRelease(ql);"
  },
  {
    "id" : "0e4b49a5-ef18-4728-955e-a664d3e4fb5a",
    "prId" : 8311,
    "prUrl" : "https://github.com/redis/redis/pull/8311#pullrequestreview-603971803",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cdb9c53d-9d19-46e7-9ef4-8f6d5e16b654",
        "parentId" : null,
        "authorId" : "f8924c9c-b0b5-4c00-9cb1-95a042d1c159",
        "body" : "if `list_sizes[list]` is odd I think this won't remove a whole node. Maybe just loop over `q1` popping from head and tail until `q1->len` size decreases.",
        "createdAt" : "2021-03-04T08:48:52Z",
        "updatedAt" : "2021-03-08T15:21:17Z",
        "lastEditedBy" : "f8924c9c-b0b5-4c00-9cb1-95a042d1c159",
        "tags" : [
        ]
      },
      {
        "id" : "7dd1112b-06d9-40f9-b99b-2f41c2964fa5",
        "parentId" : "cdb9c53d-9d19-46e7-9ef4-8f6d5e16b654",
        "authorId" : "473bc8a0-7ca7-405b-9794-3e9f874fb547",
        "body" : "I remove half elements. In most cases the nodes count > 1,  so I think it's OK.\r\nWhat I want is `ql->len == ql->compress * 2 + 1`, then delete a node. This will make old code fail.",
        "createdAt" : "2021-03-04T10:30:10Z",
        "updatedAt" : "2021-03-08T15:21:17Z",
        "lastEditedBy" : "473bc8a0-7ca7-405b-9794-3e9f874fb547",
        "tags" : [
        ]
      },
      {
        "id" : "516fa0c6-7523-4ac1-b301-9bc6578ad217",
        "parentId" : "cdb9c53d-9d19-46e7-9ef4-8f6d5e16b654",
        "authorId" : "f8924c9c-b0b5-4c00-9cb1-95a042d1c159",
        "body" : "Ok, I understand. I thought `list_sizes[list]` is the size of a node, but I misread the code.\r\nBut I think you remove either all the elements or all the elements except 1 (and not half), this is because you remove 2 elements in each iteration.",
        "createdAt" : "2021-03-04T10:57:55Z",
        "updatedAt" : "2021-03-08T15:21:17Z",
        "lastEditedBy" : "f8924c9c-b0b5-4c00-9cb1-95a042d1c159",
        "tags" : [
        ]
      },
      {
        "id" : "2632f785-a5bd-4016-a045-16c2510f5435",
        "parentId" : "cdb9c53d-9d19-46e7-9ef4-8f6d5e16b654",
        "authorId" : "f8924c9c-b0b5-4c00-9cb1-95a042d1c159",
        "body" : "Sorry my bad again. I see `ql` is populated with *2 the elements specified in `list_sizes`. Bad naming, but your code is correct.",
        "createdAt" : "2021-03-04T11:01:13Z",
        "updatedAt" : "2021-03-08T15:21:17Z",
        "lastEditedBy" : "f8924c9c-b0b5-4c00-9cb1-95a042d1c159",
        "tags" : [
        ]
      }
    ],
    "commit" : "303c6aec7a173222a5293a710afa50364dd2cc5d",
    "line" : 80,
    "diffHunk" : "@@ -1,1 +2693,2697 @@                        /* test remove node */\n                        if (step == 1) {\n                            for (int i = 0; i < list_sizes[list] / 2; i++) {\n                                quicklistPop(ql, QUICKLIST_HEAD, NULL, NULL, NULL);\n                                quicklistPop(ql, QUICKLIST_TAIL, NULL, NULL, NULL);"
  },
  {
    "id" : "592d5e6f-3d62-4088-a52d-f76954ef8e5d",
    "prId" : 2143,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e8f8ea3c-7140-42e8-a928-80d4e02be673",
        "parentId" : null,
        "authorId" : "08a6fcc8-3314-4b5f-87a6-a39d3170cfb3",
        "body" : "Why negate here? For consistency (as I think it's easier to read and done further down anyway) I would swap the if/else conditions.\n\n``` c\nif (forward) { \n        index = idx;\n        n = quicklist->head;\n} else {\n        index = (-idx) - 1;\n        n = quicklist->tail;\n}\n```\n",
        "createdAt" : "2014-11-20T07:24:26Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "08a6fcc8-3314-4b5f-87a6-a39d3170cfb3",
        "tags" : [
        ]
      },
      {
        "id" : "8012a7e9-e385-46b5-9e16-81c1d68b74ea",
        "parentId" : "e8f8ea3c-7140-42e8-a928-80d4e02be673",
        "authorId" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "body" : "I think it was inspired by https://github.com/antirez/redis/blob/unstable/src/ziplist.c#L680-L681\n\nFor readability, showing the first special case of \"negate index, subtract one\" helps the reader more quickly see something strange is happening since it's the first case.\n",
        "createdAt" : "2014-11-20T17:10:38Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "tags" : [
        ]
      }
    ],
    "commit" : "5870e22423e069452e9f858b80ac40bfc455bfe6",
    "line" : 1234,
    "diffHunk" : "@@ -1,1 +1232,1236 @@    entry->quicklist = quicklist;\n\n    if (!forward) {\n        index = (-idx) - 1;\n        n = quicklist->tail;"
  },
  {
    "id" : "87137829-61fb-4b50-8e8c-09167022bf84",
    "prId" : 2143,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0750b130-913a-4c16-b6dc-237fa3df06cf",
        "parentId" : null,
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "As _quicklistSplitNode puts it this way,\n\n###### If after==1, then the returned node has elements [OFFSET, END].\n\n###### Otherwise if after==0, then the new node has [0, OFFSET)\n\nSuppose the former quicklistNode is [0, 1, 2, 3, 4, 5] & entry->offset is 3.\nAnd it will split into two quicklistNode [0, 1, 2] [3, 4, 5]\n\n###### If after==1, then the new_node is [3, 4, 5]\n\n###### Otherwise if after==0, then the new_node is [0, 1, 2]\n\nThen,\n\n###### If after==1, we push the value at HEAD and the new_node is [value, 3, 4, 5]\n\n###### Otherwise if after==0, we push the value at TAIL and the new_node is [0, 1, 2, value]\n\nWhat's more it forget to deal with the NULL result _quicklistSplitNode returns.\n",
        "createdAt" : "2014-11-23T02:40:10Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      },
      {
        "id" : "e6ee2f90-84ac-4cb0-9ab2-304cfaf2f25b",
        "parentId" : "0750b130-913a-4c16-b6dc-237fa3df06cf",
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "I saw your trick to deal with this,\n `int orig_start = after ? offset + 1 : 0;`\n `int orig_extent = after ? -1 : offset;`\n `int new_start = after ? 0 : offset;`\n `int new_extent = after ? offset + 1 : -1;`\nwith offset + 1 :)\nBut in that way, the comment of _quicklistSplitNode is not accurate any more. :)\n",
        "createdAt" : "2014-11-23T02:59:01Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      },
      {
        "id" : "55d265f4-e899-4fc4-b8d1-e03ac122021c",
        "parentId" : "0750b130-913a-4c16-b6dc-237fa3df06cf",
        "authorId" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "body" : "> What's more it forget to deal with the NULL result _quicklistSplitNode returns.\n\nDealing with dead memory allocations here is tricky.  The Redis allocator actually just kills the entire process on OOM, so we don't _need_ extensive malloc checking (and there isn't anything sensible we can do if allocating a new node fails anyway).\n\n> But in that way, the comment of _quicklistSplitNode is not accurate any more. :)\n\nOh, good point.  I'll update it and note the changes below.\n\nThe comment does have a reinforcing statement of `The input node keeps all elements not taken by the returned node` just in case any of the examples given were actually wrong.  :)\n",
        "createdAt" : "2014-11-23T04:13:42Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "tags" : [
        ]
      }
    ],
    "commit" : "5870e22423e069452e9f858b80ac40bfc455bfe6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +930,934 @@        new_node->zl = ziplistPush(new_node->zl, value, sz,\n                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);\n        new_node->count++;\n        quicklistNodeUpdateSz(new_node);\n        __quicklistInsertNode(quicklist, node, new_node, after);"
  },
  {
    "id" : "c3b26a46-7c6e-421f-9d01-9f09b07d6f80",
    "prId" : 2143,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea290fdf-81f2-4946-b79f-8c876958f26c",
        "parentId" : null,
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "Is it okay that we just judge `else if (full && (at_tail || at_head))`?\nThis will involve some cases next `else if` owns, and make the cases more clear. :)\n",
        "createdAt" : "2014-11-23T02:44:00Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      },
      {
        "id" : "568ffcb1-38d2-4d88-ace7-2463e0da4da8",
        "parentId" : "ea290fdf-81f2-4946-b79f-8c876958f26c",
        "authorId" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "body" : "MORE DRAWINGS!\n\nLet's say maximum fill is 6.  Nodes here can't have more than 6 entries.\n\nIf we want to insert when two neighboring nodes are full, we have:\n\n``` haskell\n\n\n\n         +-------------------+      +---------------------+\n         |  Node A           |      |   Node B            |\n         |                   |      |                     |\n         |                   |      |                     |\n         |  1,2,3,4,5,6      |      |   7,8,9,10,11,12    |\n         |                   |      |                     |\n         |                   |      |                     |\n         |                   |      |                     |\n         |                   |      |                     |\n         +-------------------+      +---------------------+\n\n\n                 Requested:\n                 Insert new element before position 7\n\n\n                    So, we want to insert:\n                       - BEFORE 7\n                       - so as of 7, we are AT HEAD for NODE B\n                       - We are AT HEAD and Node B is full\n                       - Also, Node A is full\n                    Now we have: full && at_head && full_prev && !after\n\n                    So, the only way forward is to allocate an entirely\n                    new node and create a ziplist of 1 element.\n```\n\nActually, as you (i think) noted, the next \"splitting node\" case _can_ match for this case too, _but_ splitting requires extra copies and math.\n\nRight here we _know_ we can create an entirely new node, so it's quicker/easier/cleaner to just do it directly.\n\nAlso, seeing as we are already tracking the combinational state of like 25 things in that if/else tree, more explicit details everywhere make it more clear about what is happening and why (plus optional verbose debugging and comments).\n",
        "createdAt" : "2014-11-23T03:46:24Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "tags" : [
        ]
      },
      {
        "id" : "39b59619-83dc-42e9-915d-4729dbf7462f",
        "parentId" : "ea290fdf-81f2-4946-b79f-8c876958f26c",
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "Yap, you make it more clear about what is happening and why.\nThe case you gave above matches `else if (full && (at_tail || at_head))` with above 4 conditions.\nI just think a special case (nodeA [1, 2, 3, 4, 5, 6]) -> NULL\nWe append an element to nodeA, and it will split into two nodes(nodeA and an empty node).\nOf course I didn't find any bug here, I just thought the special case should be operated by the 5th branch.\n\nAnd the suggestion make no progress and mass up existing code. My bad. :)\n",
        "createdAt" : "2014-11-23T06:00:57Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5870e22423e069452e9f858b80ac40bfc455bfe6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +913,917 @@        quicklistRecompressOnly(quicklist, new_node);\n    } else if (full && ((at_tail && node->next && full_next && after) ||\n                        (at_head && node->prev && full_prev && !after))) {\n        /* If we are: full, and our prev/next is full, then:\n         *   - create new node and attach to quicklist */"
  },
  {
    "id" : "07a2e06f-aed4-4a68-a942-6001f12c0cba",
    "prId" : 2143,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "364bc2e1-903e-4245-ba9a-c3cbd860c750",
        "parentId" : null,
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "We can just skip to the head to avoid tail recursion. :)\n",
        "createdAt" : "2014-11-24T03:03:46Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      },
      {
        "id" : "9e6fe9e8-3f00-4f90-85b6-65e1fbad6262",
        "parentId" : "364bc2e1-903e-4245-ba9a-c3cbd860c750",
        "authorId" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "body" : "> We can just skip to the head\n\nHow?\n\n> to avoid tail recursion.\n\nWhy would we want to avoid?\n",
        "createdAt" : "2014-11-24T04:13:39Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "6c5b1472-9175-41fa-a762-eda1793224da",
        "tags" : [
        ]
      },
      {
        "id" : "9df150ab-9a3e-4a22-9d59-0c9b08d25c5f",
        "parentId" : "364bc2e1-903e-4245-ba9a-c3cbd860c750",
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "> How?\n\nAdd goto statement to the start of this quicklistNext function.\n\n> Why would we want to avoid?\n\nIt is just a little trick, decrease the depth of system stack, save the time system\npushes parameters on stack and allocate stack space to run this function again.\n\nThis function can at most be called one more again, this little trick doesn't save\nmuch space & time. Of course at the same time goto is harmful. \nI didn't think this special situation over. My bad. :)\n",
        "createdAt" : "2014-11-24T05:00:06Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5870e22423e069452e9f858b80ac40bfc455bfe6",
    "line" : 1175,
    "diffHunk" : "@@ -1,1 +1173,1177 @@        }\n        iter->zi = NULL;\n        return quicklistNext(iter, entry);\n    }\n}"
  },
  {
    "id" : "1d4ae7a3-edbc-42fa-b5e1-46057891ec11",
    "prId" : 2143,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e039f19-532e-4527-a4f5-ad819c8314c1",
        "parentId" : null,
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "We should limit extent within the rest of list.\nAnd the 2nd if branch (line 601) `else if (entry.offset >= 0 && extent > node->count)`\nshould add '=' to match all the cases such as, `entry.offset == 2 ;  extent == node->count` \nshould also run this branch.\nSee https://github.com/mattsta/redis/pull/5 :)\n",
        "createdAt" : "2014-11-24T13:13:07Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5870e22423e069452e9f858b80ac40bfc455bfe6",
    "line" : 958,
    "diffHunk" : "@@ -1,1 +956,960 @@ * Returns 1 if entries were deleted, 0 if nothing was deleted. */\nint quicklistDelRange(quicklist *quicklist, const long start,\n                      const long count) {\n    if (count <= 0)\n        return 0;"
  },
  {
    "id" : "9f80d6d0-3e3a-433d-a472-9c55f7a9fe33",
    "prId" : 2143,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9d7fc14-3ccb-4eeb-a93a-1bd3f0ab5013",
        "parentId" : null,
        "authorId" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "body" : "Maybe the trick _quicklistSplitNode uses can make an improvement. :)\n",
        "createdAt" : "2014-11-25T14:14:04Z",
        "updatedAt" : "2015-01-02T16:16:37Z",
        "lastEditedBy" : "e154b7c6-05e4-417a-bc5c-8b8b94d2256d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5870e22423e069452e9f858b80ac40bfc455bfe6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +549,553 @@    unsigned char *p = ziplistIndex(zl, 0);\n    while (ziplistGet(p, &value, &sz, &longval)) {\n        if (!value) {\n            /* Write the longval as a string so we can re-add it */\n            sz = ll2string(longstr, sizeof(longstr), longval);"
  },
  {
    "id" : "0db6dd36-f543-4893-b284-b549a025a45c",
    "prId" : 9113,
    "prUrl" : "https://github.com/redis/redis/pull/9113#pullrequestreview-696092275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "afb4467e-3811-4359-8b8e-97c040b50771",
        "parentId" : null,
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "It would be better to add an assert here, to determine if the old pointer has changed to determine if it has been merged.",
        "createdAt" : "2021-06-30T11:37:53Z",
        "updatedAt" : "2021-06-30T11:37:56Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      },
      {
        "id" : "7e5ca973-aaf5-409e-9d34-35e248a7a403",
        "parentId" : "afb4467e-3811-4359-8b8e-97c040b50771",
        "authorId" : "8e1240a8-b183-4992-80a9-8dfe291696e9",
        "body" : "since the larger ziplist will be used as merge target, and the old_head/tail will be deleted, so we assert old_head/tail == new_head/tail？",
        "createdAt" : "2021-06-30T11:59:42Z",
        "updatedAt" : "2021-06-30T12:10:09Z",
        "lastEditedBy" : "8e1240a8-b183-4992-80a9-8dfe291696e9",
        "tags" : [
        ]
      },
      {
        "id" : "1b45a911-082c-4752-ba85-513cbc12ab45",
        "parentId" : "afb4467e-3811-4359-8b8e-97c040b50771",
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "Sorry, I tested it and found that assert is not necessary, because ```ql_verify``` already verifies that it has been merged or not.\r\nThe code you last commit will compile error.\r\n\r\n",
        "createdAt" : "2021-06-30T12:26:27Z",
        "updatedAt" : "2021-06-30T12:28:08Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "659da4293dafd12fae89d1dae5cee9a7136ff44a",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +2018,2022 @@            char buf[4096] = {0};\n            quicklistInsertBefore(ql, &entry, buf, 4096);\n            ql_verify(ql, 4, 11, 1, 2);\n            quicklistRelease(ql);\n        }"
  },
  {
    "id" : "d0ac71a8-683a-40a1-b2c5-96e3c2a7d796",
    "prId" : 9113,
    "prUrl" : "https://github.com/redis/redis/pull/9113#pullrequestreview-696092275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4608d408-8839-46cd-9772-0230267bd234",
        "parentId" : null,
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "It would be better to add an assert here, to determine if the old pointer has changed to determine if it has been merged.",
        "createdAt" : "2021-06-30T11:37:53Z",
        "updatedAt" : "2021-06-30T11:37:56Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      },
      {
        "id" : "e72776f7-0bd0-4661-89c0-4655eee812fe",
        "parentId" : "4608d408-8839-46cd-9772-0230267bd234",
        "authorId" : "8e1240a8-b183-4992-80a9-8dfe291696e9",
        "body" : "since the larger ziplist will be used as merge target, and the old_head/tail will be deleted, so we assert old_head/tail == new_head/tail？",
        "createdAt" : "2021-06-30T11:59:42Z",
        "updatedAt" : "2021-06-30T12:10:09Z",
        "lastEditedBy" : "8e1240a8-b183-4992-80a9-8dfe291696e9",
        "tags" : [
        ]
      },
      {
        "id" : "7da63967-81a5-4dcd-ac5e-5d4ea135934c",
        "parentId" : "4608d408-8839-46cd-9772-0230267bd234",
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "Sorry, I tested it and found that assert is not necessary, because ```ql_verify``` already verifies that it has been merged or not.\r\nThe code you last commit will compile error.\r\n\r\n",
        "createdAt" : "2021-06-30T12:26:27Z",
        "updatedAt" : "2021-06-30T12:28:08Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "659da4293dafd12fae89d1dae5cee9a7136ff44a",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +2018,2022 @@            char buf[4096] = {0};\n            quicklistInsertBefore(ql, &entry, buf, 4096);\n            ql_verify(ql, 4, 11, 1, 2);\n            quicklistRelease(ql);\n        }"
  },
  {
    "id" : "af68e435-1d27-4fa7-b7e9-1d5a01a0558d",
    "prId" : 9113,
    "prUrl" : "https://github.com/redis/redis/pull/9113#pullrequestreview-696092275",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5992c65e-eab2-44cb-bbdb-41dace7c2e55",
        "parentId" : null,
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "It would be better to add an assert here, to determine if the old pointer has changed to determine if it has been merged.",
        "createdAt" : "2021-06-30T11:37:53Z",
        "updatedAt" : "2021-06-30T11:37:56Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      },
      {
        "id" : "95066a3e-6297-4e4e-bca8-84c09bf04ab6",
        "parentId" : "5992c65e-eab2-44cb-bbdb-41dace7c2e55",
        "authorId" : "8e1240a8-b183-4992-80a9-8dfe291696e9",
        "body" : "since the larger ziplist will be used as merge target, and the old_head/tail will be deleted, so we assert old_head/tail == new_head/tail？",
        "createdAt" : "2021-06-30T11:59:42Z",
        "updatedAt" : "2021-06-30T12:10:09Z",
        "lastEditedBy" : "8e1240a8-b183-4992-80a9-8dfe291696e9",
        "tags" : [
        ]
      },
      {
        "id" : "5e17a649-b6a7-462d-9835-74587a4da095",
        "parentId" : "5992c65e-eab2-44cb-bbdb-41dace7c2e55",
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "Sorry, I tested it and found that assert is not necessary, because ```ql_verify``` already verifies that it has been merged or not.\r\nThe code you last commit will compile error.\r\n\r\n",
        "createdAt" : "2021-06-30T12:26:27Z",
        "updatedAt" : "2021-06-30T12:28:08Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "659da4293dafd12fae89d1dae5cee9a7136ff44a",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +2018,2022 @@            char buf[4096] = {0};\n            quicklistInsertBefore(ql, &entry, buf, 4096);\n            ql_verify(ql, 4, 11, 1, 2);\n            quicklistRelease(ql);\n        }"
  }
]
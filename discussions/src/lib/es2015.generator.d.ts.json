[
  {
    "id" : "966af029-bcd9-4e1f-a5b0-77862d7d09b4",
    "prId" : 30790,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30790#pullrequestreview-245955857",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a0936a5-0d1f-4eed-a029-326ba734db89",
        "parentId" : null,
        "authorId" : "103d72cf-1451-4e7c-a00d-4593ecee30a0",
        "body" : "isn't `...args: [] | [TNext]` effectively `arg?: TNext`?\r\nDoes it mean that allows to not pass argument even if `TNext` is not undefined?\r\nCould a conditional type work here: `...args: undefined extends TNext ? [TNext?] : [TNext]`?",
        "createdAt" : "2019-06-05T00:43:12Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "103d72cf-1451-4e7c-a00d-4593ecee30a0",
        "tags" : [
        ]
      },
      {
        "id" : "ef4c3fed-49e7-40f4-9d04-8c93f65c196f",
        "parentId" : "5a0936a5-0d1f-4eed-a029-326ba734db89",
        "authorId" : "8f960b37-9aa5-48de-9af6-1942046dba6d",
        "body" : "The first call to `next()` starts the generator and runs it until the first `yield`. Therefore, the argument passed to this first call is completely ignored.\r\n\r\nThere's no good way to describe this statically. You'd need to know whether the code has already called `next()` to figure out what the signature should be. This is intractable, so instead this type definition describes both the first call and subsequent calls.",
        "createdAt" : "2019-06-05T07:36:22Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "8f960b37-9aa5-48de-9af6-1942046dba6d",
        "tags" : [
        ]
      },
      {
        "id" : "d199eb84-02ae-4d1e-a0c3-728094efef72",
        "parentId" : "5a0936a5-0d1f-4eed-a029-326ba734db89",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "`next(...args: [] | [TNext])` is very similar to an overload list of `next(); next(value: TNext);`, however TypeScript compares them differently. The problem is that when we compare the methods of two types, we check whether *any* overload in the source is assignable to *any* overload in the target. Unfortunately, that means `next()` in the source is assignable to `next()` in the target, even if the source and the target really shouldn't be assignable.\r\n\r\nConditional types do not work here because conditional types have even stricter assignability rules that would prevent anyone from easily subtyping `Iterator`.",
        "createdAt" : "2019-06-05T11:49:56Z",
        "updatedAt" : "2019-07-04T03:48:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f94886850b185bce3e442c40d7b638890f0de7b",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +3,7 @@interface Generator<T = unknown, TReturn = any, TNext = unknown> extends Iterator<T, TReturn, TNext> {\n    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.\n    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;\n    return(value: TReturn): IteratorResult<T, TReturn>;\n    throw(e: any): IteratorResult<T, TReturn>;"
  }
]
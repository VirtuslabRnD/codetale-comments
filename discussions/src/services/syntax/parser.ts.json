[
  {
    "id" : "745bd6ac-a1ce-4b08-915c-f0a651884690",
    "prId" : 1390,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88ccd42e-c3b9-4f75-bb3c-f6234cf7326f",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "the\n",
        "createdAt" : "2014-12-06T01:51:55Z",
        "updatedAt" : "2014-12-06T09:30:53Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "b25d0a6fbc80176041bde7d9eadbc1d43b357735",
    "line" : 389,
    "diffHunk" : "@@ -1,1 +4642,4646 @@            }\n\n            // It was valid.  Let teh source know we're consuming this node, and pass to the list\n            // parser.\n            return consumeNode(node);"
  },
  {
    "id" : "5ac5f326-0f8a-462b-92c3-bae468ef335e",
    "prId" : 1385,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0b2d7faf-728f-4c9a-b7a8-d13f1b4443fe",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "I would love to have a comment just say this is to fix up the parent\n",
        "createdAt" : "2014-12-06T01:19:17Z",
        "updatedAt" : "2014-12-06T01:19:17Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "c6ee1a01e3659c03ec01a986abd219fadeac7646",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +303,307 @@        function parseSyntaxTreeWorker(isDeclaration: boolean): SyntaxTree {\n            var sourceUnit = parseSourceUnit();\n            setupParentsForSyntaxNodeOrToken(sourceUnit);\n\n            var allDiagnostics = source.diagnostics().concat(diagnostics);"
  },
  {
    "id" : "9f765bae-51e5-45bd-aa12-2a8b2e0b3aa1",
    "prId" : 1246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84554114-cdeb-4f71-bcb4-5c1ccda2a4a0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "\"an error\"\n",
        "createdAt" : "2014-11-22T21:11:16Z",
        "updatedAt" : "2014-11-22T21:22:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "80366711d01d023baa8094a355fd7056da5d8027",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +2108,2112 @@            //      throw [no LineTerminator here]Expression[In, ?Yield];\n\n            // Because of automatic semicolon insertion, we need to report error if this \n            // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'\n            // directly as that might consume an expression on the following line.  "
  },
  {
    "id" : "9e7ac545-4193-4a26-a440-2c21a6a73df0",
    "prId" : 1246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81e5e52d-5572-4e7b-a7e5-f8bc8781b15e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Unfold this into multiple lines\n",
        "createdAt" : "2014-11-22T21:11:55Z",
        "updatedAt" : "2014-11-22T21:22:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "80366711d01d023baa8094a355fd7056da5d8027",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +2113,2117 @@            // We just return 'undefined' in that case.  The actual error will be reported in the\n            // grammar walker.\n            return canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false) ? undefined : allowInAnd(parseExpression);\n        }\n"
  },
  {
    "id" : "934d7d71-0ecf-44ee-b07b-019082adc117",
    "prId" : 1246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b1a5f47-fd4f-4827-8941-c3e3642cc9e0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "It's weird that you have the first parameter on the same line as the start of the expression, but not these.\n\nConsider putting each param on a different line, possibly indented to where parseNodeData is.\n",
        "createdAt" : "2014-11-22T21:13:21Z",
        "updatedAt" : "2014-11-22T21:22:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "80366711d01d023baa8094a355fd7056da5d8027",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +2101,2105 @@        function parseThrowStatement(throwKeyword: ISyntaxToken): ThrowStatementSyntax {\n            return new ThrowStatementSyntax(parseNodeData,\n                consumeToken(throwKeyword), tryParseThrowStatementExpression(), eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));\n        }\n"
  },
  {
    "id" : "33326deb-97ea-4e9f-931b-95fe1c7fa281",
    "prId" : 1246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b09bf200-0d86-4c5e-8490-36e59b86d415",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Again, this is odd to look at.\n",
        "createdAt" : "2014-11-22T21:14:03Z",
        "updatedAt" : "2014-11-22T21:22:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "80366711d01d023baa8094a355fd7056da5d8027",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +2118,2122 @@        function parseReturnStatement(returnKeyword: ISyntaxToken): ReturnStatementSyntax {\n            return new ReturnStatementSyntax(parseNodeData,\n                consumeToken(returnKeyword), tryParseReturnStatementExpression(), eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));\n        }\n"
  },
  {
    "id" : "e164cfb4-c0a9-4e98-9110-2515f3bffd81",
    "prId" : 1246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3a6ede6-6bd4-4c8e-840e-d2ff161e830e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Multiple lines.\n",
        "createdAt" : "2014-11-22T21:14:39Z",
        "updatedAt" : "2014-11-22T21:22:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "80366711d01d023baa8094a355fd7056da5d8027",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +2125,2129 @@            //      return [no LineTerminator here]Expression[In, ?Yield];\n\n            return canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false) ? undefined : allowInAnd(parseExpression);\n        }\n"
  },
  {
    "id" : "a42f7c14-4023-4b51-9104-d075a97790b8",
    "prId" : 1129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4ec5b3b-319d-4cc7-8804-c932561c9fa1",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "asteriskToken\n",
        "createdAt" : "2014-11-12T06:12:00Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "179025b6-4b7f-4e16-be9b-e11f6f10aa52",
        "parentId" : "c4ec5b3b-319d-4cc7-8804-c932561c9fa1",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Oh dear.  I clearly read too much Asterix and Obelix as a kid.\n",
        "createdAt" : "2014-11-12T07:12:20Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7890d4ddbde4d7fd3d2e1be0fddaaca727128f7",
    "line" : 457,
    "diffHunk" : "@@ -1,1 +1299,1303 @@                // if we have a call signature.  If so, then this is a member function, otherwise\n                // it's a member variable.\n                if (asterixToken || isCallSignature(/*peekIndex:*/ 0)) {\n                    return parseMemberFunctionDeclaration(modifiers, asterixToken, propertyName);\n                }"
  },
  {
    "id" : "14ff3fbe-2cc3-4fb9-a946-74d12d93eba5",
    "prId" : 1129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00079de4-4c73-47a6-869b-f7ad83c442ed",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What on earth is \"Lexical goal InputElementRegExp\"?\n",
        "createdAt" : "2014-11-12T06:17:16Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a79d2ab6-ae08-4b95-aeea-6084f7b646e7",
        "parentId" : "00079de4-4c73-47a6-869b-f7ad83c442ed",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "It's their way of saying \"the tokens you should parse out when you're in an expression context\" (which thus contain regexps).  As opposed to the tokens you should parse when you have  \"a / b\".  Here, the lexical goal is the default InputElement, which only contains DivElements (like `/`  and  `/=`), and not regexps. \n",
        "createdAt" : "2014-11-12T07:14:18Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "ebda27ab-b643-4a61-99f1-8a94d65ab68d",
        "parentId" : "00079de4-4c73-47a6-869b-f7ad83c442ed",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "There are different parsing contexts where you have different \"goals\" for what your lexer produces; in this context, you try to look for a RegExp instead of a slash token when you lex. There's a similar goal for template expressions.\n\nhttps://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-lexical-grammar\n\n> The source text of an ECMAScript script is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of code units as the next input element.\n> \n> There are several situations where the identification of lexical input elements is sensitive to the syntactic grammar context that is consuming the input elements. This requires multiple goal symbols for the lexical grammar. The **_InputElementDiv**_ goal symbol is the default goal symbol and is used in those syntactic grammar contexts where a leading division (/) or division-assignment (/=) operator is permitted. The **_InputElementRegExp**_ goal symbol is used in all syntactic grammar contexts where a **_RegularExpressionLiteral**_ is permitted. The **_InputElementTemplateTail**_ goal is used in syntactic grammar contexts where a **_TemplateLiteral**_ logically continues after a substitution element.\n\nIn our parser, we just rescan. I think it's partially because it helps with error handling capabilities, but it's also just cheap because we only rescan with single-character tokens anyhow.\n",
        "createdAt" : "2014-11-12T07:19:35Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7890d4ddbde4d7fd3d2e1be0fddaaca727128f7",
    "line" : 834,
    "diffHunk" : "@@ -1,1 +2492,2496 @@        function parseYieldExpression(yieldKeyword: ISyntaxToken): YieldExpressionSyntax {\n            // YieldExpression[In] :\n            //      yield\n            //      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\n            //      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]"
  },
  {
    "id" : "a2acb7f3-d120-42bf-88d9-8bd504f8ca07",
    "prId" : 1129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12d66e04-0749-4eae-9730-4ae1fd0b7b54",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Have you figured out why +GeneratorParameter means Yield should be false?\n",
        "createdAt" : "2014-11-12T06:32:03Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "9f692a6a-2773-4fde-9035-8c2315a453cf",
        "parentId" : "12d66e04-0749-4eae-9730-4ae1fd0b7b54",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Yes, though it took me a while to walk through this all (it's unpleasant that there's no grammar we can just look at at this point).  \n\nHere's the chain of productions through which we can see the 'GeneratorParameter' being passed down:\n\n```\nGeneratorDeclaration[Yield, Default] :\n  function * BindingIdentifier[?Yield] ( FormalParameters[Yield,GeneratorParameter] ) { GeneratorBody[Yield] }\n  ... elided ...\n\n// FormalParameters[yield,generateparameter] leads to:\nFormalParameter[Yield,GeneratorParameter] :\n  BindingElement[?Yield, ?GeneratorParameter]\n\nBindingElement[Yield, GeneratorParameter ] : See 13.2.3\n  ... elided ...\n  [+GeneratorParameter] BindingPattern[?Yield,GeneratorParameter] Initializer[In]opt\n\nBindingPattern[Yield,GeneratorParameter] :\n  ObjectBindingPattern[?Yield,?GeneratorParameter]\n  ... elided ...\n\nObjectBindingPattern[Yield,GeneratorParameter] :\n  ... elided ...\n  { BindingPropertyList[?Yield,?GeneratorParameter] }\n\nBindingPropertyList[Yield,GeneratorParameter] :\n  BindingProperty[?Yield, ?GeneratorParameter]\n  ... elided ...\n\nBindingProperty[Yield,GeneratorParameter] :\n  ... elided ...\n  PropertyName[?Yield, ?GeneratorParameter] : BindingElement[?Yield, ?GeneratorParameter]\n\nPropertyName[Yield,GeneratorParameter] :\n   LiteralPropertyName\n   [+GeneratorParameter] ComputedPropertyName\n   [~GeneratorParameter] ComputedPropertyName[?Yield]\n```\n\nSo, if you have:\n\n```\nfunction * foo({ [x] : ..., [y] : ... }) {\n}\n```\n\nThen 'generator parameter' is used ot indicate you're creating the parameters for hte generator.  And eventually that flag bubbles down to when you're doing the computed properties.  And, within those computed properties, yield is apparently disabled.  Meaning you can't use a yield expression inside a computed property name (which is not a terrible thing IMO).\n\n(Hopefully i'm reading that right).\n\nNow, oddly enough, outside of a generator parameter, i think it would be legal to use 'yield'.  so if you had:\n\n```\nfunction * f() {\n   var v = { [yield 1] : 1 }\n}\n```\n\nThen that would be fine.  'generator-parameter' is the context flag that enables us to flag this down.\n",
        "createdAt" : "2014-11-12T07:28:55Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b3ab010b-7e8c-4efc-98fd-f50751042a79",
        "parentId" : "12d66e04-0749-4eae-9730-4ae1fd0b7b54",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I see. And it looks like this rule also applies to initializers (both the parameter initializer and initializers in the binding pattern). But again, only inside a generator parameter. In the binding patterns and initializers of normal function parameters, yield is allowed.\n",
        "createdAt" : "2014-11-12T19:07:33Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "293be3ae-ca26-4187-93f2-030aa10b61f5",
        "parentId" : "12d66e04-0749-4eae-9730-4ae1fd0b7b54",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "There's a subtle distinction: \"In the binding patterns and initializers of normal function parameters, yield is allowed.\"\n\nIt's not that 'yield is allowed'.  It's that 'yield is inherited from the outer context'.\n",
        "createdAt" : "2014-11-12T21:57:33Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "c276442e-2fde-4ad9-982c-bb7ac7af013f",
        "parentId" : "12d66e04-0749-4eae-9730-4ae1fd0b7b54",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah, sorry, I meant that. But it looks from the spec as if the following is not allowed. Am I correct?:\n\nYield in generator parameter in another generator's body:\n\n``` js\nfunction* f() {\n    function* g({ [yield 0]: x }) {\n    }\n}\n```\n",
        "createdAt" : "2014-11-12T22:08:59Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7890d4ddbde4d7fd3d2e1be0fddaaca727128f7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +190,194 @@        // and we should explicitly unset the 'yield' context flag before calling into the Initializer.\n        // production.  Conversely, if the GeneratorParameter context flag is not set, then we \n        // should leave the 'yield' context flag alone.\n        //\n        // Getting this all correct is tricky and requires careful reading of the grammar to "
  },
  {
    "id" : "487a5657-e249-44b1-8b6e-afa4dff08e7f",
    "prId" : 1129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fae3e68-4f61-4b71-8e9a-4cde8ed526ec",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "You can safely shadow `allowYield`.\n",
        "createdAt" : "2014-11-12T07:44:54Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "0f19e7d2-5a60-4caa-ad0b-618d91945e13",
        "parentId" : "5fae3e68-4f61-4b71-8e9a-4cde8ed526ec",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I can, but i prefer not to. Too much chance for confusion IMO.\n",
        "createdAt" : "2014-11-12T08:39:31Z",
        "updatedAt" : "2014-11-13T03:09:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7890d4ddbde4d7fd3d2e1be0fddaaca727128f7",
    "line" : 1105,
    "diffHunk" : "@@ -1,1 +3593,3597 @@                eatToken(SyntaxKind.CloseBraceToken));\n        }\n\n        function parseFunctionBlock(_allowYield: boolean): BlockSyntax {\n            // If we got an errant => then we want to parse what's coming up without requiring an"
  },
  {
    "id" : "15d4b1fd-b29c-4185-93fc-85c3351b6507",
    "prId" : 997,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5918e14-7c87-4c00-a245-52f3ec6e207b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "~~Is it actually? In the other parser we have that tristate thing going on. Is it necessary here?~~\n\nNever mind, I realized this is only for arrow types.\n",
        "createdAt" : "2014-10-30T09:38:51Z",
        "updatedAt" : "2014-10-30T19:38:22Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "64086133e993f34d2b2930d7b7ff5aa746df968f",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +3698,3702 @@            }\n\n            // Anything else is a parenthesized type.\n            return false;\n        }"
  }
]
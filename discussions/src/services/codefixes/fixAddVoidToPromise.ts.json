[
  {
    "id" : "b398f98b-1f7a-40ae-a8ff-e1836697e5d2",
    "prId" : 40558,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/40558#pullrequestreview-488245899",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e611334-1838-4ad0-b620-62fd67c210c6",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Wasn't this checked when the diagnostic was produced?",
        "createdAt" : "2020-09-15T00:14:56Z",
        "updatedAt" : "2020-09-15T00:17:21Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "1114b575-99fa-4753-a9af-bd91340bd5f7",
        "parentId" : "4e611334-1838-4ad0-b620-62fd67c210c6",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Yes, but I'd rather recheck then blindly assert. The the place where we produce this error is so distant from this location, it would be easy for someone to change something and break this. Most of the checks are fairly trivial though.",
        "createdAt" : "2020-09-15T00:41:20Z",
        "updatedAt" : "2020-09-15T00:41:20Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "54681bd197359fae11f240b98d3f52d5603acbd4",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +22,26 @@    function makeChange(changes: textChanges.ChangeTracker, sourceFile: SourceFile, span: TextSpan, program: Program, seen?: Set<ParameterDeclaration>) {\n        const node = getTokenAtPosition(sourceFile, span.start);\n        if (!isIdentifier(node) || !isCallExpression(node.parent) || node.parent.expression !== node || node.parent.arguments.length !== 0) return;\n\n        const checker = program.getTypeChecker();"
  },
  {
    "id" : "3dca2024-a575-4734-8601-ba88333112e0",
    "prId" : 40558,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/40558#pullrequestreview-488245851",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e831458-0b62-462b-8586-a52818e3269c",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Wasn't this checked when the diagnostic was produced?",
        "createdAt" : "2020-09-15T00:15:00Z",
        "updatedAt" : "2020-09-15T00:17:21Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "a14804c4-b10d-474d-8a23-edb6008acae5",
        "parentId" : "7e831458-0b62-462b-8586-a52818e3269c",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Not quite. This error can be produced from the following case, but we can't apply a quick fix to it:\r\n\r\n```ts\r\ninterface Obj {\r\n  m(): Promise<number>;\r\n}\r\nconst obj: Obj = {\r\n m: () => new Promise(resolve => resolve());\r\n}\r\n```\r\nWe don't check the `type` of the promise in the checker, just the arity of the call to `resolve`. Adding `void` to `new Promise` would result in an error, and I'm not quick-fixing the definition of `m` on the `Obj` interface, as it could be code you don't own (such as from an external library), or could have repercussions throughout the codebase as you introduce a `void` that wasn't previously there. Instead, I check whether the  promise is untyped (`unknown` in TS, `any` in JS).",
        "createdAt" : "2020-09-15T00:41:11Z",
        "updatedAt" : "2020-09-15T00:41:11Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "54681bd197359fae11f240b98d3f52d5603acbd4",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +47,51 @@        }\n        else {\n            // make sure the Promise is type is untyped (i.e., `unknown`)\n            const signature = checker.getResolvedSignature(node.parent);\n            const parameter = signature?.parameters[0];"
  }
]
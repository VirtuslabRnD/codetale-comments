[
  {
    "id" : "dac5ce1a-35e2-4552-81e6-90e893ca7310",
    "prId" : 40524,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/40524#pullrequestreview-490266349",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cf02efd-5990-4731-bf49-af1b930a24db",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "```suggestion\r\n        while ((isPropertyAccessExpression(chain) || isElementAccessExpression(chain) && chain.kind === subchain.kind) {\r\n```",
        "createdAt" : "2020-09-16T16:24:54Z",
        "updatedAt" : "2020-09-22T18:21:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e6c238d3-8db8-45a7-9bee-da150b2c2a5f",
        "parentId" : "4cf02efd-5990-4731-bf49-af1b930a24db",
        "authorId" : "abcb489c-ecaa-43d7-a864-2305b3feb38c",
        "body" : "@DanielRosenwasser I used this condition in order to avoid typecasting, because for proposed change need to cast `subchain` to\r\n\r\n```ts\r\n(subchain as PropertyAccessExpression | ElementAccessExpression).expression;\r\n```",
        "createdAt" : "2020-09-17T06:03:42Z",
        "updatedAt" : "2020-09-22T18:21:52Z",
        "lastEditedBy" : "abcb489c-ecaa-43d7-a864-2305b3feb38c",
        "tags" : [
        ]
      }
    ],
    "commit" : "4bcf44585084e04a40f2efb07a07ac412399db59",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +178,182 @@        // check that the chains match at each access. Call chains in subchain are not valid.\n        while ((isPropertyAccessExpression(chain) && isPropertyAccessExpression(subchain)) ||\n               (isElementAccessExpression(chain) && isElementAccessExpression(subchain))) {\n            if (getTextOfChainNode(chain) !== getTextOfChainNode(subchain)) return false;\n            chain = chain.expression;"
  },
  {
    "id" : "95b9c029-afcd-4068-947e-407e1f1248fe",
    "prId" : 39135,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39135#pullrequestreview-447595609",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80ad1aa6-efdd-4718-a71c-b5d228f1eb19",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "You should also `node = skipParentheses(node)` at the top here",
        "createdAt" : "2020-07-02T23:33:31Z",
        "updatedAt" : "2020-07-13T21:22:23Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "56e7738b-87e0-4084-a6bc-a2a5180c088d",
        "parentId" : "80ad1aa6-efdd-4718-a71c-b5d228f1eb19",
        "authorId" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "body" : "What would be an example we care to test, something like `a && (a).b`?",
        "createdAt" : "2020-07-07T21:13:45Z",
        "updatedAt" : "2020-07-13T21:22:23Z",
        "lastEditedBy" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "tags" : [
        ]
      },
      {
        "id" : "d6beecea-5421-456e-ba56-090fda20d4d0",
        "parentId" : "80ad1aa6-efdd-4718-a71c-b5d228f1eb19",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Yep, `foo && (foo.bar === 1)` seems more realistic since the precedence between different binary operators can be hard to remember, but I think if you put `skipParentheses` in the right places, you can trivially handle `foo && (((foo).bar) === 1)` üòÅ ",
        "createdAt" : "2020-07-13T20:56:48Z",
        "updatedAt" : "2020-07-13T21:22:23Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "01854bbc1a3c0ba6f56da8e5774b5b15b7c0b7ff",
    "line" : 236,
    "diffHunk" : "@@ -1,1 +234,238 @@        // the rightmost member of the && chain should be the leftmost child of that expression.\n        node = skipParentheses(node);\n        if (isBinaryExpression(node)) {\n            return getFinalExpressionInChain(node.left);\n        }"
  }
]
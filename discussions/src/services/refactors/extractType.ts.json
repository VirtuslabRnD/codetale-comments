[
  {
    "id" : "b4f703de-8e40-45b8-b8cf-9e45b3cf1780",
    "prId" : 36688,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36688#pullrequestreview-361523725",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12fca4c2-2c2d-4a38-951d-f5e924f76f8f",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why ignore newlines here? Is that for backward compatibility?",
        "createdAt" : "2020-02-19T22:39:07Z",
        "updatedAt" : "2020-03-16T18:52:35Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "77009601-6b7a-4be6-9bec-195c616fdd4f",
        "parentId" : "12fca4c2-2c2d-4a38-951d-f5e924f76f8f",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Consider\r\n\r\n```ts\r\nfunction doSomething(options: { force?: boolean, logger?: Logger }) {\r\n  // ...\r\n}\r\n```\r\n\r\nThat looks pretty typical for a parameter type annotation, but once you extract it, you probably prefer it to wrap into one property per line. It’s kind of debatable, and would maybe benefit from additional nuance in the future now that we can control it, but this kept the existing behavior, and the existing behavior didn’t seem obviously bad.",
        "createdAt" : "2020-02-19T23:53:39Z",
        "updatedAt" : "2020-03-16T18:52:35Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "6daa27e52a5ef8fd0a76f49cffd3b76e9a5caf48",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +160,164 @@            selection\n        );\n        changes.insertNodeBefore(file, firstStatement, ignoreSourceNewlines(newTypeNode), /* blankLineBetween */ true);\n        changes.replaceNode(file, selection, createTypeReferenceNode(name, typeParameters.map(id => createTypeReferenceNode(id.name, /* typeArguments */ undefined))));\n    }"
  },
  {
    "id" : "d743b3cb-0b55-43be-958e-c2fd678042ce",
    "prId" : 30562,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30562#pullrequestreview-220758638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c93f1a2-65b0-4ed5-9cfb-7cd226acaf7f",
        "parentId" : null,
        "authorId" : "7c69145d-f707-4b28-988d-984954c5c07d",
        "body" : "why is it not necessary to handle the case where `node.typeName` is not an identifier but is a qualified name?",
        "createdAt" : "2019-03-28T23:10:08Z",
        "updatedAt" : "2019-05-07T08:40:25Z",
        "lastEditedBy" : "7c69145d-f707-4b28-988d-984954c5c07d",
        "tags" : [
        ]
      },
      {
        "id" : "efd55b58-1dd9-439c-8861-8e1480bb3f24",
        "parentId" : "8c93f1a2-65b0-4ed5-9cfb-7cd226acaf7f",
        "authorId" : "b34d84f4-89ab-4dd2-92e3-8e7d670020b5",
        "body" : "Could TypeParameter be a `QualifiedName`?\r\nIn `checkAndCollectionTypeArguments` we only iter the TypeParameter whitch defined in the statement",
        "createdAt" : "2019-03-29T01:26:18Z",
        "updatedAt" : "2019-05-07T08:40:25Z",
        "lastEditedBy" : "b34d84f4-89ab-4dd2-92e3-8e7d670020b5",
        "tags" : [
        ]
      },
      {
        "id" : "dc9230a9-9d10-48c0-8faf-01e98516be83",
        "parentId" : "8c93f1a2-65b0-4ed5-9cfb-7cd226acaf7f",
        "authorId" : "7c69145d-f707-4b28-988d-984954c5c07d",
        "body" : "i think in the common cases where you have to collect the type, the type name is an identifier and not a qualified name. but i'm really not sure, so that's why i asked.\r\nupdate: came up with an example of a qualified name for the type query check. i think there could be unusual cases where this check can fail.",
        "createdAt" : "2019-03-29T21:09:04Z",
        "updatedAt" : "2019-05-07T08:40:25Z",
        "lastEditedBy" : "7c69145d-f707-4b28-988d-984954c5c07d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bff56b725e26ef37cded48e27e31e222a14b307e",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@        function visitor(node: Node): true | undefined {\n            if (isTypeReferenceNode(node)) {\n                if (isIdentifier(node.typeName)) {\n                    const symbol = checker.resolveName(node.typeName.text, node.typeName, SymbolFlags.TypeParameter, /* excludeGlobals */ true);\n                    if (symbol) {"
  },
  {
    "id" : "30db2667-1d19-4d76-958f-b148425929d4",
    "prId" : 30562,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30562#pullrequestreview-234391733",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f1ea6f6d-d140-4656-82a3-dde0ec21b079",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "if the selection contains only a syntactically-correct infer type, then I think this code should (1) not set `hasError` but also (2) not push any results into `result`. What happens if you get an empty result list?\r\n\r\nTest cases 31-33 show that this works, but I don't understand why.",
        "createdAt" : "2019-05-06T23:16:21Z",
        "updatedAt" : "2019-05-07T08:40:25Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "d69e9cb1-26b4-4ae0-b1df-1ec3b21f9dfe",
        "parentId" : "f1ea6f6d-d140-4656-82a3-dde0ec21b079",
        "authorId" : "b34d84f4-89ab-4dd2-92e3-8e7d670020b5",
        "body" : "That caused: \r\n1. find the selections by largest and topmost type node\r\n2. Infer type node contains only a `TypeParameterDeclaration`\r\n\r\nin the following case: \r\n```ts\r\ntype A = /*a*/Promise/*b*/\r\n```\r\nThe selection is the `TypeReference` which have the same range as the` Identifier``Promise`.\r\n\r\nIn cases 31 and 32 were set the `hasError ` flag. \r\nAnd the case33:\r\n```ts\r\ntype Item<T> = T extends (infer /*a*/P/*b*/)[] ? P : never\r\n```\r\nThe selection is the `TypeParameter`(maybe, or an `Identifier`), that is a declaration rather a `TypeNode`. and we are already escaped before collectTypeParameters.\r\n",
        "createdAt" : "2019-05-07T08:57:38Z",
        "updatedAt" : "2019-05-07T08:59:11Z",
        "lastEditedBy" : "b34d84f4-89ab-4dd2-92e3-8e7d670020b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "bff56b725e26ef37cded48e27e31e222a14b307e",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +80,84 @@            }\n            else if (isInferTypeNode(node)) {\n                const conditionalTypeNode = findAncestor(node, n => isConditionalTypeNode(n) && rangeContainsSkipTrivia(n.extendsType, node, file));\n                if (!conditionalTypeNode || !rangeContainsSkipTrivia(selection, conditionalTypeNode, file)) {\n                    return true;"
  },
  {
    "id" : "1cffa6a4-0f97-46b4-b465-6cb7e998822e",
    "prId" : 30562,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30562#pullrequestreview-234240257",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a594fc5d-cf58-4527-b428-84d6b10b1b72",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "you should skip `this` elsewhere too:\r\n\r\n```ts\r\nclass C {\r\n    m<T>(): /*a*/T | this | number/*b*/ {\r\n        return {} as any\r\n    }\r\n}\r\n```\r\n\r\ncurrently produces `type NewType<T> = T | this | number`",
        "createdAt" : "2019-05-06T23:20:42Z",
        "updatedAt" : "2019-05-07T08:40:25Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "bff56b725e26ef37cded48e27e31e222a14b307e",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +99,103 @@                }\n                else {\n                    if (isThisIdentifier(node.exprName.left) && !rangeContainsSkipTrivia(selection, node.parent, file)) {\n                        return true;\n                    }"
  }
]
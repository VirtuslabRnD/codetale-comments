[
  {
    "id" : "4343b980-19d6-4c28-994a-905940378528",
    "prId" : 42770,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42770#pullrequestreview-591564326",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e520066-c6d0-4912-881d-110bdbc6f27d",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Would it be interesting to repeat this check as long as `charCodeAt(end)` is a semicolon?",
        "createdAt" : "2021-02-16T18:33:32Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "8b9a18ee-a61b-4145-be3f-20dfba4e8ce6",
        "parentId" : "7e520066-c6d0-4912-881d-110bdbc6f27d",
        "authorId" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "body" : "That would be undesirable. This refactoring behaves differently when multiple statements are selected.\r\n\r\n`var x = 1;`  gets the initializer extracted.\r\n\r\n`var x = 1;;` would be treated the same way as `var x = 1; var y = 2` and would be extracted to a new function.\r\n\r\nThe extra semicolon is obviously a mistake, and while we do currently do the second extraction today if it is selected, we shouldn't otherwise expand the selection to include it.",
        "createdAt" : "2021-02-16T19:42:30Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a630483235eee0ff55e74c1dabf1b59a5bb820e",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +618,622 @@        const start = startNode.getStart(sourceFile);\n        let end = endNode.getEnd();\n        if (sourceFile.text.charCodeAt(end) === CharacterCodes.semicolon) {\n            end++;\n        }"
  },
  {
    "id" : "482aa979-bacb-463f-8c2e-e4b525cfb08b",
    "prId" : 42770,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42770#pullrequestreview-592633585",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f953492d-8607-4eee-a4a0-fc5f2553bbb3",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "I'm not sure I understand why tokens are involved.  Couldn't this just be `invoked && charCodeAt(span.end) === CharacterCodes.semicolon`?",
        "createdAt" : "2021-02-16T18:41:09Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "11615fae-ed06-4f76-811d-3dc0575a5a08",
        "parentId" : "f953492d-8607-4eee-a4a0-fc5f2553bbb3",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Oh, I guess you might need the tokens to rule out the case where you're in the header of a for loop?  But it doesn't look like `getAdjustedSpanFromNodes` does that?",
        "createdAt" : "2021-02-16T18:51:42Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "9010f36d-c60a-4125-bfe7-38c2849c2af8",
        "parentId" : "f953492d-8607-4eee-a4a0-fc5f2553bbb3",
        "authorId" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "body" : "`getAdjustedSpan` *mostly* adjusts the span we search inside of to start at the beginning of `startToken` and end at the end of `endToken`.\r\n\r\nWe do this because `getParentNodeInSpan` finds the largest nodes contained within the selected span, containing `startToken` and `endToken`, which may be the same parent node.\r\n\r\n`getAdjustedSpan` basically snaps the span to the tokens since the aforementioned search would fail if say the end of the span terminated halfway through `endToken`, so no parent of `endToken` would ever be in the span.",
        "createdAt" : "2021-02-16T19:34:05Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "tags" : [
        ]
      },
      {
        "id" : "1f0cd78e-bf9a-4552-9c3f-49a6e881480a",
        "parentId" : "f953492d-8607-4eee-a4a0-fc5f2553bbb3",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Is there a test case covering the `for` case?  I would find that reassuring.",
        "createdAt" : "2021-02-16T22:53:37Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "927f833a-42b8-4f80-93f2-ee6a9ad3bb3f",
        "parentId" : "f953492d-8607-4eee-a4a0-fc5f2553bbb3",
        "authorId" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "body" : "I added a couple of for statement unit tests so it's apparent what works there, though this PR does not change the refactoring behavior there.",
        "createdAt" : "2021-02-17T20:55:01Z",
        "updatedAt" : "2021-02-17T20:55:01Z",
        "lastEditedBy" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "tags" : [
        ]
      },
      {
        "id" : "21b30495-10ef-4261-8172-e487497fa75b",
        "parentId" : "f953492d-8607-4eee-a4a0-fc5f2553bbb3",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Thanks!  I appreciate it.",
        "createdAt" : "2021-02-17T21:14:26Z",
        "updatedAt" : "2021-02-17T21:14:26Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a630483235eee0ff55e74c1dabf1b59a5bb820e",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +281,285 @@        refactoring actions at the span location. As they may not know the exact range that will trigger a refactoring, we expand the\n        searched span to cover a real node range making it more likely that something useful will show up. */\n        const adjustedSpan = startToken && endToken && invoked ? getAdjustedSpanFromNodes(startToken, endToken, sourceFile) : span;\n\n        // Walk up starting from the the start position until we find a non-SourceFile node that subsumes the selected span."
  },
  {
    "id" : "a2de916e-1845-49e9-b18e-26d741d22a2c",
    "prId" : 42770,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42770#pullrequestreview-591582329",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f09e052-666b-4ad1-80bf-c197182dbfd0",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Why did this move?  Was it an optimization or did it somehow affect correctness?",
        "createdAt" : "2021-02-16T18:42:46Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "8aa92147-376a-4160-bbff-da4c673b31b6",
        "parentId" : "9f09e052-666b-4ad1-80bf-c197182dbfd0",
        "authorId" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "body" : "When a JSDoc comment is selected `findTokenOnLeftOfPosition` gives the `}` token in the JSDoc type tag so snapping to the endToken doesn't match the end of the JSDoc comment. However, there is no meaningful extraction for a JSDoc comment so this would fail with a generic `cannotExtractRange` message. Since we only check the `start` node for this error anyway I just moved it up so we continue to offer the more meaningful error message.",
        "createdAt" : "2021-02-16T20:07:03Z",
        "updatedAt" : "2021-02-17T20:21:01Z",
        "lastEditedBy" : "bb7feee5-7089-4110-a20e-a163a6be1501",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a630483235eee0ff55e74c1dabf1b59a5bb820e",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +301,305 @@        }\n\n        if (isJSDoc(start)) {\n            return { errors: [createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractJSDoc)] };\n        }"
  },
  {
    "id" : "f4f6b91e-854d-4705-8281-a7a5e7467ee3",
    "prId" : 37871,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/37871#pullrequestreview-435263262",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bacd6ab8-fb29-45e9-a921-825611118d3e",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "What does this do?  I thought all refactoring errors were strings.",
        "createdAt" : "2020-06-22T21:07:50Z",
        "updatedAt" : "2020-06-22T21:09:44Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf992adf4bc5ee923a93b51bcaf230ec713f2086",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +135,139 @@        return infos.length ? infos : emptyArray;\n\n        function getStringError(errors: readonly Diagnostic[]) {\n            let error = errors[0].messageText;\n            if (typeof error !== \"string\") {"
  },
  {
    "id" : "2468bd5c-91f9-41b9-bc02-ddb6afb26f2e",
    "prId" : 21370,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/21370#pullrequestreview-91046877",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e13be133-b506-4045-8f81-4e1505132237",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "This assert is incorrect.  There are other ways this can arise.  I'm still trying to determine if a sensible assert is possible.  If not, deleting it should suffice - the only downside of returning early is not being able to extract a range.",
        "createdAt" : "2018-01-24T01:55:36Z",
        "updatedAt" : "2018-01-24T01:55:36Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "7d60ca47-7996-474d-a2f6-2c85b0f86a6f",
        "parentId" : "e13be133-b506-4045-8f81-4e1505132237",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "It looks like it can happen with any non-statement child of a block-like node (e.g. the lbrace in a block).  I'll just remove the assert.",
        "createdAt" : "2018-01-24T02:08:40Z",
        "updatedAt" : "2018-01-24T02:08:40Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f3b06a3cd5ca8c394828fee9c0c96f85f54f903",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +243,247 @@                // Consider: We could support ranges like [|case 1:|] by refining them to just\n                // the expression.\n                Debug.assert(isCaseClause(start.parent) && span.start < start.parent.expression.end);\n                return { errors: [createFileDiagnostic(sourceFile, span.start, length, Messages.cannotExtractRange)] };\n            }"
  },
  {
    "id" : "9c19a617-9056-41fe-9e80-3c9e223d29eb",
    "prId" : 19141,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/19141#pullrequestreview-69068260",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38e51b35-f129-4580-9d0a-631b9e85b6aa",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "This is the actual change.  Each other diff just shows a single new linebreak.",
        "createdAt" : "2017-10-12T21:21:15Z",
        "updatedAt" : "2017-10-12T21:21:15Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "2ea4cfe23bf0648c099a79a8a1d976febb2e2610",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +786,790 @@        }\n        else {\n            changeTracker.insertNodeBefore(context.file, scope.getLastToken(), newFunction, {\n                prefix: isLineBreak(file.text.charCodeAt(scope.getLastToken().pos)) ? context.newLineCharacter : context.newLineCharacter + context.newLineCharacter,\n                suffix: context.newLineCharacter"
  },
  {
    "id" : "0d5b277b-4e6f-4887-8a9f-b4aeb89b873b",
    "prId" : 19135,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/19135#pullrequestreview-69057731",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66c13260-980c-40ef-a541-9c7ee4eabd42",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "So if you create a fresh node that re-use tokens, do you suppressLeadingAndTrailingTrivia on the new node or the old node?",
        "createdAt" : "2017-10-12T20:30:35Z",
        "updatedAt" : "2017-10-12T20:31:42Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "81fd8d3c-118d-4c91-88ea-c430861ece79",
        "parentId" : "66c13260-980c-40ef-a541-9c7ee4eabd42",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "As we discussed offline, you probably want to suppress it on the new node.  Note that the token shouldn't appear in two places in the tree - that will mess up the positions.  You have to make a copy.",
        "createdAt" : "2017-10-12T20:40:07Z",
        "updatedAt" : "2017-10-12T20:40:07Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "6bfad5222522fbc614ba35b860f09c4736a535a4",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +741,745 @@\n        const { body, returnValueProperty } = transformFunctionBody(node, exposedVariableDeclarations, writes, substitutions, !!(range.facts & RangeFacts.HasReturn));\n        suppressLeadingAndTrailingTrivia(body);\n\n        let newFunction: MethodDeclaration | FunctionDeclaration;"
  },
  {
    "id" : "609f0749-b502-42b4-8b99-4a06539758ae",
    "prId" : 18997,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/18997#pullrequestreview-68759979",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07c0414d-838f-4814-8957-df7471fa2f51",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Where do we handle not emitting type annotations in JS files?",
        "createdAt" : "2017-10-11T21:25:49Z",
        "updatedAt" : "2017-10-12T00:36:04Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "8c3556b9-ce21-4d82-9f57-aceab470aa30",
        "parentId" : "07c0414d-838f-4814-8957-df7471fa2f51",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Got it",
        "createdAt" : "2017-10-11T21:36:25Z",
        "updatedAt" : "2017-10-12T00:36:04Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "1b896c2f80d7283fa06dd6dca17568e627f5af13",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +849,853 @@                }\n\n                newNodes.push(createVariableStatement(\n                    /*modifiers*/ undefined,\n                    createVariableDeclarationList("
  },
  {
    "id" : "1b5a0de8-e190-4df9-9065-0509eb2e0191",
    "prId" : 18997,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/18997#pullrequestreview-68759176",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6e3674b-8fa2-4247-b800-3c5a67247da9",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Why?",
        "createdAt" : "2017-10-11T21:26:25Z",
        "updatedAt" : "2017-10-12T00:36:04Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "7c6260cd-660d-4d3a-951c-3a80b1c92f18",
        "parentId" : "a6e3674b-8fa2-4247-b800-3c5a67247da9",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I see why now",
        "createdAt" : "2017-10-11T21:33:03Z",
        "updatedAt" : "2017-10-12T00:36:04Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "1b896c2f80d7283fa06dd6dca17568e627f5af13",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +865,869 @@                    let flags: NodeFlags = variableDeclaration.parent.flags;\n                    if (flags & NodeFlags.Const) {\n                        flags = (flags & ~NodeFlags.Const) | NodeFlags.Let;\n                    }\n"
  },
  {
    "id" : "4f65c1f7-f1b0-4c63-9727-914004df8889",
    "prId" : 18936,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/18936#pullrequestreview-67182783",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63407da8-8c63-44ec-bf74-583e81b42d9e",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "nit. i think we should call it `extract local` instead of `extract symbol`",
        "createdAt" : "2017-10-04T16:13:12Z",
        "updatedAt" : "2017-10-04T19:39:52Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "e0c81d17-8f5a-4e27-be76-31da3501b8bf",
        "parentId" : "63407da8-8c63-44ec-bf74-583e81b42d9e",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "As we discussed offline, that description goes on the `ApplicableRefactorInfo`.",
        "createdAt" : "2017-10-04T19:38:50Z",
        "updatedAt" : "2017-10-04T19:39:52Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "02f2a29ca24dd4aeb9cb26b6ac2fb667e02b05e3",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +6,10 @@    const extractSymbol: Refactor = {\n        name: \"Extract Symbol\",\n        description: getLocaleSpecificMessage(Diagnostics.Extract_symbol),\n        getAvailableActions,\n        getEditsForAction,"
  },
  {
    "id" : "be4d3192-6ff0-405c-a77b-0247c4d5ff49",
    "prId" : 18783,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/18783#pullrequestreview-65402742",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a99326df-a2bb-4fcf-87ee-e1083f67d2ab",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : ">extractSymbol [](start = 22, length = 13)\r\n\r\n@RyanCavanaugh, the interesting changes are here.",
        "createdAt" : "2017-09-27T00:50:39Z",
        "updatedAt" : "2017-09-28T01:08:49Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "386e76543aca28eddd98d514c408f4853e441ba2",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +3,7 @@\n/* @internal */\nnamespace ts.refactor.extractSymbol {\n    const extractSymbol: Refactor = {\n        name: \"Extract Symbol\","
  },
  {
    "id" : "ab36b05e-e3d1-46be-85de-5ec8923e9ea4",
    "prId" : 18783,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/18783#pullrequestreview-65626593",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13431bdb-c15e-41e4-a990-48051076aff3",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I would assert `prevChild !== undefined` here since it's not obvious by construction that this is impossible",
        "createdAt" : "2017-09-27T01:28:34Z",
        "updatedAt" : "2017-09-28T01:08:49Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "92948456-cd5b-46c1-bd81-4525a240597e",
        "parentId" : "13431bdb-c15e-41e4-a990-48051076aff3",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Sure, but it follows from the fact that extraction position is in a child that begins before the extraction position (i.e. there will be at least one iteration and that iteration won't kick out based on the position).",
        "createdAt" : "2017-09-27T17:38:44Z",
        "updatedAt" : "2017-09-28T01:08:49Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "386e76543aca28eddd98d514c408f4853e441ba2",
    "line" : 605,
    "diffHunk" : "@@ -1,1 +1127,1131 @@            }\n        }\n\n        Debug.assert(prevChild !== undefined);\n        return prevChild;"
  }
]
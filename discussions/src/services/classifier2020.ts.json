[
  {
    "id" : "7f4a367e-056e-40e3-9867-56e74e781f8b",
    "prId" : 39119,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39119#pullrequestreview-448279904",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2157358-dfc6-4062-b4cf-e7cb3dda637f",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "You need to check for cancellation token here. Generally we do that if for \r\n```\r\n                    case SyntaxKind.ModuleDeclaration:\r\n                    case SyntaxKind.ClassDeclaration:\r\n                    case SyntaxKind.InterfaceDeclaration:\r\n                    case SyntaxKind.FunctionDeclaration:\r\n                    case SyntaxKind.ClassExpression:\r\n                    case SyntaxKind.FunctionExpression:\r\n                    case SyntaxKind.ArrowFunction:\r\n```",
        "createdAt" : "2020-07-07T18:05:54Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "f65cce29-4942-4831-91e0-a579ce241f8d",
        "parentId" : "a2157358-dfc6-4062-b4cf-e7cb3dda637f",
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "This is in üëç ",
        "createdAt" : "2020-07-14T16:41:09Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff748a556da5ec930dec2426e46543f78d297dfa",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +72,76 @@                return;\n            }\n            const prevInJSXElement = inJSXElement;\n            if (isJsxElement(node) || isJsxSelfClosingElement(node)) {\n                inJSXElement = true;"
  },
  {
    "id" : "dc767e02-0faa-4a87-b6fe-0f95b668017b",
    "prId" : 39119,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39119#pullrequestreview-462686256",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Do you need early return if \r\n```ts\r\n if ((flags & SymbolFlags.Classifiable) === SymbolFlags.None) \r\n```",
        "createdAt" : "2020-07-07T18:07:51Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "f38e50ac-e801-40d0-90ac-f6f3f56ba707",
        "parentId" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "It could, but I'd need to make a new SymbolFlag for it as there are things like functions and variable declarations in this classifier also, do you have an opinion either way?",
        "createdAt" : "2020-07-08T12:12:44Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      },
      {
        "id" : "9ac091d6-e7e1-439a-b391-fc3b9aaa1e70",
        "parentId" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "No but on that note. Is this more additive compared to our original classifier? If so why not use this all the time and filter out things in original format mode ?",
        "createdAt" : "2020-07-08T20:38:11Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "45c04344-c455-419c-90b7-77fd022320b1",
        "parentId" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "The results sent back are different, and conform to a WIP LSP spec. The current one is used by VS, so we basically need to support both. I think [this test](https://github.com/microsoft/TypeScript/pull/39119/files#diff-b480226546c2e6363be7c39e5bcdba4aL19) shows the differences in the results quite well:\r\n\r\n```ts\r\nvar c = classification;\r\nconst c = classification(\"original\");\r\nverify.syntacticClassificationsAre(\r\n     c.comment(firstCommentText),\r\n     c.keyword(\"function\"), c.identifier(\"myFunction\"), c.punctuation(\"(\"), c.comment(\"/* x */\"), c.parameterName(\"x\"), c.punctuation(\":\"), c.keyword(\"any\"), c.punctuation(\")\"), c.punctuation(\"{\"),\r\n     c.keyword(\"var\"), c.identifier(\"y\"), c.operator(\"=\"), c.identifier(\"x\"), c.operator(\"?\"), c.identifier(\"x\"), c.operator(\"++\"), c.operator(\":\"), c.operator(\"++\"), c.identifier(\"x\"), c.punctuation(\";\"),\r\n     c.punctuation(\"}\"),\r\n     c.comment(\"// end of file\")); \r\n     c.comment(\"// end of file\"));\r\n\r\nconst c2 = classification(\"2020\");\r\n verify.semanticClassificationsAre(\"2020\",\r\n     c2.semanticToken(\"function.declaration\", \"myFunction\"), \r\n     c2.semanticToken(\"parameter.declaration\", \"x\"), \r\n     c2.semanticToken(\"variable.declaration.local\", \"y\"), \r\n     c2.semanticToken(\"parameter\", \"x\"), \r\n     c2.semanticToken(\"parameter\", \"x\"), \r\n     c2.semanticToken(\"parameter\", \"x\"), \r\n );\r\n```\r\n\r\nThe first format (original) includes everything form comments to braces, the second (LSP) is quite an explicit a subset of those results ",
        "createdAt" : "2020-07-09T12:01:11Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      },
      {
        "id" : "7033ab96-b22b-4267-b66b-c3dfec0ae7e9",
        "parentId" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "But if thats the case isnt it better to classify things in one place as function. variable, comments etc and filter out and swithc things depending on format ?\r\n\r\nEg. returned \"function.declaration\" becomes identifier in original. \r\npunctuation, comment is ignored in 2020 etc",
        "createdAt" : "2020-07-09T18:08:37Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "8ea6ecdc-5b18-4910-b044-035654df7f61",
        "parentId" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "That not an unreasonable idea! However the current implementation is a scanner, but I need to use an AST to get resolved information for things which are outside the scope of the current file. They do end up with quite different semantics given that one works entirely via an AST because it's a semantic vs syntactic.\r\n\r\nThe subsequent PR from this https://github.com/orta/TypeScript/pull/3/commits/58e830c3d6a5bbceaecd599ebad5255e0cde5e62#diff-830691d11bb3d3f0f7ca90ef0ee364afR266 speeds up the processing but requires the AST ahead of time, and while it could be implemented on top of the current classifier scanner - there's quite a mis-match between what they're doing",
        "createdAt" : "2020-07-14T16:40:57Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      },
      {
        "id" : "f38423a9-17ce-47e9-91a6-b35596d82c8b",
        "parentId" : "2bbed5dd-4b0b-41e0-9dcd-528b34461c21",
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "Poke on ^ - is that reasonable? ",
        "createdAt" : "2020-08-06T16:36:25Z",
        "updatedAt" : "2020-09-11T12:23:10Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff748a556da5ec930dec2426e46543f78d297dfa",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +143,147 @@    function classifySymbol(symbol: Symbol, meaning: SemanticMeaning): TokenType | undefined {\n        const flags = symbol.getFlags();\n        if (flags & SymbolFlags.Class) {\n            return TokenType.class;\n        }"
  }
]
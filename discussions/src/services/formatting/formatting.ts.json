[
  {
    "id" : "12f9aa86-bf19-4f6d-ac82-1d729aac63ad",
    "prId" : 39718,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39718#pullrequestreview-454434595",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2126c497-a9ff-48ed-b0cd-3ae03e1bfab7",
        "parentId" : null,
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "Moved down to ensures that the scanner always moves forward",
        "createdAt" : "2020-07-23T19:31:27Z",
        "updatedAt" : "2020-07-30T16:47:37Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dfd198e19359772d8df889492dc592521f5ef75",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +743,747 @@                        consumeTokenAndAdvanceScanner(tokenInfo, node, parentDynamicIndentation, child);\n                        return inheritedIndentation;\n                    }\n                }\n"
  },
  {
    "id" : "13900664-8018-41aa-8808-596b2f39d6af",
    "prId" : 39718,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39718#pullrequestreview-454434595",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "acedcdf9-21be-47f0-afa9-541b051ee210",
        "parentId" : null,
        "authorId" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "body" : "if the outer token's start position is ahead of the childs start, then we're basically in a weird state - try reparsing",
        "createdAt" : "2020-07-23T19:32:39Z",
        "updatedAt" : "2020-07-30T16:47:37Z",
        "lastEditedBy" : "9302e396-f4ae-400e-962a-ed2cd3258fdf",
        "tags" : [
        ]
      }
    ],
    "commit" : "2dfd198e19359772d8df889492dc592521f5ef75",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +723,727 @@                        if (tokenInfo.token.pos > childStartPos) {\n                            formattingScanner.skipToStartOf(child);\n                        }\n                        // stop when formatting scanner advances past the beginning of the child\n                        break;"
  },
  {
    "id" : "ef36f0e3-2e4b-4ef5-af12-ac6afcccd282",
    "prId" : 33402,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/33402#pullrequestreview-293895022",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42bc65c0-e3be-448a-813d-79f436b077c5",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "what does this do? I can tell that it's handling EOF specially but `processPair` doesn't mean enough to me. does \"pair\" refer to a current-previous pair?",
        "createdAt" : "2019-09-26T16:58:57Z",
        "updatedAt" : "2019-09-26T19:04:29Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "11a97575-8b1e-4d6d-b9f0-446085f16082",
        "parentId" : "42bc65c0-e3be-448a-813d-79f436b077c5",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Yeah, itâ€™s where all the text changes actually occur. Corresponds to the pair of tokens provided in every `rule()` in `rules.ts`.",
        "createdAt" : "2019-09-26T17:46:01Z",
        "updatedAt" : "2019-09-26T19:04:29Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "61c3e61f3e56e2f570b2b6b478913c3878aaa17a",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +656,660 @@                const token = formattingScanner.readEOFTokenRange();\n                if (token.end <= node.end && previousRange) {\n                    processPair(\n                        token,\n                        sourceFile.getLineAndCharacterOfPosition(token.pos).line,"
  },
  {
    "id" : "b2ea024c-0ea2-4adc-9b2b-4be95658e133",
    "prId" : 9420,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99ffa70b-bdcd-4727-968b-6335827edf57",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "The following code looks like it now disagrees with the comment: without `!isLineBreak`, \"1. the end of the previous line\" will no longer happen.\n",
        "createdAt" : "2016-06-29T21:52:40Z",
        "updatedAt" : "2016-07-01T20:57:26Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "54275aea-d34e-435b-85cc-8e0955138e4e",
        "parentId" : "99ffa70b-bdcd-4727-968b-6335827edf57",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "`isWhiteSpace` will already return false on line breaks, so when we reach the end of the previous line the `while` loop will terminate.\n",
        "createdAt" : "2016-06-30T13:43:42Z",
        "updatedAt" : "2016-07-01T20:57:26Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c40fea9f1da904957ab774c23bd1523e255a513",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +78,82 @@        //  1. the end of the previous line\n        //  2. the last non-whitespace character in the current line\n        let endOfFormatSpan = getEndLinePosition(line, sourceFile);\n        while (isWhiteSpaceSingleLine(sourceFile.text.charCodeAt(endOfFormatSpan))) {\n            endOfFormatSpan--;"
  },
  {
    "id" : "2a9daeec-40ff-4417-87df-4ba41039cd26",
    "prId" : 8487,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42a9d9d5-9874-46fa-97be-be496875a88d",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "why not just `indentationString === soruceFile.text.substr(startLinePosition , indentationString.length);`\n",
        "createdAt" : "2016-05-05T22:33:24Z",
        "updatedAt" : "2016-05-06T08:09:32Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "e11b08fa91c3f1a18c56c531d350cc2058939a03",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +868,872 @@                let tokenStart = sourceFile.getLineAndCharacterOfPosition(pos);\n                let startLinePosition = getStartPositionOfLine(tokenStart.line, sourceFile);\n                if (indentation !== tokenStart.character || indentationIsDifferent(indentationString, startLinePosition)) {\n                    recordReplace(startLinePosition, tokenStart.character, indentationString);\n                }"
  },
  {
    "id" : "946dc7de-7f79-499c-9b9e-ee17c161f64d",
    "prId" : 8364,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64b83a5e-0ab5-4b54-a11c-a86912180275",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "why do we need to specialize it to array, should not the firstListItem be enough indicator?\n",
        "createdAt" : "2016-04-30T00:14:00Z",
        "updatedAt" : "2016-04-30T00:14:00Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "8de5bbcd-7990-42ad-bffc-5cc505cc55a3",
        "parentId" : "64b83a5e-0ab5-4b54-a11c-a86912180275",
        "authorId" : "369b80dc-e364-41b0-b447-7b9bba064064",
        "body" : "It would break cases for other things like parameter list\n\n``` ts\nfunction test(p1: string,\n              p2: number) {} \n```\n",
        "createdAt" : "2016-04-30T02:05:23Z",
        "updatedAt" : "2016-04-30T02:05:23Z",
        "lastEditedBy" : "369b80dc-e364-41b0-b447-7b9bba064064",
        "tags" : [
        ]
      },
      {
        "id" : "e0f0dfa9-4345-47cb-93eb-7d2649a128ba",
        "parentId" : "64b83a5e-0ab5-4b54-a11c-a86912180275",
        "authorId" : "6feba8ca-0b6a-496c-83fb-5fdd3b4e56f3",
        "body" : "Is there a test that guards parameter list formatting?\n",
        "createdAt" : "2016-05-17T07:52:48Z",
        "updatedAt" : "2016-05-17T07:52:48Z",
        "lastEditedBy" : "6feba8ca-0b6a-496c-83fb-5fdd3b4e56f3",
        "tags" : [
        ]
      }
    ],
    "commit" : "b85b0046c32573bf45b8bc0038e9498b3dd85e4a",
    "line" : 155,
    "diffHunk" : "@@ -1,1 +628,632 @@                childContextNode = node;\n\n                if (isFirstListItem && parent.kind === SyntaxKind.ArrayLiteralExpression && inheritedIndentation === Constants.Unknown) {\n                    inheritedIndentation = childIndentation.indentation;\n                }"
  },
  {
    "id" : "a7de421b-2dea-496c-b855-014b8e364216",
    "prId" : 4994,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a6e014f-168d-4319-823c-e297d11c9f17",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you make this `lineEndPosition < range.end`\n\nAlso, this doesn't cover the case where these are unterminated, does it?\n",
        "createdAt" : "2015-09-29T00:12:36Z",
        "updatedAt" : "2015-09-29T20:57:21Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "47cad7f5-6b5c-4630-8c9f-0a5a19baaa08",
        "parentId" : "8a6e014f-168d-4319-823c-e297d11c9f17",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Never mind, discussed offline, nodes with errors don't get formatted.\n",
        "createdAt" : "2015-09-29T00:20:28Z",
        "updatedAt" : "2015-09-29T20:57:21Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "16762a4ff0db4c421c7b964bc2fa6315c546e49c",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +935,939 @@\n                // do not trim whitespaces in comments or template expression\n                if (range && (isComment(range.kind) || isStringOrRegularExpressionOrTemplateLiteral(range.kind)) && range.pos <= lineEndPosition && range.end > lineEndPosition) {\n                    continue;\n                }"
  },
  {
    "id" : "be1fffe0-9527-486f-9316-9d13a21f344b",
    "prId" : 4398,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48a86603-ec20-4c3f-b808-cb2294f72984",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "> /\\* Not to miss zero-range nodes e.g. JsxText */\n\ntext can not be zero-length, is there an example that would trigger this?\n",
        "createdAt" : "2015-08-21T21:44:15Z",
        "updatedAt" : "2015-12-09T14:43:18Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "ae0fb16c-d5b2-4cd3-b1ec-d813f2ebe7bb",
        "parentId" : "48a86603-ec20-4c3f-b808-cb2294f72984",
        "authorId" : "1c5d8e1e-e1db-4d80-8ca6-745f98c8216f",
        "body" : "@mhegazy I've found that this code blocks autoformatting:\n\n``` typescript\nlet x = <div>\n<span>\n</span>\n</div>\n```\n\n`<span>` won't be indented here because by some reason a zero-length JsxText node right before JsxElement node incorrectly sets indentation value to zero. An additional `rangeContainsStartEnd` check prevents this bug.\n",
        "createdAt" : "2015-08-22T02:17:59Z",
        "updatedAt" : "2015-12-09T14:43:18Z",
        "lastEditedBy" : "1c5d8e1e-e1db-4d80-8ca6-745f98c8216f",
        "tags" : [
        ]
      },
      {
        "id" : "6d609065-e42b-4ad2-bf27-5a57e97d6e33",
        "parentId" : "48a86603-ec20-4c3f-b808-cb2294f72984",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "looks like a parser bug then. \n",
        "createdAt" : "2015-08-25T19:48:18Z",
        "updatedAt" : "2015-12-09T14:43:18Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "64494164-b8e7-4239-aaea-d4866c940ea7",
        "parentId" : "48a86603-ec20-4c3f-b808-cb2294f72984",
        "authorId" : "1c5d8e1e-e1db-4d80-8ca6-745f98c8216f",
        "body" : "Maybe related to #4332?\n",
        "createdAt" : "2015-08-26T03:39:59Z",
        "updatedAt" : "2015-12-09T14:43:18Z",
        "lastEditedBy" : "1c5d8e1e-e1db-4d80-8ca6-745f98c8216f",
        "tags" : [
        ]
      },
      {
        "id" : "3c9e1908-47fa-495a-a1a5-0168fce4ca8f",
        "parentId" : "48a86603-ec20-4c3f-b808-cb2294f72984",
        "authorId" : "1c5d8e1e-e1db-4d80-8ca6-745f98c8216f",
        "body" : "#4596 didn't fix this zero-length problem. CC: @vladima \n",
        "createdAt" : "2015-09-04T03:28:28Z",
        "updatedAt" : "2015-12-09T14:43:18Z",
        "lastEditedBy" : "1c5d8e1e-e1db-4d80-8ca6-745f98c8216f",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e3ee5d716d439b40fe0f6838141e9890fe77c46",
    "line" : null,
    "diffHunk" : "@@ -1,1 +362,366 @@\n            if (rangeOverlapsWithStartEnd(range, startPos, endPos) ||\n                rangeContainsStartEnd(range, startPos, endPos) /* Not to miss zero-range nodes e.g. JsxText */) {\n                \n                if (inheritedIndentation !== Constants.Unknown) {"
  },
  {
    "id" : "0cd7b91c-c418-4617-8388-41f71552561b",
    "prId" : 1906,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9a4de1a-bde9-4d69-8a7d-d5f48621bc8d",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Perhaps you could leave a comment for what each of these cases means. I don't see how this corresponds to being in a comment.\n",
        "createdAt" : "2015-02-03T07:28:42Z",
        "updatedAt" : "2015-02-03T18:17:21Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "0f046d35-03bf-4863-ad5b-69171fb09352",
        "parentId" : "a9a4de1a-bde9-4d69-8a7d-d5f48621bc8d",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "when it is claimed that trigger character was typed at given position we verify that there is a token with a matching kind whose end is equal to position (because the character was just typed). If this condition is not hold - then trigger character was typed in some other context, i.e. in comment and thus should not trigger autoformatting\n",
        "createdAt" : "2015-02-03T16:11:55Z",
        "updatedAt" : "2015-02-03T18:17:21Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "c095bb356c7c3acb8ce9661467900e46cab7bd7d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +128,132 @@        if (!precedingToken ||\n            precedingToken.kind !== expectedTokenKind ||\n            position !== precedingToken.getEnd()) {\n            return undefined;\n        }"
  }
]
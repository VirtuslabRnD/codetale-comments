[
  {
    "id" : "cd712648-862d-4fb9-9d4b-ad45a7f70131",
    "prId" : 33402,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/33402#pullrequestreview-293940067",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f0ba981-288d-4324-a5d4-78628abf7017",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why doesn't this same rule apply to property declarations with no type and no initialiser? and why only to property signatures inside interfaces and types?",
        "createdAt" : "2019-09-26T17:14:39Z",
        "updatedAt" : "2019-09-26T19:04:29Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "b0ab0bf6-e4fa-4916-8c6c-21ac8cc31346",
        "parentId" : "0f0ba981-288d-4324-a5d4-78628abf7017",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Because interfaces/types can’t have property declarations, and classes/objects can’t have method signatures (or any other member that starts with an open paren, AFAICT.)\r\n\r\nUnfortunately, due to the definition of where ASI occurs, determining whether ASI occurs while parsing is really easy, but determining whether a given semicolon in an already-parsed tree _would_ have been inserted by ASI were it not explicitly included (which is what this function tries to determine) is _extremely_ wishy washy. The definition is (paraphrasing a bit) “ASI occurs just about any time the parser can’t understand the next token without inserting a semicolon first.” Which means, to truly tell whether a semicolon was necessary, you have to try parsing without it, and see if you get the same result. That’s why this function appears so strange, and why the chances that this misses an opportunity to delete a semicolon is _much_ higher than the chance that `isSemicolonInsertionContext` is wrong—that one essentially just enumerates the places where `parser.ts` parses an optional semicolon.",
        "createdAt" : "2019-09-26T19:03:49Z",
        "updatedAt" : "2019-09-26T19:06:01Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "61c3e61f3e56e2f570b2b6b478913c3878aaa17a",
    "line" : 469,
    "diffHunk" : "@@ -1,1 +826,830 @@            // Can’t remove semicolon after `foo`; it would parse as a method declaration:\n            //\n            // interface I {\n            //   foo;\n            //   (): void"
  },
  {
    "id" : "79e74128-f7ca-42c1-9459-873e58fe71b1",
    "prId" : 30743,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30743#pullrequestreview-222512690",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8fcd8666-4d1e-427a-8ebc-a92062d2541e",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Removed OpenParen from the list because that should be handled only by `SpaceBeforeOpenParenInFuncDecl` or `SpaceAfterAnonymousFunctionKeyword` to minimize the number of competing rules.",
        "createdAt" : "2019-04-04T00:24:33Z",
        "updatedAt" : "2019-04-04T00:27:18Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "45ed0186a158bdefe8c1e7d0d8dd64c28cab1486",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +99,103 @@\n            rule(\"NoSpaceBetweenFunctionKeywordAndStar\", SyntaxKind.FunctionKeyword, SyntaxKind.AsteriskToken, [isFunctionDeclarationOrFunctionExpressionContext], RuleAction.Delete),\n            rule(\"SpaceAfterStarInGeneratorDeclaration\", SyntaxKind.AsteriskToken, SyntaxKind.Identifier, [isFunctionDeclarationOrFunctionExpressionContext], RuleAction.Space),\n\n            rule(\"SpaceAfterFunctionInFuncDecl\", SyntaxKind.FunctionKeyword, anyToken, [isFunctionDeclContext], RuleAction.Space),"
  },
  {
    "id" : "a3d90dbe-ce99-496c-887c-eeeefa92c8e7",
    "prId" : 30743,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30743#pullrequestreview-222512690",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bab9bcfa-0dca-49c6-b5ae-475675ae80cb",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "This rule is now a slight misnomer since we look at more than just `SyntaxKind.FunctionKeyword`, but I think it matches users' intuition (at least #30675 seems to support that theory).",
        "createdAt" : "2019-04-04T00:25:52Z",
        "updatedAt" : "2019-04-04T00:27:18Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "45ed0186a158bdefe8c1e7d0d8dd64c28cab1486",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +243,247 @@            // Insert space after function keyword for anonymous functions\n            rule(\"SpaceAfterAnonymousFunctionKeyword\", [SyntaxKind.FunctionKeyword, SyntaxKind.AsteriskToken], SyntaxKind.OpenParenToken, [isOptionEnabled(\"insertSpaceAfterFunctionKeywordForAnonymousFunctions\"), isFunctionDeclContext], RuleAction.Space),\n            rule(\"NoSpaceAfterAnonymousFunctionKeyword\", [SyntaxKind.FunctionKeyword, SyntaxKind.AsteriskToken], SyntaxKind.OpenParenToken, [isOptionDisabledOrUndefined(\"insertSpaceAfterFunctionKeywordForAnonymousFunctions\"), isFunctionDeclContext], RuleAction.Delete),\n\n            // Insert space after keywords in control flow statements"
  },
  {
    "id" : "d11bd730-af27-4331-ae26-28184778c069",
    "prId" : 4309,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e1694b3-ed03-403a-a937-d265c7231e42",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why is this part of this change?\n",
        "createdAt" : "2015-08-13T21:49:38Z",
        "updatedAt" : "2015-08-13T22:26:02Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "2b9e9864-bac3-4ffa-8d27-1340a302fcbc",
        "parentId" : "7e1694b3-ed03-403a-a937-d265c7231e42",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "no idea.\n",
        "createdAt" : "2015-08-13T22:22:36Z",
        "updatedAt" : "2015-08-13T22:26:02Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "2d249c8a26221ffba270853409021bd4d59c3443",
    "line" : null,
    "diffHunk" : "@@ -1,1 +727,731 @@                case SyntaxKind.CallExpression:\n                case SyntaxKind.NewExpression:\n                case SyntaxKind.ExpressionWithTypeArguments:\n                    return true;\n                default:"
  },
  {
    "id" : "7646f095-6ca5-4c3d-bcbf-f0cf9266c044",
    "prId" : 2664,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d1ff5b6-d866-46d1-8721-3c77d8b311c6",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "Can you add a test for space after decorator should not be added\n\n``` ts\n@x[\"\"]\nclass c {\n}\n```\n\nor\n\n``` ts\n@decorator(arg) \nclass  {}\n```\n",
        "createdAt" : "2015-04-08T17:04:58Z",
        "updatedAt" : "2015-04-09T00:06:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "051a6b02-8743-4d22-b55a-79e1cd2d1c53",
        "parentId" : "0d1ff5b6-d866-46d1-8721-3c77d8b311c6",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i would add \"function\" as well\n",
        "createdAt" : "2015-04-08T17:05:22Z",
        "updatedAt" : "2015-04-09T00:06:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "ae94ab78-79a5-4f80-802b-5de4945e1339",
        "parentId" : "0d1ff5b6-d866-46d1-8721-3c77d8b311c6",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "@mhegazy, can you clarify what you mean by this:\n\n> i would add \"function\" as well\n",
        "createdAt" : "2015-04-08T23:51:01Z",
        "updatedAt" : "2015-04-09T00:06:05Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "a3bc3d6d-aec9-45ef-ba82-7190367d51ad",
        "parentId" : "0d1ff5b6-d866-46d1-8721-3c77d8b311c6",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "@mhegazy, I'm not sure what you're trying illustrate with this:\n\n> Can you add a test for space after decorator should not be added\n> \n> ``` ts\n> @x[\"\"]\n> class c {\n> }\n> ```\n> \n> or\n> \n> ``` ts\n> @decorator(arg) \n> class  {}\n> ```\n",
        "createdAt" : "2015-04-08T23:53:52Z",
        "updatedAt" : "2015-04-09T00:06:05Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "54dab13b-8b19-4ee9-9084-41597233ffea",
        "parentId" : "0d1ff5b6-d866-46d1-8721-3c77d8b311c6",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i meant functionKeyword. `@dec function func() {}` thought we can add that when we support it\n",
        "createdAt" : "2015-04-09T19:18:39Z",
        "updatedAt" : "2015-04-09T19:18:39Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "dd38b7e5-6db5-405e-8fe4-2a130609c5aa",
        "parentId" : "0d1ff5b6-d866-46d1-8721-3c77d8b311c6",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i meant the sapceAfterDecorator rule would not apply to decorators expressions.\n",
        "createdAt" : "2015-04-09T19:19:22Z",
        "updatedAt" : "2015-04-09T19:19:22Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "609036a2d669572145fb18d96a213fa3f5c6e784",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +353,357 @@            this.SpaceBeforeAt = new Rule(RuleDescriptor.create2(Shared.TokenRange.Any, SyntaxKind.AtToken), RuleOperation.create2(new RuleOperationContext(Rules.IsSameLineTokenContext), RuleAction.Space));\n            this.NoSpaceAfterAt = new Rule(RuleDescriptor.create3(SyntaxKind.AtToken, Shared.TokenRange.Any), RuleOperation.create2(new RuleOperationContext(Rules.IsSameLineTokenContext), RuleAction.Delete));\n            this.SpaceAfterDecorator = new Rule(RuleDescriptor.create4(Shared.TokenRange.Any, Shared.TokenRange.FromTokens([SyntaxKind.Identifier, SyntaxKind.ExportKeyword, SyntaxKind.DefaultKeyword, SyntaxKind.ClassKeyword, SyntaxKind.StaticKeyword, SyntaxKind.PublicKeyword, SyntaxKind.PrivateKeyword, SyntaxKind.ProtectedKeyword, SyntaxKind.GetKeyword, SyntaxKind.SetKeyword, SyntaxKind.OpenBracketToken, SyntaxKind.AsteriskToken])), RuleOperation.create2(new RuleOperationContext(Rules.IsEndOfDecoratorContextOnSameLine), RuleAction.Space));\n\n            // These rules are higher in priority than user-configurable rules."
  }
]
[
  {
    "id" : "8d8fd0ba-16ca-4ad7-a870-c7670102f9e0",
    "prId" : 23095,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/23095#pullrequestreview-108766946",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f8a3a76-d615-4f87-9078-22131c7cb558",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "(`charIsPunctuation` doesn't have a case for `$` anyway)",
        "createdAt" : "2018-04-02T22:45:19Z",
        "updatedAt" : "2018-04-04T15:15:49Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c0665ffb99567b477d004afda9e9060b845f515",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +587,591 @@\n    function isAllPunctuation(identifier: string, start: number, end: number): boolean {\n        return every(identifier, ch => charIsPunctuation(ch) && ch !== CharacterCodes._, start, end);\n    }\n"
  },
  {
    "id" : "15f80e66-e4b2-404d-b762-2e37d414f863",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ece70ea-71bc-441c-9623-2e39eb5ffc74",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why does this note mention your username? This is a useful comment on its own.\n",
        "createdAt" : "2015-02-20T08:58:25Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "af102715-fb34-4b3c-b65b-1240268b2d44",
        "parentId" : "5ece70ea-71bc-441c-9623-2e39eb5ffc74",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "So that i can search for notes/todos from me.  It's also useful to know who owns notes/todos so you can sweep through your codebase addressing them.  Otherwise, you get todos/notes that proliferate and never get handled.\n",
        "createdAt" : "2015-02-20T19:12:20Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 2,
    "diffHunk" : "@@ -1,1 +0,4 @@module ts {\n    // Note(cyrusn): this enum is ordered from strongest match type to weakest match type.\n    export enum PatternMatchKind {\n        Exact,"
  },
  {
    "id" : "241b1088-ae20-4e22-a849-c1cd1d5b7ac8",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "749af443-62ff-4790-8a8e-74ccb365b94b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Weird to heard \"you\" in the comment but maybe it's good because it captures the reader's attention.\n",
        "createdAt" : "2015-02-20T09:02:21Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +31,35 @@\n    // The pattern matcher maintains an internal cache of information as it is used.  Therefore,\n    // you should not keep it around forever and should get and release the matcher appropriately\n    // once you no longer need it.\n    export interface PatternMatcher {"
  },
  {
    "id" : "67905d58-2f0c-4fbe-b687-8f928a6925e5",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b08f9966-963d-4922-bf8a-3a00b8b9e7d6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Odd comment, `ts.compiler` is not a module in our compiler.\n",
        "createdAt" : "2015-02-20T09:04:36Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c16e3d20-630b-4aac-b960-9ffc7587db60",
        "parentId" : "b08f9966-963d-4922-bf8a-3a00b8b9e7d6",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Although, I think I get that the point you're trying to illustrate is that `dottedContainer` can take on non-identifier strings\n",
        "createdAt" : "2015-02-20T09:05:44Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "58c0c9a2-aad1-4e00-b89d-ec0a63d51935",
        "parentId" : "b08f9966-963d-4922-bf8a-3a00b8b9e7d6",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I'm just using it as an illustrative example.\n",
        "createdAt" : "2015-02-20T19:13:48Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@        // this will return a successful match, having only tested \"SK\" against \"SyntaxKind\".  At\n        // that point a call can be made to 'getMatches(\"SyntaxKind\", \"ts.compiler\")', with the\n        // work to create 'ts.compiler' only being done once the first match succeeded.\n        getMatchesForLastSegmentOfPattern(candidate: string): PatternMatch[];\n"
  },
  {
    "id" : "b806a820-533b-4841-b5bb-244b9f684169",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb8f4f6c-cc30-4142-b57d-99cc8db8931f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "When can `candidate` be `undefined`?\n",
        "createdAt" : "2015-02-20T20:26:41Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "5285f9ac-e881-44c9-8578-bf89e575d40b",
        "parentId" : "bb8f4f6c-cc30-4142-b57d-99cc8db8931f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "candidate will also be falsy when it's the empty string\n",
        "createdAt" : "2015-02-20T22:17:11Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +129,133 @@        // Quick checks so we can bail out when asked to match a candidate.\n        function skipMatch(candidate: string) {\n            return invalidPattern || !candidate;\n        }\n        "
  },
  {
    "id" : "792ed230-140b-4cf2-a7b4-1cfb0d8ea9a3",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2548bee0-a824-413a-ae55-2f2df9df5426",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Optional? You say it's only if it's an exact match character-by-character\n",
        "createdAt" : "2015-02-20T20:35:24Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : null,
    "diffHunk" : "@@ -1,1 +22,26 @@        // matched case sensitively or case insensitively.  Case sensitive matches of the kind\n        // are better matches than insensitive matches.\n        isCaseSensitive: boolean;\n\n        // Whether or not this match occurred with the punctuation from the search pattern stripped"
  },
  {
    "id" : "cd65157b-f2bf-463c-9423-2da2ac632bfe",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73c1933f-7d36-47ea-8d93-f3e986414889",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems like if you have segments separated by dots, you are not typing something that can have spaces interspersed.\n",
        "createdAt" : "2015-02-20T20:40:39Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +57,61 @@    // dots is a 'Segment'.  The 'Segment' contains information about the entire section of \n    // text between the dots, as well as information about any individual 'Words' that we \n    // can break the segment into.  A 'Word' is simply a contiguous sequence of characters\n    // that can appear in a typescript identifier.  So \"GetKeyword\" would be one word, while\n    // \"Get Keyword\" would be two words.  Once we have the individual 'words', we break those"
  },
  {
    "id" : "bc48209c-ec9b-4368-91be-3569bc708e19",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cff89bb-baa9-454f-a657-03fd5573285d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "comprising\n",
        "createdAt" : "2015-02-20T20:41:41Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +69,73 @@        totalTextChunk: TextChunk;\n\n        // Information about the subwords compromising the total word.  For example, if the \n        // text between the dots is 'GetFoo KeywordBar', then the subwords will be 'GetFoo' \n        // and 'KeywordBar'.  Those individual words will have CharacterSpans of ('Get' and "
  },
  {
    "id" : "91ba6b13-03d6-437b-b011-7ecdfd55053e",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "192e5c1a-2c2b-4cc0-973a-533f96ed863f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So a TextChunk can represent either a Segment or a Word? Why is it not a strict hierarchy, with Segments containing Words and Words containing CharacterSpans? TextChunk seems to blur the hierarchy.\n",
        "createdAt" : "2015-02-20T20:45:56Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +79,83 @@    // cached information about the character spans within in.  Character spans are used for \n    // camel case matching.\n    interface TextChunk {\n        // The text of the chunk.  This should be a contiguous sequence of character that could\n        // occur in a symbol name."
  },
  {
    "id" : "eae4fda8-b6be-44f1-ae3b-e0d6e4683e16",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "889cfb81-59c9-49e8-ad20-b834bb674ce9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would just inline the object literals instead. This is not an interesting function.\n",
        "createdAt" : "2015-02-20T20:46:37Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +99,103 @@    }\n\n    function createPatternMatch(kind: PatternMatchKind, punctuationStripped: boolean, isCaseSensitive: boolean, camelCaseWeight?: number): PatternMatch {\n        return {\n            kind,"
  },
  {
    "id" : "773675a3-ff5e-46b0-a603-e6888e955c22",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fb70dd31-1f28-4c2c-9f17-df5504592274",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "You should mention in the comment that the candidate is represented as a TextSpan\n",
        "createdAt" : "2015-02-20T20:51:27Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 115,
    "diffHunk" : "@@ -1,1 +113,117 @@        // such, we cache the information we compute about the candidate for the life of this \n        // pattern matcher so we don't have to compute it multiple times.\n        var stringToWordSpans: Map<TextSpan[]> = {};\n\n        pattern = pattern.trim();"
  },
  {
    "id" : "a02254e5-d22b-43fc-9090-8b03211bdd13",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ea55282-688e-46fe-9320-3f73b1822b54",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Makes sense to be resilient, but who puts white space next to a dot?\n",
        "createdAt" : "2015-02-20T20:53:36Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "66557e58-8548-4310-a89a-c92a723bc327",
        "parentId" : "6ea55282-688e-46fe-9320-3f73b1822b54",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I do :)  \n",
        "createdAt" : "2015-02-21T01:29:43Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +118,122 @@\n        var fullPatternSegment = createSegment(pattern);\n        var dotSeparatedSegments = pattern.split(\".\").map(p => createSegment(p.trim()));\n        var invalidPattern = dotSeparatedSegments.length === 0 || forEach(dotSeparatedSegments, segmentIsInvalid);\n"
  },
  {
    "id" : "7219e3d2-0e0a-4453-bd15-475c9de70496",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8fba924-ca18-4d58-80c0-302b563fc866",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Please inline segmentIsInvalid\n",
        "createdAt" : "2015-02-20T20:56:47Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "1a4e5ade-0407-457a-ab95-6ded3eb49faf",
        "parentId" : "f8fba924-ca18-4d58-80c0-302b563fc866",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh I forgot, we do this in order to avoid allocations.\n",
        "createdAt" : "2015-02-23T05:33:06Z",
        "updatedAt" : "2015-02-23T05:33:06Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +119,123 @@        var fullPatternSegment = createSegment(pattern);\n        var dotSeparatedSegments = pattern.split(\".\").map(p => createSegment(p.trim()));\n        var invalidPattern = dotSeparatedSegments.length === 0 || forEach(dotSeparatedSegments, segmentIsInvalid);\n\n        return {"
  },
  {
    "id" : "ba2e3932-502f-4f51-aa43-4efc85227dd3",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e196ef28-8208-48ef-9d0b-fc803cb0aa96",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Errr... I've never seen a loop shaped like this.\n",
        "createdAt" : "2015-02-20T22:20:56Z",
        "updatedAt" : "2015-02-21T22:34:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 172,
    "diffHunk" : "@@ -1,1 +170,174 @@            for (var i = dotSeparatedSegments.length - 2, j = containerParts.length - 1;\n                 i >= 0;\n                 i--, j--) {\n\n                var segment = dotSeparatedSegments[i];"
  },
  {
    "id" : "c4753420-d1f7-48f2-9470-d6ca71455795",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47ab07bc-4ac1-4f59-8781-af57dea22978",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why not call `getMatchesForLastSegmentOfPattern`?\n",
        "createdAt" : "2015-02-23T05:37:28Z",
        "updatedAt" : "2015-02-23T05:37:28Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +148,152 @@            // candidate.  If not, then there's no point in proceeding and doing the more\n            // expensive work.\n            var candidateMatch = matchSegment(candidate, lastOrUndefined(dotSeparatedSegments));\n            if (!candidateMatch) {\n                return undefined;"
  },
  {
    "id" : "c82f6c15-f53b-4d02-a0a0-469f9f55697f",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e4e39d37-aa1e-4449-b4ce-34222f740529",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would give dottedContainer a default parameter initializer\n",
        "createdAt" : "2015-02-23T05:38:13Z",
        "updatedAt" : "2015-02-23T05:38:13Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 155,
    "diffHunk" : "@@ -1,1 +153,157 @@            }\n\n            dottedContainer = dottedContainer || \"\";\n            var containerParts = dottedContainer.split(\".\");\n"
  },
  {
    "id" : "83689ca4-efb0-4e04-93b3-f6ec1388efe0",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d05b345b-98d4-4c68-83b8-064f711be86d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Does containerParts always represent a name that is fully qualified? That's the assumption you seem to be relying on.\n",
        "createdAt" : "2015-02-23T05:40:39Z",
        "updatedAt" : "2015-02-23T05:40:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +158,162 @@            // -1 because the last part was checked against the name, and only the rest\n            // of the parts are checked against the container.\n            if (dotSeparatedSegments.length - 1 > containerParts.length) {\n                // There weren't enough container parts to match against the pattern parts.\n                // So this definitely doesn't match."
  },
  {
    "id" : "f16b193a-7ced-41a0-ad23-eaba7dde79f3",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b24502cf-40a7-44c8-a92c-ecfffa370aa8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "undefined\n",
        "createdAt" : "2015-02-23T05:40:51Z",
        "updatedAt" : "2015-02-23T05:40:51Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 163,
    "diffHunk" : "@@ -1,1 +161,165 @@                // There weren't enough container parts to match against the pattern parts.\n                // So this definitely doesn't match.\n                return null;\n            }\n"
  },
  {
    "id" : "991352dd-e3d7-4db5-b87a-93e511ce7087",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e8a2849-9353-456c-9478-d8791d19fa99",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What does this do? Where is addRange defined?\n",
        "createdAt" : "2015-02-23T05:46:22Z",
        "updatedAt" : "2015-02-23T05:46:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 183,
    "diffHunk" : "@@ -1,1 +181,185 @@                }\n\n                addRange(totalMatch, containerMatch);\n            }\n"
  },
  {
    "id" : "e4cea564-a52e-46f3-9406-0ea7a2c663a3",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6db869b2-75d7-4676-8545-5997d219d836",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What's indexOfIgnoringCase?\n",
        "createdAt" : "2015-02-23T05:50:08Z",
        "updatedAt" : "2015-02-23T05:50:08Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +198,202 @@\n        function matchTextChunk(candidate: string, chunk: TextChunk, punctuationStripped: boolean): PatternMatch {\n            var index = indexOfIgnoringCase(candidate, chunk.textLowerCase);\n            if (index === 0) {\n                if (chunk.text.length === candidate.length) {"
  },
  {
    "id" : "4cbfd1a3-882c-4af3-9ca0-53ec76e59f20",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ee6abed-4130-4955-af4c-2b3b4c5fdd6c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Your comment implies that there is something to check, but you are just creating the match off the bat. Where did you actually check that it matched?\n",
        "createdAt" : "2015-02-23T05:56:59Z",
        "updatedAt" : "2015-02-23T05:56:59Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +203,207 @@                    // a) Check if the part matches the candidate entirely, in an case insensitive or\n                    //    sensitive manner.  If it does, return that there was an exact match.\n                    return createPatternMatch(PatternMatchKind.Exact, punctuationStripped, /*isCaseSensitive:*/ candidate === chunk.text);\n                }\n                else {"
  },
  {
    "id" : "3fd05bd8-9002-40ca-b803-cfd8fd4e5193",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90a439b9-db21-4e13-880c-b06bf2e4e796",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would expect startsWith to return true if chunk is a prefix, false if it is not. However, I would expect isCaseSensitive to _assume_ that the chunk is a prefix, and it should be true if it is an exact prefix, and false if it's a case insensitive prefix. Something doesn't line up here.\n",
        "createdAt" : "2015-02-23T05:57:50Z",
        "updatedAt" : "2015-02-23T05:57:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 210,
    "diffHunk" : "@@ -1,1 +208,212 @@                    // b) Check if the part is a prefix of the candidate, in a case insensitive or sensitive\n                    //    manner.  If it does, return that there was a prefix match.\n                    return createPatternMatch(PatternMatchKind.Prefix, punctuationStripped, /*isCaseSensitive:*/ startsWith(candidate, chunk.text));\n                }\n            }"
  },
  {
    "id" : "e0021582-8dee-427b-aa09-78cb8f97a269",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "170986fc-416d-47fe-90df-af4812038fce",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Merge with else block above\n",
        "createdAt" : "2015-02-23T05:59:25Z",
        "updatedAt" : "2015-02-23T05:59:25Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 243,
    "diffHunk" : "@@ -1,1 +241,245 @@            }\n\n            if (!isLowercase) {\n                // e) If the part was not entirely lowercase, then attempt a camel cased match as well.\n                if (chunk.characterSpans.length > 0) {"
  },
  {
    "id" : "7f9343c2-94ab-40c1-96df-71f4b1deeb44",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79f5e07c-a659-4100-aed1-6c7e8b9527ca",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Merge with lowercase block above\n",
        "createdAt" : "2015-02-23T06:14:45Z",
        "updatedAt" : "2015-02-23T06:14:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 259,
    "diffHunk" : "@@ -1,1 +257,261 @@            }\n\n            if (isLowercase) {\n                // f) Is the pattern a substring of the candidate starting on one of the candidate's word boundaries?\n"
  },
  {
    "id" : "6d162423-dfcf-4a44-9841-559937a66e78",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0b96b83-567c-4ab9-854f-9ff2a54f912a",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "You never had to check that the length was less than the candidate's length before. Why do you have to now?\n",
        "createdAt" : "2015-02-23T06:21:28Z",
        "updatedAt" : "2015-02-23T06:21:28Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 267,
    "diffHunk" : "@@ -1,1 +265,269 @@                // filter the list based on a substring that starts on a capital letter and also with a lowercase one.\n                // (Pattern: fogbar, Candidate: quuxfogbarFogBar).\n                if (chunk.text.length < candidate.length) {\n                    if (index > 0 && isUpperCaseLetter(candidate.charCodeAt(index))) {\n                        return createPatternMatch(PatternMatchKind.Substring, punctuationStripped, /*isCaseSensitive:*/ false);"
  },
  {
    "id" : "80040583-a481-44b8-94e2-f5425ae7dc39",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a6aa2fa-cb5f-4368-b4c2-c6bcf41624c8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "The initial block checked `index === 0`, so if you are here, index has to be more than 0, right? Unless it is less, but in that case why would you still be here?\n",
        "createdAt" : "2015-02-23T06:23:14Z",
        "updatedAt" : "2015-02-23T06:23:14Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 268,
    "diffHunk" : "@@ -1,1 +266,270 @@                // (Pattern: fogbar, Candidate: quuxfogbarFogBar).\n                if (chunk.text.length < candidate.length) {\n                    if (index > 0 && isUpperCaseLetter(candidate.charCodeAt(index))) {\n                        return createPatternMatch(PatternMatchKind.Substring, punctuationStripped, /*isCaseSensitive:*/ false);\n                    }"
  },
  {
    "id" : "6611ad77-b7e6-41ab-8ef8-5147dfcc3449",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e622c496-c00f-4f52-a61c-abdf92436572",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "How is this different from step c?\n",
        "createdAt" : "2015-02-23T06:23:22Z",
        "updatedAt" : "2015-02-23T06:23:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 260,
    "diffHunk" : "@@ -1,1 +258,262 @@\n            if (isLowercase) {\n                // f) Is the pattern a substring of the candidate starting on one of the candidate's word boundaries?\n\n                // We could check every character boundary start of the candidate for the pattern. However, that's"
  },
  {
    "id" : "e364c025-caa4-4653-99d4-d8a0f1fc37b7",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43b6d568-d346-4d7f-bd41-b87a7bc8463e",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can't you just use indexOf?\n",
        "createdAt" : "2015-02-23T06:24:45Z",
        "updatedAt" : "2015-02-23T06:24:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 278,
    "diffHunk" : "@@ -1,1 +276,280 @@\n        function containsSpaceOrAsterisk(text: string): boolean {\n            for (var i = 0; i < text.length; i++) {\n                var ch = text.charCodeAt(i);\n                if (ch === CharacterCodes.space || ch === CharacterCodes.asterisk) {"
  },
  {
    "id" : "800e565d-8a07-40be-97a5-f47873401b0e",
    "prId" : 2094,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af2eeb1d-c8ed-48e1-aea0-c37b6f1614e3",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Change \"that if\" to \"is that it\"\n",
        "createdAt" : "2015-02-23T06:28:33Z",
        "updatedAt" : "2015-02-23T06:28:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "06a278458adec76b646354a779c2609b89888318",
    "line" : 306,
    "diffHunk" : "@@ -1,1 +304,308 @@            //\n            // 1) Break the segment passed in into words.  Breaking is rather simple and a\n            //    good way to think about it that if gives you all the individual alphanumeric words\n            //    of the pattern.\n            //"
  }
]
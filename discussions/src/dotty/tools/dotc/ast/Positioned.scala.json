[
  {
    "id" : "9cb17931-19c2-4ee5-99b8-6232f5f87a68",
    "prId" : 1154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e03ebb8-1d6a-4527-ae1c-159d1e83dafa",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "So what was wrong with the previous version of this method? And was it impossible to write the new version using recursive calls? I think it'd be helpful to add some comments explaining how this algorithm work and what are the invariants for all the mutable variables.\n",
        "createdAt" : "2016-03-12T19:35:11Z",
        "updatedAt" : "2016-03-14T09:02:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c18e37886e90d217579112ccf867c22658273be",
    "line" : null,
    "diffHunk" : "@@ -1,1 +66,70 @@   *  as a while loop with a termination by return in the middle.\n   */\n  private def setChildPositions(pos: Position): Unit = {\n    var n = productArity                    // subnodes are analyzed right to left\n    var elems: List[Any] = Nil              // children in lists still to be considered, from right to left"
  }
]
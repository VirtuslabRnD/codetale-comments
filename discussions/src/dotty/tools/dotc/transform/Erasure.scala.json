[
  {
    "id" : "e87a49fd-7557-45ac-a031-4cca8961f8da",
    "prId" : 411,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02bf3852-dcf1-4ebc-bd7d-0032a52d684a",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "in this branch `!(tree.tpe isRef defn.NullClass)`, I'm not getting what is happening in this branch.\n",
        "createdAt" : "2015-03-28T22:06:03Z",
        "updatedAt" : "2015-05-01T12:04:42Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "4d6fbe10-0c4b-4829-abc4-ac006df13fad",
        "parentId" : "02bf3852-dcf1-4ebc-bd7d-0032a52d684a",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Ok, I get it. You are synthesizing zero of respective type. Please add a comment(or better, rename variables) to indicate this. \n",
        "createdAt" : "2015-03-28T22:07:09Z",
        "updatedAt" : "2015-05-01T12:04:42Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "ff733c1f-1e67-4548-a095-195f2b8bed6a",
        "parentId" : "02bf3852-dcf1-4ebc-bd7d-0032a52d684a",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "What variable renaming do you think would be appropriate?\n",
        "createdAt" : "2015-03-28T22:10:08Z",
        "updatedAt" : "2015-05-01T12:04:42Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "e18da129-e38d-40c8-a15c-002fa403be44",
        "parentId" : "02bf3852-dcf1-4ebc-bd7d-0032a52d684a",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "`unboxedNull` -> `zeroOfValueType`\n",
        "createdAt" : "2015-03-28T22:12:25Z",
        "updatedAt" : "2015-05-01T12:04:42Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d012f93635184dc8aa6325b715a133861c74ab08",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +184,188 @@            else if (!(tree.tpe <:< clazz.typeRef)) {\n              assert(!(tree.tpe.typeSymbol.isPrimitiveValueClass))\n              val nullTree = Literal(Constant(null))\n              val unboxedNull = adaptToType(nullTree, underlying)\n"
  },
  {
    "id" : "8f295a35-8385-4e9a-8b2b-caf77e1eaa66",
    "prId" : 147,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1bc3b593-218e-416f-bb89-aa6b25f561c7",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "Why widen only `treeElem`? Meta-comment: this is prone to fiddling if not documented why one needs to be widened but not the other.\n",
        "createdAt" : "2014-07-29T11:54:59Z",
        "updatedAt" : "2014-08-03T15:46:37Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "a622b193-7624-47d0-b9bb-c4a058bf8628",
        "parentId" : "1bc3b593-218e-416f-bb89-aa6b25f561c7",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think ptElem should not be a singleton type here. That should be erased away. I'll add an assertion to verify that fact.\n",
        "createdAt" : "2014-07-29T12:40:23Z",
        "updatedAt" : "2014-08-03T15:46:37Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3f49de5de32eca71621c77494d5ccd284599e68",
    "line" : null,
    "diffHunk" : "@@ -1,1 +141,145 @@      else (tree.tpe, pt) match {\n        case (defn.ArrayType(treeElem), defn.ArrayType(ptElem))\n        if treeElem.widen.isPrimitiveValueType && !ptElem.isPrimitiveValueType =>\n          // See SI-2386 for one example of when this might be necessary.\n          cast(runtimeCall(nme.toObjectArray, tree :: Nil), pt)"
  },
  {
    "id" : "4f8243dc-9735-4103-8352-a81d0c8c768d",
    "prId" : 140,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "667860d4-a469-4696-8117-1ee56fe672e1",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Why was check for idempotence replaced by purity check? \n",
        "createdAt" : "2014-07-11T14:30:37Z",
        "updatedAt" : "2014-07-17T09:54:35Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "14b206cb-4c57-4b53-a53f-7cf6123fcc51",
        "parentId" : "667860d4-a469-4696-8117-1ee56fe672e1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Because idempotent is wrong, semantically. Only pure statements can be dropped.\n",
        "createdAt" : "2014-07-14T12:52:17Z",
        "updatedAt" : "2014-07-17T09:54:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "736dceb837d059df35c12f2d35fbbe0bf0f9f8f5",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +87,91 @@\n    def constant(tree: Tree, const: Tree)(implicit ctx: Context) =\n      if (isPureExpr(tree)) Block(tree :: Nil, const) else const\n\n    final def box(tree: Tree, target: => String = \"\")(implicit ctx: Context): Tree = ctx.traceIndented(i\"boxing ${tree.showSummary}: ${tree.tpe} into $target\") {"
  },
  {
    "id" : "e8b1a13a-8ebe-4a78-a9e1-88d67bbb59dd",
    "prId" : 109,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6f45057f-593b-48d6-a2d5-fb5359887a31",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Replace traverse thingy and accumulator by a `zip` with `flatMap`. E.g.\n\n```\nassert(after.size == before.size)\nfor {\n  (oldMember, newMember) <- before zip after\n  bridge <- calcBridges(oldMember, newMember)\n} yield bridge\n```\n\nIt is very hard to understand like this what traverse does.\n",
        "createdAt" : "2014-04-03T12:29:39Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "3fc8d281-48f4-4853-a34e-fcef5551c40b",
        "parentId" : "6f45057f-593b-48d6-a2d5-fb5359887a31",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Hmmm.. I guess I'm proving my own point. Since the subsequent iterations depend on the previous, you should probably use a fold.\n",
        "createdAt" : "2014-04-03T12:36:02Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "897389c0-0b46-43e0-9ee7-bcba1a4d446e",
        "parentId" : "6f45057f-593b-48d6-a2d5-fb5359887a31",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "I'd say that thisn't so good idea as it looks like.\nHonestly, zip is really bad in terms of both memory and cpu, and your approach will require huge memory allocations, as it will create a collection of tuples and a collection for every tuple.\nI'd rather improve documentation around, as current implementation doesn't allocate anything except the result\n",
        "createdAt" : "2014-04-03T13:07:35Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "609daf7f-0522-4944-b49f-6892139713f3",
        "parentId" : "6f45057f-593b-48d6-a2d5-fb5359887a31",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "But, when(if?) we'll have a good fusion in place I'd totaly agree with you.\n",
        "createdAt" : "2014-04-03T13:14:13Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "60478a67-1443-46af-b635-d0e5a261f22a",
        "parentId" : "6f45057f-593b-48d6-a2d5-fb5359887a31",
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "If you don't want to do a `zip`, then please at least make it a (disguised) while loop and use `head` and `tail` instead of the nested pattern match. It is really extremely hard to read.\n",
        "createdAt" : "2014-04-04T06:55:55Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b50b29cb9e8b43fff1d012dd53561b5ac0a437c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +272,276 @@      def traverse(after: List[Tree], before: List[untpd.Tree],\n                   emittedBridges: ListBuffer[tpd.DefDef] = ListBuffer[tpd.DefDef]()): List[tpd.DefDef] = {\n        after match {\n          case Nil => emittedBridges.toList\n          case (member: DefDef) :: newTail =>"
  },
  {
    "id" : "ebf90cdf-e684-4b31-9a8e-a03dda62da4b",
    "prId" : 109,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "054b59af-b25c-4ec3-b658-69ca8eb88af5",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Consider moving the `if` into the for loop\n",
        "createdAt" : "2014-04-03T12:31:38Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      },
      {
        "id" : "dbb667df-d90a-43d9-a5a4-389b51195604",
        "parentId" : "054b59af-b25c-4ec3-b658-69ca8eb88af5",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "this if depends on the element of the loop.\nIf i will add computation of this isRequired to the loop, i'd say it would be a lot harder to read \n",
        "createdAt" : "2014-04-03T13:01:19Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b50b29cb9e8b43fff1d012dd53561b5ac0a437c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +291,295 @@                  val isRequired = minimalSet.forall(nxtBridge => !(bridge.info =:= nxtBridge.info))\n\n                  if (isRequired) {\n                    // check for clashes\n                    val clash: Option[Symbol] = oldSymbol.owner.decls.lookupAll(bridge.name).find {"
  },
  {
    "id" : "0ad60073-3362-41ff-818e-dc690ed744f2",
    "prId" : 109,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57e0fb7a-4179-4e9a-a1bb-16f0a3d93021",
        "parentId" : null,
        "authorId" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "body" : "Consider replacing the mutable set by a `fold` over `needsBridges` / `neededBridges`.\n",
        "createdAt" : "2014-04-03T12:33:59Z",
        "updatedAt" : "2014-04-04T16:59:34Z",
        "lastEditedBy" : "f186a0ec-8fc4-4e94-87e9-c629d1b38b60",
        "tags" : [
        ]
      }
    ],
    "commit" : "0b50b29cb9e8b43fff1d012dd53561b5ac0a437c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +286,290 @@                val neededBridges = oldOverriden -- newOverriden\n\n                var minimalSet = Set[Symbol]()\n                // compute minimal set of bridges that are needed:\n                for (bridge <- neededBridges) {"
  }
]
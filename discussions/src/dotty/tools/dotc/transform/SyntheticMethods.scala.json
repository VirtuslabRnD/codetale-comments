[
  {
    "id" : "1876483d-b13b-4732-9c91-dc858d9e0ce0",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "257bc879-4bfc-4ada-a74e-0ab316d946cc",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "This looks very ugly to me: scalaClassName takes a type and converts it to symbol just to take its name.\nIf we have `TypeRef`s hash-consed(on names), why do not we rely on it?\n",
        "createdAt" : "2015-11-09T16:18:41Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "e10672a8-b50e-4ee2-b07c-393e4f2d5fd9",
        "parentId" : "257bc879-4bfc-4ada-a74e-0ab316d946cc",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "TypeRefs are not canonical. Different typerefs can represent the same type (I did it first with typerefs and then learned the hard way that this will not work). Example:\n\n```\nTypeRef(TermRef(ThisType(<root>), scala), Array)\n```\n\nand\n\n```\nTypeRef(ThisType(scala), Array)\n```\n",
        "createdAt" : "2015-11-09T18:59:49Z",
        "updatedAt" : "2015-11-09T19:00:58Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +163,167 @@    /** The hashCode implementation for given symbol `sym`. */\n    def hashImpl(sym: Symbol)(implicit ctx: Context): Tree =\n      defn.scalaClassName(sym.info.finalResultType) match {\n        case tpnme.Unit | tpnme.Null               => Literal(Constant(0))\n        case tpnme.Boolean                         => If(ref(sym), Literal(Constant(1231)), Literal(Constant(1237)))"
  }
]
[
  {
    "id" : "b06b0b7b-085f-495f-9ac3-a605998d0058",
    "prId" : 734,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1567d709-0287-40b7-8b6a-e1d8b21796b3",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "some types don't have symbols before erasure. I'd add \n\n``` scala\ndef runsAfter = Set(classOf[Erasure])\n```\n",
        "createdAt" : "2015-07-25T11:35:11Z",
        "updatedAt" : "2015-07-27T18:19:04Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "53bb76aa-15b1-402e-a326-7369f7fe8242",
        "parentId" : "1567d709-0287-40b7-8b6a-e1d8b21796b3",
        "authorId" : "16f853ec-70c8-423e-8111-3cbd675c9428",
        "body" : "I thought that order in `Compiler` is enough for phases ordering. Why do we explicitly need `runsAfter`? \n",
        "createdAt" : "2015-07-25T12:08:27Z",
        "updatedAt" : "2015-07-27T18:19:04Z",
        "lastEditedBy" : "16f853ec-70c8-423e-8111-3cbd675c9428",
        "tags" : [
        ]
      },
      {
        "id" : "fb985478-1c2d-43ac-8ab0-28ff40489fca",
        "parentId" : "1567d709-0287-40b7-8b6a-e1d8b21796b3",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "> I thought that order in Compiler is enough for phases ordering\n\nIt is enough.\n\n> Why do we explicitly need runsAfter? \n\nWe have a checks, before building compiler pipeline that ensures that those `runsAfter` are followed. This is very handy if someone wants to play around with phase ordering, as it makes dependencies explicit. \n",
        "createdAt" : "2015-07-25T12:39:39Z",
        "updatedAt" : "2015-07-27T18:19:04Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d24c6945963198566cd8e97e6bcacf6ebe2127dc",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +29,33 @@      case Apply(Select(qual, nme.getClass_), Nil) =>\n        val defn = ctx.definitions\n        val claz = qual.tpe.classSymbol\n\n        def TYPE(module: TermSymbol) = ref(module).select(nme.TYPE_).ensureConforms(tree.tpe)"
  }
]
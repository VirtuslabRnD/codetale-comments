[
  {
    "id" : "f26a2125-bc96-4fee-867e-b1f3451d66f4",
    "prId" : 1270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fe78374-4113-4c45-b41b-b17f1c026181",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why not change the definition of `isDefinedInCurrentRun` ?\n",
        "createdAt" : "2016-05-20T15:20:18Z",
        "updatedAt" : "2016-05-23T13:54:05Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "a4b35acc-a14f-4873-a03b-c5fd9c0e4174",
        "parentId" : "4fe78374-4113-4c45-b41b-b17f1c026181",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Because it's used elsewhere to mean: In a compilation unit that's currently being compiled. \n",
        "createdAt" : "2016-05-20T17:06:49Z",
        "updatedAt" : "2016-05-23T13:54:05Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c996e42224eedaf3b097fea0c6175eba7d3cbe63",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +399,403 @@    /** Subclass tests and casts */\n    final def isTerm(implicit ctx: Context): Boolean =\n      (if (defRunId == ctx.runId) lastDenot else denot).isTerm\n\n    final def isType(implicit ctx: Context): Boolean ="
  },
  {
    "id" : "f6f78902-f79c-456b-a06d-cfa5f60bfea7",
    "prId" : 436,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1462acb1-5179-4b6c-a12a-38ea2a3459aa",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "- Add a doc comment. \n- Formatting: if (.\n- It's more common to pass owner as a symbol\n- \"ret\" is not descriptive.\n- In this case, I do not think the named parameters add anything. All arguments make it clear by their names already what parameter they are for.\n\nI'd reformulate as follows:\n\n```\ndef synthesizeCompanionMethod(target: Symbol, owner: Symbol)(implicit ctx: Context) = \n  if (target.exists && owner.exists) {\n    val name = if (target is Module) nme.COMPANION_MODULE_METHOD else nme.COMPANION_CLASS_METHOD\n    ctx.newSymbol(owner, name, Flags.Synthetic | Flags.Private, ExprType(target.typeRef)\n  }\n  else NoSymbol\n```\n",
        "createdAt" : "2015-03-28T18:52:51Z",
        "updatedAt" : "2015-04-02T14:30:29Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1a0e38c1-6579-4f2f-94e1-0039e3131a2e",
        "parentId" : "1462acb1-5179-4b6c-a12a-38ea2a3459aa",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Defining method name based on flags doesn't work here: in order to not force type you will need `flagsUNSAFE`, and tests suggest that Module could still be unset.\n",
        "createdAt" : "2015-04-02T14:32:19Z",
        "updatedAt" : "2015-04-02T14:32:19Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5618d29e37ad50bd1b8c591ed50db63a6d7bc79",
    "line" : null,
    "diffHunk" : "@@ -1,1 +171,175 @@    } else NoSymbol\n\n  /** Create a package symbol with associated package class\n   *  from its non-info fields and a lazy type for loading the package's members.\n   */"
  }
]
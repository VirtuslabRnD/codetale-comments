[
  {
    "id" : "3c19a645-3d92-4199-8e55-c4e86007a1f8",
    "prId" : 1677,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1677#pullrequestreview-7455145",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e94e3e5e-c6c9-4a9e-8a49-77fcccfc62b1",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is the `butNot` still necessary? Do accessors get the inline flag too somehow?\n",
        "createdAt" : "2016-11-07T16:26:05Z",
        "updatedAt" : "2016-11-07T17:42:17Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "eb904361-07d8-4505-b253-0769154911cd",
        "parentId" : "e94e3e5e-c6c9-4a9e-8a49-77fcccfc62b1",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "They might if we have an accessor of an inline val. Better play it safe.\n",
        "createdAt" : "2016-11-07T16:48:08Z",
        "updatedAt" : "2016-11-07T17:42:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2e02b292cca07f8b619aba0e03dca878e22c415f",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +752,756 @@    def isSkolem: Boolean = name == nme.SKOLEM\n\n    def isInlineMethod(implicit ctx: Context): Boolean = is(InlineMethod, butNot = Accessor) \n\n    // ------ access to related symbols ---------------------------------"
  },
  {
    "id" : "e4d4fd06-ed2c-4c12-bbcd-479ad94a9edc",
    "prId" : 1477,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0e5ee2c1-0995-40ac-9679-73fa76f2d496",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This reminds me of https://github.com/lampepfl/dotty/commit/4b0cc8aabf0dbbd74979faedee7371c41177b755 which fixed an issue with stale Java symbol and outer fields, are you sure that the stale outer field here is not incorrectly generated by Dotty?\n",
        "createdAt" : "2016-08-25T19:47:55Z",
        "updatedAt" : "2016-09-21T17:15:49Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9d670f4ce41662215799a728b145c6a2f6ab826",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +57,61 @@      !owner.isClass\n      || owner.isRefinementClass\n      || owner.is(Scala2x)\n      || (owner.unforcedDecls.lookupAll(denot.name) contains denot.symbol)\n      || denot.isSelfSym)"
  },
  {
    "id" : "5f1a15bc-01bd-471c-a956-a60bb901a078",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34451114-bdc8-4b5f-a78d-a146c55c8798",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "down to 22secs from 60secs with this change.\nNow, need to do something with `compareAliasedRefined` to get back to 2.5secs.\n",
        "createdAt" : "2016-07-05T15:44:27Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +1643,1647 @@      def isCachable(tp: Type): Boolean = tp match {\n        case _: TypeErasure.ErasedValueType => false\n        case tp: TypeRef if tp.symbol.isClass => true\n        case tp: TypeVar => tp.inst.exists && inCache(tp.inst)\n        case tp: TypeProxy => inCache(tp.underlying)"
  },
  {
    "id" : "a1bc1ccb-b457-4c20-92dc-70ee5b2e21f4",
    "prId" : 1186,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5856fa5-ce33-40c4-8a80-887c83509fc2",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Shouldn't we create a `NameFilter` instance that filters named type params directly instead?\n\n``` scala\n  object namedTypeParamNameFilter extends NameFilter {\n    def apply(pre: Type, name: Name)(implicit ctx: Context): Boolean =\n      name.isTypeName && {\n        val mbr = pre.member(name)\n        mbr.symbol.is(Deferred | TypeParam, butNot = ExpandedName) &&\n        mbr.info.isInstanceOf[RealTypeBounds]\n      }\n  }\n```\n",
        "createdAt" : "2016-04-06T12:33:48Z",
        "updatedAt" : "2016-04-06T12:34:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "f675ad9507089f8b912357fab86740653c1b8789",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +1224,1228 @@      def computeNamedTypeParams: Set[TypeSymbol] =\n        if (ctx.erasedTypes || is(Module)) Set() // fast return for modules to avoid scanning package decls\n        else memberNames(abstractTypeNameFilter).map(name =>\n          info.member(name).symbol.asType).filter(_.is(TypeParam, butNot = ExpandedName)).toSet\n      if (myNamedTypeParams == null) myNamedTypeParams = computeNamedTypeParams"
  },
  {
    "id" : "0d0e16f0-c8ca-4f7f-b670-77ae09aa04e4",
    "prId" : 598,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8d515ee9-91a3-48bb-bf65-9ae5055dc0de",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Neither name nor comment explains what this method does. Comment says nothing about class being numeric, and name of the method does not say anything about class being primitive. Methods tests for both of those.\n",
        "createdAt" : "2015-05-23T14:09:57Z",
        "updatedAt" : "2015-05-27T18:08:59Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "d07d669ae03ad4cb5eb8352bcbb5a0be7f3aa0f0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +388,392 @@\n    /** Is symbol a primitive numeric value class? */\n    def isNumericValueClass(implicit ctx: Context) = defn.ScalaNumericValueClasses contains symbol\n\n    /** Is symbol a phantom class for which no runtime representation exists? */"
  },
  {
    "id" : "80200812-b143-4ef3-a288-322c0a5791b4",
    "prId" : 564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "099b4ca3-b881-4c4a-886b-ac375818b5d9",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "what does `~` stand for?\n",
        "createdAt" : "2015-05-13T15:48:37Z",
        "updatedAt" : "2015-05-13T15:48:37Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "45521484c5acb8f3174aebcd23674c0af955dc06",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +314,318 @@        while (!encl.isClass && !encl.isPackageObject) {\n          encl = encl.owner\n          sep += \"~\"\n        }\n        if (owner.is(ModuleClass) && sep == \"$\") sep = \"\" // duplicate scalac's behavior: don't write a double '$$' for module class members."
  },
  {
    "id" : "fe26b135-bf8c-4849-952f-065106e2b795",
    "prId" : 251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8647c22b-0e91-40a0-831f-cf40f60fc556",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why was the method moved from SymUtils? \n",
        "createdAt" : "2014-12-12T17:36:04Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "19f10001-c697-46f6-b37e-61d2fbb5c9df",
        "parentId" : "8647c22b-0e91-40a0-831f-cf40f60fc556",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "I've intentionally moved it here to have isAnonymous**\\* in same location. What's your feeling about where those methods should belong to? they both apply only to SymDenotations and thus could either be here or in SymUtils.\n",
        "createdAt" : "2014-12-12T17:39:51Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "62bff3ee-5659-47a2-80b5-e1a78891b090",
        "parentId" : "8647c22b-0e91-40a0-831f-cf40f60fc556",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The idea is if a method is transform/backend only then it can be kept in SymUtils, the theory being that it is only an implementation detail, not something you need to know fundamentally about a symbol or type. isAnonymousClass is accessed from typer, so can't be moved. But your criterion of keeping isAnonymous methods together makes sense. So this patch LGTM.\n",
        "createdAt" : "2014-12-12T17:51:42Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c112037290a526c66bbb782a61bcd8a60730b4b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +325,329 @@      isClass && (initial.asSymDenotation.name startsWith tpnme.ANON_CLASS)\n\n    final def isAnonymousFunction(implicit ctx: Context) =\n      this.symbol.is(Method) && (initial.asSymDenotation.name startsWith nme.ANON_FUN)\n"
  },
  {
    "id" : "6b3e8319-e307-46f3-bac9-18443174c188",
    "prId" : 147,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c9e572f-7ad5-49b5-a977-8859781a0d91",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "`exists && ...`? Or suitable override in `NoSymbol`?\n",
        "createdAt" : "2014-07-29T11:52:53Z",
        "updatedAt" : "2014-08-03T15:46:37Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "600a57cc-27f8-41b9-b7a1-72bfce1e93f2",
        "parentId" : "4c9e572f-7ad5-49b5-a977-8859781a0d91",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "maybeOwner is that override already. It's NoSymbol for NoSymbol, so NoSymbol cannot have a class owner.\n",
        "createdAt" : "2014-07-29T12:33:14Z",
        "updatedAt" : "2014-08-03T15:46:37Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "aa28d7d9-b0b8-43a0-8f5e-6a4940141ed8",
        "parentId" : "4c9e572f-7ad5-49b5-a977-8859781a0d91",
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : ":+1: \n",
        "createdAt" : "2014-07-29T12:34:02Z",
        "updatedAt" : "2014-08-03T15:46:37Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      }
    ],
    "commit" : "d3f49de5de32eca71621c77494d5ccd284599e68",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +738,742 @@     */\n    final def canMatchInheritedSymbols(implicit ctx: Context): Boolean =\n      maybeOwner.isClass && !isConstructor && !is(Private)\n\n    /** The symbol, in class `inClass`, that is overridden by this denotation. */"
  },
  {
    "id" : "4b71f856-b759-47b3-9710-d00773990387",
    "prId" : 140,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0616053a-70fc-4b67-b7b7-ba7fb3f69590",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "For now we have two methods of reporting error. \nMost methods in failure return a `NoDenotation` or `NoSymbol`. But some throw an exception, like this. \nFor now one needs to remember which methods use which type of error reporting. \nMaybe it would be more uniform to make `owner` return `NoSymbol` for `NoDenotation` and remove need for `maybeOwner`?\n",
        "createdAt" : "2014-07-11T14:42:33Z",
        "updatedAt" : "2014-07-17T09:54:35Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "00c52710-64d8-4875-a9fc-5aefe2b0fb98",
        "parentId" : "0616053a-70fc-4b67-b7b7-ba7fb3f69590",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "In general, it's an important sanity check that owner of NoDenotation does not exist. Otherwise, we'd turn every crawling up the owner chain into an infinite loop instead of an assertion error.\n",
        "createdAt" : "2014-07-14T12:53:26Z",
        "updatedAt" : "2014-07-17T09:54:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "736dceb837d059df35c12f2d35fbbe0bf0f9f8f5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +85,89 @@\n    /** Same as owner, except returns NoSymbol for NoSymbol */\n    def maybeOwner: Symbol = if (exists) owner else NoSymbol\n\n    /** The flag set */"
  },
  {
    "id" : "a0266ac3-ebbb-45d3-87ee-322843014c8a",
    "prId" : 140,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f2222bd-01a8-492d-8479-0eaaeb69677c",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "`copyAnnotations`?\n",
        "createdAt" : "2014-07-11T14:43:06Z",
        "updatedAt" : "2014-07-17T09:54:35Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "6d2bbbf8-7542-4f45-a86b-d92028ba001a",
        "parentId" : "1f2222bd-01a8-492d-8479-0eaaeb69677c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The whole imperative annotations thing is not ideal. We should try to make annotations immutable.\n",
        "createdAt" : "2014-07-14T12:54:07Z",
        "updatedAt" : "2014-07-17T09:54:35Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "736dceb837d059df35c12f2d35fbbe0bf0f9f8f5",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +221,225 @@\n    /** Copy all annotations from given symbol by adding them to this symbol */\n    final def addAnnotations(from: Symbol)(implicit ctx: Context): Unit =\n      from.annotations.foreach(addAnnotation)\n"
  },
  {
    "id" : "ab6a4cc9-8354-4f99-9732-f495a1072f0c",
    "prId" : 137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39daef19-0392-4104-9237-e195c63a30d4",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "`&& !isFinal` for further optimization?\n",
        "createdAt" : "2014-06-25T16:54:11Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "f82584d0-c16f-4766-bfcf-12dae206fd09",
        "parentId" : "39daef19-0392-4104-9237-e195c63a30d4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Don't understand: we are looking for the symbols which this symbol overrides. Finality of the overriding symbol does not change anything. \n",
        "createdAt" : "2014-06-26T10:26:13Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e710af6ad48b9c2749785e68aee1e4195d7264bb",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +708,712 @@    /** All symbols overriden by this denotation. */\n    final def allOverriddenSymbols(implicit ctx: Context): Iterator[Symbol] =\n      if (exists && owner.isClass)\n        owner.info.baseClasses.tail.iterator map overriddenSymbol filter (_.exists)\n      else"
  }
]
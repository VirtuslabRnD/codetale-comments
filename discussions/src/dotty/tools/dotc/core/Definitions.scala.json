[
  {
    "id" : "0a376374-c836-428f-bf06-903a18658935",
    "prId" : 1413,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e39b7b52-5240-42ce-a144-88949191b177",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "`MaxFunctionArity` should be 44 as documented below.\n",
        "createdAt" : "2016-07-25T08:46:10Z",
        "updatedAt" : "2016-07-25T11:31:15Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "3d12f4ba-5853-490c-888e-8af09fc4c8f0",
        "parentId" : "e39b7b52-5240-42ce-a144-88949191b177",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Actually it is the doc that is off.\n",
        "createdAt" : "2016-07-25T08:48:29Z",
        "updatedAt" : "2016-07-25T11:31:15Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "a42c4eccdbb623d4f00b406e6985336deb4f3922",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +14,18 @@object Definitions {\n  val MaxTupleArity, MaxAbstractFunctionArity = 22\n  val MaxFunctionArity = 24\n    // Awaiting a definite solution that drops the limit altogether, 24 gives a safety\n    // margin over the previous 22, so that treecopiers in miniphases are allowed to"
  },
  {
    "id" : "43ca99d4-deb2-4586-8171-937288061017",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "776b688c-0588-4cb6-b795-7ecdd210ac38",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "maybe rename to `Sys_errorRef`?\n",
        "createdAt" : "2015-11-09T15:55:21Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +129,133 @@  // fundamental modules\n  lazy val SysPackage = ctx.requiredModule(\"scala.sys.package\")\n    lazy val Sys_errorR = SysPackage.moduleClass.requiredMethodRef(nme.error)\n    def Sys_error(implicit ctx: Context) = Sys_errorR.symbol\n"
  },
  {
    "id" : "d0e707de-d8e1-4aff-8f94-c92807dc1c0d",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d886bee-313e-4f45-ae74-49ffe78bba0b",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "`Predef_conformsRef`\n",
        "createdAt" : "2015-11-09T15:56:10Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +217,221 @@  def ScalaPredefModule(implicit ctx: Context) = ScalaPredefModuleRef.symbol\n\n    lazy val Predef_conformsR = ScalaPredefModule.requiredMethodRef(\"$conforms\")\n    def Predef_conforms(implicit ctx: Context) = Predef_conformsR.symbol\n"
  },
  {
    "id" : "31995b20-5799-4415-b235-9b4a3ed596b3",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ace26601-6387-44fc-a0e7-7e8a6e7e5ede",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "`ScalaRuntime_dropRef`\n",
        "createdAt" : "2015-11-09T15:56:28Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +225,229 @@\n    def runtimeMethodRef(name: PreName) = ScalaRuntimeModule.requiredMethodRef(name)\n    def ScalaRuntime_dropR(implicit ctx: Context) = runtimeMethodRef(nme.drop)\n    def ScalaRuntime_drop(implicit ctx: Context) = ScalaRuntime_dropR.symbol\n"
  },
  {
    "id" : "2862a092-f7b0-489a-965b-c98440cb1138",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57f33e72-b908-4c3e-8af7-2d90e2d566c7",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "StringAdd_plusRef\n",
        "createdAt" : "2015-11-09T15:58:51Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "5a0963b2-168d-43e2-9fcb-f91ebe813d8d",
        "parentId" : "57f33e72-b908-4c3e-8af7-2d90e2d566c7",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It's systematic R instead of Ref. But it's probably better to make them private anyway.\n",
        "createdAt" : "2015-11-09T16:01:01Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "9b57ce05-296a-4880-94ad-35e1f97dc657",
        "parentId" : "57f33e72-b908-4c3e-8af7-2d90e2d566c7",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Currently, a lot of lazy vals use `Ref` and only several use `R`. I would prefer the first, but even if we go with second is better to be systematic.\n",
        "createdAt" : "2015-11-09T16:02:37Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 364,
    "diffHunk" : "@@ -1,1 +391,395 @@  def StringAddClass(implicit ctx: Context) = StringAddType.symbol.asClass\n\n    lazy val StringAdd_plusR = StringAddClass.requiredMethodRef(nme.raw.PLUS)\n    def StringAdd_+(implicit ctx: Context) = StringAdd_plusR.symbol\n"
  },
  {
    "id" : "54aa38ca-997c-44c9-b69d-6702acb121f9",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a624874c-ef22-44a9-a492-ab07b4e80253",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Product_canEqualRef\n",
        "createdAt" : "2015-11-09T15:59:01Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 381,
    "diffHunk" : "@@ -1,1 +408,412 @@  lazy val ProductType: TypeRef                 = ctx.requiredClassRef(\"scala.Product\")\n  def ProductClass(implicit ctx: Context) = ProductType.symbol.asClass\n    lazy val Product_canEqualR = ProductClass.requiredMethodRef(nme.canEqual_)\n    def Product_canEqual(implicit ctx: Context) = Product_canEqualR.symbol\n    lazy val Product_productArityR = ProductClass.requiredMethodRef(nme.productArity)"
  },
  {
    "id" : "0a79c4d4-4ca3-495d-ab44-c35e65a9b58c",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80e5ad32-d6a1-4c96-92f0-019d0a058d35",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Product_productArityRef\n",
        "createdAt" : "2015-11-09T15:59:06Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 383,
    "diffHunk" : "@@ -1,1 +410,414 @@    lazy val Product_canEqualR = ProductClass.requiredMethodRef(nme.canEqual_)\n    def Product_canEqual(implicit ctx: Context) = Product_canEqualR.symbol\n    lazy val Product_productArityR = ProductClass.requiredMethodRef(nme.productArity)\n    def Product_productArity(implicit ctx: Context) = Product_productArityR.symbol\n    lazy val Product_productPrefixR = ProductClass.requiredMethodRef(nme.productPrefix)"
  },
  {
    "id" : "78066a66-da0a-4eaf-9c5c-d8b16f389e1f",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83ffc088-094b-4304-ad6e-1309fd9cacdf",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Product_productPrefixRef\n",
        "createdAt" : "2015-11-09T15:59:12Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 385,
    "diffHunk" : "@@ -1,1 +412,416 @@    lazy val Product_productArityR = ProductClass.requiredMethodRef(nme.productArity)\n    def Product_productArity(implicit ctx: Context) = Product_productArityR.symbol\n    lazy val Product_productPrefixR = ProductClass.requiredMethodRef(nme.productPrefix)\n    def Product_productPrefix(implicit ctx: Context) = Product_productPrefixR.symbol\n  lazy val LanguageModuleRef          = ctx.requiredModule(\"dotty.language\")"
  },
  {
    "id" : "351a0bfb-e92d-4a2b-b0d7-e4edd4c8bf57",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a48c8f34-7e89-499d-a757-fae802dd08e7",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Could we please maintain the old name `FunctionType`? \nI do not think that new name is substantially better to justify source incompatibility with various unmerged branches.\n",
        "createdAt" : "2015-11-09T16:03:26Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "f6f7811a-e7d2-41dc-a3b6-df58d26617f6",
        "parentId" : "a48c8f34-7e89-499d-a757-fae802dd08e7",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Additionally, this change pollutes the history, as around 30% of changed lines in this PR are changed only because of those renamings.\n",
        "createdAt" : "2015-11-09T16:11:51Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 523,
    "diffHunk" : "@@ -1,1 +505,509 @@    sym.owner.linkedClass.typeRef\n\n  object FunctionOf {\n    def apply(args: List[Type], resultType: Type)(implicit ctx: Context) =\n      FunctionType(args.length).appliedTo(args ::: resultType :: Nil)"
  },
  {
    "id" : "accc77d1-6772-4486-b0cf-7d4b350e6180",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21c4105d-5813-47fc-b4cc-21ffe49c06cd",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Same comment as for `FunctionOf`.\n",
        "createdAt" : "2015-11-09T16:03:43Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 543,
    "diffHunk" : "@@ -1,1 +520,524 @@  }\n\n  object ArrayOf {\n    def apply(elem: Type)(implicit ctx: Context) =\n      if (ctx.erasedTypes) JavaArrayType(elem)"
  },
  {
    "id" : "f4ca19ff-037f-43ac-94c4-2b5cf9cc08b8",
    "prId" : 928,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15e9966c-a8f4-471d-b1b7-cb9bcc749a85",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Do we still need this initialization?\n",
        "createdAt" : "2015-11-09T16:06:09Z",
        "updatedAt" : "2015-11-09T18:36:54Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "949c48e0f325afa29ebc70e94de17d525b26386e",
    "line" : 801,
    "diffHunk" : "@@ -1,1 +788,792 @@    if (!_isInitialized) {\n      // force initialization of every symbol that is synthesized or hijacked by the compiler\n      val forced = syntheticCoreClasses ++ syntheticCoreMethods ++ ScalaValueClasses()\n      _isInitialized = true\n    }"
  },
  {
    "id" : "105be480-5c9e-493f-8e7d-97798fc140ff",
    "prId" : 388,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Could this package be instead implemented, instead of being synthesized?\nIE it could actually contain, eg java\\javascript\\assembly implemented methods, such as Throw and primitive array operations that were suggested.\n",
        "createdAt" : "2015-03-04T15:28:26Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "dc92adb4-dd9a-49e6-a78e-fd3a1ccf5907",
        "parentId" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "If you're hoping for _actual_ implementations being used in real life: at least for JS, it cannot. Because there is no such thing as creating IR nodes from anything but Scala source code. So you would still need a Scala source code that would actually produce a `Throw` node, and not forward it again to ... itself.\n",
        "createdAt" : "2015-03-04T15:41:47Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "e3394fa3-f942-4fe8-9220-8bf37c8b762d",
        "parentId" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That package exists: It's called scala.runtime. What I am after is a container for methods such as array indexing which HAVE to be treated specially by the backend. And then I would argue that it's better that the package does not really exist, because otherwise we might end up accidentally with non-sensical calls.\n",
        "createdAt" : "2015-03-04T15:45:30Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "06a1111a-cf55-4893-b4e2-9d9b81d9ce91",
        "parentId" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "@sjrd can you call to javascript from ScalaJS? Then you can just remove special handling of it entirely. Indeed, `throw` method implementation cannot be written in scala, but you already intercept some methods, eg identityHashCode as far as I know.\n\n@odersky, in case of `throw` why is it required to treat it specially by compiler? Can't it be normal call to normal java method, which will just `throw` the Throwable that was given to it?\nThis will allow to remove of special handling of `throw` in JVM backend. But array ops indeed need special handling.\n",
        "createdAt" : "2015-03-04T17:27:55Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "215e86fa-7fb4-49ae-b30b-35bc0469ea5e",
        "parentId" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Yes, sure, Scala.js can call JS. But JS code is opaque to the optimizer, so it cannot inline these methods. And there are some things the JS code _cannot_ do, for example get/set/length of an array, because a Scala Array is opaque to JS.\n\nIntercepted methods (intrinsics) are only intercepted when the optimizer is enabled. It is not acceptable to _require_ it. Even identityHashCode has a valid implementation in Scala.js code, which is used when the optimizer is not there to intercept it.\n\nSo there's no way to do this but for the back-end to capture these method calls as primitives. Primitives are different from intrinsics in that they _have_ to be intercepted by the back-end and transformed into special IR nodes. Intrinsics are normal method calls, with a valid implementation, but which can optionally be intercepted by the optimizer to use a more efficient implementation.\n",
        "createdAt" : "2015-03-04T19:23:27Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "b559d3bf-6092-4780-b679-1cc63903f233",
        "parentId" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "`throw` doesn't have to be intercepted, this could just go to JS, which will just throw whataver was the argument. If optimizer is not present, that's just a method call. If it's present - you can intensify such calls. It's not _required_ to intensify such calls - as if compiled as calls to either JS or Java defined method they will perfectly run. \n\nI'm still not getting why `throw` _has_ to be intrensified - it could just be some method in `scala.runtime.*` written in java, or javascript. But I totally agree about arrays.\n",
        "createdAt" : "2015-03-04T19:39:03Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "c5a573ca-a90f-44b0-8120-f6995a29946c",
        "parentId" : "4d7ec6ad-fff3-43ce-8dc7-45572355c6d0",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "You're right, `throw` could be a non-inlined method call to JS. But it would require _some_ \"library\" JS to be shipped with every Scala.js output, though, which would not be nice. Of course we have built-in JS ([scalajsenv.js](https://github.com/scala-js/scala-js/blob/master/tools/scalajsenv.js)), but these are part of the the lambda surrounding the Scala.js code, and hence do not leak in the outer JS scope. That `throw` function would need to be leaked in order to be callable from Scala.js code (ironically).\n",
        "createdAt" : "2015-03-04T19:48:19Z",
        "updatedAt" : "2015-03-05T21:08:05Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "d274f4d4e0601e44524aae842c8581a2c6ecafd7",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +103,107 @@  lazy val EmptyPackageClass = EmptyPackageVal.moduleClass.asClass\n\n  /** A package in which we can place all methods that are interpreted specially by the compiler */\n  lazy val OpsPackageVal = ctx.newCompletePackageSymbol(RootClass, nme.OPS_PACKAGE).entered\n  lazy val OpsPackageClass = OpsPackageVal.moduleClass.asClass"
  },
  {
    "id" : "d2961fbd-472e-4163-b2a9-6388118a572e",
    "prId" : 124,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f341693d-5ab5-47a7-9a34-8b60054678ef",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Not sure if it matters in Dotty, but in scalac these should be `def`-s, not `vals`. Why? Subsequent runs of the compiler might recompile `Array` (this happens if you navigate to its sources in Scala IDE, for example), which would result in new symbols for its members.\n\nThat's why I split out `RunDefinitions` in scalac, so we could have correctness and speed.\n",
        "createdAt" : "2014-05-06T14:11:04Z",
        "updatedAt" : "2014-05-06T14:18:53Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "ebd2df18-acd2-4365-8cfe-4ce5f4764bf8",
        "parentId" : "f341693d-5ab5-47a7-9a34-8b60054678ef",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "For Dotty definitions are part of context and I would say that in case discarding is required, the better approach would be to discard context itself.\n",
        "createdAt" : "2014-05-06T14:12:21Z",
        "updatedAt" : "2014-05-06T14:18:53Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "e2467e2e-f6d9-4884-bf24-37db0adc1f0c",
        "parentId" : "f341693d-5ab5-47a7-9a34-8b60054678ef",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Agreed we should do the same thing. (Keep them as lazyvals but break them\nout into a new class) It's planned by has not been done yet. - Martin\n\nOn Tue, May 6, 2014 at 4:11 PM, Jason Zaugg notifications@github.comwrote:\n\n> In src/dotty/tools/dotc/core/Definitions.scala:\n> \n> > @@ -168,6 +170,10 @@ class Definitions {\n> >        List(AnyClass.typeRef), EmptyScope)\n> >    lazy val SeqClass: ClassSymbol = ctx.requiredClass(\"scala.collection.Seq\")\n> >    lazy val ArrayClass: ClassSymbol = ctx.requiredClass(\"scala.Array\")\n> > -    lazy val Array_apply                 = ctx.requiredMethod(ArrayClass, nme.apply)\n> > -    lazy val Array_update                = ctx.requiredMethod(ArrayClass, nme.update)\n> > -    lazy val Array_length                = ctx.requiredMethod(ArrayClass, nme.length)\n> > -    lazy val Array_clone                 = ctx.requiredMethod(ArrayClass, nme.clone_)\n> \n> Not sure if it matters in Dotty, but in scalac these should be def-s, not\n> vals. Why? Subsequent runs of the compiler might recompile Array (this\n> happens if you navigate to its sources in Scala IDE, for example), which\n> would result in new symbols for its members.\n> \n> That's why I split out RunDefinitions in scalac, so we could have\n> correctness and speed.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/lampepfl/dotty/pull/124/files#r12325734\n> .\n\n## \n\nMartin Odersky\n\n## EPFL\n\nJOIN US. REGISTER TODAY! http://www.scaladays.org/\nScala http://www.scaladays.org/\nDays http://www.scaladays.org/\nJune 16th-18th, http://www.scaladays.org/\nBerlin http://www.scaladays.org/\n",
        "createdAt" : "2014-05-06T14:19:24Z",
        "updatedAt" : "2014-05-06T14:19:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a6b236b9-37ca-44eb-a640-d44657500c68",
        "parentId" : "f341693d-5ab5-47a7-9a34-8b60054678ef",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Martin, why do you need a new class for this? Isn't Definitions itself a class that can be discarded with context holding it.\n",
        "createdAt" : "2014-05-06T14:24:51Z",
        "updatedAt" : "2014-05-06T14:24:51Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "20010624fe079297ae9039d9b31efbcfa7483bf0",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +174,178 @@    lazy val Array_update                = ctx.requiredMethod(ArrayClass, nme.update)\n    lazy val Array_length                = ctx.requiredMethod(ArrayClass, nme.length)\n    lazy val Array_clone                 = ctx.requiredMethod(ArrayClass, nme.clone_)\n  lazy val uncheckedStableClass: ClassSymbol = ctx.requiredClass(\"scala.annotation.unchecked.uncheckedStable\")\n"
  }
]
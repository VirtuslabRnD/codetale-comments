[
  {
    "id" : "f6893066-8b93-4e87-9288-23739f36b472",
    "prId" : 1377,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9422d6e-6c49-495e-9827-efa78225c759",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "``` scala\nif (!isSubType(newBounds.lo, newBounds.hi))\n ctx.gadt.setBounds(tparam, newBounds)\n\ntrue\n```\n\nIs equivalent but less hacky.\n",
        "createdAt" : "2016-07-15T10:00:15Z",
        "updatedAt" : "2016-07-15T11:30:50Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "6681cc0b-cfe5-485b-a308-130ea8d54476",
        "parentId" : "e9422d6e-6c49-495e-9827-efa78225c759",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I would not describe it as hacky. The full code you propose would be:\n\n```\n if (isSubType(newBounds.lo, newBounds.hi)) {\n   ctx.gadt.setBounds(tparam, newBounds)\n   true\n }\n else false\n```\n\nIt's certainly longer. There are quite a few other places in the code base by now that use the same idiom.\n",
        "createdAt" : "2016-07-15T11:22:48Z",
        "updatedAt" : "2016-07-15T11:30:50Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bde23afb0ee6c4dddf637d16defb5074c5a1db8",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +830,834 @@          if (isUpper) TypeBounds(oldBounds.lo, oldBounds.hi & bound)\n          else TypeBounds(oldBounds.lo | bound, oldBounds.hi)\n        isSubType(newBounds.lo, newBounds.hi) &&\n        { ctx.gadt.setBounds(tparam, newBounds); true }\n    }"
  },
  {
    "id" : "52798bb5-b82a-4f91-a69c-ae95378d3190",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88d3ecb7-9260-403e-a5c4-3254594c19db",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Shouldn't we check all arguments, not just the first one?\n",
        "createdAt" : "2016-07-11T07:48:52Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 314,
    "diffHunk" : "@@ -1,1 +725,729 @@    else args2.nonEmpty && {\n      val v = tparams.head.paramVariance\n      (v > 0 || isSubType(args2.head, args1.head)) &&\n      (v < 0 || isSubType(args1.head, args2.head))\n    } && isSubArgs(args1.tail, args2.tail, tparams)"
  },
  {
    "id" : "8add4a79-3b6c-45fb-826e-7dd7f6a61c12",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "610c692b-abee-4d23-9ff2-073156d1c74e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why not `case AppliedType` here?\n",
        "createdAt" : "2016-07-11T08:53:58Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "fc88d26e-d4cc-462a-ab09-37a9d93dfc88",
        "parentId" : "610c692b-abee-4d23-9ff2-073156d1c74e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The types must have the same structure, so if `tp2` is an HKApply, `tp1` must be one also for the method to succeed.\n",
        "createdAt" : "2016-07-11T15:20:26Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "7b47f6a5-a27a-4107-b0d8-532575fa7d19",
        "parentId" : "610c692b-abee-4d23-9ff2-073156d1c74e",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "So if I have something like compareHkApply2(`List { type List$$A = Int }`, `CC[Int]`, `CC`, `Int`), where `CC` is `[X] -> List[X]`, it's expected to fail and be handled somewhere else? Could this be documented?\n",
        "createdAt" : "2016-07-11T22:09:56Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : null,
    "diffHunk" : "@@ -1,1 +582,586 @@     */\n    def isMatchingApply(tp1: Type): Boolean = tp1 match {\n      case HKApply(tycon1, args1) =>\n        tycon1.dealias match {\n          case tycon1: PolyParam =>"
  },
  {
    "id" : "c9a7556e-103e-4df8-a5e8-65187d4a413a",
    "prId" : 984,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6a77975-0700-42f5-93f6-f5667132dfb1",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "It seems like you could avoid a bunch of recursive calls to `firstTry` by using a utility function like:\n\n``` scala\ndef dealiasTypeRef(tp: TypeRef): Type =\n  if (tp.symbol.isClass) tp\n  else tp.info match {\n   case TypeAlias(alias: TypeRef) => dealiasTypeRef(alias)\n   case TypeAlias(alias) => alias\n   case _ => tp\n  }\n```\n",
        "createdAt" : "2015-11-29T16:46:54Z",
        "updatedAt" : "2015-11-30T16:31:43Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e7e40b9f33aec952a9fcb05d45734dd19da0322",
    "line" : null,
    "diffHunk" : "@@ -1,1 +144,148 @@        implicit val ctx: Context = this.ctx\n        tp2.info match {\n          case info2: TypeAlias => firstTry(tp1, info2.alias)\n          case _ => tp1 match {\n            case tp1: NamedType =>"
  },
  {
    "id" : "2f724907-5720-4eb1-b43f-10e31e75ee42",
    "prId" : 331,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab623d34-225d-4a49-9753-479f2777049f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "It would be nice to have a test for this check\n",
        "createdAt" : "2015-01-24T18:39:33Z",
        "updatedAt" : "2015-01-28T18:04:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "70e55d26100199b99502705233786bbdc15c4c6b",
    "line" : 861,
    "diffHunk" : "@@ -1,1 +398,402 @@      def compareClassInfo = tp1 match {\n        case ClassInfo(pre1, cls1, _, _, _) =>\n          (cls1 eq cls2) && isSubType(pre1, pre2)\n        case _ =>\n          false"
  },
  {
    "id" : "bc2f72e2-f1f2-406b-941c-9919c42c22a7",
    "prId" : 230,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5faacd9-603a-4dc8-ac76-6ef8e393d276",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Should we have a \"eitherIsNewSubType\" or is that not necessary?\n",
        "createdAt" : "2014-11-17T17:25:39Z",
        "updatedAt" : "2014-11-18T14:28:49Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "4081bb82-7f6f-4ccc-ad26-baaa0281e722",
        "parentId" : "e5faacd9-603a-4dc8-ac76-6ef8e393d276",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, the isNewSubType was a mistake. The test was not covered before, so isSubType is correct.\n",
        "createdAt" : "2014-11-18T14:27:31Z",
        "updatedAt" : "2014-11-18T14:28:49Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2743f7e62b1322dc6cbbc0b4602e92fee14162b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +800,804 @@      } || needsEtaLift(tp2, tp1) && tp2.testLifted(tp1.typeParams, isSubType(tp1, _))\n    case AndType(tp11, tp12) =>\n      eitherIsSubType(tp11, tp2, tp12, tp2)\n    case JavaArrayType(elem1) =>\n      tp2 isRef ObjectClass"
  }
]
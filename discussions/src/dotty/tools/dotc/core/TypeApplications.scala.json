[
  {
    "id" : "83961347-de2f-4435-86aa-21f013a0e153",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8078af4b-cf23-4f2b-a396-7fc0056641ec",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Comment needs to be updated since there is no `sym` involved anymore\n",
        "createdAt" : "2016-07-11T08:37:24Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6115f78d-1c22-4448-8605-d971c355ab44",
        "parentId" : "8078af4b-cf23-4f2b-a396-7fc0056641ec",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "fixed in a later commit\n",
        "createdAt" : "2016-07-11T15:09:32Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +40,44 @@\n  /** Does variance `v1` conform to variance `v2`?\n   *  This is the case if the variances are the same or `sym` is nonvariant.\n   */\n  def varianceConforms(v1: Int, v2: Int): Boolean ="
  },
  {
    "id" : "6277ab35-4ced-4e87-a8ce-d1542c9a4f86",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "24ab1480-6dd9-43bb-8f8a-22619582b139",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "typo: of -> if\n",
        "createdAt" : "2016-07-11T08:38:52Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : null,
    "diffHunk" : "@@ -1,1 +52,56 @@  /** Do the variances of type parameters `tparams1` conform to the variances\n   *  of corresponding type parameters `tparams2`?\n   *  This is only the case of `tparams1` and `tparams2` have the same length.\n   */\n  def variancesConform(tparams1: List[TypeParamInfo], tparams2: List[TypeParamInfo])(implicit ctx: Context): Boolean ="
  },
  {
    "id" : "eb550e60-e4a0-4fe0-bb79-d559c892ba36",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d071f80f-09ee-4ad3-bb50-d4d27f662e5f",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The comment above the object says that the variances and bounds of the type lambda parameters should match those of the type parameters of the class, but is this checked anywhere here?\n",
        "createdAt" : "2016-07-11T08:50:07Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +73,77 @@\n    def unapply(tp: Type)(implicit ctx: Context): Option[TypeRef] = tp match {\n      case tp @ TypeLambda(tparams, AppliedType(fn: TypeRef, args)) if (args == tparams.map(_.toArg)) => Some(fn)\n      case _ => None\n    }"
  },
  {
    "id" : "223abc23-6608-42c7-ab4f-05ad871adf02",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c6ca407-f67a-429e-9f1f-d516c4684a3e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Why is this needed?\n",
        "createdAt" : "2016-07-11T09:29:30Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "55dc5dd1-0da0-4b33-8d73-8c10fa52a95c",
        "parentId" : "4c6ca407-f67a-429e-9f1f-d516c4684a3e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "you mean `available -= p.paramNum`? To ensure that there is only one substituted occurrence. \n",
        "createdAt" : "2016-07-11T15:27:47Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "f0c02233-80b8-47fa-94df-df3dba1def9a",
        "parentId" : "4c6ca407-f67a-429e-9f1f-d516c4684a3e",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I think this is worthy of a comment in the code\n",
        "createdAt" : "2016-07-11T22:17:33Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "247712b0-8899-4876-9727-dfb86429d337",
        "parentId" : "4c6ca407-f67a-429e-9f1f-d516c4684a3e",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Also, what's wrong with substituting multiple times? Say, if the body of my lambda is `Foo { type A = X; type B = X }`, shouldn't this become `Foo { type A >: L <: H; type B >: L <: H }` ?\n",
        "createdAt" : "2016-07-11T22:20:15Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 266,
    "diffHunk" : "@@ -1,1 +169,173 @@    def apply(t: Type) = t match {\n      case t @ TypeAlias(p: PolyParam) if hasWildcardArg(p) && canReduceWildcard(p) =>\n        available -= p.paramNum\n        args(p.paramNum)\n      case p: PolyParam if p.binder == tycon =>"
  },
  {
    "id" : "ce84c175-4b08-470f-bf33-57d1ff316945",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67c69c50-4322-4057-abb3-0e49ada5f3f3",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "That was on my TODO list also :). So far I've only noticed one method that expects only the upper-bound to be a lambda: `adaptHkVariances`\n",
        "createdAt" : "2016-07-11T09:47:15Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 460,
    "diffHunk" : "@@ -1,1 +337,341 @@   *      type T[X] >: L <: U  becomes    type T >: L <: ([X] -> U)\n   *\n   *  TODO: Handle parameterized lower bounds\n   */\n  def LambdaAbstract(tparams: List[TypeParamInfo])(implicit ctx: Context): Type = {"
  },
  {
    "id" : "cdf12d38-288d-48c2-9a0f-7049ad3e1ed7",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "28c37379-1682-421c-bced-9aea6269e272",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Could you add a comment explaining why reduction is safe/needed here? Also any reason to not turn that off when `Config.simplifyApplications` is false?\n",
        "createdAt" : "2016-07-14T09:38:08Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 648,
    "diffHunk" : "@@ -1,1 +473,477 @@            val followAlias = stripped match {\n              case stripped: TypeRef =>\n                stripped.symbol.is(BaseTypeArg)\n              case _ =>\n                Config.simplifyApplications && {"
  },
  {
    "id" : "cbcc60f3-4a46-4f6c-a16b-8bdbcd50df7b",
    "prId" : 1001,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aa5e48f-f4eb-42c9-b9f6-461e1f48506d",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Maybe add `@pre tparams1.length == tparams2.length` or add an assert.\n",
        "createdAt" : "2015-12-20T17:10:17Z",
        "updatedAt" : "2015-12-21T12:43:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9675b84a4dd82a3705990e8474299725861424ea",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +192,196 @@   *   - bounds `Bi` are the intersection of the corresponding type parameter bounds\n   *     of `tp1` and `tp2`.\n   */\n  def hkCombine(tp1: Type, tp2: Type,\n      tparams1: List[TypeSymbol], tparams2: List[TypeSymbol], op: (Type, Type) => Type)"
  },
  {
    "id" : "c8ba0f55-796c-4808-89d7-0fb09f5e872d",
    "prId" : 994,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3c142ab-3456-49f7-b8d3-16c7b71ca514",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Does that mean that we cannot refer to `X` in `L` ?\n",
        "createdAt" : "2015-12-06T15:14:09Z",
        "updatedAt" : "2015-12-13T15:56:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "8309b98c-119a-41c2-b82a-8adc1abd20a5",
        "parentId" : "d3c142ab-3456-49f7-b8d3-16c7b71ca514",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes\n",
        "createdAt" : "2015-12-06T15:20:00Z",
        "updatedAt" : "2015-12-13T15:56:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "e5bcae93-925e-415a-9965-8d3ae12d7dc8",
        "parentId" : "d3c142ab-3456-49f7-b8d3-16c7b71ca514",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "OK, then this should be explicitly disallowed somewhere, currently the following:\n\n``` scala\nclass Test {\n  type Foo[X] >: List[X]\n}\n```\n\nTriggers an assertion: `unresolved symbols: type X`\nOn the other hand, couldn't we rewrite `type T[X] >: L <: U`  as `type T = [X] -> (_ >: L <: U)` or something else to allow this?\n",
        "createdAt" : "2015-12-06T15:31:28Z",
        "updatedAt" : "2015-12-13T15:56:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "2efd8e97-8ae3-4526-921e-551aefb59ff5",
        "parentId" : "d3c142ab-3456-49f7-b8d3-16c7b71ca514",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That means bounds can be lambdas (and lambdas are complex arrangements of refinements and references). So what was a TypeBounds type now becomes something very complicated. I am afraid to got there. If we had explicit type lambdas as a separate type it would take it under consideration. But then we need also explicit AppliedType types.\n",
        "createdAt" : "2015-12-11T08:31:30Z",
        "updatedAt" : "2015-12-13T15:56:47Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a9e89afffb501ed7b312c21aa5e9981cd4e2b23",
    "line" : 314,
    "diffHunk" : "@@ -1,1 +277,281 @@   *\n   *      type T[X] = U        becomes    type T = [X] -> U\n   *      type T[X] >: L <: U  becomes    type T >: L <: ([X] -> _ <: U)\n   */\n  def LambdaAbstract(tparams: List[Symbol])(implicit ctx: Context): Type = {"
  },
  {
    "id" : "10796347-bb76-4065-b5a9-bd8e137c41d8",
    "prId" : 950,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b30bfd93-68fe-48b4-90d1-006c10a23b7e",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "I'm assuming that the \"otherwise\" case here only reached in ill-typed programs, and will result in an error being issued in `adapt`. Is that assumption right?\n",
        "createdAt" : "2015-11-12T03:23:18Z",
        "updatedAt" : "2015-11-17T16:54:48Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "455ca932-821e-41cf-a995-59dfcdb7e01f",
        "parentId" : "b30bfd93-68fe-48b4-90d1-006c10a23b7e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think it can also appear in tryLifted, which gets called during a subtype check. Essentially, we compare an unexpanded hk type with a type lambda and go on expanding the unexpanded type. It seems we can get a discrepancy in variances there.\n",
        "createdAt" : "2015-11-12T08:17:11Z",
        "updatedAt" : "2015-11-17T16:54:48Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b37b9e3b9f675c5b312f85511d20aaa50200eff1",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +532,536 @@   *  Here, XYZ corresponds to the variances of\n   *   - `U1,...,Un` if the variances of `T1,...,Tn` are pairwise compatible with `U1,...,Un`,\n   *   - `T1,...,Tn` otherwise.\n   *  v1 is compatible with v2, if v1 = v2 or v2 is non-variant.\n   */"
  },
  {
    "id" : "07829634-bfb9-4c57-b144-f9c2ce3d9d9b",
    "prId" : 361,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23341981-7166-4081-adb3-7f206af54a5a",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The documentation still seems incomplete, we don't always check that there is a base type where the type parameters match `tparams`, and there's a special case when `tparams.isEmpty`.\n",
        "createdAt" : "2015-02-11T22:32:34Z",
        "updatedAt" : "2015-02-11T22:32:34Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "000461c376807d51964841ae9cb08d5f255ea2a2",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +509,513 @@   *               { type $hkArg$0 = T1; ...; type $hkArg$n = Tn }\n   *\n   *  satisfies predicate `p`. Try base types in the order of their occurrence in `baseClasses`.\n   *  A type parameter matches a variance V if it has V as its variance or if V == 0.\n   */"
  },
  {
    "id" : "35022b9c-1aee-4a8e-aca2-e8b6e82b0aa7",
    "prId" : 251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9093c0fa-578d-4f5b-a806-ecce0e3845a5",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Yes. This commits will go away after code review. But they are needed for tests to pass.\n",
        "createdAt" : "2014-12-12T17:40:57Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c112037290a526c66bbb782a61bcd8a60730b4b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +371,375 @@    case defn.ArrayType(elemtp) => elemtp\n    case JavaArrayType(elemtp) => elemtp\n    case _ => firstBaseArgInfo(defn.SeqClass)\n  }\n"
  },
  {
    "id" : "a014822f-feb0-4697-aab5-df70d1202c28",
    "prId" : 137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bed4016f-8cf3-40df-815c-f31f994ad7b0",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "case OrType ?\n",
        "createdAt" : "2014-06-25T19:06:38Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "25983f98-fcf8-4eed-a042-939c79465332",
        "parentId" : "bed4016f-8cf3-40df-815c-f31f994ad7b0",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "The AndType case got removed in a subsequent commit. Type parameters now exist only for\nclasses and non-singleton proxies.\n",
        "createdAt" : "2014-06-26T10:29:46Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e710af6ad48b9c2749785e68aee1e4195d7264bb",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +99,103 @@      case tp: TypeProxy =>\n        tp.underlying.rawTypeParams\n      case _ =>\n        Nil\n    }"
  },
  {
    "id" : "2dd19224-8c0f-42a1-97e8-03e45cfe4c42",
    "prId" : 137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f886d09b-cee3-4f21-9635-b672442bc261",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "Does this work for a singleton type with an underlying type that's an alias for a lambda class?\n\n```\ntype T = Foo[Int]\nlazy val x: T = ???\ntypeOf[x.type].LambdaClass\n```\n",
        "createdAt" : "2014-06-25T19:10:02Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "b22bf3ad-27ae-4c61-9805-a736a94dbfab",
        "parentId" : "f886d09b-cee3-4f21-9635-b672442bc261",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, it does not. I changed to comment to exclude singleton type in general and adapted the implementation accordingly.\n",
        "createdAt" : "2014-06-26T10:33:00Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e710af6ad48b9c2749785e68aee1e4195d7264bb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +110,114 @@   *                  but returns NoSymbol when it would have to otherwise.\n   */\n  def LambdaClass(forcing: Boolean)(implicit ctx: Context): Symbol = track(\"LambdaClass\") { self.stripTypeVar match {\n    case self: TypeRef =>\n      val sym = self.symbol"
  },
  {
    "id" : "1089413c-2312-4d5e-89db-9fcb6703dbd2",
    "prId" : 137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f07ac1b7-6662-493c-b1f1-7d9cc1c5ecb9",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "instead of ints to encode variance, use a value class over int?\n",
        "createdAt" : "2014-06-25T19:11:51Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "1294a0de-f1d1-4895-acd7-c13b104c13e1",
        "parentId" : "f07ac1b7-6662-493c-b1f1-7d9cc1c5ecb9",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "We could but we need a couple of arithmetic operations on the value class. Not sure it would carry its weight. It's something to do later, maybe.\n",
        "createdAt" : "2014-06-26T10:34:00Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e710af6ad48b9c2749785e68aee1e4195d7264bb",
    "line" : 157,
    "diffHunk" : "@@ -1,1 +171,175 @@            else {\n              ctx.warning(i\"encountered F-bounded higher-kinded type parameters for $tsym; assuming they are invariant\")\n              defn.lambdaTrait(args map alwaysZero).typeParams\n            }\n          matchParams(tp, safeTypeParams, args)"
  }
]
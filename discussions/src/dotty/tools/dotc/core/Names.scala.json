[
  {
    "id" : "09d41b19-f99b-4658-ad3c-8a9e5aa15ea3",
    "prId" : 708,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b33ae49f-e3b2-4884-8cdb-3db2c911ee90",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Keeping track and maintaining such annotation could be a burden. \nInstead of annotating explicitly, could we infer that private fields that are modified in `synchronized(this)` blocks are sharable?\n",
        "createdAt" : "2015-07-05T09:03:56Z",
        "updatedAt" : "2015-07-06T16:24:12Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "38e50930-e362-4f54-b776-6aa73d53ce6d",
        "parentId" : "b33ae49f-e3b2-4884-8cdb-3db2c911ee90",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Maybe at some point. But right now that's probably too much of a detour. Let's see first whether @sharable thing becomes a feature of general utility. Even now it serves a purpose: If we want to figure out data races, it's good to scrutinize members with @sharable annotations. For the others we can run -Ycheck:reentrant to rule them out (well, almost, modulo to the shortcomings mentioned in the comment).\n",
        "createdAt" : "2015-07-05T18:20:36Z",
        "updatedAt" : "2015-07-06T16:24:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7cc6d851b660c97e80cda806bf5366200c8836b",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +204,208 @@\n  /** Memory to store all names sequentially. */\n  @sharable // because it's only mutated in synchronized block of termName\n  private[dotty] var chrs: Array[Char] = new Array[Char](InitialNameSize)\n"
  },
  {
    "id" : "43d15500-a724-428c-ae4d-08d377753ef5",
    "prId" : 251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2b8d93e-a649-4b32-8437-b3622af94f2a",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Where is `chrs` accessed? Seems strange that anyone would need access to it!\n",
        "createdAt" : "2014-12-12T17:34:58Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "25128da1-ce01-4911-b5ed-d5ae9a77ac56",
        "parentId" : "e2b8d93e-a649-4b32-8437-b3622af94f2a",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Backend in scalac(in as result in dotty) uses this to access raw names in several locations without creating intermediate string. I'm not sure if this is an optimization or an artifact of name encoding. \nI would better get all the tests passing both in scalac and dotty and then check if something breaks if I try to change.\n",
        "createdAt" : "2014-12-12T17:48:25Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c112037290a526c66bbb782a61bcd8a60730b4b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +201,205 @@\n  /** Memory to store all names sequentially. */\n  private[dotty] var chrs: Array[Char] = new Array[Char](InitialNameSize)\n\n  /** The number of characters filled. */"
  }
]
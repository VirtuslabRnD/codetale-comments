[
  {
    "id" : "70694d39-87b5-44fc-958f-39766fa44fb9",
    "prId" : 1656,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1656#pullrequestreview-7097240",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4a764df-50fc-4319-a8a3-a9315067b05b",
        "parentId" : null,
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "It would be nice to have a comment here, since it's not clear exactly why a `PolyType` is a type lambda if the variances are non-empty. Is it because a `PolyType` without parameters is not a type lambda?\n",
        "createdAt" : "2016-11-03T20:32:24Z",
        "updatedAt" : "2016-11-04T07:51:02Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      }
    ],
    "commit" : "372140c7acc46a690f7b7538114f425afdc07e4f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2532,2536 @@     *  method type? Only type lambdas get created with variances, that's how we can tell.\n     */\n    def isTypeLambda: Boolean = variances.nonEmpty\n\n    /** PolyParam references to all type parameters of this type */"
  },
  {
    "id" : "50ba211d-fa18-4bb8-8f39-64ce0b1ef699",
    "prId" : 1522,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1522#pullrequestreview-458685",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c545521b-b236-47aa-afa8-05457127a0eb",
        "parentId" : null,
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "Nitpick: weird indent doesn't match next row\n",
        "createdAt" : "2016-09-17T15:17:23Z",
        "updatedAt" : "2016-09-18T08:23:17Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      }
    ],
    "commit" : "440eddd665d043bd609c3749b5cd5606cd5d4e3e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +929,933 @@\n    /** Useful for diagnostics: The underlying type if this type is a type proxy,\n     *  otherwise NoType\n     */\n    def underlyingIfProxy(implicit ctx: Context) = this match {"
  },
  {
    "id" : "b4167bd7-50c5-48aa-b2e4-b09757081260",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fe0aba0-bead-4799-b39f-fa1f3821a9bb",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is this still worth it now that we don't use `RecType` for encoding higher-kinded types? At the very least this comment needs to be updated to stop mentiong higher-kinded types.\n",
        "createdAt" : "2016-07-11T09:08:55Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "c2d59680-3deb-4ab5-8bb3-a515accbecfd",
        "parentId" : "5fe0aba0-bead-4799-b39f-fa1f3821a9bb",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, it's quite possible that this arises with recursive refinement types only.\n",
        "createdAt" : "2016-07-11T15:25:11Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : null,
    "diffHunk" : "@@ -1,1 +456,460 @@          // type first. But if we do this always we risk being inefficient and we ran into\n          // stackoverflows when compiling pos/hk.scala under the refinement encoding\n          // of hk-types. So we only do a copy if the type\n          // is visited again in a recursive call to `findMember`, as tracked by `tp.opened`.\n          // Furthermore, if this happens we mark the original recursive type with `openedTwice`"
  },
  {
    "id" : "07f01976-cfca-40f6-b3d9-70e797872924",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47b4b984-ba57-48fd-98d9-c10900bd380e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Is it even possible to create a typelambda with no parameters?\n",
        "createdAt" : "2016-07-13T19:36:55Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "1cae41bb-6349-4d4b-b95c-9f791f11d9fa",
        "parentId" : "47b4b984-ba57-48fd-98d9-c10900bd380e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No, but note that foldArgs is recursive.\n",
        "createdAt" : "2016-07-13T20:06:40Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "6db033ab-4ec3-47f4-bef6-489c0708207f",
        "parentId" : "47b4b984-ba57-48fd-98d9-c10900bd380e",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Oh, I see.\n",
        "createdAt" : "2016-07-13T21:04:10Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3615,3619 @@      case tp @ HKApply(tycon, args) =>\n        def foldArgs(x: T, tparams: List[TypeParamInfo], args: List[Type]): T =\n          if (args.isEmpty) {\n            assert(tparams.isEmpty)\n            x"
  },
  {
    "id" : "01c6ec2a-e04f-473a-ba33-048467ba2969",
    "prId" : 1343,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a38f90a6-fe62-4e6a-b116-bb9e1d866a85",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I can't get this to trigger but I assume that this should only assert if `Config.simplifyApplications` is true?\n",
        "createdAt" : "2016-07-14T11:23:21Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "d8c8abb3-7f7e-47eb-bc24-27ccdbc9a39b",
        "parentId" : "a38f90a6-fe62-4e6a-b116-bb9e1d866a85",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "No TypeLambdas are always bete-reduced. Only TypeRefs aliased to TypeLambdas aren't.\n",
        "createdAt" : "2016-07-14T13:24:53Z",
        "updatedAt" : "2016-07-15T08:36:54Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "894c9fbf247765041fc32788c78b85f1b2b2a191",
    "line" : 983,
    "diffHunk" : "@@ -1,1 +2683,2687 @@        case _: PolyParam | ErrorType | _: WildcardType =>\n        case _: TypeLambda =>\n          assert(args.exists(_.isInstanceOf[TypeBounds]), s\"unreduced type apply: $this\")\n        case tycon: AnnotatedType =>\n          check(tycon.underlying)"
  },
  {
    "id" : "3950f495-bb98-4372-9613-a10466974fd9",
    "prId" : 1291,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87cb7433-18b3-4a92-ac1e-ed9ac24324c0",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "What happens if we try to map or fold over such a type? Did we think of that?\n",
        "createdAt" : "2016-06-08T13:13:14Z",
        "updatedAt" : "2016-07-07T09:17:09Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "9bbd1c32-9bce-482b-9a3e-25f54d6807a6",
        "parentId" : "87cb7433-18b3-4a92-ac1e-ed9ac24324c0",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "The idea is that it behaves like `ErrorType` on any operation until it is caught and handled. I considered making it a subtype of `ErrorType` but this seamed a bit dangerous and with this alternative there was only one place where I had to add it to a `case` to do the same as `ErrorType`. \n",
        "createdAt" : "2016-06-08T13:51:15Z",
        "updatedAt" : "2016-07-07T09:17:09Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "2d495a48-19ea-4caa-9f8c-35ae08595c54",
        "parentId" : "87cb7433-18b3-4a92-ac1e-ed9ac24324c0",
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Actually, now that I think about it, it should be `object TryDynamicCallType extends ErrorType`.\n",
        "createdAt" : "2016-06-08T15:28:41Z",
        "updatedAt" : "2016-07-07T09:17:09Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      }
    ],
    "commit" : "7e00c724273d432c8900c0e8ec852bb77357958e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3024,3028 @@  /* Type used to track Select nodes that could not resolve a member and their qualifier is a scala.Dynamic. */\n  object TryDynamicCallType extends ErrorType\n\n  /** Wildcard type, possibly with bounds */\n  abstract case class WildcardType(optBounds: Type) extends CachedGroundType with TermType {"
  },
  {
    "id" : "61bdab09-4505-460b-b37b-116fe85e6c5c",
    "prId" : 1289,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "84e7302a-c235-4d4b-bbff-6f914b38ca4e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The supertype should be stable if `tp.inst.exists`\n",
        "createdAt" : "2016-07-27T21:58:19Z",
        "updatedAt" : "2016-07-27T22:38:14Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "bdb23339-29dd-4bfc-9940-08c69d362c58",
        "parentId" : "84e7302a-c235-4d4b-bbff-6f914b38ca4e",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good point. Fixed in latest commit.\n",
        "createdAt" : "2016-07-27T22:39:08Z",
        "updatedAt" : "2016-07-27T22:39:08Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "04e6d5e5ad39d046a977de1bfd4563287e5b0f41",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2647,2651 @@          case tp: TypeLambda => defn.AnyType\n          case tp: TypeVar if !tp.inst.exists =>\n            // supertype not stable, since underlying might change\n            return tp.underlying.applyIfParameterized(args)\n          case tp: TypeProxy => tp.superType.applyIfParameterized(args)"
  },
  {
    "id" : "37f53f76-1451-4f5e-b778-4aef4d24c12f",
    "prId" : 1186,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69612115-7dfc-4f0e-84ab-81d629570a03",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Interesting abstraction, do you think we could reimplement `TypeAssigner#avoid` using it?\n",
        "createdAt" : "2016-04-06T13:22:37Z",
        "updatedAt" : "2016-04-06T13:22:51Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "f675ad9507089f8b912357fab86740653c1b8789",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +3233,3237 @@  }\n\n  abstract class ApproximatingTypeMap(implicit ctx: Context) extends TypeMap { thisMap =>\n    def approx(lo: Type = defn.NothingType, hi: Type = defn.AnyType) =\n      if (variance == 0) NoType"
  },
  {
    "id" : "58a2671e-9638-4468-ae15-11efab3ebfd2",
    "prId" : 1001,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44620ac1-5b2f-449d-b4c0-9e33735f67a5",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Isn't `isMissing` too restrictive? If we have `(S & T)#A`, then `S#A` might be an alias in `S`, so `derived1` may not return a `TypeRef`.\n",
        "createdAt" : "2015-12-19T16:13:04Z",
        "updatedAt" : "2015-12-21T12:43:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "f1136f6d-c29e-4aba-a36e-2b1a35e25569",
        "parentId" : "44620ac1-5b2f-449d-b4c0-9e33735f67a5",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Don't understand. `isMissing` is supposed to detect when a branch of an |/& does not have a member with the given name. If it is an alias then it does have a member, so it won't be missing anyway.\n",
        "createdAt" : "2015-12-21T12:06:36Z",
        "updatedAt" : "2015-12-21T12:43:44Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "429d4bc4-ed04-44ff-98b2-2a6cf22d3530",
        "parentId" : "44620ac1-5b2f-449d-b4c0-9e33735f67a5",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Nevermind, I misunderstood how this function worked.\n",
        "createdAt" : "2015-12-21T12:25:20Z",
        "updatedAt" : "2015-12-21T12:43:44Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9675b84a4dd82a3705990e8474299725861424ea",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +1559,1563 @@              def isMissing(tp: Type) = tp match {\n                case tp: TypeRef => !tp.info.exists\n                case _ => false\n              }\n              val derived1 = derivedSelect(prefix.tp1)"
  },
  {
    "id" : "5c854e54-2d85-435a-985f-54d8b7d2f6f1",
    "prId" : 702,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a4104dc-af18-40e6-bfae-e8168229abdb",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Typo: \"nor\" -> \"or\"\n",
        "createdAt" : "2015-06-28T19:01:08Z",
        "updatedAt" : "2015-07-06T15:12:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "da38e5a8-560c-4a8d-b855-09d77e2d087a",
        "parentId" : "2a4104dc-af18-40e6-bfae-e8168229abdb",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "isn't `\\n` here an escaped \"end of line\" character?\n",
        "createdAt" : "2015-06-28T19:02:22Z",
        "updatedAt" : "2015-07-06T15:12:57Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "d0e52392-9332-4c73-b150-a4b64d4c5b65",
        "parentId" : "2a4104dc-af18-40e6-bfae-e8168229abdb",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah, you're right, I misread that.\n",
        "createdAt" : "2015-06-28T19:03:45Z",
        "updatedAt" : "2015-07-06T15:12:57Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "175499537c87c78d0b926d84b7a9030011e42c00",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +3194,3198 @@  private def otherReason(pre: Type)(implicit ctx: Context): String = pre match {\n    case pre: ThisType if pre.givenSelfType.exists =>\n      i\"\\nor the self type of $pre might not contain all transitive dependencies\"\n    case _ => \"\"\n  }"
  },
  {
    "id" : "45320ab8-8762-4cb3-80f4-093a1baa543c",
    "prId" : 673,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c164704-616d-477f-b769-cacb40650e6c",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "`to` -> `that`\n",
        "createdAt" : "2015-06-21T10:03:35Z",
        "updatedAt" : "2015-06-21T10:03:35Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "76a056f5e1ea01b3cfdc8832e2a164562da770ab",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +602,606 @@    }\n\n    /** Is this type a primitive value type which can be widened to the primitive value type `to`? */\n    def isValueSubType(that: Type)(implicit ctx: Context) = widenExpr match {\n      case self: TypeRef if defn.ScalaValueClasses contains self.symbol =>"
  },
  {
    "id" : "b0217841-5d51-452e-a861-e7f2db11ea90",
    "prId" : 284,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec803469-003b-47cc-ba4f-9ed9191378a8",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why do we need to re-wrap the annotation here? \n",
        "createdAt" : "2014-12-14T18:27:24Z",
        "updatedAt" : "2014-12-14T18:27:24Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "b54d2c90-ec37-402e-ab43-bdddc8dd0c76",
        "parentId" : "ec803469-003b-47cc-ba4f-9ed9191378a8",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "On second thought, the rewrap makes sense.\n",
        "createdAt" : "2014-12-14T19:02:52Z",
        "updatedAt" : "2014-12-14T19:02:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa62cff53d8d568670eadf64b3accee6f6e6d030",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +679,683 @@        tp.ref.dealias\n      case tp: AnnotatedType =>\n        tp.derivedAnnotatedType(tp.annot, tp.tpe.dealias)\n      case tp => tp\n    }"
  },
  {
    "id" : "bb5ca3e6-4d49-4f2f-b5a0-0007b2ab9dbc",
    "prId" : 270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "880e565d-2614-4537-b8fd-c78fc826dbe9",
        "parentId" : null,
        "authorId" : "8b10c0b3-102a-43f0-9f7e-9832973ffe2b",
        "body" : "always holds\n",
        "createdAt" : "2014-12-11T07:42:56Z",
        "updatedAt" : "2014-12-11T07:42:56Z",
        "lastEditedBy" : "8b10c0b3-102a-43f0-9f7e-9832973ffe2b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c1e76d085734697ccc17c4b21f59c15e078e0aa",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +2456,2460 @@\n  abstract class TypeAlias(val alias: Type, override val variance: Int) extends TypeBounds(alias, alias) {\n    /** pre: this is a type alias */\n    def derivedTypeAlias(tp: Type, variance: Int = this.variance)(implicit ctx: Context) =\n      if (lo eq tp) this"
  },
  {
    "id" : "7239a770-7ef9-420d-add2-4bf14a38c2da",
    "prId" : 270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87e3860c-5bc9-4eb5-95fd-edf341362893",
        "parentId" : null,
        "authorId" : "8b10c0b3-102a-43f0-9f7e-9832973ffe2b",
        "body" : "could replace `lo`, `this.lo`, `this.hi`, by `alias`\n",
        "createdAt" : "2014-12-11T07:44:31Z",
        "updatedAt" : "2014-12-11T07:44:31Z",
        "lastEditedBy" : "8b10c0b3-102a-43f0-9f7e-9832973ffe2b",
        "tags" : [
        ]
      },
      {
        "id" : "6190684a-0d1f-409f-8f43-a6db2d370653",
        "parentId" : "87e3860c-5bc9-4eb5-95fd-edf341362893",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, let's do that.\n",
        "createdAt" : "2014-12-11T09:24:30Z",
        "updatedAt" : "2014-12-11T09:24:30Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "b3f38942-dbe9-4b19-a816-981aeea565a2",
        "parentId" : "87e3860c-5bc9-4eb5-95fd-edf341362893",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "On second thought, I prefer it as it is. More symmetric this way. \n",
        "createdAt" : "2014-12-11T09:25:52Z",
        "updatedAt" : "2014-12-11T09:25:52Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7c1e76d085734697ccc17c4b21f59c15e078e0aa",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +2473,2477 @@      else if (v < 0) derivedTypeAlias(this.lo & that.lo, v)\n      else super.| (that)\n    }\n  }\n"
  },
  {
    "id" : "e8545202-ec26-4604-a9dd-ff73ef72ef0b",
    "prId" : 251,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c51ba324-fcf9-4125-92a7-8528bc343c4a",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "clearer: `is(requiredFlags, butNot = excludedFlags)`. \n\nAnd doc comment needs updating.\n",
        "createdAt" : "2014-12-12T17:40:10Z",
        "updatedAt" : "2014-12-16T14:24:02Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c112037290a526c66bbb782a61bcd8a60730b4b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +535,539 @@\n    /** The set of members  of this type  having at least one of `requiredFlags` but none of  `excludedFlags` set */\n    final def membersBasedOnFlags(requiredFlags: FlagSet, excludedFlags: FlagSet)(implicit ctx: Context): Seq[SingleDenotation] = track(\"implicitMembers\") {\n      memberDenots(takeAllFilter,\n        (name, buf) => buf ++= member(name).altsWith(x => x.is(requiredFlags, butNot = excludedFlags)))"
  },
  {
    "id" : "bb0c99ed-b9b5-4d9b-ae1f-842a060f3e1d",
    "prId" : 238,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9429f545-1e7e-44a0-a945-458762d0ce9f",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Should this also treat `SuperType`? I would think that should have either:\n\n``` scala\ncase tp: SuperType => dependsOnRefinedThis(tp.thistpe) || dependsOnRefinedThis(tp.supertpe)\n```\n\nor maybe just:\n\n``` scala\ncase tp: SuperType => dependsOnRefinedThis(tp.thistpe)\n```\n\nHere's a test case:\n\n``` scala\ntrait T { type X }\n\"\": (T { type X = Int; type U = super[T].X })#U\n```\n\n```\nsandbox/test.scala:16: error: type mismatch:\n found   : String(\"\")\n required: Super(C.this.T{X = Int; U = super.X}).X\n  \"\": (T { type X = Int; type U = super[T].X })#U\n  ^\n```\n\nI also tried this somewhat silly example, not sure what to make of the results.\n\n``` scala\n\"\": ({ type U = this.type })#U\n```\n\n```\nsandbox/test.scala:18: error: type mismatch:\n found   : String(\"\")\n required: Object{\n  U =\n    Object{\n      U =\n        Object{\n          U =\n            Object{\n              U =\n                Object{\n                  U =\n                    Object{\n                      U =\n                        Object{\n                          U =\n                            Object{\n                              U =\n                                Object{\n                                  U =\n                                    Object{\n                                      U =\n                                        Object{\n                                          U =\n                                            Object{\n                                              U =\n                                                Object{\n                                                  U =\n                                                    Object{\n                                                      U =\n                                                        Object{\n                                                          U =\n                                                            Object{\n                                                              U =\n                                                                Object{\n                                                                  U =\n                                                                    Object{\n                                                                      U =\n                                                                        Object{\n                                                                          U =\n                                                                            ...(\n                                                                              ...\n                                                                            )\n                                                                        }(this)\n                                                                    }(this)\n                                                                }(this)\n                                                            }(this)\n                                                        }(this)\n                                                    }(this)\n                                                }(this)\n                                            }(this)\n                                        }(this)\n                                    }(this)\n                                }(this)\n                            }(this)\n                        }(this)\n                    }(this)\n                }(this)\n            }(this)\n        }(this)\n    }(this)\n}#U\n  \"\": ({ type U = this.type })#U\n  ^\n```\n",
        "createdAt" : "2014-11-22T08:16:47Z",
        "updatedAt" : "2014-11-25T10:19:01Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      },
      {
        "id" : "52d4965d-eb52-4a47-b458-66c71aff3e29",
        "parentId" : "9429f545-1e7e-44a0-a945-458762d0ce9f",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I pushed a commit which rules out the silly example as deprecated.\n\nRegarding SuperTypes: I believe we do not want to allow them as prefixes of TypeRefs. I.e. only allow them as prefixes of termRefs. Then we do not need a case in lookupRefined for them. I'll open a separate issue for that.\n",
        "createdAt" : "2014-11-24T11:48:08Z",
        "updatedAt" : "2014-11-25T10:19:01Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2884d5338e139fb2ff795b3d08947df58f9b953",
    "line" : 74,
    "diffHunk" : "@@ -1,1 +752,756 @@        case tp: TypeBounds => dependsOnRefinedThis(tp.lo) || dependsOnRefinedThis(tp.hi)\n        case tp: AnnotatedType => dependsOnRefinedThis(tp.underlying)\n        case tp: AndOrType => dependsOnRefinedThis(tp.tp1) || dependsOnRefinedThis(tp.tp2)\n        case _ => false\n      }"
  },
  {
    "id" : "6bc82e12-7e3e-4736-901c-a1f5ed53e17c",
    "prId" : 233,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70756272-5bbd-4dbd-a817-15ebd9ad2dd6",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "if that is left for debug only, can you please add a message that tells this in case of failure?\n",
        "createdAt" : "2014-11-17T18:45:03Z",
        "updatedAt" : "2014-11-17T18:45:03Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e63feffe063987df54cb9a5916003eb400c0b49d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +398,402 @@    final def findMember(name: Name, pre: Type, excluded: FlagSet)(implicit ctx: Context): Denotation = try {\n      recCount += 1\n      assert(recCount < 40)\n      @tailrec def go(tp: Type): Denotation = tp match {\n        case tp: RefinedType =>"
  },
  {
    "id" : "7d1bfbf4-9354-470c-a370-6f2fcf78fe9d",
    "prId" : 152,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b450689e-7024-4ab5-9172-c1a2974a3e69",
        "parentId" : null,
        "authorId" : "f4528580-1528-4847-8158-c4d0bb86f278",
        "body" : "s/is/if/  ?\n",
        "createdAt" : "2014-07-22T02:36:01Z",
        "updatedAt" : "2014-07-22T02:36:01Z",
        "lastEditedBy" : "f4528580-1528-4847-8158-c4d0bb86f278",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9aa810472b5ee117b0865350a06b28a06b27c5c",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +833,837 @@      ctx.substThis(this, cls, tp, null)\n\n    /** As substThis, but only is class is a static owner (i.e. a globally accessible object) */\n    final def substThisUnlessStatic(cls: ClassSymbol, tp: Type)(implicit ctx: Context): Type =\n      if (cls.isStaticOwner) this else ctx.substThis(this, cls, tp, null)"
  },
  {
    "id" : "296cf5d2-a823-4239-9d89-2f8930adaf1c",
    "prId" : 137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "909ef957-4558-48e4-856b-ba83dd937980",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "Is comparing by name safe here?\n",
        "createdAt" : "2014-06-25T19:26:23Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "9c3aa83f-d5f0-4c9d-adcd-4a6f027e1c46",
        "parentId" : "909ef957-4558-48e4-856b-ba83dd937980",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why would it not be safe?\n",
        "createdAt" : "2014-06-26T10:38:39Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e710af6ad48b9c2749785e68aee1e4195d7264bb",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +126,130 @@        if (absTypeNames.nonEmpty) typr.println(s\"abstract type members of ${this.showWithUnderlying()}: $absTypeNames\")\n        absTypeNames.isEmpty ||\n          absTypeNames.head == selector && absTypeNames.tail.isEmpty\n      }\n"
  },
  {
    "id" : "72689619-1a77-4154-b954-32d1c3c74003",
    "prId" : 137,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49814381-0b0d-4778-bf73-ed601d62cf5a",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "does existsPart look at bounds?\n\nconsider `class C { type X } ; P { self => type T = C { type X <: self.U }; type U } # T`\n",
        "createdAt" : "2014-06-25T19:32:32Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      },
      {
        "id" : "de89c8b3-610d-4ca2-9012-c73cfe357e32",
        "parentId" : "49814381-0b0d-4778-bf73-ed601d62cf5a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, it follows bounds in a refinement.\n",
        "createdAt" : "2014-06-26T10:49:30Z",
        "updatedAt" : "2014-06-26T14:18:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e710af6ad48b9c2749785e68aee1e4195d7264bb",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +674,678 @@        else pre.refinedInfo match {\n          case TypeBounds(lo, hi) if lo eq hi =>\n            if (hi.existsPart(dependsOnThis)) NoType else hi\n          case _ => NoType\n        }"
  },
  {
    "id" : "2af30234-d093-42e7-b4b2-2ae12cd80f64",
    "prId" : 115,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08f707a7-74b8-4553-874d-31328a169742",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Let us not introduce more `withX` methods that mutate `this`, shall we?\n",
        "createdAt" : "2014-04-04T12:56:35Z",
        "updatedAt" : "2014-04-08T15:08:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "27d2e49d-cbf9-459d-aae8-5f0cf365a26e",
        "parentId" : "08f707a7-74b8-4553-874d-31328a169742",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Note that there's setDenot and withDenot. setDenot is the mutator. withDenot returns potentially a new tree and, where it does not, verifies that it does not overwrite any existing denotations. So I think the name is appropriate.\n",
        "createdAt" : "2014-04-04T13:05:11Z",
        "updatedAt" : "2014-04-08T15:08:21Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "11e46b96-2e1a-456e-bb62-41ed75887e5b",
        "parentId" : "08f707a7-74b8-4553-874d-31328a169742",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "ah ok.\n",
        "createdAt" : "2014-04-04T13:27:38Z",
        "updatedAt" : "2014-04-08T15:08:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "dcfd96328f350a6265d7aac55c411ab798e93e77",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +1062,1066 @@    protected def sig: Signature = Signature.NotAMethod\n\n    private[dotc] def withDenot(denot: Denotation)(implicit ctx: Context): ThisType =\n      if (sig != denot.signature)\n        withSig(denot.signature).withDenot(denot).asInstanceOf[ThisType]"
  },
  {
    "id" : "137cb8d3-c95b-48b2-9308-8cd842c86ef5",
    "prId" : 115,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aaa9a23-fdf0-4c0c-ab48-eeeea636e1af",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "\"but with a new name\" does not mean anything. The comment should be more explicit.\n",
        "createdAt" : "2014-04-04T13:39:37Z",
        "updatedAt" : "2014-04-08T15:08:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "b9bf78d2-a305-45ea-a93e-173be9685dee",
        "parentId" : "1aaa9a23-fdf0-4c0c-ab48-eeeea636e1af",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Well spotted. In fact the comment applied to a different method that got deleted :-) How about:\n\n```\nCreate a shadowed named type with the same prefix as this type which refers to a non-public\nmember which has potentially the same name as a private member of the prefix. Note that we\nneed to different NamedTypes here to avoid noDoubleBindings assertion errors.\n```\n",
        "createdAt" : "2014-04-04T13:46:01Z",
        "updatedAt" : "2014-04-08T15:08:21Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "d49f39ed-b895-4173-b0dc-c4ce42eed492",
        "parentId" : "1aaa9a23-fdf0-4c0c-ab48-eeeea636e1af",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "\"need to _have_ different NamedTypes\", but otherwise yes, that's good.\n",
        "createdAt" : "2014-04-04T13:51:30Z",
        "updatedAt" : "2014-04-08T15:08:21Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "dcfd96328f350a6265d7aac55c411ab798e93e77",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +1166,1170 @@      NamedType(prefix, name)\n\n    /** Create a NamedType of the same kind as this type, but with a new name.\n     */\n    final def shadowed(implicit ctx: Context): NamedType ="
  }
]
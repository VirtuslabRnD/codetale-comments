[
  {
    "id" : "e3956bf3-39c0-481d-8d0e-ab20c5c1b867",
    "prId" : 1660,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1660#pullrequestreview-7328959",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3983c16d-7bf2-48ae-bb76-061dc9a85592",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "I think it would be better to not introduce new string error messages and to make a new error message class by following Felix's guide instead: https://github.com/lampepfl/dotty/issues/1589\n",
        "createdAt" : "2016-11-05T18:55:43Z",
        "updatedAt" : "2016-11-05T18:56:02Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "81db0c04-586b-4ea0-bf9d-6e140a59e956",
        "parentId" : "3983c16d-7bf2-48ae-bb76-061dc9a85592",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Agreed in principle, but I think it's best to leave that to others who are already in it. Crafting a good error message takes time. But my goal here is to clear the backlog of fuzzing errors, so I want to move quickly.\n",
        "createdAt" : "2016-11-06T09:42:42Z",
        "updatedAt" : "2016-11-06T09:42:42Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cf351a20fcd9de79eedeca76fad59bad55d5a5ec",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +451,455 @@          case AppliedTypeTree(_, targs) =>\n            for (targ @ TypeBoundsTree(_, _) <- targs)\n              ctx.error(\"type argument must be fully defined\", targ.pos)\n          case _ =>\n        }"
  },
  {
    "id" : "4edeb81d-7fb0-4fbb-8291-367c35bbb402",
    "prId" : 1634,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1634#pullrequestreview-9632964",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d3a6642-0469-4737-bca5-ec779a0d5061",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "A bit late, but any reason to not use `typedPolyTypeTree` here?",
        "createdAt" : "2016-11-22T10:26:10Z",
        "updatedAt" : "2016-11-22T10:26:10Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2b1e601142e66255c252bf0584d2fc5ceb46b07",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +1188,1192 @@    val rhs1 = tdef.rhs match {\n      case rhs @ PolyTypeTree(tparams, body) =>\n        val tparams1 = tparams.map(typed(_)).asInstanceOf[List[TypeDef]]\n        val body1 = typedType(body)\n        assignType(cpy.PolyTypeTree(rhs)(tparams1, body1), tparams1, body1)"
  },
  {
    "id" : "2b94561e-eca0-49de-a73b-45d3f41db183",
    "prId" : 1521,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1521#pullrequestreview-3548032",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c3b41f1-238c-40e4-9c95-e369d3a2b7b3",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "What's the reason for the first `|` after the \"\"\"?\n",
        "createdAt" : "2016-10-10T15:46:20Z",
        "updatedAt" : "2016-10-10T19:32:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "eaa49ad5-2226-4945-8f3d-fab77f3b64bd",
        "parentId" : "2c3b41f1-238c-40e4-9c95-e369d3a2b7b3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Otherwise LGTM\n",
        "createdAt" : "2016-10-10T15:51:41Z",
        "updatedAt" : "2016-10-10T19:32:18Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "471ac13b-87a3-47d4-99a4-d57d11606bca",
        "parentId" : "2c3b41f1-238c-40e4-9c95-e369d3a2b7b3",
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "Since we're applying `stripMargin` to the result of the string interpolation, the result is the same with or without the first `|`.\n\nI simply like it present since it can then be aligned with the other pipe symbols showing clearly what the resulting string will look like.\n",
        "createdAt" : "2016-10-10T18:11:27Z",
        "updatedAt" : "2016-10-10T19:32:18Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      }
    ],
    "commit" : "550c643a2a9ad785318e9a727ddc82e3e2f244aa",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +172,176 @@          if (!scala2pkg && !previous.isError && !found.isError) {\n            error(\n              ex\"\"\"|reference to `$name` is ambiguous\n                   |it is both ${bindingString(newPrec, ctx, \"\")}\n                   |and ${bindingString(prevPrec, prevCtx, \" subsequently\")}\"\"\","
  },
  {
    "id" : "e89150a9-22a6-41a1-b61c-b20e5cccfde6",
    "prId" : 1492,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1492#pullrequestreview-2449264",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee365443-7144-4cde-972e-35f6e663f83b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "This is the only call to `inlineCall` and it's in a branch with `tree.tpe <:< pt` this means that when `adaptToSubType` is necessary we never inline, for example `get` isn't inlined in `foo`:\n\n``` scala\nobject Test {\n  inline def get: Int = 1\n\n  def foo: Unit = {\n    get\n  }\n}\n```\n",
        "createdAt" : "2016-09-27T16:57:19Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "9de9cbab-2120-4efa-91de-99025089fea2",
        "parentId" : "ee365443-7144-4cde-972e-35f6e663f83b",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "It turns out we cannot move this test earlier or we get inline errors. I fixed the problem by recursively calling adapt when converting to Unit. I think that's the only place where an inline was missing.\n",
        "createdAt" : "2016-10-02T13:52:33Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0a14e7939eda6a7f4914831975b2ac8877696f2",
    "line" : 199,
    "diffHunk" : "@@ -1,1 +1825,1829 @@              !ctx.settings.YnoInline.value &&\n              !ctx.isAfterTyper)\n            adapt(Inliner.inlineCall(tree, pt), pt)\n          else if (ctx.typeComparer.GADTused && pt.isValueType)\n            // Insert an explicit cast, so that -Ycheck in later phases succeeds."
  },
  {
    "id" : "047a2801-1291-41fb-bb28-896774df7405",
    "prId" : 1395,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a205d8c-8790-4704-a831-26059ca82dbd",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "A comment should clarify that this method is called for its side-effects, and why we don't need to do anything special when it returns `false` (I think this is the only instance of `isFullyDefined` in the compiler where we ignore the return value)\n",
        "createdAt" : "2016-07-16T22:58:44Z",
        "updatedAt" : "2016-07-18T16:02:18Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9ccb47ae2e9ae34a0ebd6bafbf6f327b39fc8d4a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +604,608 @@          // work the error will be reported later in `inferredParam`,\n          // when we try to infer the parameter type.\n          isFullyDefined(pt, ForceDegree.noBottom)\n        case _ =>\n      }"
  },
  {
    "id" : "d6ed3a07-7e31-4664-90a6-e27765ff89cf",
    "prId" : 1377,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98d607f2-56a3-428d-b0dc-dc9e5097284d",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "`Case` is described as:\n\n``` scala\n /** A case class or its companion object */\nfinal val Case = commonFlag(17, \"case\")\nfinal val CaseClass = Case.toTypeFlags\nfinal val CaseVal = Case.toTermFlags\n```\n\nso I don't understand what it's supposed to do here\n",
        "createdAt" : "2016-07-17T02:32:38Z",
        "updatedAt" : "2016-07-17T02:32:38Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "9bde23afb0ee6c4dddf637d16defb5074c5a1db8",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +986,990 @@  private def newPatternBoundSym(name: Name, info: Type, pos: Position)(implicit ctx: Context) = {\n    val flags = if (name.isTypeName) BindDefinedType else EmptyFlags\n    val sym = ctx.newSymbol(ctx.owner, name, flags | Case, info, coord = pos)\n    if (name.isTypeName) ctx.gadt.setBounds(sym, info.bounds)\n    sym"
  },
  {
    "id" : "f89e7910-7818-4c45-8f6e-65226caf418b",
    "prId" : 1154,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "224f3738-38fa-4f61-af21-82c6b10d0010",
        "parentId" : null,
        "authorId" : "7aa36552-f314-4217-a921-109d4a7a544d",
        "body" : "Typo\n",
        "createdAt" : "2016-03-09T14:29:26Z",
        "updatedAt" : "2016-03-14T09:02:34Z",
        "lastEditedBy" : "7aa36552-f314-4217-a921-109d4a7a544d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c18e37886e90d217579112ccf867c22658273be",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +993,997 @@  }\n\n  /** Add a @volitile to lazy vals when rewriting from Scala2 */\n  private def patchIfLazy(vdef: ValDef)(implicit ctx: Context): Unit = {\n    val sym = vdef.symbol"
  },
  {
    "id" : "1ccbed73-780e-477f-9689-1e3ab6aad623",
    "prId" : 887,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c18e3627-f1db-4f74-b587-b0cfbb156f2e",
        "parentId" : null,
        "authorId" : "1f1241a4-206b-4204-be44-be9e433da151",
        "body" : "Do you need to do anything with dependent method types here?\n\n... \n\nI just looked and I see that the `SAMType` extractor excludes them.\n\nA few more tests to show what is and isn't supported would be welcome.\n",
        "createdAt" : "2015-10-31T03:01:27Z",
        "updatedAt" : "2015-10-31T03:01:39Z",
        "lastEditedBy" : "1f1241a4-206b-4204-be44-be9e433da151",
        "tags" : [
        ]
      }
    ],
    "commit" : "b80b179d6fbb92c8f6ff3616cec1f3aab5106799",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +508,512 @@    case SAMType(meth) =>\n      val mt @ MethodType(_, paramTypes) = meth.info\n      (paramTypes, mt.resultType)\n    case _ =>\n      (List.range(0, defaultArity) map alwaysWildcardType, WildcardType)"
  },
  {
    "id" : "741006a7-f2ad-458d-b2f0-e61df176a584",
    "prId" : 665,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "daaac902-1bf1-4753-8cdb-6eaadf3c119e",
        "parentId" : null,
        "authorId" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "body" : "I wonder whether `resolveOverloaded` could do `adaptByResult`'s work from the start? What's the rationale for doing this afterwards?\n",
        "createdAt" : "2015-06-18T21:36:12Z",
        "updatedAt" : "2015-06-19T13:31:25Z",
        "lastEditedBy" : "9eb7e1a2-8927-4525-9474-5b5e4ce6afb0",
        "tags" : [
        ]
      }
    ],
    "commit" : "0bbc85895807aa4df05f46b1f0794a8c2fc4d095",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1237,1241 @@        TermRef.withSigAndDenot(ref.prefix, ref.name, alt.info.signature, alt))\n      def expectedStr = err.expectedTypeStr(pt)\n      resolveOverloaded(alts, pt) match {\n        case alt :: Nil =>\n          adapt(tree.withType(alt), pt, original)"
  },
  {
    "id" : "ed7e8a26-3b61-44da-8a60-dc8972ca4189",
    "prId" : 382,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "471ec47c-26cc-460b-852c-33503847249a",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Are we sure that after erasure `tree.from` is not an `EmptyTree`?\n",
        "createdAt" : "2015-02-26T15:49:43Z",
        "updatedAt" : "2015-02-26T15:49:43Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "eb48860c-46fc-47ff-8961-326b9312654d",
        "parentId" : "471ec47c-26cc-460b-852c-33503847249a",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Why does that matter?\n",
        "createdAt" : "2015-02-26T16:12:51Z",
        "updatedAt" : "2015-02-26T16:12:51Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "aa1179a6c58849375527ee7ea4c79bc96f87551d",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +717,721 @@      if (tree.from.isEmpty) enclMethInfo(ctx)\n      else {\n        val from = tree.from.asInstanceOf[tpd.Tree]\n        val proto = \n          if (ctx.erasedTypes) from.symbol.info.finalResultType "
  },
  {
    "id" : "013a6dac-ca93-4145-8592-da6768631fa2",
    "prId" : 42,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12aeead8-c0ae-4e52-8b27-9e71e88824b7",
        "parentId" : null,
        "authorId" : "8b10c0b3-102a-43f0-9f7e-9832973ffe2b",
        "body" : "why do you assign Unit to a val?\n",
        "createdAt" : "2014-03-04T23:26:35Z",
        "updatedAt" : "2014-03-04T23:26:35Z",
        "lastEditedBy" : "8b10c0b3-102a-43f0-9f7e-9832973ffe2b",
        "tags" : [
        ]
      },
      {
        "id" : "5747bf5a-577b-497e-8e00-c3f399b000ee",
        "parentId" : "12aeead8-c0ae-4e52-8b27-9e71e88824b7",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Good catch. I will do a shortcut in the interest of time and fix it in the next commit. \n",
        "createdAt" : "2014-03-06T09:09:03Z",
        "updatedAt" : "2014-03-06T09:09:03Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f196e074c41f7ccde118dcf6764898a2c26fda3a",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +141,145 @@            val whyNot = new StringBuffer\n            val addendum =\n              alts foreach (_.isAccessibleFrom(pre, superAccess, whyNot))\n            if (!tpe.isError)\n              ctx.error(i\"$what cannot be accessed as a member of $pre$where.$whyNot\", pos)"
  }
]
[
  {
    "id" : "5f6fa5ca-a320-4c28-a27c-208a3377dd31",
    "prId" : 1014,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2fa7177-e384-43f9-93cd-0f7298efae7b",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "The TypeBounds.empty thing is tricky and I don't really understand why it's done and how it works, I think it'd be great to explain it in more details, for example there's a comment above that says:\n\n``` scala\n// The scheme critically relies on an implementation detail of isRef, which\n// inspects a TypeRef's info, instead of simply dealiasing alias types.\n```\n\nBut why would this scheme not work if isRef was implemented differently? (I don't even see how you could implement it differently, how can you know if an alias TypeRef refers to a particular symbol without looking at its info?)\n",
        "createdAt" : "2016-01-10T22:34:19Z",
        "updatedAt" : "2016-01-18T17:22:54Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "224232df2affa882c2c41fc8a6730ad7fc049679",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +894,898 @@    }\n\n    // Here we pay the price for the cavalier setting info to TypeBounds.empty above.\n    // We need to compensate by invalidating caches in references that might\n    // still contain the TypeBounds.empty. If we do not do this, stdlib factories"
  },
  {
    "id" : "b68f39f7-06ff-412b-96b4-75d40346bc62",
    "prId" : 436,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cbcf9496-2bb5-4954-9849-98f0957e809d",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I think this is a bit on the complex side, in particuar I do not like the repetition of the complicated Thicket pattern matches. Can we experiment with having 4 Maps:\n\n `classDef`, `moduleDef` as before\n\n```\n val syntheticCompanionDef: Map[TypeName, TypeDef]  // a map from case classes to synthetic companions\n val coreCaseClassDef: Map[TypeName, List[Tree]] // a map from case classes to the definitions w/o synthetic companions\n```\n\nUsing these we could streamline the traversal of ModuleDefs. \n\nSee what I mean?\n",
        "createdAt" : "2015-03-28T19:14:27Z",
        "updatedAt" : "2015-04-02T14:30:29Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "264148eb-2f0b-47ce-a804-f5fedce7ab1a",
        "parentId" : "cbcf9496-2bb5-4954-9849-98f0957e809d",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Should those maps be directly updated by desugar or you'll still use attachments?\nIf second, you'll still need 2 pattern matches, one over classes, and one over modules to populate maps.\nAnd then you'll need an additional pattern match to update the annotations, so you still have three pattern matches. Am I missing something?\n",
        "createdAt" : "2015-03-28T19:19:40Z",
        "updatedAt" : "2015-04-02T14:30:29Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e5618d29e37ad50bd1b8c591ed50db63a6d7bc79",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +430,434 @@        }\n      }\n    }\n\n    def createLinks(classTree: TypeDef, moduleTree: TypeDef)(implicit ctx: Context) = {"
  }
]
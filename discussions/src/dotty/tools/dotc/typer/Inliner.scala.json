[
  {
    "id" : "dfab7aac-7446-432e-8846-49d6229dd6f2",
    "prId" : 1607,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1607#pullrequestreview-7410856",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac5a69c5-869b-4de6-94ca-93b5f3b5d96b",
        "parentId" : null,
        "authorId" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "body" : "@odersky - updated with your suggestion\n",
        "createdAt" : "2016-11-07T13:08:44Z",
        "updatedAt" : "2016-11-07T13:08:44Z",
        "lastEditedBy" : "2dc29bea-17b2-4800-bf4f-843c62cca7de",
        "tags" : [
        ]
      }
    ],
    "commit" : "1fec582b4e85de715e92ccb621ac55e02874558e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +191,195 @@          sym.updateAnnotation(LazyBodyAnnotation { _ =>\n            implicit val ctx: Context = inlineCtx\n            ctx.withNoError(treeExpr(ctx))(makeInlineable)\n          })\n        }"
  },
  {
    "id" : "63c1522c-d264-424e-9aa5-39ebf617eb55",
    "prId" : 1492,
    "prUrl" : "https://github.com/lampepfl/dotty/pull/1492#pullrequestreview-2553344",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Can't we just disable access checks for type members in inlined blocks? We need accessors for term members because of the JVM but type members get erased anyway.\n",
        "createdAt" : "2016-09-23T19:48:37Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "bd704a23-b24b-4074-81b0-13b939e7797d",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Not true for classes. They don't get erased.\n",
        "createdAt" : "2016-10-02T13:02:43Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "bf0dd3d6-343e-4f24-a6f0-ee3a5ca82ee3",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Indeed, but does the JVM restrict access to classes in any way? As far as I know it only restricts access to the constructor of the class, but we take care of that by adding a term accessor for the constructor, not a type accessor.\n",
        "createdAt" : "2016-10-02T18:23:36Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "a9423163-1b85-4bfb-9ecf-2ffd9f8b5fca",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I thought access to private classes is caught by the JVM\n",
        "createdAt" : "2016-10-02T21:51:15Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "2f76ee0e-51f4-44fe-876a-91b3ddde48cb",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Doesn't seem so, here's some Java code:\n`Foo.java`:\n\n``` java\npublic class Foo {\n  public class Inner {\n    int get() { return 42; }\n  }\n  Inner inner = new Inner();\n}\n```\n\n`Bar.java`:\n\n``` java\npublic class Bar {\n  public static void main(String[] args) {\n    Foo.Inner inner = (new Foo()).inner;\n    System.out.println(inner.get());\n  }\n}\n```\n\n``` shell\n$ javac Foo.java\n$ javac Bar.java\n$ java Bar\n42\n$ edit Foo.java, make Inner private\n$ javac Foo.java\n$ java Bar\n42\n```\n",
        "createdAt" : "2016-10-03T15:20:05Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "42de316c-a8d5-48cf-91ce-64a2e535bda4",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Inner classes indeed get the private modifier removed. But package inner classes are maintained in the JVM I think\n",
        "createdAt" : "2016-10-03T15:44:31Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "fd070b13-478e-47f0-a79e-ae76f9ae3109",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Ah you're right indeed, the following breaks:\n\n``` java\npackage a;\n\npublic class Foo {\n  public class Inner {\n    public int get() { return 42; }\n  }\n  public Inner inner = new Inner();\n}\n```\n\n``` java\npackage b;\n\npublic class Bar {\n  public static void main(String[] args) {\n    a.Foo.Inner inner = (new a.Foo()).inner;\n    System.out.println(inner.get());\n  }\n}\n```\n\n``` shell\n$ javac a/Foo.java\n$ javac b/Bar.java\n$ java b.Bar\n$ Remove public from \"public class Inner\"\n$ javac a/Foo.java\n$ java b.Bar\nException in thread \"main\" java.lang.IllegalAccessError: tried to access class a.Foo$Inner from class b.Bar\n        at b.Bar.main(Bar.java:6)\n```\n\nI don't think adding a type alias is going to help us here since it's just going to get erased, I think we need to mark public in the bytecode all the package inner classes referenced from inline methods\n",
        "createdAt" : "2016-10-03T15:54:25Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "6ebd756c-72ce-4de6-b4ec-b5ae86cdbe8d",
        "parentId" : "a33dd643-5563-4a39-9704-00b0b96e1d72",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Interestingly, `scalac` 2.11 and 2.12 always emit private inner classes with `ACC_PUBLIC`:\n\n``` scala\npackage a;\n\nclass Foo {\n  private class Inner {\n    def get = 42\n  }\n}\n```\n\nBut `dotty` does emit them without `ACC_PUBLIC` unless we remove `private` from `private class Inner`.\n\nBoth `scalac` and `dotty` will prevent you from leaking a reference to a private class:\n\n``` scala\npackage a;\n\nclass Foo {\n  private class Inner {\n    def get = 42\n  }\n  val inner = new Inner // error: non-private value inner refers to private class Inner\n  type Duck = Inner // error: non-private type Duck refers to private class Inner\n}\n```\n\nThe easiest solution would be to always emit inner classes with `ACC_PUBLIC` as `scalac` does, @DarkDimius: do you think that this is reasonable ?\n",
        "createdAt" : "2016-10-03T16:14:55Z",
        "updatedAt" : "2016-10-05T16:02:27Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0a14e7939eda6a7f4914831975b2ac8877696f2",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +151,155 @@              // This is quite tricky, as such types can appear anywhere, including as parts\n              // of types of other things. For the moment we do nothing and complain\n              // at the implicit expansion site if there's a reference to an inaccessible type.\n              // Draft code (incomplete):\n              //"
  }
]
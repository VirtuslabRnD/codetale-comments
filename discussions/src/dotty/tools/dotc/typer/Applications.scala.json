[
  {
    "id" : "74fa5e28-905d-4d6f-a73a-36fe5cfc709c",
    "prId" : 1460,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34a0996d-b642-421c-8c4b-95db4b3c5a87",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Some of this code is duplicated from `typedApply` and this line is especially non-obvious, it would be better to have `simpleApply` and `typedApply` call into a common method\n",
        "createdAt" : "2016-08-22T07:39:50Z",
        "updatedAt" : "2016-08-22T07:39:50Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "971685af-3dc9-48be-980f-cfadae46b389",
        "parentId" : "34a0996d-b642-421c-8c4b-95db4b3c5a87",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "As far as I can see, the code was moved out of typedApply, not duplicated.\n",
        "createdAt" : "2016-08-22T14:27:36Z",
        "updatedAt" : "2016-08-22T14:27:36Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "41b7ca73480e868d830b08db382debf049418973",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +573,577 @@              else\n                new ApplyToUntyped(tree, fun1, funRef, proto, pt)(argCtx(tree))\n            convertNewGenericArray(ConstFold(app.result))\n          case _ =>\n            handleUnexpectedFunType(tree, fun1)"
  },
  {
    "id" : "7ae42867-8aa0-404b-ae87-4569b3a4a76b",
    "prId" : 1459,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe8a2bd3-12d4-4b6c-a357-3625cb2cd698",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Should be `def fail()` since it's not pure\n",
        "createdAt" : "2016-08-21T09:17:59Z",
        "updatedAt" : "2016-08-21T09:17:59Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "3360130593e3949b455b179f244ad76d7aedfe0e",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +593,597 @@              convertNewGenericArray(ConstFold(result))\n            } { (failedVal, failedState) =>\n              def fail = { failedState.commit(); failedVal }\n              tryWithImplicitOnQualifier(fun1, originalProto).getOrElse(\n                if (proto eq originalProto) fail"
  },
  {
    "id" : "4fc5b861-587c-4357-b17c-894a61f33779",
    "prId" : 1459,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aef52c9-8a83-4186-8fe6-65be71637dc4",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "Shouldn't this comment be updated? It says \"we assume the tupled proto-type in the rest of the application\" but we use both `proto` and `originalProto` below\n",
        "createdAt" : "2016-08-21T09:22:47Z",
        "updatedAt" : "2016-08-21T09:22:47Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "300ebe7f-fda9-4e34-82ba-b21fb6474913",
        "parentId" : "0aef52c9-8a83-4186-8fe6-65be71637dc4",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "OK, I'll take care of this in #1460.\n",
        "createdAt" : "2016-08-21T10:15:51Z",
        "updatedAt" : "2016-08-21T10:15:51Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3360130593e3949b455b179f244ad76d7aedfe0e",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +559,563 @@\n      // Warning: The following lines are dirty and fragile. We record that auto-tupling was demanded as\n      // a side effect in adapt. If it was, we assume the tupled proto-type in the rest of the application.\n      // This crucially relies on he fact that `proto` is used only in a single call of `adapt`,\n      // otherwise we would get possible cross-talk between different `adapt` calls using the same"
  },
  {
    "id" : "63dc5696-25ab-44ec-b59a-2e98996ea5b6",
    "prId" : 1399,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ed2d09e-5d25-430b-8baf-ef9f7059bd16",
        "parentId" : null,
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Why `RefinedType` is no longer relevant here? Is it possible that`tp.superType` is a `RefinedType` referencing a class, thus the recursive call becomes inconsistent with the specification that:\n\n> If a type proxy P is not a reference to a class, P's supertype is in G\n",
        "createdAt" : "2016-07-17T23:04:40Z",
        "updatedAt" : "2016-07-18T13:25:15Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "c1d82639-c111-4200-b14d-44593032c1ba",
        "parentId" : "1ed2d09e-5d25-430b-8baf-ef9f7059bd16",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "`RefinedType` is a `TypeProxy`. Generally, the diagram at the top of file Types.scala is important for full understanding of type testing logic.\n",
        "createdAt" : "2016-07-18T10:59:46Z",
        "updatedAt" : "2016-07-18T13:25:15Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "a525e29a-b248-4f35-aaa5-7eefeb2ffb4a",
        "parentId" : "1ed2d09e-5d25-430b-8baf-ef9f7059bd16",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "Thanks @odersky , I see `RefinedType` is a `TypeProxy`. I mean `RefinedType` referencing a class may be caught by `case tp: TypeProxy`, while the comment says:\n\n> If a type proxy P is **not a reference to a class**, P's supertype is in G\n\nIt seems to me the comment needs to be updated to be in accord with the code.\n",
        "createdAt" : "2016-07-18T11:20:28Z",
        "updatedAt" : "2016-07-18T13:25:15Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      },
      {
        "id" : "952b1d71-77d1-4209-a2f5-bc08f968cff3",
        "parentId" : "1ed2d09e-5d25-430b-8baf-ef9f7059bd16",
        "authorId" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "body" : "I see now, by _reference_ you mean only _TypeRef_, I was thinking any `TypeProxy` is referencing.\n",
        "createdAt" : "2016-07-18T11:31:14Z",
        "updatedAt" : "2016-07-18T13:25:15Z",
        "lastEditedBy" : "bc4c7970-6d84-475b-b408-2ed0f22a7bf3",
        "tags" : [
        ]
      }
    ],
    "commit" : "198817b3d55f3a3df4f320622e60515f05da3aa0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +753,757 @@        case tp: TypeRef if tp.symbol.isClass =>\n          tp.symbol.is(Trait) && isSubTypeOfParent(subtp, tp.firstParent)\n        case tp: TypeProxy => isSubTypeOfParent(subtp, tp.superType)\n        case _ => false\n      }"
  },
  {
    "id" : "6704e9c1-7c95-4e95-9666-8226b93cdd54",
    "prId" : 1389,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71849cb9-0aa4-4c6b-beba-3ca91b7746a9",
        "parentId" : null,
        "authorId" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "body" : "Could avoid the `var` here.\n",
        "createdAt" : "2016-07-15T09:42:18Z",
        "updatedAt" : "2016-07-18T08:14:02Z",
        "lastEditedBy" : "a7e5fcc8-eade-485d-96d2-94106dd74f83",
        "tags" : [
        ]
      },
      {
        "id" : "9f265c3a-32a0-4257-9619-0d9fbb24701f",
        "parentId" : "71849cb9-0aa4-4c6b-beba-3ca91b7746a9",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "How would you propose to avoid it?\n",
        "createdAt" : "2016-07-15T13:17:43Z",
        "updatedAt" : "2016-07-18T08:14:02Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "762375cb41c23fc912dd9c9e1cc273b706a65631",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +1087,1091 @@    }\n\n    var found = resolveOverloaded(alts, pt, Nil)(ctx.retractMode(Mode.ImplicitsEnabled))\n    if (found.isEmpty && ctx.mode.is(Mode.ImplicitsEnabled))\n      found = resolveOverloaded(alts, pt, Nil)"
  },
  {
    "id" : "63a48fd8-067a-49d6-b8fa-18a6fbf4754d",
    "prId" : 1288,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "643def8a-ee11-4cad-9948-b9a2899613e7",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That changes the logic of overloading resolution. With the change, we prefer methods that are applicable without implicit conversions to other methods. That's not as specced I think. What is the motivation for the change?\n",
        "createdAt" : "2016-06-03T15:24:35Z",
        "updatedAt" : "2016-06-03T19:33:08Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1fd9a965-9d80-48d9-95df-bcdc42721684",
        "parentId" : "643def8a-ee11-4cad-9948-b9a2899613e7",
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "From the commit message of https://github.com/lampepfl/dotty/pull/1288/commits/7a060ba8ed52bc4a5762917c8f0cb1322542bc4a:\n\n> If a directly applicable alternative exists, there is no need to try\n> every alternative (which would require searching for implicit\n> conversions for every argument that doesn't directly match). This should\n> not affect semantics since applicable overloads that require some\n> implicit conversions are dismissed in `narrowMostSpecific`\n\nThe motivation for this change is that I observed that many of the implicit searches when compiling dotty were caused by overloading resolution (e.g., every call to `Int#+` will check if the argument can be converted to `Char`,`Short`,`Double`, etc even if the argument is an `Int`)  It's possible that I missed a case where this does change the semantics, if so could you give an example?\n",
        "createdAt" : "2016-06-03T15:50:43Z",
        "updatedAt" : "2016-06-03T19:33:08Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "295c981f719d09a690076af9d87d48679b1ceb42",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1156,1160 @@            )\n          else\n            alts2\n        }\n"
  },
  {
    "id" : "2f077468-bf45-4907-b937-8552ac68f17d",
    "prId" : 1246,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b03974de-87f0-445b-9bb7-ae9dc8b5437e",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "When you say \"for methods\" you mean in the context of implicit resolution, right? It would be useful to say this explicitly, maybe even mention what part of the spec this refers to.\n",
        "createdAt" : "2016-05-06T17:39:06Z",
        "updatedAt" : "2016-05-23T16:54:36Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      }
    ],
    "commit" : "2f3b895a6e97d10fcc3d44bb2be782db9cc6bc68",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +951,955 @@     *  So `T <: U` would imply `List[Cmp[U]] <:s List[Cmp[T]]`, as usual.\n     *\n     *  This relation might seem strange, but it models closely what happens for methods.\n     *  Indeed, if we integrate the existing rules for methods into `<:s` we have now that\n     *"
  },
  {
    "id" : "9a2ddbca-9b0d-48d1-b678-020517d02adf",
    "prId" : 47,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1af39fa1-442a-41f3-b040-cae474e114e5",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "\"fromScala2x\" feels like a conversion, maybe \"isFromScala2x\"\n",
        "createdAt" : "2014-03-07T12:00:05Z",
        "updatedAt" : "2014-03-07T12:00:05Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "1e9c5fc7-dff2-4e67-a567-2594f3b72db5",
        "parentId" : "1af39fa1-442a-41f3-b040-cae474e114e5",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Agreed.\n",
        "createdAt" : "2014-03-07T13:14:19Z",
        "updatedAt" : "2014-03-07T13:14:19Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6aa88d6dfe501a695183761c2b5f4bd201cdf2c0",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +575,579 @@    }\n\n    def fromScala2x = unapplyFn.symbol.exists && (unapplyFn.symbol.owner is Scala2x)\n\n    def unapplyArgs(unapplyResult: Type)(implicit ctx: Context): List[Type] = {"
  }
]
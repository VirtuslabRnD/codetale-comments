[
  {
    "id" : "25a27147-04eb-4014-8cab-d6ce16f7e1ac",
    "prId" : 1188,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44b49d7b-1d47-4a4c-b91b-b94377eceef3",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "Why do you need `returnType`, here?\n\nAlso, why no bound? Right now `componentType` is completely unchecked; it might not be in sync. What about the following signature?\n\n``` scala\n  def newArray[T](componentType: Class[T], returnType: Class[Arrary[T]], dimensions: Array[Int]): Array[T] =\n    jlr.Array.newInstance(componentType, dimensions: _*).asInstanceOf[Arrary[T]]\n```\n",
        "createdAt" : "2016-03-24T14:03:30Z",
        "updatedAt" : "2016-04-18T13:01:34Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "2a4ea3bf-436f-43a1-8b31-95d579f91c20",
        "parentId" : "44b49d7b-1d47-4a4c-b91b-b94377eceef3",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "> Why do you need returnType, here?\n\nI need to recreate the returned type at backend. And this is the easiest way I've found to do this.\n\n> Also, why no bound? Right now componentType is completely unchecked; it might not be in sync. What about the following signature?\n\nIt's NOT in sync before erasure. When you're creating a `Array[Int]`, where `Int` is a primitive, you would like to pass https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#TYPE, that is the `Class` for primitive Int, but is statically typed as `Class[java.lang.Integer]`.\n",
        "createdAt" : "2016-03-24T14:48:37Z",
        "updatedAt" : "2016-04-18T13:01:34Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "24a0f98f-8e0d-4412-b251-bdc7327d6f64",
        "parentId" : "44b49d7b-1d47-4a4c-b91b-b94377eceef3",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "> that is the Class for primitive Int, but is statically typed as Class[java.lang.Integer].\n\nOuch! Why do we need this? Why can't we keep a `Literal(Constant(defn.IntType))`? That's how scalac does it, and I find it much more consistent.\n",
        "createdAt" : "2016-03-24T15:23:56Z",
        "updatedAt" : "2016-04-18T13:01:34Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "5399fbed6d33dca132ca27314f2eba414aea4415",
    "line" : null,
    "diffHunk" : "@@ -1,1 +28,32 @@   */\n  def newArray[Arr](componentType: Class[_], returnType: Class[Arr], dimensions: Array[Int]): Arr =\n    jlr.Array.newInstance(componentType, dimensions: _*).asInstanceOf[Arr]\n}"
  },
  {
    "id" : "a80a6b88-af35-4ef1-a767-2a2da5c79ecc",
    "prId" : 1188,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "439f5e2d-e67b-4b04-8797-3920eb1a10ef",
        "parentId" : null,
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "This comment is obsolete.\n",
        "createdAt" : "2016-03-31T13:04:45Z",
        "updatedAt" : "2016-04-18T13:01:34Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      }
    ],
    "commit" : "5399fbed6d33dca132ca27314f2eba414aea4415",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +25,29 @@  }\n\n  /** Create an array of a reference type T.\n   */\n  def newArray[Arr](componentType: Class[_], returnType: Class[Arr], dimensions: Array[Int]): Arr ="
  },
  {
    "id" : "ce4ed896-9d38-410c-8ac0-e4280933c965",
    "prId" : 1188,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58579f62-f951-4acb-b32f-b75ee9fe1404",
        "parentId" : null,
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Question: Am I right that the backend will eliminate these calls? If not it would be a potential performance problem, say if someone creates lots of 3-element Float vectors.\n",
        "createdAt" : "2016-04-01T12:41:32Z",
        "updatedAt" : "2016-04-18T13:01:34Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "1153c0a7-a510-406d-b061-5adc7a96cf9f",
        "parentId" : "58579f62-f951-4acb-b32f-b75ee9fe1404",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "That's the intention!\nIf `dimension.size ==1` backend will create a normal array\nIf `dimension.size > 1` backend will issue `multianewarray` instruction.\n\nSee example here: https://github.com/dotty-staging/dotty/blob/remove-newarray-magic/tests/run/MultiArr.scala\n",
        "createdAt" : "2016-04-01T13:03:08Z",
        "updatedAt" : "2016-04-18T13:01:34Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "5399fbed6d33dca132ca27314f2eba414aea4415",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +27,31 @@  /** Create an array of a reference type T.\n   */\n  def newArray[Arr](componentType: Class[_], returnType: Class[Arr], dimensions: Array[Int]): Arr =\n    jlr.Array.newInstance(componentType, dimensions: _*).asInstanceOf[Arr]\n}"
  },
  {
    "id" : "b29296b5-aa2a-4e39-b6cd-8d14c7533918",
    "prId" : 254,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0632529a-cd61-43a6-989e-a030f284805c",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "Is return type T instead of Array[T] here intentional?\n",
        "createdAt" : "2014-12-01T14:50:53Z",
        "updatedAt" : "2014-12-01T14:50:53Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "8e2ef3ee-cace-47dd-aceb-ba33eaf62945",
        "parentId" : "0632529a-cd61-43a6-989e-a030f284805c",
        "authorId" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "body" : "From the comment: \"`T` must be of form `Array[E]`\". So yes, I suppose it is intentional.\n",
        "createdAt" : "2014-12-01T14:53:43Z",
        "updatedAt" : "2014-12-01T14:53:43Z",
        "lastEditedBy" : "5a9cd756-9120-4d5e-ac88-e9c636084f0e",
        "tags" : [
        ]
      },
      {
        "id" : "334b6278-33fc-4fcc-8014-00e81ef82f35",
        "parentId" : "0632529a-cd61-43a6-989e-a030f284805c",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, that's intentional. It's a technically to fit best with the way erasure works for polymorphic functions. That way, we can treat newRefArray and asInstanceOf in exactly the same way.\n",
        "createdAt" : "2014-12-01T15:02:27Z",
        "updatedAt" : "2014-12-01T15:02:27Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "91c61e4694097971b9a0c139048b7239d0f05588",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +17,21 @@   *  E being a reference type.\n   */\n  def newRefArray[T](length: Int): T = ???\n\n  /** Create a Byte[] array */"
  }
]
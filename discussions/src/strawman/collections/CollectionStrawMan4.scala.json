[
  {
    "id" : "b346c421-46d4-4cd9-bdc6-da2677c923bc",
    "prId" : 1249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9cb569a-23a2-4fd9-b13e-b6afac62b376",
        "parentId" : null,
        "authorId" : "7aa36552-f314-4217-a921-109d4a7a544d",
        "body" : "Is this commit here intentionally?\n",
        "createdAt" : "2016-05-14T23:29:55Z",
        "updatedAt" : "2016-05-14T23:29:55Z",
        "lastEditedBy" : "7aa36552-f314-4217-a921-109d4a7a544d",
        "tags" : [
        ]
      },
      {
        "id" : "f2b6a16b-2bc3-4d88-85b8-2c5c49b0dbdc",
        "parentId" : "c9cb569a-23a2-4fd9-b13e-b6afac62b376",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, I just threw it in to save time.\n",
        "createdAt" : "2016-05-16T15:28:28Z",
        "updatedAt" : "2016-05-16T15:28:28Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5ae15e2943bd5319c86c1fc01753fc2ceeb36d6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +14,18 @@ *  For a test file, see tests/run/CollectionTests.scala.\n *\n *  Strawman4 is like strawman1, but built over views instead of by-name iterators\n */\nobject CollectionStrawMan4 {"
  },
  {
    "id" : "4cc7bbb9-1fa1-4ce5-b567-540d78670271",
    "prId" : 1160,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dde8d215-d400-425c-bb49-ddfd4bc5b91e",
        "parentId" : null,
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "AFAIK Rust initially had `RandomAccessIterator`, but then they decided to drop it. It was creating more problems than solving.\n",
        "createdAt" : "2016-03-09T13:11:24Z",
        "updatedAt" : "2016-03-09T17:35:12Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      }
    ],
    "commit" : "7dfab5f427ad9600b8e54b61716461787d7fa4a1",
    "line" : 292,
    "diffHunk" : "@@ -1,1 +290,294 @@\n  /** Iterator defined in terms of indexing a range */\n  trait RandomAccessView[+A] extends View[A] {\n    def start: Int\n    def end: Int"
  },
  {
    "id" : "05b3fc6f-8ec1-4008-8af7-03582173c438",
    "prId" : 1160,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c97aea9-01ac-460a-8800-6c9f5daa2fde",
        "parentId" : null,
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "From the perspective of the optimizer this looks \"rather\" complex, optimistically speaking. Probably too hard to optimize (cc @sjrd)\n\nHere's how things expand:\n\n```\nList(1,2,3).map(_ + 1)\n\n// extension method\nnew IterablePolyTransforms(List(1,2,3)).map(_ + 1)\n\n// inline map\nval pt = new IterablePolyTransforms(List(1,2,3))\npt. fromIterable(View.Map(pt.coll, _ + 1))\n\n// inline IterablePolyTransforms.fromIterable\nval pt = new IterablePolyTransforms(List(1,2,3))\npt.coll.fromIterable(View.Map(pt.coll, _ + 1))\n\n// inline List.fromIterable\nval pt = new IterablePolyTransforms(List(1,2,3))\nList.fromIterable(View.Map(pt.coll, _ + 1))\n\n// inline List$.fromIterable\nval pt = new IterablePolyTransforms(List(1,2,3))\nView.Map(pt.coll, _ + 1) match {\n  case View.Concat(xs, ys: Iterable[B]) => ...\n  case View.Drop(xs: List[B], n) => ..\n  case _ => fromIterator(c.iterator)\n}\n\n// inline fromIterator -- actually not possible because it's recursive in non-tail position\nval pt = new IterablePolyTransforms(List(1,2,3))\ndef fromIt(it: Iterator) = if (it.hasNext) Cons(it.next, fromIterator(it)) else Nil\nfromIt(View.Map(pt.coll, _ + 1).iterator)\n\n// stack-allocate View.Map and inline .iterator\nval pt = new IterablePolyTransforms(List(1,2,3))\ndef fromIt(it: Iterator) = if (it.hasNext) Cons(it.next, fromIterator(it)) else Nil\nfromIt(pt.coll.iterator.map(_ + 1))\n\n// inline Iterator.map\nval pt = new IterablePolyTransforms(List(1,2,3))\ndef fromIt(it: Iterator) = if (it.hasNext) Cons(it.next, fromIterator(it)) else Nil\nfromIt(new Iterator {\n  val f = (x: Int) => x + 1\n  val self = pt.coll.iterator\n  def hasNext = self.hasNext\n  def next() = f(self.next())\n})\n```\n\nIf `fromIt` was not recursive we could inline it and start inlining `hasNext` and `next`, and eventually end up with a monomorphic loop. I jumped over many details, I'm really not sure we could push the optimizer that far.\n",
        "createdAt" : "2016-03-09T13:39:50Z",
        "updatedAt" : "2016-03-09T17:35:12Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      },
      {
        "id" : "8ce9f638-8e6f-446c-a9b3-5c9745ba3843",
        "parentId" : "4c97aea9-01ac-460a-8800-6c9f5daa2fde",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am not sure the problem with recursive `fromIterator` will persist in the full system. Instead of using `Cons` we'd use a `ListBuffer` and append at the end. Then `fromIterator` would be tail recursive.\n",
        "createdAt" : "2016-03-09T13:54:58Z",
        "updatedAt" : "2016-03-09T17:35:12Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "55319354-300d-4cb5-9efc-5a22ac10fafe",
        "parentId" : "4c97aea9-01ac-460a-8800-6c9f5daa2fde",
        "authorId" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "body" : "sure, but that is not the hard part for the optimizer\n",
        "createdAt" : "2016-03-09T14:01:31Z",
        "updatedAt" : "2016-03-09T17:35:12Z",
        "lastEditedBy" : "998ba0f7-d6a6-448f-a3ba-0d2237ed0cf9",
        "tags" : [
        ]
      }
    ],
    "commit" : "7dfab5f427ad9600b8e54b61716461787d7fa4a1",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +80,84 @@    protected def coll: Iterable[A]\n    protected def fromIterable[B](it: Iterable[B]): C[B]\n    def map[B](f: A => B): C[B] = fromIterable(View.Map(coll, f))\n    def flatMap[B](f: A => IterableOnce[B]): C[B] = fromIterable(View.FlatMap(coll, f))\n    def ++[B >: A](xs: IterableOnce[B]): C[B] = fromIterable(View.Concat(coll, xs))"
  }
]
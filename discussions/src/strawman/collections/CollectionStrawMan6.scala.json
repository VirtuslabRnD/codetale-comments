[
  {
    "id" : "fcdcf803-5ec4-4c5d-a9a5-845cfd0cb4e0",
    "prId" : 1414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19d48294-1fce-4a89-9644-b8567cd83689",
        "parentId" : null,
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "Why do we need two separate classes? Could the array operations be implemented in ArrayView?\n",
        "createdAt" : "2016-07-28T13:59:26Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "2162821b-90bc-45bd-860a-d0310a17c73f",
        "parentId" : "19d48294-1fce-4a89-9644-b8567cd83689",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Then they would not be considered in this scenario:\n\n```\nval x: Seq[Int] = Array(1, 2, 3)\n```\n",
        "createdAt" : "2016-07-28T14:34:49Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e95a105869ec2d978d5e7e0a3f78442e19b2fe5",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +10,14 @@\n  /** Convert array to iterable via view. Lower priority than ArrayOps */\n  implicit def arrayToView[T](xs: Array[T]): ArrayView[T] = new ArrayView[T](xs)\n\n  /** Convert string to iterable via view. Lower priority than StringOps */"
  },
  {
    "id" : "63e96aba-59e6-42a5-bb20-8f38af7f883f",
    "prId" : 1414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ebef8b1-4480-4bb3-826b-abc29dfd3c28",
        "parentId" : null,
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "Is this a good abstraction for efficiency? As used in `ListBuffer`, it adds overhead for the copy-on-write semantics, which could be avoided with a special builder class.\n",
        "createdAt" : "2016-07-28T15:55:36Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "e20a9ea4-e3e9-4c88-9360-f2f2af67d3e4",
        "parentId" : "1ebef8b1-4480-4bb3-826b-abc29dfd3c28",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "I am not sure I have understood where you see the inefficiency. When using a ListBuffer to build a List, there's one additional object created (namely the List builder which is the result of `mapResult`). True, we would could prevent allocation of that object by specialising. \n",
        "createdAt" : "2016-07-29T09:49:46Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "dc69ee26-224e-42d5-9deb-57b4589042fe",
        "parentId" : "1ebef8b1-4480-4bb3-826b-abc29dfd3c28",
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "It looks like `ListBuffer` only uses copy-on-write because it is used internally as a builder. COW may add overhead because it has to check `aliased` on every append (but I wouldn't be surprised if the impact turns out to be negligible in practice due to branch prediction doing the right thing).\n",
        "createdAt" : "2016-07-29T11:09:33Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "38491647-10f6-43cc-b709-886ed6157d14",
        "parentId" : "1ebef8b1-4480-4bb3-826b-abc29dfd3c28",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "ListBuffer always had copy on write semantics, and that's also heavily used in manual construction. Having a ListBuffer without COW would not gain us much I believe.\n",
        "createdAt" : "2016-07-29T11:54:43Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e95a105869ec2d978d5e7e0a3f78442e19b2fe5",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +198,202 @@\n    /** A builder resulting from this builder my mapping the result using `f`. */\n    def mapResult[NewTo](f: To => NewTo) = new Builder[A, NewTo] {\n      def +=(x: A): this.type = { self += x; this }\n      override def ++=(xs: IterableOnce[A]): this.type = { self ++= xs; this }"
  },
  {
    "id" : "131dd785-f33a-4601-9b68-27411c5fd1fe",
    "prId" : 1414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "485dc22c-8fab-49b6-ab9e-271cac648a3d",
        "parentId" : null,
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "Will the dotty linker be able to specialize this?\n",
        "createdAt" : "2016-07-28T16:49:42Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "5b8dd08c-9607-4759-81de-3f2b4589db57",
        "parentId" : "485dc22c-8fab-49b6-ab9e-271cac648a3d",
        "authorId" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "body" : "So far, no. If user insisted on AnyRef, it currently does nothing.\n",
        "createdAt" : "2016-07-28T17:16:46Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "5bf81a51-885f-46a7-83a3-61092da8405f",
        "tags" : [
        ]
      },
      {
        "id" : "c08c1318-4b47-4285-95e6-abc7c4b7dda8",
        "parentId" : "485dc22c-8fab-49b6-ab9e-271cac648a3d",
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "It would be great if this problem could be solved in a strawman proposal. Getting specialized arrays internally in the collection implementations would be a big improvement over the current collections library.\n",
        "createdAt" : "2016-07-29T10:46:28Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e95a105869ec2d978d5e7e0a3f78442e19b2fe5",
    "line" : 527,
    "diffHunk" : "@@ -1,1 +525,529 @@    def this() = this(new Array[AnyRef](16), 0)\n\n    private var elems: Array[AnyRef] = initElems\n    private var start = 0\n    private var end = initLength"
  },
  {
    "id" : "d4c5e5a9-2ab8-4d85-856e-00a24b29461c",
    "prId" : 1414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2f7ece1-10dc-4303-9259-9666a65dab61",
        "parentId" : null,
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "Why not a `lazy val result` so you don't need a separate `force` method?\n",
        "createdAt" : "2016-07-28T17:10:31Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "27188626-ed53-48a7-8c17-ea4c5b5d8059",
        "parentId" : "c2f7ece1-10dc-4303-9259-9666a65dab61",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Printing (and maybe other ops?) need to find out whether the result is forced or not. Can't do this with a lazy val. \n",
        "createdAt" : "2016-07-29T09:43:04Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "9e19fbde-c544-490b-b62a-117ecdfd8f28",
        "parentId" : "c2f7ece1-10dc-4303-9259-9666a65dab61",
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "How about this?\n\n```\n  private[this] var evaluated = false\n  private[this] lazy val result: LazyList.Evaluated[A] = {\n    val res = expr\n    evaluated = true\n    res\n  }\n\n```\n",
        "createdAt" : "2016-07-29T10:53:33Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "eb5f0b0d-0832-4180-9149-7349a0f33f1a",
        "parentId" : "c2f7ece1-10dc-4303-9259-9666a65dab61",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "Yes, that's another way to write it. \n",
        "createdAt" : "2016-07-29T11:55:45Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e95a105869ec2d978d5e7e0a3f78442e19b2fe5",
    "line" : 611,
    "diffHunk" : "@@ -1,1 +609,613 @@    private[this] var result: LazyList.Evaluated[A] = _\n\n    def force: LazyList.Evaluated[A] = {\n      if (!evaluated) {\n        result = expr"
  },
  {
    "id" : "ebe10dcb-3701-4ddd-852d-a26d84eccb23",
    "prId" : 1414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6be947fa-ed35-4c5b-9bd6-804c67b9deb3",
        "parentId" : null,
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "Could you have types like `IndexedView` with additional operations on views that are based on IndexedSeqs? This approach doesn't look very extensible because the View operation subclasses for that would all have to extend `IndexedView`.\n",
        "createdAt" : "2016-07-28T17:27:08Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "44d0418c-b4e0-4586-9d98-d717a58b2d26",
        "parentId" : "6be947fa-ed35-4c5b-9bd6-804c67b9deb3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That's an interesting tradeoff. The current 2.{7-12} views do indeed subclass, but introduce a LOT of boilerplate that way. The design here does not do that, but opts instead for views to represent the _operations_ in the case classes while abstracting over the underlying collection type. I have not yet found a good way to combine the two, nor a hard reason why we should.\n",
        "createdAt" : "2016-07-29T09:45:32Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      },
      {
        "id" : "3c16bd71-63fe-4efb-a829-3a29e154679f",
        "parentId" : "6be947fa-ed35-4c5b-9bd6-804c67b9deb3",
        "authorId" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "body" : "Possible use case:\n\n```\n(xs: IndexedSeq[A]).view.map(f).map(g).slice(a, b)\n```\n\nIf you want to have optimized versions for `IndexedSeq` I think you need to bake it into the supported operations. For example, `Map` and `Slice` would extend `IndexedView`, but you'd only see them cast up to a `View` unless you use them on an `IndexedSeq`. `Filter` on the other hand would only extend `View`. If you call it on an `IndexedView` you only get a `View` as the result.\n",
        "createdAt" : "2016-07-29T11:03:41Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "1d2e6057-010c-4222-83cf-671f8414157b",
        "tags" : [
        ]
      },
      {
        "id" : "73c09d84-96f8-47b7-879e-0f7680dc7313",
        "parentId" : "6be947fa-ed35-4c5b-9bd6-804c67b9deb3",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "That's similar to what we have so far. But it basically means virtual classes, which has a heavy encoding (the current version of views is due to Sean McDermid, who at the time was a big fan of virtual classes).\n",
        "createdAt" : "2016-07-29T15:58:13Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e95a105869ec2d978d5e7e0a3f78442e19b2fe5",
    "line" : 785,
    "diffHunk" : "@@ -1,1 +783,787 @@\n    /** Avoid copying if source collection is already a view. */\n    override def fromIterable[B](c: Iterable[B]): View[B] = c match {\n      case c: View[B] => c\n      case _ => View.fromIterator(c.iterator)"
  },
  {
    "id" : "40f11309-fab5-4d31-bc8b-f6879cf9d61d",
    "prId" : 1414,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "57fe0285-cfd6-4fe7-af78-183b95e46550",
        "parentId" : null,
        "authorId" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "body" : "If you do this then any call to `view` on a value with type `IndexedSeq[Foo]` will end up going through reflection, no?\n",
        "createdAt" : "2016-07-30T22:07:51Z",
        "updatedAt" : "2016-07-31T10:18:17Z",
        "lastEditedBy" : "9ffc9890-522c-4d3a-8fe5-fb5cbad2b309",
        "tags" : [
        ]
      },
      {
        "id" : "eb26398f-868a-4cd8-8dcf-7fb42cae9ffe",
        "parentId" : "57fe0285-cfd6-4fe7-af78-183b95e46550",
        "authorId" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "body" : "On Sun, Jul 31, 2016 at 12:07 AM, Guillaume Martres <\nnotifications@github.com> wrote:\n\n> In src/strawman/collections/CollectionStrawMan6.scala\n> https://github.com/lampepfl/dotty/pull/1414#discussion_r72894931:\n> \n> > @@ -156,6 +159,8 @@ object CollectionStrawMan6 extends LowPriority {\n> >      }\n> >    }\n> > -  type IndexedSeq[+A] = Seq[A] { def view: IndexedView[A] }\n> \n> If you do this then any call to view on a value with type IndexedSeq[Foo]\n> will end up going through reflection, no?\n> \n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/lampepfl/dotty/pull/1414/files/dabf044485c60245e0fdf64c28eaa90285242a75..8db8c110a2b2a287875222a74511511d80be2b15#r72894931,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAwlVn1LM5xD42dSM8pPrJcmLIQls_Cjks5qa8s5gaJpZM4JUZlv\n> .\n> \n> I don't think so, since `view` is already a method on `Seq`.\n",
        "createdAt" : "2016-07-31T10:20:45Z",
        "updatedAt" : "2016-07-31T10:20:45Z",
        "lastEditedBy" : "d08d2c4a-dc79-4be6-96b0-506d21e90d1d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e95a105869ec2d978d5e7e0a3f78442e19b2fe5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +160,164 @@  }\n\n  type IndexedSeq[+A] = Seq[A] { def view: IndexedView[A] }\n\n  /** Base trait for strict collections that can be built using a builder."
  }
]
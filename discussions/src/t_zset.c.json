[
  {
    "id" : "78cbbd70-c247-4fef-b067-fd5d5a0b3036",
    "prId" : 8979,
    "prUrl" : "https://github.com/redis/redis/pull/8979#pullrequestreview-667425704",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11d2c2c1-050d-4a48-a0f6-9cf77955b9ae",
        "parentId" : null,
        "authorId" : "ad1e7044-3785-4002-a4a5-9bf9117dfa24",
        "body" : "In fact, this is a bug that currently does not cause memory leaks, because `op->type = OBJ_ZSET`, In `zuiClearIterator`, we will do nothing, but I agree that `zuiInitIterator` and `zuiClearIterator` should appear in pairs.",
        "createdAt" : "2021-05-25T06:15:50Z",
        "updatedAt" : "2021-05-25T06:16:30Z",
        "lastEditedBy" : "ad1e7044-3785-4002-a4a5-9bf9117dfa24",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c504a241dfa64e3323b4d9b664a639fbc434056",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +4071,4075 @@                addReplyDouble(c, zval.score);\n        }\n        zuiClearIterator(&src);\n        return;\n    }"
  },
  {
    "id" : "cd7d44ac-adc5-401f-a563-5eea0535fc3e",
    "prId" : 8398,
    "prUrl" : "https://github.com/redis/redis/pull/8398#pullrequestreview-575991488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4f132ea-b1d3-4811-864d-8ead399f2f6d",
        "parentId" : null,
        "authorId" : "3ca74ed4-ec73-427d-88cb-0c084b679a52",
        "body" : "Looks like the build is failing since withscores is now unused, I guess we should remove it from this function. ",
        "createdAt" : "2021-01-26T03:46:11Z",
        "updatedAt" : "2021-01-26T04:03:43Z",
        "lastEditedBy" : "3ca74ed4-ec73-427d-88cb-0c084b679a52",
        "tags" : [
        ]
      }
    ],
    "commit" : "efa4b8beedf24b523bd566ae3b7286f7ac10ebbb",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +3175,3179 @@\n            rangelen++;\n            handler->emitResultFromCBuffer(handler, ln->ele, sdslen(ln->ele), ln->score);\n\n            /* Move to next node */"
  },
  {
    "id" : "d5b72c3e-d6b1-4de0-a431-cdf14f418132",
    "prId" : 8297,
    "prUrl" : "https://github.com/redis/redis/pull/8297#pullrequestreview-574943077",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3274525-5163-4609-a9bc-daafeb186f45",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "btw, i now saw that CASE 2, and CASE 3, are not taking care of random order (CASE 4 is easy to fix by replying right away and not at the end)\r\n\r\nso we need to re-think if CASE 1 really needs random order or we can switch to a slightly more efficient algorithm",
        "createdAt" : "2021-01-21T15:34:48Z",
        "updatedAt" : "2021-01-29T08:33:17Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "9ba4fbfd-d3d7-4a02-8336-9ac4b5853901",
        "parentId" : "f3274525-5163-4609-a9bc-daafeb186f45",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "thinking about this more, i think there might be a good reason for a difference in behavior in terms of order of returned elements between positive and negative count.\r\n\r\nnegative count is like an optimization of calling this function without count, in a loop.\r\nso doing\r\n```\r\na = SRANDMEMBER(s, -3)\r\n```\r\nshould be like:\r\n```\r\nfor(i=0; i<3; i++)\r\n    a[i] = SRANDMEMBER(s)\r\n```\r\ni would vote to make sure CASE1 (negative count) returns random order, and let the others return unique random elements without random order.\r\n@itamarhaber WDYT?",
        "createdAt" : "2021-01-24T09:10:10Z",
        "updatedAt" : "2021-01-29T08:33:17Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "5ccefb43-9550-4515-a88e-0417d4d18fe5",
        "parentId" : "f3274525-5163-4609-a9bc-daafeb186f45",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "Discussed with Itamar, we concluded that only the negative count should retain random order.\r\nsee https://github.com/redis/redis/pull/8297/files#r561944719",
        "createdAt" : "2021-01-24T15:58:58Z",
        "updatedAt" : "2021-01-29T08:33:17Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      }
    ],
    "commit" : "c456e035bea6605b76f09769a331653a83496ffa",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +4046,4050 @@        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the zset: simply return the whole zset. */"
  },
  {
    "id" : "23fbff78-4264-4453-88a9-da2d5477cff5",
    "prId" : 8105,
    "prUrl" : "https://github.com/redis/redis/pull/8105#pullrequestreview-540526144",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8df9c4fe-09a9-49d3-98a5-8f881050034f",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "i think we may be iterating on the last element twice (please check).\r\ni.e. we start with the element name of the last element (second to the last in the ziplist).\r\nthen we go forward to take it's score.\r\nbut then we'll use zzlPrev to to go backwards, which will call ziplistPrev twice (serving the same element we just saw again).\r\nif i'm right, the fix is to replace these two lines with ziplistIndex(-1), and ziplistPrev (switching eptr with sptr)",
        "createdAt" : "2020-11-29T07:35:03Z",
        "updatedAt" : "2020-12-03T07:28:21Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "151e9706-519b-4d98-9e72-692a071ed9af",
        "parentId" : "8df9c4fe-09a9-49d3-98a5-8f881050034f",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "Initially I implemented exactly as you said, and it worked, but then I realized that there is no need, just changing the initial index already does what we want. What matters for zzlPrev is that eptr points to the first element in the \"pair\", and sptr the second element. That's why it calls ziplistPrev twice, going back from eptr, the first call to ziplistPrev gets the previous sptr, and then gets the previous eptr.\r\n\r\nIn the initialization, we first get to eptr by getting the element just before the last one. The call to ziplistNext then gets the tail element, which is just after eptr. I can reverse the order like you said (get sptr at \"-1\", then eptr by using ziplistPrev), if you think it makes the code more readable, but it works the same.",
        "createdAt" : "2020-11-29T16:10:06Z",
        "updatedAt" : "2020-12-03T07:28:21Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "e3cc470c-0849-463c-84a2-ac804d9422df",
        "parentId" : "8df9c4fe-09a9-49d3-98a5-8f881050034f",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "@felipou maybe we don't understand each other.\r\ni don't care if we go to -2, then -1, or go to -1 and then -2.\r\nbut i think with the current code we iterate on the last item in the set twice.\r\ni.e. in our first iteration, eptr is -2, and sptr is -1.\r\nthen we call zzlPrev, which will set sptr to -1, and etpr to -2.\r\nthen call zzlPrev again, which will set sptr to -3 and eptr to -4.\r\n\r\nor am i missing something?",
        "createdAt" : "2020-11-29T16:34:01Z",
        "updatedAt" : "2020-12-03T07:28:21Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "fba0789a-2e39-4fba-b0b4-62366176d2c3",
        "parentId" : "8df9c4fe-09a9-49d3-98a5-8f881050034f",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "We init eptr as -2 and sptr -1. The zuiNext call will return these values, and also call zzlPrev. The zzlPrev call will call ziplistPrev on eptr (-2) to get the new sptr at -3, and then it calls ziplistPrev again but now on the new sptr (-3), getting the new eptr at -4.\r\n\r\nThe ziplistPrev gets an element as an argument, and returns the elements before it. So if we pass the eptr at -2, we will get the previous sptr at -3.",
        "createdAt" : "2020-11-29T21:48:26Z",
        "updatedAt" : "2020-12-03T07:28:21Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "d8c91dc2-53d0-4a17-81c1-4a0136fe4afe",
        "parentId" : "8df9c4fe-09a9-49d3-98a5-8f881050034f",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "ok got it.\r\nthanks.",
        "createdAt" : "2020-11-29T21:52:55Z",
        "updatedAt" : "2020-12-03T07:28:21Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      }
    ],
    "commit" : "b398354e9a821a5e0b242a1a6f902be3cd77a9c0",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1974,1978 @@            it->zl.eptr = ziplistIndex(it->zl.zl,-2);\n            if (it->zl.eptr != NULL) {\n                it->zl.sptr = ziplistNext(it->zl.zl,it->zl.eptr);\n                serverAssert(it->zl.sptr != NULL);\n            }"
  },
  {
    "id" : "97eda53a-f3ce-4aad-908a-d5bc1168b5f7",
    "prId" : 7961,
    "prUrl" : "https://github.com/redis/redis/pull/7961#pullrequestreview-521154258",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31686f8e-9238-463a-84d3-cfafc58d6c7b",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "i see you forgot to release the dict iterator (memory leak).",
        "createdAt" : "2020-10-28T07:33:59Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "2d734004-5158-4d0d-aaf4-a37bc9032190",
        "parentId" : "31686f8e-9238-463a-84d3-cfafc58d6c7b",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "Fixed.",
        "createdAt" : "2020-10-31T17:06:32Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      }
    ],
    "commit" : "540a78b57a6dba3b2ae8093eb458914b6391949d",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +2215,2219 @@    dictReleaseIterator(di);\n\n    return maxelelen;\n}\n"
  },
  {
    "id" : "44d07109-b678-490c-aee0-55f1e950b67b",
    "prId" : 7961,
    "prUrl" : "https://github.com/redis/redis/pull/7961#pullrequestreview-527856601",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6edd5fe1-9bdf-4c23-be4f-566de7ac11b4",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "going over the list backwards will make zslInsert more efficient, see:\r\nhttps://github.com/redis/redis/blob/d8fbd3a8bafc9b430da6c3c13bdd04af4d75ad0c/src/rdb.c#L855-L862\r\n\r\nalternatively, maybe we can improve zslInsert to be optimized for this case too?",
        "createdAt" : "2020-11-04T19:16:01Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "c8b6eb34-fb36-4a96-9eb0-303e6fe3824f",
        "parentId" : "6edd5fe1-9bdf-4c23-be4f-566de7ac11b4",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "Ok, I just analyzed the code, and it's a bit more complicated than I thought. The referenced code already knows that it's a skiplist. In the case of zdiff, we have to cover all cases since the `src` values can have any encoding. I've checked that `zuiInitIterator` and `zuiNext` are only used in zinter/zunion/zdiff, so I thought about changing then to `zuiInitBackIterator` and `zuiPrev`. I'll have to study the data structure a bit more to understand how to do that, but shouldn't be too hard. I'll try to finish this tomorrow.",
        "createdAt" : "2020-11-11T04:38:37Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      }
    ],
    "commit" : "540a78b57a6dba3b2ae8093eb458914b6391949d",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +2244,2248 @@    memset(&zval, 0, sizeof(zval));\n    zuiInitIterator(&src[0]);\n    while (zuiNext(&src[0],&zval)) {\n        double value;\n        int exists = 0;"
  },
  {
    "id" : "c439f824-ab5a-41cc-a43d-ae89d320839e",
    "prId" : 7961,
    "prUrl" : "https://github.com/redis/redis/pull/7961#pullrequestreview-540423758",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "same, going backwards will make zslInsert faster",
        "createdAt" : "2020-11-04T19:16:45Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "b3785b57-c595-4160-83c0-6938d121a18c",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "Here I had an extra concern, which is the impact that this will have on `zsetslDel`. Should we iterate forward when deleting the elements? This would be simple, we could just move loop to inside the if that checks if it's the first set or not, iterating backwards in one case, and forward in the other.",
        "createdAt" : "2020-11-11T04:40:13Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "720ce7fd-4898-4c0a-b7ab-a6ff2e0c6488",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "you mean `zslDelete`? looking at it, and considering we can't know the order of elements between efferent sets, i'm not sure if it has any principal difference.\r\n\r\nmaybe for the (possibly common case) that we have just two sets, and the majority of the elements are being deleted, it's best to iterate from head to tail. (constantly deleting the first element and no need for long searches).\r\n\r\nmaybe instead of changing the ZDIFF code, it's better to try to have zslInsert detect an insertion to the tail and make it efficient for that case too.\r\nthis way no one else will have to worry to scan insertions in the efficient direction.",
        "createdAt" : "2020-11-11T12:43:07Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "f5db7dd8-313b-4847-92fb-d3301e1746b6",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "Seems like a better idea indeed. I'll try to look into it, but I'll have to better understand the skiplist data structure, because I read the zslInsert code and couldn't see an easy way to optimize for that case. The only idea I had was to add a \"hint\" so that it assumes the element is greater than all, but I don't think it's possible to just reverse the loops, since it would change the way the \"rank\" array in the function is calculated.",
        "createdAt" : "2020-11-11T13:19:15Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "33065661-a997-42d8-8c79-673f727d52ae",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "It just ocurred to me: since this is an optimization that affects other commands, maybe it should be in a different pull request?",
        "createdAt" : "2020-11-11T13:21:03Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "26318e59-db29-472c-a9f2-70dc9058c76d",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "yeah, it can (be in a different PR).\r\nthe reason to consider it now, is because we added a new inefficient code in ZDIFF.\r\nbut even if we'll end up concluding that zslInsert should remain as is, and decide to change the ZDIFF code to run backwards, we can do that in a different PR too.\r\n\r\np.s. the skiplist has a tail pointer, it should be easy to see that the new entry is greater than the tail. not sure about the efficiency of insertion yet.\r\n\r\nanyway, if you rather lave that out for now i'm ok with it.\r\nin which case we just need to merge my documentation changes (assuming you confirm that they're correct).",
        "createdAt" : "2020-11-11T14:53:42Z",
        "updatedAt" : "2020-11-13T01:25:15Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "aafa11d2-e0e0-471c-a624-d0400d26f66f",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "As it's a deeper algorithmic change that affects other commands, it should fit well as a separate pull request, but I don't have anything against doing it here. I've finished everything else, so I think it's an option to consider. But anyway, I'll focus on the optimization of zslInsert from now on!",
        "createdAt" : "2020-11-13T01:29:50Z",
        "updatedAt" : "2020-11-13T01:29:50Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "ec62f7d3-0288-4f17-b6e4-4e14c49ecde1",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "let's make it in a different PR. this one is already going too long, and since the change isn't gonna affect the API, and might even be in a different are in the code with implications to other parts of redis...",
        "createdAt" : "2020-11-13T07:58:30Z",
        "updatedAt" : "2020-11-13T07:58:30Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "c37a85fd-2b0d-488b-97e3-dff9f7bf4c1f",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "@felipou will you have time to try to handle that soon?\r\ni wanna make ZDIFF efficient for 6.2 one way or another (we have about 2 weeks before an RC).",
        "createdAt" : "2020-11-25T08:52:37Z",
        "updatedAt" : "2020-11-25T08:52:38Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "4e3b7c64-7d72-4c64-9e3e-3270e04ff2be",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "I'll try to come up with something today, at least an initial PR that we can build on top of, that way if I don't have much time in the next weeks someone can pick up where I left. But I believe I can get something working by the next weekend.",
        "createdAt" : "2020-11-25T18:01:04Z",
        "updatedAt" : "2020-11-25T18:01:05Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "38218cc4-bd38-4020-be74-8b3b3e839832",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "I just reviewed the insert algorithm for skip lists, and if I understand correctly, there is no way to efficiently insert backwards. To insert, we need to update the forward pointers in all levels, so we need to traverse the list anyway. The backwards pointer is only in the first level, and is only an optimization for ZREVRANGE to traverse the list backwards. If we created backward pointers for all levels, we would end up having to traverse the list both ways when inserting (and deleting and updating).\r\n\r\nI'll try to come up with the backward equivalents of zuiInitIterator and zuiNext instead, so that we can modify the ZDIFF code directly. ",
        "createdAt" : "2020-11-25T21:08:28Z",
        "updatedAt" : "2020-11-25T21:08:28Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      },
      {
        "id" : "2090845b-2bf5-42c4-87b5-84807b33db1e",
        "parentId" : "b39dd340-11e4-489c-9373-158ab88ec17c",
        "authorId" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "body" : "Just finished this PR: https://github.com/redis/redis/pull/8105",
        "createdAt" : "2020-11-28T23:31:08Z",
        "updatedAt" : "2020-11-28T23:31:09Z",
        "lastEditedBy" : "7673380f-a2c4-427b-9f36-399e22dd7463",
        "tags" : [
        ]
      }
    ],
    "commit" : "540a78b57a6dba3b2ae8093eb458914b6391949d",
    "line" : 176,
    "diffHunk" : "@@ -1,1 +2298,2302 @@        memset(&zval, 0, sizeof(zval));\n        zuiInitIterator(&src[j]);\n        while (zuiNext(&src[j],&zval)) {\n            if (j == 0) {\n                tmp = zuiNewSdsFromValue(&zval);"
  },
  {
    "id" : "48bd20f7-0dcf-442f-b4f9-09524173dcbd",
    "prId" : 7844,
    "prUrl" : "https://github.com/redis/redis/pull/7844#pullrequestreview-563302396",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d1c6687-e246-42b5-863f-f367b550adf2",
        "parentId" : null,
        "authorId" : "3ca74ed4-ec73-427d-88cb-0c084b679a52",
        "body" : "Does userdata need to be generic, since it's only used to store the deferred length? It would improve readability if it was deferred_length.",
        "createdAt" : "2020-12-30T06:18:43Z",
        "updatedAt" : "2021-01-07T08:47:53Z",
        "lastEditedBy" : "3ca74ed4-ec73-427d-88cb-0c084b679a52",
        "tags" : [
        ]
      },
      {
        "id" : "8e73db76-0d62-4e43-a8c4-2260d23570b1",
        "parentId" : "3d1c6687-e246-42b5-863f-f367b550adf2",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "i think it makes sense to let the handler implementation store something. so i actually like to keep it generic.",
        "createdAt" : "2020-12-30T11:15:27Z",
        "updatedAt" : "2021-01-07T08:47:53Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "9fd5aec0-cf68-4e8b-81d3-c63ee3658307",
        "parentId" : "3d1c6687-e246-42b5-863f-f367b550adf2",
        "authorId" : "b35f6f04-eae9-4f88-8265-08b19050f11b",
        "body" : "It also comes with the price of ugly `void*` to `int` conversions.",
        "createdAt" : "2021-01-06T16:14:00Z",
        "updatedAt" : "2021-01-07T08:47:53Z",
        "lastEditedBy" : "b35f6f04-eae9-4f88-8265-08b19050f11b",
        "tags" : [
        ]
      },
      {
        "id" : "69f36880-9b10-47e1-b30a-133aa16e7440",
        "parentId" : "3d1c6687-e246-42b5-863f-f367b550adf2",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "@yossigo not sure i follow you.. it is used to store the result of addReplyDeferredLen (a pointer to heap)",
        "createdAt" : "2021-01-07T08:47:36Z",
        "updatedAt" : "2021-01-07T08:47:53Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e76af4f3b25043949281dd4fee63509def56f54",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +2822,2826 @@    robj                                *dstkey;\n    robj                                *dstobj;\n    void                                *userdata;\n    int                                  withscores;\n    int                                  should_emit_array_length;"
  },
  {
    "id" : "c5895572-e512-45f6-b658-97855b741be8",
    "prId" : 7844,
    "prUrl" : "https://github.com/redis/redis/pull/7844#pullrequestreview-565204711",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83583dbf-e17a-459c-9fca-07de9c0c100c",
        "parentId" : null,
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "@oranagra `((withscores) ? ln->score : ln->score)` Shouldn't it be changed to `ln->score`",
        "createdAt" : "2021-01-11T08:53:13Z",
        "updatedAt" : "2021-01-11T09:01:32Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      },
      {
        "id" : "a34744f1-3a43-4d7b-b836-93fc1d326522",
        "parentId" : "83583dbf-e17a-459c-9fca-07de9c0c100c",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "you're right, the ternary op can be dropped. but at least that's not a bug.\r\nthe store variant always passes true for withscores, and the non-store variant ignores the score if it wasn't requested.",
        "createdAt" : "2021-01-11T10:00:02Z",
        "updatedAt" : "2021-01-11T10:50:17Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e76af4f3b25043949281dd4fee63509def56f54",
    "line" : 558,
    "diffHunk" : "@@ -1,1 +3174,3178 @@            rangelen++;\n            handler->emitResultFromCBuffer(handler, ln->ele, sdslen(ln->ele),\n              ((withscores) ? ln->score : ln->score));\n\n            /* Move to next node */"
  },
  {
    "id" : "ab690e1a-4b34-4752-9116-7177f2636462",
    "prId" : 7844,
    "prUrl" : "https://github.com/redis/redis/pull/7844#pullrequestreview-565247458",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33c521cf-ac24-41f3-bfd9-297e9717329f",
        "parentId" : null,
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "@oranagra I read the zunionInterDiffGenericCommand function, it should be similar, when there is a flag store, only the number of results will be replied, without specific data.\r\nIf there is a store flag, zrangeResultHandlerScoreEmissionEnable should not effect.",
        "createdAt" : "2021-01-11T09:01:27Z",
        "updatedAt" : "2021-01-11T09:01:32Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      },
      {
        "id" : "72d4afb2-88e5-4bd7-8c0a-09633708ec91",
        "parentId" : "33c521cf-ac24-41f3-bfd9-297e9717329f",
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "i'm not sure what you mean by this comment.\r\nin case `store` is set, the call to zrangeResultHandlerScoreEmissionEnable is in some way redundant. since the two variables it sets are only used by the non-store variant handlers, so we can remove the `|| store` from the above condition, and this function will never be called.\r\n\r\nthere's something a bit ugly in my final changes to this PR, is that i added the `store` argument to this function.\r\nin theory, the handler should know what to do.\r\nbut i wanted to give syntax error on the WITHSCORES argument on the store variant, and added that store argument, that's where the mess started.",
        "createdAt" : "2021-01-11T10:49:19Z",
        "updatedAt" : "2021-01-11T10:50:17Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "06b7c966-0b1c-44fb-9abe-4b0eef15013b",
        "parentId" : "33c521cf-ac24-41f3-bfd9-297e9717329f",
        "authorId" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "body" : "```c\r\nstruct zrange_result_handler {\r\n    zrange_consumer_type                 type;\r\n    client                              *client;\r\n    robj                                *dstkey;\r\n    robj                                *dstobj;\r\n    void                                *userdata;\r\n    int                                  withscores;\r\n    int                                  should_emit_array_length;\r\n    int                                  store; <- here what I add\r\n    zrangeResultBeginFunction            beginResultEmission;\r\n    zrangeResultFinalizeFunction         finalizeResultEmission;\r\n    zrangeResultEmitCBufferFunction      emitResultFromCBuffer;\r\n    zrangeResultEmitLongLongFunction     emitResultFromLongLong;\r\n};\r\n```\r\n\r\nYour idea should be exactly what I am trying to do. zrange_result_handler should know what it should do.",
        "createdAt" : "2021-01-11T10:58:09Z",
        "updatedAt" : "2021-01-11T10:58:31Z",
        "lastEditedBy" : "4c4e22a4-3f0d-4f25-9809-81320210dfb6",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e76af4f3b25043949281dd4fee63509def56f54",
    "line" : 894,
    "diffHunk" : "@@ -1,1 +3601,3605 @@    }\n\n    if (opt_withscores || store) {\n        zrangeResultHandlerScoreEmissionEnable(handler);\n    }"
  },
  {
    "id" : "605150ec-0a6f-4a8c-a26d-ee1bc6ac3414",
    "prId" : 7794,
    "prUrl" : "https://github.com/redis/redis/pull/7794#pullrequestreview-487782161",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bc4fbc8-b67e-4619-8dc4-5856e0c3f8f8",
        "parentId" : null,
        "authorId" : "ad1e7044-3785-4002-a4a5-9bf9117dfa24",
        "body" : "Git changes only due to code indentation",
        "createdAt" : "2020-09-14T13:43:29Z",
        "updatedAt" : "2020-09-17T08:29:29Z",
        "lastEditedBy" : "ad1e7044-3785-4002-a4a5-9bf9117dfa24",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5e29ec91fd7aaa93ea37b78b78e1382e9310de5",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +2387,2391 @@    }\n\n    if (dstkey) {\n        if (dstzset->zsl->length) {\n            zsetConvertToZiplistIfNeeded(dstobj, maxelelen);"
  },
  {
    "id" : "a92ef2ed-9d6f-4b9d-9490-078d566d09d2",
    "prId" : 7794,
    "prUrl" : "https://github.com/redis/redis/pull/7794#pullrequestreview-488365954",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf33c437-205d-40be-af3d-c5ef57f84307",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "let's add a top comment that describes the argument (specifically the last 2)",
        "createdAt" : "2020-09-15T06:57:48Z",
        "updatedAt" : "2020-09-17T08:29:29Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5e29ec91fd7aaa93ea37b78b78e1382e9310de5",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2178,2182 @@ * 'op' SET_OP_INTER or SET_OP_UNION.\n */\nvoid zunionInterGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op) {\n    int i, j;\n    long setnum;"
  },
  {
    "id" : "8dfd57e5-8e42-472d-a3f1-b100e63d10ca",
    "prId" : 7794,
    "prUrl" : "https://github.com/redis/redis/pull/7794#pullrequestreview-489223204",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "870f38ff-aa9f-4995-9c68-66d1e32e5b0e",
        "parentId" : null,
        "authorId" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "body" : "i noticed that the zrange code has special code to handle integer encoded ziplists.\r\ni see that in out case the object will never be ziplist encoded, but I prefer to add some coverage in the test suite by using this command on zset with integer members too.",
        "createdAt" : "2020-09-15T17:17:43Z",
        "updatedAt" : "2020-09-17T08:29:29Z",
        "lastEditedBy" : "02e243fa-aeed-4b15-9e9e-405ca1702d7e",
        "tags" : [
        ]
      },
      {
        "id" : "a2438640-9190-4d49-b56f-5541b556affa",
        "parentId" : "870f38ff-aa9f-4995-9c68-66d1e32e5b0e",
        "authorId" : "ad1e7044-3785-4002-a4a5-9bf9117dfa24",
        "body" : "Yes, `dstobj` encoding is `OBJ_ENCODING_SKIPLIST`. \r\n\r\nI also added a test about integer members.",
        "createdAt" : "2020-09-16T02:05:33Z",
        "updatedAt" : "2020-09-17T08:29:29Z",
        "lastEditedBy" : "ad1e7044-3785-4002-a4a5-9bf9117dfa24",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5e29ec91fd7aaa93ea37b78b78e1382e9310de5",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +2415,2419 @@        while (zn != NULL) {\n            if (withscores && c->resp > 2) addReplyArrayLen(c,2);\n            addReplyBulkCBuffer(c,zn->ele,sdslen(zn->ele));\n            if (withscores) addReplyDouble(c,zn->score);\n            zn = zn->level[0].forward;"
  },
  {
    "id" : "415f5f56-cd53-4d68-a2a7-6177b29b5a45",
    "prId" : 7593,
    "prUrl" : "https://github.com/redis/redis/pull/7593#pullrequestreview-460177172",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c03662b1-1705-4dfc-b88a-468a1b10476d",
        "parentId" : null,
        "authorId" : "3ca74ed4-ec73-427d-88cb-0c084b679a52",
        "body" : "I think we should be consistent with other sorted set commands, and return a single nil if the key doesn't exist. Otherwise there is no differentiation between all the items are missing and the key is missing.",
        "createdAt" : "2020-08-03T15:57:22Z",
        "updatedAt" : "2020-08-03T17:18:37Z",
        "lastEditedBy" : "3ca74ed4-ec73-427d-88cb-0c084b679a52",
        "tags" : [
        ]
      },
      {
        "id" : "1a8037ac-1674-4102-b71c-236dbdb29cc7",
        "parentId" : "c03662b1-1705-4dfc-b88a-468a1b10476d",
        "authorId" : "71fabdcb-a6e2-467c-8c51-54d8426893b5",
        "body" : "> I amended the PR to make fetching the zmscore for an empty zset return a list of nil values.\r\n> \r\n> This was done to be consistent with https://redis.io/commands/hmget ...\r\n>\r\n> >> Because non-existing keys are treated as empty hashes, running HMGET against a non-existing key will return a list of nil values.\r\n\r\n- `get` returns a string or nil\r\n- `mget` returns a list of (string or nil)\r\n- `hget` returns a string or nil\r\n- `hmget` returns a list of (string or nil)\r\n- `zscore` returns a stringified float or nil\r\n- `zmscore` returns a list of (stringified float or nil) to be consistent\r\n\r\nEDIT: Also, the absence of a key is the same as the empty zset for all other sorted set commands, already",
        "createdAt" : "2020-08-03T16:41:36Z",
        "updatedAt" : "2020-08-03T17:18:37Z",
        "lastEditedBy" : "71fabdcb-a6e2-467c-8c51-54d8426893b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "b6af33668c088d369f24d6d07465a40b73eda5fd",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +3093,3097 @@    for (int j = 2; j < c->argc; j++) {\n        /* Treat a missing set the same way as an empty set */\n        if (zobj == NULL || zsetScore(zobj,c->argv[j]->ptr,&score) == C_ERR) {\n            addReplyNull(c);\n        } else {"
  }
]
[
  {
    "id" : "b95ac038-32d6-4002-96bc-98a3d0f818aa",
    "prId" : 866,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/866#pullrequestreview-411114403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea372637-5ae9-4e99-8a57-845676efa233",
        "parentId" : null,
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "Gotta bikeshed about the infix syntax a bit...",
        "createdAt" : "2020-05-11T01:33:37Z",
        "updatedAt" : "2020-05-14T19:45:54Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      },
      {
        "id" : "8a1d2ea0-b5ea-4c23-9d99-9f36f589e590",
        "parentId" : "ea372637-5ae9-4e99-8a57-845676efa233",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "I only use it when following with a curly brace. So, `Kleisli { r => \\n` as well as `Eq instance { (a, b) => \\n`. However, if I were keeping it on a single line, I would use a parenthetical lambda/block and dot dispatch.\r\n\r\nThis style (which I owe to @odersky) encourages slightly more intermediate `val` usage (i.e. fewer long chains wrapped across lines) as well as entirely avoids the extremely weird rules surrounding `}.`, which I'd be willing to bet most people would get wrong on a Scala trivial quiz.",
        "createdAt" : "2020-05-11T02:13:12Z",
        "updatedAt" : "2020-05-14T19:45:54Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "caea466d-381e-47b0-b7ff-8cb5ab58bce3",
        "parentId" : "ea372637-5ae9-4e99-8a57-845676efa233",
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "Fair enough... by the way, we should totally get scalafmt here",
        "createdAt" : "2020-05-11T02:23:33Z",
        "updatedAt" : "2020-05-14T19:45:54Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      },
      {
        "id" : "90bff824-9709-4df1-8bbe-e911ae2f82aa",
        "parentId" : "ea372637-5ae9-4e99-8a57-845676efa233",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "We really should. I just have vigorous objections to the config that's in master. :-)",
        "createdAt" : "2020-05-11T14:45:31Z",
        "updatedAt" : "2020-05-14T19:45:54Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      },
      {
        "id" : "6ae3eb86-b4ab-46b9-b8df-cc4ca14fcc71",
        "parentId" : "ea372637-5ae9-4e99-8a57-845676efa233",
        "authorId" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "body" : "then I suggest you start with one, as I don't know which options you don't like ;)",
        "createdAt" : "2020-05-13T16:48:59Z",
        "updatedAt" : "2020-05-14T19:45:54Z",
        "lastEditedBy" : "df537f5b-c150-4710-8eb4-40b8b59c3bcc",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc98d745673740f5a2bb1ffc67d2ea7516bbf8b0",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +35,39 @@  }\n\n  implicit def eq[F[_], E: Eq, A](implicit FA: Eq[F[A]]): Eq[Outcome[F, E, A]] = Eq instance {\n    case (Canceled, Canceled) => true\n    case (Errored(left), Errored(right)) => left === right"
  },
  {
    "id" : "011b71d2-5cc2-495b-a85b-5d294884c2bb",
    "prId" : 856,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/856#pullrequestreview-410235525",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0c67793c-a116-41c6-8299-74fe56fca025",
        "parentId" : null,
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "My badâ€¦",
        "createdAt" : "2020-05-12T16:50:54Z",
        "updatedAt" : "2020-05-12T16:56:07Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "042544d3217c4d9e1d9a9b4e5e66933903e75402",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +38,42 @@    new ExitCaseApplicativeError[F, E]\n\n  //todo needs renaming\n  protected class ExitCaseApplicativeError[F[_]: Applicative, E] extends ApplicativeError[Outcome[F, E, ?], E] {\n"
  }
]
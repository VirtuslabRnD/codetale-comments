[
  {
    "id" : "3d23741f-036f-4290-b6de-1dff24cc950c",
    "prId" : 3461,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf624747-3cfb-4fee-813d-0680c0509b27",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "why is the function check required? In the reset of the code only `init_fn.IsEmpty()` is used to check of async-wrap is enabled. The `SetupHooks` function also checks that `init_fn` is a function.\n",
        "createdAt" : "2015-10-26T10:12:14Z",
        "updatedAt" : "2015-11-06T23:38:13Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "1a9cbb74-c36c-4f2f-8778-c3ef1cf8cf6f",
        "parentId" : "cf624747-3cfb-4fee-813d-0680c0509b27",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Currently in `AsyncWrap::AsyncWrap` we check if the `init` hook is set. If not then it returns early. If this is the case then `bits_` will never be set and no additional callback will ever be called for that object as a result. I can probably rethink the logic, but this seemed the most straight forward for this PR.\n",
        "createdAt" : "2015-10-26T16:52:13Z",
        "updatedAt" : "2015-11-06T23:38:13Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb1bd7639554766a88b8f7aef8891bf8249e613e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +105,109 @@  Environment* env = Environment::GetCurrent(args);\n  Local<Function> init_fn = env->async_hooks_init_function();\n  if (init_fn.IsEmpty() || !init_fn->IsFunction())\n    return env->ThrowTypeError(\"init callback is not assigned to a function\");\n  env->async_hooks()->set_enable_callbacks(1);"
  },
  {
    "id" : "f982d8c3-7570-417c-8fe6-0dba8ad3fd5a",
    "prId" : 4507,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "parentId" : null,
        "authorId" : "7885009b-14c8-46d1-a915-0c610839ac69",
        "body" : "It may be worth mentioning in a comment that this early return is very important because of the way `node::FatalException` is called when no `TryCatch` instance is present in this stack frame.\n\nWithout a `TryCatch` instance, `node::FatalException` will be called after this function returns, and thus exiting the current active domain if an error is thrown from the JavaScript function `cb` would exit the active domain _before_ its error handler had a chance to run.\n",
        "createdAt" : "2016-02-09T19:26:42Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "7885009b-14c8-46d1-a915-0c610839ac69",
        "tags" : [
        ]
      },
      {
        "id" : "c8374279-081e-4556-8308-dfdd4913fddb",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Good call. I'll add it to both locations.\n",
        "createdAt" : "2016-02-09T21:31:22Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "df229fbb-04c6-4c98-af18-86b841a0562c",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@misterdjules actually I'm a little confused. without the `TryCatch` `node::FatalException` is run immediately after \"cb\". Even before the AsyncWrap post callback has a chance to run. Meaning the domain stack will have already been cleared before we get to `domain.exit()`. I'm just returning early to save us a call to JS.\n",
        "createdAt" : "2016-02-09T23:29:56Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "7e140d03-8d79-4fc9-94d8-b9268c63db70",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Verified this by placing the early return after the domain exit call and tested with the following:\n\n``` js\n'use strict';\n\nconst domain = require('domain');\nconst d = domain.create();\nconst async_wrap = process.binding('async_wrap');\n\nasync_wrap.setupHooks(function() {\n}, function() {\n  process._rawDebug('before');\n}, function() {\n  process._rawDebug('after');\n});\nasync_wrap.enable();\n\nd.on('error', function() {\n  process._rawDebug('d errored');\n});\n\nd.run(function() {\n  require('crypto').randomBytes(1024, function() {\n    throw new Error('crap');\n  });\n});\n```\n",
        "createdAt" : "2016-02-09T23:32:50Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab6fe5998a625af68b58ccc63b230ef37c054af7",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +219,223 @@  }\n\n  if (ret.IsEmpty()) {\n    return Undefined(env()->isolate());\n  }"
  },
  {
    "id" : "cc935305-5b9f-4f42-b275-241e89aa1c95",
    "prId" : 5756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "parentId" : null,
        "authorId" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "body" : "Is there a reason for requiring callers to explicitly disable callbacks, vs implicitly disabling them & restoring them?\n",
        "createdAt" : "2016-03-22T16:38:47Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "tags" : [
        ]
      },
      {
        "id" : "e016165f-7306-4d90-9efb-026b7da63656",
        "parentId" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "I'm missing context. Users have to explicitly run `async_wrap.enable()` before callbacks will be called. This case is to handle:\n\n``` js\nconst async_wrap = require('async_wrap');\nasync_wrap.setupHooks({ ...callbacks... });\nasync_wrap.enable();\nasync_wrap.setupHooks({ ...different callbacks... });\n```\n\nTo prevent callbacks from being pulled out from underneath the user while operations may be in flight.\n",
        "createdAt" : "2016-03-23T06:31:47Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "90476c3e-8434-42af-8c13-a8c2c5a484f4",
        "parentId" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "authorId" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "body" : "Right, question is why is it the responsibility of the `setupHooks()` caller to `enable()/disable()`?  i.e., why can't this be done implicitly by `setupHooks()`?  \n\nSame question follows when the handlers are invoked.  We know that if an `init()` callback triggers an async operation, it risks infinite recursion, so why not implicitly disable async callbacks before invoking `init()`?\n",
        "createdAt" : "2016-03-23T15:17:38Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a17200b520919a20f72b3353974de82684168b35",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +122,126 @@  Environment* env = Environment::GetCurrent(args);\n\n  if (env->async_hooks()->callbacks_enabled())\n    return env->ThrowError(\"hooks should not be set while also enabled\");\n  if (!args[0]->IsObject())"
  },
  {
    "id" : "dd72ca49-94c5-4719-8c26-491040b1fc28",
    "prId" : 10400,
    "prUrl" : "https://github.com/nodejs/node/pull/10400#pullrequestreview-14175201",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "967a97fe-4a88-4efd-ba62-d78378310d90",
        "parentId" : null,
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "Can I suggest you swap before iteration?  I.e.:\r\n```c++\r\nstd::vector<int64_t> destroy_ids_list;\r\ndestroy_ids_list.swap(*env->destroy_ids_list());\r\nfor (auto current_id : destroy_ids_list) {\r\n  // ...\r\n}\r\n```\r\nThat way the list is both cleared and immune to concurrent modification by the callback.",
        "createdAt" : "2016-12-22T06:44:31Z",
        "updatedAt" : "2016-12-22T15:36:19Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      },
      {
        "id" : "6c4b3dbd-eb81-4511-a8c6-43fee9f7f817",
        "parentId" : "967a97fe-4a88-4efd-ba62-d78378310d90",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "done",
        "createdAt" : "2016-12-22T15:33:13Z",
        "updatedAt" : "2016-12-22T15:36:19Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "833294f681db34dda78276f1f65dc9eb3badcd9e",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +216,220 @@  }\n\n  env->destroy_ids_list()->clear();\n}\n"
  },
  {
    "id" : "2dec3961-3869-42d8-b129-596bd4643db9",
    "prId" : 13369,
    "prUrl" : "https://github.com/nodejs/node/pull/13369#pullrequestreview-41638155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a032d5c-95d6-4cd8-a1ab-742729eaff24",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "will this not call the `destroy` hook synchronously if `emitDestroy` was called from within the `destroy` hook? We don't want that because `destroy` hooks should never be called synchronously.",
        "createdAt" : "2017-06-01T14:21:53Z",
        "updatedAt" : "2017-06-02T22:22:08Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "f72bce6c-34c4-4fc3-bf10-f2c4f9f50456",
        "parentId" : "3a032d5c-95d6-4cd8-a1ab-742729eaff24",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@AndreasMadsen It would act like a `nextTick()`. The current execution scope would complete before the destroy hook was called.",
        "createdAt" : "2017-06-01T20:27:54Z",
        "updatedAt" : "2017-06-02T22:22:08Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "36eebb4f-6147-47aa-93a7-9d5ccc70f633",
        "parentId" : "3a032d5c-95d6-4cd8-a1ab-742729eaff24",
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "Yeah, that came to me a few hours after I wrote that. Thanks!",
        "createdAt" : "2017-06-01T21:09:37Z",
        "updatedAt" : "2017-06-02T22:22:08Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      }
    ],
    "commit" : "78b135806f10c39c3bbd00edf206ddc9f505597e",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +148,152 @@  TryCatch try_catch(env->isolate());\n\n  do {\n    std::vector<double> destroy_ids_list;\n    destroy_ids_list.swap(*env->destroy_ids_list());"
  },
  {
    "id" : "219d744a-ae38-4918-92a0-04aad8c63d70",
    "prId" : 13585,
    "prUrl" : "https://github.com/nodejs/node/pull/13585#pullrequestreview-43294768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79bbc629-ede7-45fc-bba8-a38576802dcd",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "Since we are going with the temp fix, I guess this is okay. But I really want to see a better solution. I'm not really convinced there aren't some obscure bug with the right `.enable()` and `.disable()` calls.",
        "createdAt" : "2017-06-10T10:11:37Z",
        "updatedAt" : "2017-06-16T17:28:18Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      }
    ],
    "commit" : "af1a551965ac990e91fa5924d95e99450a6f0814",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +441,445 @@  Environment* env = Environment::GetCurrent(args);\n\n  // Delay the call to `RemovePromiseHook` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  env->isolate()->EnqueueMicrotask([](void* data) {"
  },
  {
    "id" : "eae7eca5-d2bd-4355-ac78-feb4a3483628",
    "prId" : 14208,
    "prUrl" : "https://github.com/nodejs/node/pull/14208#pullrequestreview-63175379",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1018797-f09f-4504-876a-e105cae4d579",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "I don't like this. It is not clear from the constructor signature that this is only for promises. It would be better with a unified constructor function, like how `AsyncReset` is now implemented.",
        "createdAt" : "2017-07-13T08:30:42Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "f9a7f43b-42b4-408a-87c2-1ef6176c3f16",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "I don't agree that adding another parameter to the constructor for a single case is a good idea. The general constructor is currently used in 12 locations outside of `async-wrap.cc`. I only allowed `AsyncWrap::AsyncReset()` the additional parameter because it's only used in a single location outside of `async-wrap.cc` and only 3 locations in `async-wrap.cc`. Also I think the fact that `PROVIDER_PROMISE` is explicitly passed to `provider_type_` makes it clear that the constructor is only meant to be used for Promises.\r\n\r\nIf everyone is absolutely against the new constructor then I'll figure out another way to have the constructor not call `init()`, without needing to pass the additional argument.",
        "createdAt" : "2017-07-13T21:11:40Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "329cfdb0-b222-4ab9-83d3-e58fbfd233a4",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "> The general constructor is currently used in 12 locations outside of `async-wrap.cc`.\r\n\r\nI can't follow that argument at all. To me, using default arguments is only an issue if there become too many of them, I don't see that happening here. Besides, your solution is just a different kind of default argument.\r\n\r\n> Also I think the fact that `PROVIDER_PROMISE` is explicitly passed to `provider_type_` makes it clear that the constructor is only meant to be used for Promises.\r\n\r\nIt is not clear from the calling code.",
        "createdAt" : "2017-07-13T21:31:37Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "a3de9234-b57a-47e3-ab6d-af0e81bd9845",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "> I can't follow that argument at all. To me, using default arguments is only an issue if there become too many of them, I don't see that happening here.\r\n\r\nIf there's a parameter that will only ever be used by one other class, in the same file, I don't see a good reason that it should pollute the general constructor. Even if it has a default.\r\n\r\n> Besides, your solution is just a different kind of default argument.\r\n\r\nDon't follow what you're saying.\r\n\r\n> It is not clear from the calling code.\r\n\r\nI'm really not worried about that since it's only called once from the same file.",
        "createdAt" : "2017-07-13T22:56:32Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "ff734b05-28ef-4cc5-aad1-6f48c2e03201",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "> I'm really not worried about that since it's only called once from the same file.\r\n\r\nFor the mere mortals who didn't write the file, it is actually a really big file that and it is hard for me to orient myself when reading it.",
        "createdAt" : "2017-07-14T07:34:38Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "b1666843-a810-4bdd-a26f-26bafd1bf9ea",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@AndreasMadsen Does is not feel like a wart on the API to add a parameter with default value just to accommodate a class that isn't public? To make the intention of the alternative class constructor clear beyond the fact that `PROMISE_PROVIDER` is force-ably passed I added the following to the `private` class declaration:\r\n```cpp\r\n  friend class PromiseWrap;\r\n\r\n  // Constructor specifically for PromiseWrap.\r\n  AsyncWrap(Environment* env, v8::Local<v8::Object> promise, bool silent);\r\n```\r\nso there would be no ambiguity as to why that alternative constructor exists, and so no other classes could accidentally call that constructor. I believe the intention of this code is reasonably clear.\r\n\r\n/cc @bnoordhuis if you're around, mind giving feedback on how you'd approach this scenario?",
        "createdAt" : "2017-07-17T21:20:08Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "cd7662ab-2478-41d8-ac69-18c3c36cb56e",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "> Does is not feel like a wart on the API to add a parameter with default value just to accommodate a class that isn't public?\r\n\r\nNo. At least not when it is just relaying the parameter to `AsyncReset`.\r\n\r\nI think this is about minimizing complexity and readability. I think the default parameter is simultaneously a more simple solution and more readable.\r\n\r\nI'm not strong enough in C++ to give a better argument and \"wart\" is not concrete enough for me to argue against. I will let others take the argument from here.\r\n\r\n/cc @nodejs/async_hooks ",
        "createdAt" : "2017-07-17T21:28:07Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "21d6b3b6-be69-44ab-92f5-66687cb18fc6",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "> I think this is about minimizing complexity and readability. I think the default parameter is simultaneously a more simple solution and more readable.\r\n\r\nAt this point I think we just have a different aesthetic. IMO it's more clear to have a second documented constructor dedicated to a singular edge case usage than use an additional optional parameter.\r\n\r\nThe key here is that in no foreseeable case will the optional parameter be used by anything other than `PromiseWrap`. If there were even the slightest chance of that possibility then I'd agree that adding the optional parameter would be the correct approach.",
        "createdAt" : "2017-07-17T22:29:30Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "232b90ad-d022-47f2-bcb1-5e30fc4e7a1a",
        "parentId" : "a1018797-f09f-4504-876a-e105cae4d579",
        "authorId" : "23dd1f9f-2ce6-4461-ad78-bdc0fc563445",
        "body" : "IMHO an adding a comment stating that this ctor is for use by `PromiseWrap` only, in order not to expose a rarely used argument, is a decent compromise.",
        "createdAt" : "2017-09-15T22:23:15Z",
        "updatedAt" : "2017-09-27T10:24:06Z",
        "lastEditedBy" : "23dd1f9f-2ce6-4461-ad78-bdc0fc563445",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b9b46cd55835b33382dacb86f614cbcdc5f7b98",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +595,599 @@                     bool silent)\n    : BaseObject(env, object),\n      provider_type_(PROVIDER_PROMISE) {\n  CHECK_GE(object->InternalFieldCount(), 1);\n"
  }
]
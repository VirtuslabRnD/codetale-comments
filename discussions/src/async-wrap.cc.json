[
  {
    "id" : "3d23741f-036f-4290-b6de-1dff24cc950c",
    "prId" : 3461,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf624747-3cfb-4fee-813d-0680c0509b27",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "why is the function check required? In the reset of the code only `init_fn.IsEmpty()` is used to check of async-wrap is enabled. The `SetupHooks` function also checks that `init_fn` is a function.\n",
        "createdAt" : "2015-10-26T10:12:14Z",
        "updatedAt" : "2015-11-06T23:38:13Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "1a9cbb74-c36c-4f2f-8778-c3ef1cf8cf6f",
        "parentId" : "cf624747-3cfb-4fee-813d-0680c0509b27",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Currently in `AsyncWrap::AsyncWrap` we check if the `init` hook is set. If not then it returns early. If this is the case then `bits_` will never be set and no additional callback will ever be called for that object as a result. I can probably rethink the logic, but this seemed the most straight forward for this PR.\n",
        "createdAt" : "2015-10-26T16:52:13Z",
        "updatedAt" : "2015-11-06T23:38:13Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb1bd7639554766a88b8f7aef8891bf8249e613e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +105,109 @@  Environment* env = Environment::GetCurrent(args);\n  Local<Function> init_fn = env->async_hooks_init_function();\n  if (init_fn.IsEmpty() || !init_fn->IsFunction())\n    return env->ThrowTypeError(\"init callback is not assigned to a function\");\n  env->async_hooks()->set_enable_callbacks(1);"
  },
  {
    "id" : "f982d8c3-7570-417c-8fe6-0dba8ad3fd5a",
    "prId" : 4507,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "parentId" : null,
        "authorId" : "7885009b-14c8-46d1-a915-0c610839ac69",
        "body" : "It may be worth mentioning in a comment that this early return is very important because of the way `node::FatalException` is called when no `TryCatch` instance is present in this stack frame.\n\nWithout a `TryCatch` instance, `node::FatalException` will be called after this function returns, and thus exiting the current active domain if an error is thrown from the JavaScript function `cb` would exit the active domain _before_ its error handler had a chance to run.\n",
        "createdAt" : "2016-02-09T19:26:42Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "7885009b-14c8-46d1-a915-0c610839ac69",
        "tags" : [
        ]
      },
      {
        "id" : "c8374279-081e-4556-8308-dfdd4913fddb",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Good call. I'll add it to both locations.\n",
        "createdAt" : "2016-02-09T21:31:22Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "df229fbb-04c6-4c98-af18-86b841a0562c",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@misterdjules actually I'm a little confused. without the `TryCatch` `node::FatalException` is run immediately after \"cb\". Even before the AsyncWrap post callback has a chance to run. Meaning the domain stack will have already been cleared before we get to `domain.exit()`. I'm just returning early to save us a call to JS.\n",
        "createdAt" : "2016-02-09T23:29:56Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "7e140d03-8d79-4fc9-94d8-b9268c63db70",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Verified this by placing the early return after the domain exit call and tested with the following:\n\n``` js\n'use strict';\n\nconst domain = require('domain');\nconst d = domain.create();\nconst async_wrap = process.binding('async_wrap');\n\nasync_wrap.setupHooks(function() {\n}, function() {\n  process._rawDebug('before');\n}, function() {\n  process._rawDebug('after');\n});\nasync_wrap.enable();\n\nd.on('error', function() {\n  process._rawDebug('d errored');\n});\n\nd.run(function() {\n  require('crypto').randomBytes(1024, function() {\n    throw new Error('crap');\n  });\n});\n```\n",
        "createdAt" : "2016-02-09T23:32:50Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab6fe5998a625af68b58ccc63b230ef37c054af7",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +219,223 @@  }\n\n  if (ret.IsEmpty()) {\n    return Undefined(env()->isolate());\n  }"
  },
  {
    "id" : "cc935305-5b9f-4f42-b275-241e89aa1c95",
    "prId" : 5756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "parentId" : null,
        "authorId" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "body" : "Is there a reason for requiring callers to explicitly disable callbacks, vs implicitly disabling them & restoring them?\n",
        "createdAt" : "2016-03-22T16:38:47Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "tags" : [
        ]
      },
      {
        "id" : "e016165f-7306-4d90-9efb-026b7da63656",
        "parentId" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "I'm missing context. Users have to explicitly run `async_wrap.enable()` before callbacks will be called. This case is to handle:\n\n``` js\nconst async_wrap = require('async_wrap');\nasync_wrap.setupHooks({ ...callbacks... });\nasync_wrap.enable();\nasync_wrap.setupHooks({ ...different callbacks... });\n```\n\nTo prevent callbacks from being pulled out from underneath the user while operations may be in flight.\n",
        "createdAt" : "2016-03-23T06:31:47Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "90476c3e-8434-42af-8c13-a8c2c5a484f4",
        "parentId" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "authorId" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "body" : "Right, question is why is it the responsibility of the `setupHooks()` caller to `enable()/disable()`?  i.e., why can't this be done implicitly by `setupHooks()`?  \n\nSame question follows when the handlers are invoked.  We know that if an `init()` callback triggers an async operation, it risks infinite recursion, so why not implicitly disable async callbacks before invoking `init()`?\n",
        "createdAt" : "2016-03-23T15:17:38Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a17200b520919a20f72b3353974de82684168b35",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +122,126 @@  Environment* env = Environment::GetCurrent(args);\n\n  if (env->async_hooks()->callbacks_enabled())\n    return env->ThrowError(\"hooks should not be set while also enabled\");\n  if (!args[0]->IsObject())"
  }
]
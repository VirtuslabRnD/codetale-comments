[
  {
    "id" : "3d23741f-036f-4290-b6de-1dff24cc950c",
    "prId" : 3461,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf624747-3cfb-4fee-813d-0680c0509b27",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "why is the function check required? In the reset of the code only `init_fn.IsEmpty()` is used to check of async-wrap is enabled. The `SetupHooks` function also checks that `init_fn` is a function.\n",
        "createdAt" : "2015-10-26T10:12:14Z",
        "updatedAt" : "2015-11-06T23:38:13Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "1a9cbb74-c36c-4f2f-8778-c3ef1cf8cf6f",
        "parentId" : "cf624747-3cfb-4fee-813d-0680c0509b27",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Currently in `AsyncWrap::AsyncWrap` we check if the `init` hook is set. If not then it returns early. If this is the case then `bits_` will never be set and no additional callback will ever be called for that object as a result. I can probably rethink the logic, but this seemed the most straight forward for this PR.\n",
        "createdAt" : "2015-10-26T16:52:13Z",
        "updatedAt" : "2015-11-06T23:38:13Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb1bd7639554766a88b8f7aef8891bf8249e613e",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +105,109 @@  Environment* env = Environment::GetCurrent(args);\n  Local<Function> init_fn = env->async_hooks_init_function();\n  if (init_fn.IsEmpty() || !init_fn->IsFunction())\n    return env->ThrowTypeError(\"init callback is not assigned to a function\");\n  env->async_hooks()->set_enable_callbacks(1);"
  },
  {
    "id" : "f982d8c3-7570-417c-8fe6-0dba8ad3fd5a",
    "prId" : 4507,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "parentId" : null,
        "authorId" : "7885009b-14c8-46d1-a915-0c610839ac69",
        "body" : "It may be worth mentioning in a comment that this early return is very important because of the way `node::FatalException` is called when no `TryCatch` instance is present in this stack frame.\n\nWithout a `TryCatch` instance, `node::FatalException` will be called after this function returns, and thus exiting the current active domain if an error is thrown from the JavaScript function `cb` would exit the active domain _before_ its error handler had a chance to run.\n",
        "createdAt" : "2016-02-09T19:26:42Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "7885009b-14c8-46d1-a915-0c610839ac69",
        "tags" : [
        ]
      },
      {
        "id" : "c8374279-081e-4556-8308-dfdd4913fddb",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Good call. I'll add it to both locations.\n",
        "createdAt" : "2016-02-09T21:31:22Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "df229fbb-04c6-4c98-af18-86b841a0562c",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@misterdjules actually I'm a little confused. without the `TryCatch` `node::FatalException` is run immediately after \"cb\". Even before the AsyncWrap post callback has a chance to run. Meaning the domain stack will have already been cleared before we get to `domain.exit()`. I'm just returning early to save us a call to JS.\n",
        "createdAt" : "2016-02-09T23:29:56Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "7e140d03-8d79-4fc9-94d8-b9268c63db70",
        "parentId" : "3d95fd2a-4b03-4f55-9e7f-6a3fe5741b00",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "Verified this by placing the early return after the domain exit call and tested with the following:\n\n``` js\n'use strict';\n\nconst domain = require('domain');\nconst d = domain.create();\nconst async_wrap = process.binding('async_wrap');\n\nasync_wrap.setupHooks(function() {\n}, function() {\n  process._rawDebug('before');\n}, function() {\n  process._rawDebug('after');\n});\nasync_wrap.enable();\n\nd.on('error', function() {\n  process._rawDebug('d errored');\n});\n\nd.run(function() {\n  require('crypto').randomBytes(1024, function() {\n    throw new Error('crap');\n  });\n});\n```\n",
        "createdAt" : "2016-02-09T23:32:50Z",
        "updatedAt" : "2016-02-12T21:04:06Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "ab6fe5998a625af68b58ccc63b230ef37c054af7",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +219,223 @@  }\n\n  if (ret.IsEmpty()) {\n    return Undefined(env()->isolate());\n  }"
  },
  {
    "id" : "cc935305-5b9f-4f42-b275-241e89aa1c95",
    "prId" : 5756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "parentId" : null,
        "authorId" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "body" : "Is there a reason for requiring callers to explicitly disable callbacks, vs implicitly disabling them & restoring them?\n",
        "createdAt" : "2016-03-22T16:38:47Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "tags" : [
        ]
      },
      {
        "id" : "e016165f-7306-4d90-9efb-026b7da63656",
        "parentId" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "I'm missing context. Users have to explicitly run `async_wrap.enable()` before callbacks will be called. This case is to handle:\n\n``` js\nconst async_wrap = require('async_wrap');\nasync_wrap.setupHooks({ ...callbacks... });\nasync_wrap.enable();\nasync_wrap.setupHooks({ ...different callbacks... });\n```\n\nTo prevent callbacks from being pulled out from underneath the user while operations may be in flight.\n",
        "createdAt" : "2016-03-23T06:31:47Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "90476c3e-8434-42af-8c13-a8c2c5a484f4",
        "parentId" : "b9325f04-8351-49ed-9fdd-e75b3048716c",
        "authorId" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "body" : "Right, question is why is it the responsibility of the `setupHooks()` caller to `enable()/disable()`?  i.e., why can't this be done implicitly by `setupHooks()`?  \n\nSame question follows when the handlers are invoked.  We know that if an `init()` callback triggers an async operation, it risks infinite recursion, so why not implicitly disable async callbacks before invoking `init()`?\n",
        "createdAt" : "2016-03-23T15:17:38Z",
        "updatedAt" : "2016-03-28T17:34:05Z",
        "lastEditedBy" : "45f3b364-5008-42de-944a-d363ae6ae8f2",
        "tags" : [
        ]
      }
    ],
    "commit" : "a17200b520919a20f72b3353974de82684168b35",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +122,126 @@  Environment* env = Environment::GetCurrent(args);\n\n  if (env->async_hooks()->callbacks_enabled())\n    return env->ThrowError(\"hooks should not be set while also enabled\");\n  if (!args[0]->IsObject())"
  },
  {
    "id" : "dd72ca49-94c5-4719-8c26-491040b1fc28",
    "prId" : 10400,
    "prUrl" : "https://github.com/nodejs/node/pull/10400#pullrequestreview-14175201",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "967a97fe-4a88-4efd-ba62-d78378310d90",
        "parentId" : null,
        "authorId" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "body" : "Can I suggest you swap before iteration?  I.e.:\r\n```c++\r\nstd::vector<int64_t> destroy_ids_list;\r\ndestroy_ids_list.swap(*env->destroy_ids_list());\r\nfor (auto current_id : destroy_ids_list) {\r\n  // ...\r\n}\r\n```\r\nThat way the list is both cleared and immune to concurrent modification by the callback.",
        "createdAt" : "2016-12-22T06:44:31Z",
        "updatedAt" : "2016-12-22T15:36:19Z",
        "lastEditedBy" : "4224fcfe-ee22-4bd8-9ed5-4e8efd7a90bc",
        "tags" : [
        ]
      },
      {
        "id" : "6c4b3dbd-eb81-4511-a8c6-43fee9f7f817",
        "parentId" : "967a97fe-4a88-4efd-ba62-d78378310d90",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "done",
        "createdAt" : "2016-12-22T15:33:13Z",
        "updatedAt" : "2016-12-22T15:36:19Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      }
    ],
    "commit" : "833294f681db34dda78276f1f65dc9eb3badcd9e",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +216,220 @@  }\n\n  env->destroy_ids_list()->clear();\n}\n"
  },
  {
    "id" : "2dec3961-3869-42d8-b129-596bd4643db9",
    "prId" : 13369,
    "prUrl" : "https://github.com/nodejs/node/pull/13369#pullrequestreview-41638155",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a032d5c-95d6-4cd8-a1ab-742729eaff24",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "will this not call the `destroy` hook synchronously if `emitDestroy` was called from within the `destroy` hook? We don't want that because `destroy` hooks should never be called synchronously.",
        "createdAt" : "2017-06-01T14:21:53Z",
        "updatedAt" : "2017-06-02T22:22:08Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      },
      {
        "id" : "f72bce6c-34c4-4fc3-bf10-f2c4f9f50456",
        "parentId" : "3a032d5c-95d6-4cd8-a1ab-742729eaff24",
        "authorId" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "body" : "@AndreasMadsen It would act like a `nextTick()`. The current execution scope would complete before the destroy hook was called.",
        "createdAt" : "2017-06-01T20:27:54Z",
        "updatedAt" : "2017-06-02T22:22:08Z",
        "lastEditedBy" : "ec4d48db-e488-47ba-b17d-0da1c3b9df08",
        "tags" : [
        ]
      },
      {
        "id" : "36eebb4f-6147-47aa-93a7-9d5ccc70f633",
        "parentId" : "3a032d5c-95d6-4cd8-a1ab-742729eaff24",
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "Yeah, that came to me a few hours after I wrote that. Thanks!",
        "createdAt" : "2017-06-01T21:09:37Z",
        "updatedAt" : "2017-06-02T22:22:08Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      }
    ],
    "commit" : "78b135806f10c39c3bbd00edf206ddc9f505597e",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +148,152 @@  TryCatch try_catch(env->isolate());\n\n  do {\n    std::vector<double> destroy_ids_list;\n    destroy_ids_list.swap(*env->destroy_ids_list());"
  },
  {
    "id" : "219d744a-ae38-4918-92a0-04aad8c63d70",
    "prId" : 13585,
    "prUrl" : "https://github.com/nodejs/node/pull/13585#pullrequestreview-43294768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79bbc629-ede7-45fc-bba8-a38576802dcd",
        "parentId" : null,
        "authorId" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "body" : "Since we are going with the temp fix, I guess this is okay. But I really want to see a better solution. I'm not really convinced there aren't some obscure bug with the right `.enable()` and `.disable()` calls.",
        "createdAt" : "2017-06-10T10:11:37Z",
        "updatedAt" : "2017-06-16T17:28:18Z",
        "lastEditedBy" : "07d067f8-a546-476c-a323-f0ae8fdb5357",
        "tags" : [
        ]
      }
    ],
    "commit" : "af1a551965ac990e91fa5924d95e99450a6f0814",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +441,445 @@  Environment* env = Environment::GetCurrent(args);\n\n  // Delay the call to `RemovePromiseHook` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  env->isolate()->EnqueueMicrotask([](void* data) {"
  }
]
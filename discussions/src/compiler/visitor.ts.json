[
  {
    "id" : "d040053f-0d62-486e-9b8e-ac14df623b7b",
    "prId" : 16310,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/16310#pullrequestreview-42971524",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1c24450-69c0-468b-ab55-cf867aab0982",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "should not this be a getter too?",
        "createdAt" : "2017-06-06T23:52:32Z",
        "updatedAt" : "2017-06-06T23:52:32Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "f7310fc6-0254-416c-a858-fecc20cf7e90",
        "parentId" : "c1c24450-69c0-468b-ab55-cf867aab0982",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "No. `typeToString` performs type checking, which could result in caching resolutions/types/etc. This can be problematic when you are in the middle of debugging a resolution.\r\n\r\nIts available as a method as there are cases where you _would_ like to get a view of type while debugging and `typeToString` is not available as it is not in the environment record of the closure.",
        "createdAt" : "2017-06-07T01:44:08Z",
        "updatedAt" : "2017-06-07T01:44:08Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "025f3da8-b1d9-4967-8d84-a17a6fff414c",
        "parentId" : "c1c24450-69c0-468b-ab55-cf867aab0982",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i just wounder how slow it would be to do this on every type when you are debugging.",
        "createdAt" : "2017-06-08T16:59:51Z",
        "updatedAt" : "2017-06-08T16:59:51Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "e1125ab1-3c9c-4668-8fda-af34107d5864",
        "parentId" : "c1c24450-69c0-468b-ab55-cf867aab0982",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "The performance impact so far has been fairly small, as far as my own experience has been, as it only matters when the debugger is paused as that is the only time the watch window performs expression evaluation.",
        "createdAt" : "2017-06-08T18:16:21Z",
        "updatedAt" : "2017-06-08T18:16:21Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c65be8bad4c0fb72d11f3ecf4e98279fe381e17",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +1580,1584 @@                \"__debugFlags\": { get(this: Type) { return formatTypeFlags(this.flags); } },\n                \"__debugObjectFlags\": { get(this: Type) { return this.flags & TypeFlags.Object ? formatObjectFlags((<ObjectType>this).objectFlags) : \"\"; } },\n                \"__debugTypeToString\": { value(this: Type) { return this.checker.typeToString(this); } },\n            });\n"
  },
  {
    "id" : "7d3d91a1-0292-411c-9524-a97abc6cd6e5",
    "prId" : 6892,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "480a4e1b-d249-420f-a610-6a919a3e9b8c",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Why do we have to create a new array in the case that `visited === undefined`?\n",
        "createdAt" : "2016-02-17T00:25:20Z",
        "updatedAt" : "2016-03-18T23:39:52Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "eae0343a-a68c-4afd-8628-133dbbfc2c85",
        "parentId" : "480a4e1b-d249-420f-a610-6a919a3e9b8c",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "When we visit a NodeArray with `visitNodes` we want to return a reference to the original `nodes` array if there are no changes. This is to allow us to use a less expensive reference equality test to check for differences when visiting the tree, rather than a more expensive check of each node in the resulting array.\n\nWhen the `visitor` callback returns `undefined`, it signals that the visited node has no corresponding node in the output. As a result, if we have not yet allocated the `updated` node array, we need to make sure that it is allocated. Otherwise, if you were to visit a node array with three nodes, and all of them were to be removed, we would instead return the original node array.\n",
        "createdAt" : "2016-02-21T22:28:29Z",
        "updatedAt" : "2016-03-18T23:39:52Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "340917e0-25dc-46bf-8a6a-e57fb7973518",
        "parentId" : "480a4e1b-d249-420f-a610-6a919a3e9b8c",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "OK, I was missing the property \"return undefined to mean 'missing node'\". Makes sense.\n",
        "createdAt" : "2016-02-22T16:31:30Z",
        "updatedAt" : "2016-03-18T23:39:52Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "f9cb493a1cfd467279e82f4a815e20e733a4655c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +580,584 @@            const visited = node !== undefined ? visitor(node) : undefined;\n            if (updated !== undefined || visited === undefined || visited !== node) {\n                if (updated === undefined) {\n                    // Ensure we have a copy of `nodes`, up to the current index.\n                    updated = createNodeArray(nodes.slice(0, i), /*location*/ nodes, nodes.hasTrailingComma);"
  }
]
[
  {
    "id" : "0f8e98c5-13d1-4bbd-a7f6-abc4a27b57d9",
    "prId" : 44150,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/44150#pullrequestreview-664437400",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c2d4299-7323-4a3e-bc83-6807c788488f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "`while`?\r\n\r\nWhat does `Foo#Bar#Baz` parse as?",
        "createdAt" : "2021-05-19T18:57:38Z",
        "updatedAt" : "2021-05-19T18:57:54Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "8d59e88e-079b-424e-abe2-134c013795f7",
        "parentId" : "1c2d4299-7323-4a3e-bc83-6807c788488f",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "A left-deep JSDocInstanceReference tree: `((Foo#Bar)#Baz)`",
        "createdAt" : "2021-05-20T14:12:00Z",
        "updatedAt" : "2021-05-20T14:12:00Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "de55f80968d3397cef5a234db0bc2ab085cbd14a",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +7315,7319 @@                const p2 = getNodePos();\n                let entityName: EntityName | JSDocMemberName = parseEntityName(/* allowReservedWords*/ false);\n                while (token() === SyntaxKind.PrivateIdentifier) {\n                    reScanHashToken(); // rescan #id as # id\n                    nextTokenJSDoc(); // then skip the #"
  },
  {
    "id" : "fff78909-7713-4ccc-a53c-e35c9a9e8ab3",
    "prId" : 43780,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/43780#pullrequestreview-642471386",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "791e6e1a-4187-4864-98b8-9bf97fc58e6d",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "this is the bulk of fix (2), with a couple of `if`s below to correct parsing in the error case.",
        "createdAt" : "2021-04-22T17:14:17Z",
        "updatedAt" : "2021-04-22T17:14:22Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7f6739a79b07c77ae7444adeab9c1b4201ccc7a",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +4886,4890 @@            const pos = getNodePos();\n            const opening = parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext);\n            let result: JsxElement | JsxSelfClosingElement | JsxFragment;\n            if (opening.kind === SyntaxKind.JsxOpeningElement) {\n                let children = parseJsxChildren(opening);"
  },
  {
    "id" : "055c53d2-17f1-43bf-ab36-68574fd2b8c5",
    "prId" : 43312,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/43312#pullrequestreview-618064749",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f39275aa-eda6-4d88-a477-eb0b55bfc324",
        "parentId" : null,
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "Not new, but why is `comments` accumulated as an array of parts and joined later, rather than simply accumulated as a string?",
        "createdAt" : "2021-03-22T17:43:05Z",
        "updatedAt" : "2021-03-22T22:15:30Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "b20b85e9-9b40-4300-993a-2593814f6e48",
        "parentId" : "f39275aa-eda6-4d88-a477-eb0b55bfc324",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Habit from immutable-string languages without optimisations for `+=`. I'm *not* sure if JS is still one of these languages or not.",
        "createdAt" : "2021-03-22T17:44:15Z",
        "updatedAt" : "2021-03-22T22:15:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "6d1c75d2-958d-4008-bae2-8c19dd3e0d7e",
        "parentId" : "f39275aa-eda6-4d88-a477-eb0b55bfc324",
        "authorId" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "body" : "I'm pretty sure I remember reading that `+=` is the fastest way to accumulate a string in JS, but I don't have a source.",
        "createdAt" : "2021-03-22T17:48:41Z",
        "updatedAt" : "2021-03-22T22:15:30Z",
        "lastEditedBy" : "4fe07f9f-2018-4a29-969c-e58ed20233c7",
        "tags" : [
        ]
      },
      {
        "id" : "ad79aed7-c68d-4c5b-9da5-9f45bd01cb44",
        "parentId" : "f39275aa-eda6-4d88-a477-eb0b55bfc324",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I'm going to try this in a separate PR.",
        "createdAt" : "2021-03-22T23:37:49Z",
        "updatedAt" : "2021-03-22T23:37:49Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "556a9632c563987ed3ce05608f27132f7c10002d",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +7336,7340 @@                let linkEnd: number;\n                let commentsPos: number | undefined;\n                let comments: string[] = [];\n                const parts: (JSDocLink | JSDocText)[] = [];\n"
  },
  {
    "id" : "48237b52-66f4-4587-8ade-456cb05c6d2c",
    "prId" : 43005,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/43005#pullrequestreview-714187142",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "09277d5f-caa1-4a29-af70-160461212544",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "We should only report an error here if there's no preceding line terminator. This is valid JS:\r\n```js\r\nclass C {\r\n  a\r\n  b\r\n  c() {}\r\n}\r\n```\r\nASI inserts a `;` between `a` and `b`, and between `b` and `c()`. I would expect the same to be true for decorators:\r\n```js\r\nclass C {\r\n  a\r\n  @dec b\r\n  c() {}\r\n}\r\n```\r\nThis should be legal since ASI would insert a `;` between `a` and `@dec`, however now it is an error.",
        "createdAt" : "2021-07-24T00:27:01Z",
        "updatedAt" : "2021-07-24T00:27:39Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "b16d5eb39b391abf45e1ec35f4e054ac37c9de63",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +1651,1655 @@            switch (token()) {\n                case SyntaxKind.AtToken:\n                    parseErrorAtCurrentToken(Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);\n                    return;\n"
  },
  {
    "id" : "d7af0d1e-4e9b-49bc-aeb5-d8295aff1cd0",
    "prId" : 42520,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42520#pullrequestreview-579525271",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41cdf630-0e8b-47a1-a6b4-d7cc232a8b13",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "We only use identifierCount for diagnostics purposes. Is there a reason to make it conditional?",
        "createdAt" : "2021-01-29T18:27:21Z",
        "updatedAt" : "2021-01-29T20:47:12Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "3e9c5ebd-ecb2-41f6-bb73-233107636f31",
        "parentId" : "41cdf630-0e8b-47a1-a6b4-d7cc232a8b13",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "I didn’t think it was super important, but realized it was double-counting invalid identifiers, and it was easy to make it more accurate.",
        "createdAt" : "2021-01-29T18:46:45Z",
        "updatedAt" : "2021-01-29T20:47:12Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "177f88baca5e8b83b26466cdb56696afcbb7e6c5",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1639,1643 @@        function createIdentifier(isIdentifier: boolean, diagnosticMessage?: DiagnosticMessage, privateIdentifierDiagnosticMessage?: DiagnosticMessage): Identifier {\n            if (isIdentifier) {\n                identifierCount++;\n                const pos = getNodePos();\n                // Store original token kind if it is not just an Identifier so we can report appropriate error later in type checker"
  },
  {
    "id" : "2f740afd-f961-4627-94bc-c99df105cbda",
    "prId" : 42300,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/42300#pullrequestreview-567124980",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "08725032-f55a-4d88-81f6-73d80aacc0db",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Why the node kind check?",
        "createdAt" : "2021-01-12T21:35:28Z",
        "updatedAt" : "2021-01-12T21:35:29Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "97c45bd2-e3a0-4c7f-89a9-8801731987c4",
        "parentId" : "08725032-f55a-4d88-81f6-73d80aacc0db",
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "This avoids unnecessary work for tokens, which cannot have children. Depending on the user code, that can avoid up to 50% of the calls to `gatherPossibleChildren`",
        "createdAt" : "2021-01-13T05:37:49Z",
        "updatedAt" : "2021-01-13T05:45:14Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "965c1d12-b6de-42e8-8ce5-da45d6513a0f",
        "parentId" : "08725032-f55a-4d88-81f6-73d80aacc0db",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Oh, nice.",
        "createdAt" : "2021-01-13T11:20:29Z",
        "updatedAt" : "2021-01-13T11:20:29Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "af19b77ca55175c6239089bcb64e31c6b09cdf0f",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +586,590 @@                    return res;\n                }\n                if (current.kind >= SyntaxKind.FirstNode) {\n                    // add children in reverse order to the queue, so popping gives the first child\n                    for (const child of gatherPossibleChildren(current)) {"
  },
  {
    "id" : "c3831ead-3d1a-44d6-a2fa-efcfa73fbac9",
    "prId" : 39803,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39803#pullrequestreview-457987014",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b110b1e8-8f5a-40e1-b8a4-6fb1db004739",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "what does this change do?",
        "createdAt" : "2020-07-29T23:07:43Z",
        "updatedAt" : "2020-07-30T10:16:31Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "753c80a7-d587-43ba-8c08-73b3d498a791",
        "parentId" : "b110b1e8-8f5a-40e1-b8a4-6fb1db004739",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "An *IdentifierName* is any valid user-declarable *Identifier* along with any reserved keywords.",
        "createdAt" : "2020-07-29T23:19:32Z",
        "updatedAt" : "2020-07-30T10:16:31Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f5ecd8af-51f1-4e03-81ba-b5f009bfc3e7",
        "parentId" : "b110b1e8-8f5a-40e1-b8a4-6fb1db004739",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "That's actually backwards: An _Identifier_ is any valid _IdentifierName_ **excluding** reserved keywords:\r\n\r\n[![Identifier Production](https://user-images.githubusercontent.com/3902892/88864977-6ca40700-d1bb-11ea-8158-ca5f5d7e1302.png \"Identifier: IdentifierName but not ReservedWord\")](https://tc39.es/ecma262/#prod-Identifier)\r\n",
        "createdAt" : "2020-07-29T23:50:42Z",
        "updatedAt" : "2020-07-30T10:16:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "00a6ce16-3701-42d5-9479-3844f49b1f79",
        "parentId" : "b110b1e8-8f5a-40e1-b8a4-6fb1db004739",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "tomato / tomat + o",
        "createdAt" : "2020-07-30T00:32:48Z",
        "updatedAt" : "2020-07-30T10:16:31Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "12178073-0740-4fe7-ad2e-2777bb5a1fa1",
        "parentId" : "b110b1e8-8f5a-40e1-b8a4-6fb1db004739",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "or maybe\r\n\r\ntomato / tomatoo - o",
        "createdAt" : "2020-07-30T00:33:31Z",
        "updatedAt" : "2020-07-30T10:16:31Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bdd6e12d0539c1d3c8f210a5b967a76c59acfb26",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +6997,7001 @@\n        function parseNamespaceExport(pos: number): NamespaceExport {\n            return finishNode(factory.createNamespaceExport(parseIdentifierName()), pos);\n        }\n"
  },
  {
    "id" : "96dc41df-b922-473d-a025-f93da446a738",
    "prId" : 39570,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39570#pullrequestreview-448301949",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f09b6b6f-d33d-49ef-a07f-d2baf80d8bdf",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "side note: I bet this newish function could replace a lot of other lower-level error-reporting functions in the parser; it's only used 3 other places right now.",
        "createdAt" : "2020-07-14T17:23:47Z",
        "updatedAt" : "2020-07-15T06:19:20Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4c84fcd0e89ed05994652056d79e7241d9c205e",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +3590,3594 @@\n                }\n                parseErrorAtRange(type, diagnostic);\n                return type;\n            }"
  },
  {
    "id" : "497eb66a-af05-4503-82ee-db214faa4670",
    "prId" : 39216,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39216#pullrequestreview-436245643",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ddafe4a3-3a72-4c7d-bcef-1b42034a146f",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "If we reparse a statement, is it possible when we exit the speculation helper that we'd need to adjust diagnostic positions here? I guess not, since we stay in the speculation helper so long as the statement positions aren't aligned.",
        "createdAt" : "2020-06-23T23:55:40Z",
        "updatedAt" : "2020-06-24T00:20:46Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "610d0f70-fd11-41bd-bc11-476844738b22",
        "parentId" : "ddafe4a3-3a72-4c7d-bcef-1b42034a146f",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "No, we shouldn't need to adjust. If the resulting statement overlaps an existing statement that follows it then we would reparse the statement that follows as well and use the newly-generated diagnostics for that statement.",
        "createdAt" : "2020-06-24T00:25:41Z",
        "updatedAt" : "2020-06-24T00:25:41Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "6298d84460ac0a80ec09359447baba0d0b9fa6c4",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +1059,1063 @@                const diagnosticEnd = diagnosticStart >= 0 ? findIndex(savedParseDiagnostics, diagnostic => diagnostic.start >= nextStatement.pos, diagnosticStart) : -1;\n                if (diagnosticStart >= 0) {\n                    addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart, diagnosticEnd >= 0 ? diagnosticEnd : undefined);\n                }\n"
  },
  {
    "id" : "d7550535-769f-4c72-99dd-ee38cebbffe9",
    "prId" : 39123,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39123#pullrequestreview-432796527",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6c85a2b-9609-47bd-be83-1dd29d2d2dca",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Comment appears to be out of date?",
        "createdAt" : "2020-06-17T21:40:09Z",
        "updatedAt" : "2020-06-17T21:42:15Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "d7c8e5231ed397269329aec76e9a60d413d2527f",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +3356,3360 @@                        break;\n                    case SyntaxKind.QuestionToken:\n                        // If not in JSDoc and next token is start of a type we have a conditional type\n                        if (lookAhead(nextTokenIsStartOfType)) {\n                            return type;"
  },
  {
    "id" : "4c9b2550-d215-4875-b90f-afad65a6e04b",
    "prId" : 39084,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39084#pullrequestreview-432007250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a9eda1d-8980-43d1-9ce8-4f5ef188080e",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "This is essentially every non-expression node which contains an expression node, yeah? Can we add a comment to that effect? The requirement for inclusion here is nonobvious.",
        "createdAt" : "2020-06-17T02:00:41Z",
        "updatedAt" : "2020-06-18T18:18:37Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "75c6375a121529670d4860fc42b5e8cded09df63",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +1062,1066 @@                // We explicitly visit each non-Expression node that has an immediate Expression child so that\n                // we can reparse the Expression in an Await context\n                switch (node.kind) {\n                    case SyntaxKind.Decorator: return reparseDecorator(node as Decorator);\n                    case SyntaxKind.ComputedPropertyName: return reparseComputedPropertyName(node as ComputedPropertyName);"
  },
  {
    "id" : "5d07e348-514e-4723-ae48-5f14fa94cdb6",
    "prId" : 39084,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39084#pullrequestreview-432693236",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6d47b02-d3ca-4b96-9cbf-727008356f60",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Hm. Should we do something smarter when we're doing an incremental parse, like only visiting and reparsing the changed subtree?",
        "createdAt" : "2020-06-17T02:10:45Z",
        "updatedAt" : "2020-06-18T18:18:37Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "c7d37f18-4f48-44b9-a427-d551788d0d93",
        "parentId" : "c6d47b02-d3ca-4b96-9cbf-727008356f60",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "The biggest issue with incremental parse is that it depends in part on differences in the context flags, and whether the top-level is an `Await` context is dependent on whether we treat it as a module. What happens when the changed subtree includes a new `export {}` that turns the file into a module? What I might do is hold onto a pointer for the non-reparsed source file to pass to incremental parse, and then just handle reparse individually as needed. We might not get as much node reuse inside of expressions, but incremental parse node reuse only applies to a limited set of list contexts (statements, class members, switch clauses, etc.) and is ignored at the expression level.\r\n\r\n",
        "createdAt" : "2020-06-17T19:04:38Z",
        "updatedAt" : "2020-06-18T18:18:37Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "75c6375a121529670d4860fc42b5e8cded09df63",
    "line" : 201,
    "diffHunk" : "@@ -1,1 +1197,1201 @@            // If we parsed this as an external module, it may contain top-level await\n            if (!isDeclarationFile && isExternalModule(sourceFile) && sourceFile.transformFlags & TransformFlags.ContainsPossibleTopLevelAwait) {\n                sourceFile = reparseTopLevelAwait(sourceFile);\n            }\n"
  },
  {
    "id" : "da247b0e-e335-484a-8863-1a82b54a05d0",
    "prId" : 39084,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39084#pullrequestreview-432696536",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c44a838-e7fc-4760-b3cd-e8c16e8656a0",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Would using `initializeState` and passing in a syntax cursor here allow us to reuse the initially parsed nodes where possible, even in the case of a partial reparse? (Reparse due to context invalidation and incremental reparsing I would think seem similar)",
        "createdAt" : "2020-06-17T02:17:57Z",
        "updatedAt" : "2020-06-18T18:18:37Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "f99b2dd8-a1cf-4ec2-a9ee-a94a7e4071a4",
        "parentId" : "2c44a838-e7fc-4760-b3cd-e8c16e8656a0",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Possibly. I'm on the fence as to whether I wanted to set `original` pointers for these nodes. I need to add some incremental parse test cases.",
        "createdAt" : "2020-06-17T18:34:55Z",
        "updatedAt" : "2020-06-18T18:18:37Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "5cfd2c7f-1e57-4a0d-889c-3ff3a0bb9526",
        "parentId" : "2c44a838-e7fc-4760-b3cd-e8c16e8656a0",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I considered using incremental parse, but it doesn't apply at the expression level, only at certain list context levels (see https://github.com/microsoft/TypeScript/pull/39084#discussion_r441770690). I might have been able to leverage it by reparsing the statement itself, but some of the necessary incremental parse machinery isn't currently accessible from within `Parser`, and would be fairly complex to wire up properly.",
        "createdAt" : "2020-06-17T19:09:24Z",
        "updatedAt" : "2020-06-18T18:18:37Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "75c6375a121529670d4860fc42b5e8cded09df63",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +1090,1094 @@                    if (isExpression(node)) {\n                        return speculationHelper(() => {\n                            scanner.setTextPos(node.pos);\n                            const savedContextFlags = contextFlags;\n                            contextFlags = node.flags & NodeFlags.ContextFlags;"
  },
  {
    "id" : "725ee7ce-8551-4e1b-91b4-278df0aca2b9",
    "prId" : 37917,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/37917#pullrequestreview-406827653",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "766a943e-fc58-4720-91ea-7f29a838b102",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Do you have a test that demonstrates this `skipTrivia` skips comments?",
        "createdAt" : "2020-05-06T17:22:48Z",
        "updatedAt" : "2020-06-01T19:03:48Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb1fdb7d4ff8e0917b20246515ec93c26a6dc41d",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +4551,4555 @@                    badNode.operatorToken = createMissingNode(SyntaxKind.CommaToken, /*reportAtCurrentPosition*/ false);\n                    badNode.operatorToken.pos = badNode.operatorToken.end = badNode.right.pos;\n                    parseErrorAt(skipTrivia(sourceText, topBadPos), invalidElement.end, Diagnostics.JSX_expressions_must_have_one_parent_element);\n                    return <JsxElement><Node>badNode;\n                }"
  },
  {
    "id" : "a0367479-40db-4cba-87e5-338063915daa",
    "prId" : 37632,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/37632#pullrequestreview-383123508",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42398297-0d3b-4d13-8693-e80c782ccc33",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "I think `concatenate` in core can handle this in a single call, similarly to `append`",
        "createdAt" : "2020-03-27T17:41:54Z",
        "updatedAt" : "2020-03-27T17:42:10Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "1d40642e-9aaa-4e13-a73d-5cf68e4f7b43",
        "parentId" : "42398297-0d3b-4d13-8693-e80c782ccc33",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "That one creates new array if both arrays are `!undefined` which is what this avoids since anyways we already have new array",
        "createdAt" : "2020-03-27T18:55:47Z",
        "updatedAt" : "2020-03-27T18:55:47Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ac6d9bb4ccc7f67ce4ba19681dda53fb044e4a26",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +7863,7867 @@                else if (newDirectives) {\n                    commentDirectives.push(...newDirectives);\n                }\n            }\n        }"
  },
  {
    "id" : "12b3f7b4-09e8-409a-9b33-1c950a61a6ea",
    "prId" : 36724,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36724#pullrequestreview-357171476",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2770a5af-db3d-4638-8d93-eed37956fe45",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "is this just an optimisation? The previous version just passed a single `cbNode`.",
        "createdAt" : "2020-02-12T00:09:10Z",
        "updatedAt" : "2020-02-25T01:01:09Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "881688d9-d718-4a16-9e28-a4a80636b4aa",
        "parentId" : "2770a5af-db3d-4638-8d93-eed37956fe45",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`forEachChild` allows callers to pass a `NodeArray` handler, so this also supports that. This functionality is utilized in the JS walker, which provides separate `walk` and `walkArray` helpers. (The parser's `fixupParentPointers` usage still only provides a `cbNode` argument)",
        "createdAt" : "2020-02-12T03:41:33Z",
        "updatedAt" : "2020-02-25T01:01:09Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff4ca8620e04a075b0d166335056a3efb38b68ad",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +562,566 @@        function visitAllPossibleChildren(parent: Node, children: readonly (Node | NodeArray<Node>)[]) {\n            for (const child of children) {\n                if (isArray(child)) {\n                    if (cbNodes) {\n                        const res = cbNodes(child, parent);"
  },
  {
    "id" : "f9d00654-a7be-4ebc-9cf9-cbb69527a476",
    "prId" : 36724,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36724#pullrequestreview-566137920",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bc5fe40-a511-4a8f-bb7a-325d51cc96a6",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "is it intended that the child is added to the stack, even though `cbNode` returned `\"skip\"`?",
        "createdAt" : "2021-01-12T08:58:58Z",
        "updatedAt" : "2021-01-12T09:12:24Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "7c22a440-24a6-4afb-a0c2-e512ad1ce5e5",
        "parentId" : "4bc5fe40-a511-4a8f-bb7a-325d51cc96a6",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`cbnode` visits the node itself. The `skip` it returns prevents adding the children of that node to the list of things to visit.",
        "createdAt" : "2021-01-12T10:30:38Z",
        "updatedAt" : "2021-01-12T10:30:53Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "b5b184a8-e99d-47fc-af6e-27286b62bc07",
        "parentId" : "4bc5fe40-a511-4a8f-bb7a-325d51cc96a6",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "So, probably not, no, the stack push of the children should probably be within the condition. This probably means that the visitor isn't skipping anything with a fixed number of children; but I guess we don't filter down like that all that often.",
        "createdAt" : "2021-01-12T10:35:17Z",
        "updatedAt" : "2021-01-12T10:37:16Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff4ca8620e04a075b0d166335056a3efb38b68ad",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +585,589 @@                    const res = cbNode(child, parent);\n                    if (res) {\n                        if (res === \"skip\") continue;\n                        return res;\n                    }"
  },
  {
    "id" : "e0cb544d-fca3-4382-8411-8407078d1cd7",
    "prId" : 36724,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36724#pullrequestreview-566171191",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0eae9b85-c8f6-46ca-88a2-ba995ca27b4a",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "is it intended, that children are visited in reverse order?",
        "createdAt" : "2021-01-12T09:00:39Z",
        "updatedAt" : "2021-01-12T09:12:24Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "6439a196-d2f8-45a9-84d7-12cc18703ba5",
        "parentId" : "0eae9b85-c8f6-46ca-88a2-ba995ca27b4a",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "In the `for` loop below? IIRC, yes; because a stack is in use as the work-tracking structure, when we add things to the stack, we want to add them in the opposite order we want them to get popped off in.",
        "createdAt" : "2021-01-12T10:40:07Z",
        "updatedAt" : "2021-01-12T10:40:08Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "7d73c770-a19b-4d36-9c0f-e699315008bd",
        "parentId" : "0eae9b85-c8f6-46ca-88a2-ba995ca27b4a",
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "I got that it's necessary for the stack order, but adding to the stack and calling `cbNode` is done in the same iteration. Therefore children of a given parent are visited in reversed order.\r\n\r\nGiven the tree from the comment above the current logic is as follows:\r\n\r\n* gather children of 1 in reverse order: [3, 2]\r\n* visitNode 3, add 3 to the stack\r\n* visitNode 2, add 2 to the stack\r\n* pop 2 from the stack\r\n* recurse into 2\r\n  * gather children of 2 in reverse order: [5, 4]\r\n  * visitNode 5, add to stack\r\n  * visitNode 4, add to stack\r\n  * pop 4 from the stack\r\n  * pop 5 from the stack\r\n* pop 3 from the stack\r\n* recurse into 3\r\n  * ... \r\n\r\nThis doesn't match the inline comment about this being \"depth-first preorder\".",
        "createdAt" : "2021-01-12T11:18:29Z",
        "updatedAt" : "2021-01-12T11:45:05Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff4ca8620e04a075b0d166335056a3efb38b68ad",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +561,565 @@\n        function visitAllPossibleChildren(parent: Node, children: readonly (Node | NodeArray<Node>)[]) {\n            for (const child of children) {\n                if (isArray(child)) {\n                    if (cbNodes) {"
  },
  {
    "id" : "b601f58c-7c77-4e98-89e9-185fdfe80e2a",
    "prId" : 36724,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36724#pullrequestreview-566056489",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d8bf284-5b78-4247-9c53-a81d6468a31f",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "since this is immediately calling `cbNode` on all immediate children, this kinda is a breadth-first / level-order traversal.",
        "createdAt" : "2021-01-12T09:04:53Z",
        "updatedAt" : "2021-01-12T09:12:24Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff4ca8620e04a075b0d166335056a3efb38b68ad",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +561,565 @@\n        function visitAllPossibleChildren(parent: Node, children: readonly (Node | NodeArray<Node>)[]) {\n            for (const child of children) {\n                if (isArray(child)) {\n                    if (cbNodes) {"
  },
  {
    "id" : "bb2ae27f-442e-456c-8355-1f00bebdfa03",
    "prId" : 36289,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36289#pullrequestreview-346862542",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a8c2225-c479-428b-854e-d84b680eea5d",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "What other things can token be here? Why is it that only `Identifier` leaves the node's kind as unknown?",
        "createdAt" : "2020-01-22T18:35:56Z",
        "updatedAt" : "2020-01-22T18:37:40Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "7b9e411a-4328-4b48-8a8f-a0ea54461ebd",
        "parentId" : "2a8c2225-c479-428b-854e-d84b680eea5d",
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "This change is necessary so we can correctly handle `ExpressionStatement` inside `createNodeWithJSDoc`. You are right, that it would've been set later anyway, but that's too late as the JSDoc would already be attached to the `ExpressionStatement` node.\r\n\r\n`Identifier` has a special handling here, because it's the only token that could be the start of a `LabeledStatement`. This change is only about `ExpressionStatement`s starting with parentheses. Hence we can leave this as `Unknown` and avoid the lookahead to determine whether we are actually dealing with a `LabeledStatement`.",
        "createdAt" : "2020-01-22T19:57:55Z",
        "updatedAt" : "2020-01-22T19:57:55Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      }
    ],
    "commit" : "d8222bf80a5e529ed23f81f6466ecf5f722ac284",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +5392,5396 @@            // out an expression, seeing if it is identifier and then seeing if it is followed by\n            // a colon.\n            const node = <ExpressionStatement | LabeledStatement>createNodeWithJSDoc(token() === SyntaxKind.Identifier ? SyntaxKind.Unknown : SyntaxKind.ExpressionStatement);\n            const expression = allowInAnd(parseExpression);\n            if (expression.kind === SyntaxKind.Identifier && parseOptional(SyntaxKind.ColonToken)) {"
  },
  {
    "id" : "c8030852-7294-43d5-a539-e1dcb2efb3c1",
    "prId" : 36188,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36188#pullrequestreview-346923659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I'm not a huge fan of optional parameters in the parser. Is there a lot of overhead to making this parameter required?",
        "createdAt" : "2020-01-16T23:32:41Z",
        "updatedAt" : "2020-01-16T23:36:17Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "7ca5645e-21d7-4471-86d4-4c1be8bec6b8",
        "parentId" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "Nope. Also forgot to pass them through to binding pattern parsing. Fixed.",
        "createdAt" : "2020-01-16T23:43:31Z",
        "updatedAt" : "2020-01-16T23:43:31Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "ee9706cb-bfa4-44a6-8d2b-b8985619cd9f",
        "parentId" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "How do you know that they’re slow, by the way? I can’t see an appreciable difference running silly contrived test cases in Chrome.",
        "createdAt" : "2020-01-16T23:50:10Z",
        "updatedAt" : "2020-01-16T23:50:11Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "aedde025-225c-4352-bed2-ee0fee4b9242",
        "parentId" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Discussions around the office, which is why I'm not convinced it's true. I may have misunderstood something, or it may be out of date, or the impact may never be that big.",
        "createdAt" : "2020-01-17T22:56:57Z",
        "updatedAt" : "2020-01-17T22:56:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "6b63259e-0b56-4719-8638-c06d6ca37854",
        "parentId" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I'm not certain whether this has changed in the past few years, but the original rationale was this:\r\n\r\nWhen V8 compiles a function, that compiled function has a fixed number of arguments. If you undersupply arguments to that function, what V8 does is creates a *new* compiled function with that number of arguments that in turn calls the original compiled function, with `undefined` filling in the missing arguments. The reason this can degrade performance is due to the fact that V8 has to generate this new function, and that new function could possibly be garbage collected at some point if it is used infrequently and may eventually need to be generated again.\r\n\r\nI *have* seen this issue in practice several years ago, as there was a bug andy-ms found regarding performance in one of our core functions, though I cannot find the bug report or related PR at this time.",
        "createdAt" : "2020-01-22T21:33:16Z",
        "updatedAt" : "2020-01-22T21:33:16Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "1c0566c0-d7f7-4047-be12-06d01cc3a0c5",
        "parentId" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "@rbuckton do you know if/how default parameters affect that? (I guess it’s a moot point for us since we downlevel to ES5.)",
        "createdAt" : "2020-01-22T21:40:23Z",
        "updatedAt" : "2020-01-22T21:40:23Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "86c75d88-a520-4f93-b7b6-c2fe4c053c41",
        "parentId" : "98b3f038-3df0-4da9-801d-b1600966e429",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Not offhand, no. @syg might know more about whether this optimization still exists (or ever existed?) or could at least point us to someone who might know more.",
        "createdAt" : "2020-01-22T21:42:38Z",
        "updatedAt" : "2020-01-22T21:42:39Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "eeb050e095e3c252cbdb7c6cdd8bb67a2d9ef621",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +5815,5819 @@        }\n\n        function parseIdentifierOrPattern(privateIdentifierDiagnosticMessage?: DiagnosticMessage): Identifier | BindingPattern {\n            if (token() === SyntaxKind.OpenBracketToken) {\n                return parseArrayBindingPattern();"
  },
  {
    "id" : "a32b5b79-3efc-4499-b437-b49c286b8ea9",
    "prId" : 32695,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32695#pullrequestreview-270474127",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81fa4913-cacb-473c-a20b-a6f2b5691558",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "adding this property here and not assigning it in `parseTypeOrTypePredicate` where regular `TypePredicate` nodes are constructed, create yet another hidden class that hinders optimization at runtime.\r\nEither assign it last in this function or (even better) assign it in both functions in the same order",
        "createdAt" : "2019-08-03T19:27:13Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "f715dc74-78dd-4a7f-82f9-68afa6c0279c",
        "parentId" : "81fa4913-cacb-473c-a20b-a6f2b5691558",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Agreed",
        "createdAt" : "2019-08-03T22:02:27Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcdf33d8de066b827e8251875675b7a0084446c5",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +3282,3286 @@        function parseAssertsTypePredicate(): TypeNode {\n            const node = <TypePredicateNode>createNode(SyntaxKind.TypePredicate);\n            node.assertsModifier = parseExpectedToken(SyntaxKind.AssertsKeyword);\n            node.parameterName = token() === SyntaxKind.ThisKeyword ? parseThisTypeNode() : parseIdentifier();\n            node.type = parseOptional(SyntaxKind.IsKeyword) ? parseType() : undefined;"
  },
  {
    "id" : "0ed65538-fe72-4385-84e7-4259fbc049d8",
    "prId" : 32695,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32695#pullrequestreview-270474133",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd056d3e-28e6-43e1-aa2e-172807248d23",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "Is there a possibility that there will be more modifiers in the future? If so, would it make sense to put this into `Node#modifiers`?",
        "createdAt" : "2019-08-03T19:28:45Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "734f582e-71c3-49ac-a602-44dc995cff56",
        "parentId" : "fd056d3e-28e6-43e1-aa2e-172807248d23",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It's possible, but for now I'm going to keep it the way it is.",
        "createdAt" : "2019-08-03T22:03:01Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcdf33d8de066b827e8251875675b7a0084446c5",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +3282,3286 @@        function parseAssertsTypePredicate(): TypeNode {\n            const node = <TypePredicateNode>createNode(SyntaxKind.TypePredicate);\n            node.assertsModifier = parseExpectedToken(SyntaxKind.AssertsKeyword);\n            node.parameterName = token() === SyntaxKind.ThisKeyword ? parseThisTypeNode() : parseIdentifier();\n            node.type = parseOptional(SyntaxKind.IsKeyword) ? parseType() : undefined;"
  },
  {
    "id" : "50bd254c-89ff-46cf-a20c-89bab6b8b00c",
    "prId" : 31480,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/31480#pullrequestreview-240335633",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "19805a7a-a347-4a0a-b24c-dae16d63febf",
        "parentId" : null,
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "When we successfully parse something we know is illegal, is that always a grammar error, or is there ever a reason why that should be a parse error? I know a parse error will prevent the node from being reused incrementally—in this case the tree should be well-formed, so I think reusing it isn’t a problem.",
        "createdAt" : "2019-05-21T22:51:36Z",
        "updatedAt" : "2019-05-22T17:00:21Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad9c36e0ecae1be0532b1e87db59ecc4f80c96bc",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +4434,4438 @@                // but we can unambiguously parse a comma sequence and provide\n                // a better error message in grammar checking.\n                node.expression = parseExpression();\n            }\n            if (inExpressionContext) {"
  },
  {
    "id" : "8cb3fa89-4d26-434b-afaa-1b34c03d8e1b",
    "prId" : 30838,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30838#pullrequestreview-224700350",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "601e46fc-d27c-4f16-87f3-de3734e7e10f",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "margin is the thing that's fixed, whereas indent goes up for each line. So this name was wrong before.",
        "createdAt" : "2019-04-09T23:25:29Z",
        "updatedAt" : "2019-04-09T23:26:03Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "45c54e54c686855f3699474edc83f2f385587b4c",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +6561,6565 @@                }\n\n                function parseTag(margin: number) {\n                    Debug.assert(token() === SyntaxKind.AtToken);\n                    const start = scanner.getTokenPos();"
  },
  {
    "id" : "cb913aa3-e9c4-49f4-9e0f-8762d4a21558",
    "prId" : 29717,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/29717#pullrequestreview-201298447",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fcf74cb-4e7e-49b0-bd99-7381dd0d008e",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "this looks like it will include whitespace just after the initial tag, with `@author X Y` resulting in the comment `\" X Y\"`. Is that correct?",
        "createdAt" : "2019-02-05T22:16:25Z",
        "updatedAt" : "2019-04-19T10:03:55Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "9aed7f3d-72be-4a89-8146-e4bd7b493bc2",
        "parentId" : "1fcf74cb-4e7e-49b0-bd99-7381dd0d008e",
        "authorId" : "ebf240bf-2673-4f74-941b-b16d6f2bdd9e",
        "body" : "No, it doesn't do that. I tried with arbitrary amount of spaces/tabs and it ignored it all until the first non-whitespace character.\r\n\r\nSee the baseline for the quick info test which doesn't include the single whitespace, which is following after the `author` tag.\r\n\r\nTest tag\r\nhttps://github.com/Microsoft/TypeScript/blob/7deee5d21a28504ee7cf4dcf53ed41c7be5c16d2/tests/cases/fourslash/quickInfoJsDocTags.ts#L6\r\nParsed tag\r\nhttps://github.com/Microsoft/TypeScript/blob/7deee5d21a28504ee7cf4dcf53ed41c7be5c16d2/tests/baselines/reference/quickInfoJsDocTags.baseline#L73",
        "createdAt" : "2019-02-07T20:08:29Z",
        "updatedAt" : "2019-04-19T10:03:55Z",
        "lastEditedBy" : "ebf240bf-2673-4f74-941b-b16d6f2bdd9e",
        "tags" : [
        ]
      }
    ],
    "commit" : "08bd017db97445709cc249d3c0c9661ff962c009",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +6910,6914 @@                        switch (token) {\n                            case SyntaxKind.Identifier:\n                            case SyntaxKind.WhitespaceTrivia:\n                            case SyntaxKind.DotToken:\n                            case SyntaxKind.AtToken:"
  },
  {
    "id" : "853caee0-e1a6-40f6-9f56-fe0df83ef227",
    "prId" : 29435,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/29435#pullrequestreview-193274184",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98b60211-c430-42a3-b927-9c0ec0999534",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Think we need test/handling for .d.ts generation and decorator for this new typeNode kind.",
        "createdAt" : "2019-01-16T18:01:24Z",
        "updatedAt" : "2019-01-29T00:31:01Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "332468441e0dd950895788c03690c7dc97e8cd9f",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +3079,3083 @@                case SyntaxKind.KeyOfKeyword:\n                case SyntaxKind.UniqueKeyword:\n                case SyntaxKind.ReadonlyKeyword:\n                    return parseTypeOperator(operator);\n                case SyntaxKind.InferKeyword:"
  },
  {
    "id" : "7247cbe4-d9d4-4fda-bbbb-880225cf77d1",
    "prId" : 28742,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/28742#pullrequestreview-179959978",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a005a46a-41b1-45d1-a73a-d92c334da808",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why are we commenting these out?",
        "createdAt" : "2018-11-29T18:42:26Z",
        "updatedAt" : "2018-11-29T18:52:43Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e5c1033a-ae6f-4e23-9acc-6b376585d97d",
        "parentId" : "a005a46a-41b1-45d1-a73a-d92c334da808",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Because there was no code associated with them. They're just headings for comments. So they should be comments themselves.",
        "createdAt" : "2018-11-29T18:57:56Z",
        "updatedAt" : "2018-11-29T18:57:56Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "92a8cc9f5f4ee23b848f2f3328646556e8b19236",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +1831,1835 @@                // heritage clauses.\n\n                // case ParsingContext.TypeParameters:\n                // This would probably be safe to reuse.  There is no speculative parsing with\n                // type parameters.  Note that that's because type *parameters* only occur in"
  },
  {
    "id" : "f8ace05b-1af4-41fc-a4a6-6a17ec3d364a",
    "prId" : 27850,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/27850#pullrequestreview-164053070",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5bf5699-6ee5-434c-a1ab-b1b775eb1b9f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Does this mean that we no longer error when we run into a `.`?",
        "createdAt" : "2018-10-11T23:10:03Z",
        "updatedAt" : "2018-10-11T23:29:27Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c1dc26d4-ea5c-4f28-b5d7-e6400420ea2c",
        "parentId" : "d5bf5699-6ee5-434c-a1ab-b1b775eb1b9f",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "This code just determines whether we *try* to parse a new object literal member -- we can still fail to do so.",
        "createdAt" : "2018-10-11T23:29:27Z",
        "updatedAt" : "2018-10-11T23:29:27Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f4b49bfb3481eb99d600885d38d57214458a778",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +1487,1491 @@                        case SyntaxKind.AsteriskToken:\n                        case SyntaxKind.DotDotDotToken:\n                        case SyntaxKind.DotToken: // Not an object literal member, but don't want to close the object (see `tests/cases/fourslash/completionsDotInObjectLiteral.ts`)\n                            return true;\n                        default:"
  },
  {
    "id" : "abb20e99-1866-44f8-8216-e0597b32e299",
    "prId" : 25886,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25886#pullrequestreview-170957544",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac346afc-2945-41ee-bb20-8bd3bd6bf9a1",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "In parseJsonText you need to handle numeric literal checks (to ignore the big ints)",
        "createdAt" : "2018-11-01T19:57:40Z",
        "updatedAt" : "2018-11-05T20:24:02Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "260bec6b-0580-4170-a551-0724eb2df288",
        "parentId" : "ac346afc-2945-41ee-bb20-8bd3bd6bf9a1",
        "authorId" : "2a9ff7d0-9e5d-4e6a-9c76-06f809e7ccca",
        "body" : "I separated `SyntaxKind.BigIntLiteral` from `SyntaxKind.NumericLiteral`, so I believe that is no longer necessary",
        "createdAt" : "2018-11-02T03:09:00Z",
        "updatedAt" : "2018-11-05T20:24:02Z",
        "lastEditedBy" : "2a9ff7d0-9e5d-4e6a-9c76-06f809e7ccca",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb99c4123003ade3e471cf17472be6d3f72d96ff",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +2903,2907 @@                case SyntaxKind.StringKeyword:\n                case SyntaxKind.NumberKeyword:\n                case SyntaxKind.BigIntKeyword:\n                case SyntaxKind.SymbolKeyword:\n                case SyntaxKind.BooleanKeyword:"
  },
  {
    "id" : "07f500e8-5e03-4217-9aae-96527ceab6b1",
    "prId" : 25886,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25886#pullrequestreview-170957949",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "33003409-c4a0-4fd7-9cdb-aacab68795d2",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Need to handle bigint in `parsePropertyNameWorker`",
        "createdAt" : "2018-11-01T19:58:42Z",
        "updatedAt" : "2018-11-05T20:24:02Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "963fd062-bcc8-458d-b216-31dc989d4608",
        "parentId" : "33003409-c4a0-4fd7-9cdb-aacab68795d2",
        "authorId" : "2a9ff7d0-9e5d-4e6a-9c76-06f809e7ccca",
        "body" : "I don't think `bigint`s are valid property names, e.g. `{1n: 2}` throws a `SyntaxError` in V8",
        "createdAt" : "2018-11-02T03:12:00Z",
        "updatedAt" : "2018-11-05T20:24:02Z",
        "lastEditedBy" : "2a9ff7d0-9e5d-4e6a-9c76-06f809e7ccca",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb99c4123003ade3e471cf17472be6d3f72d96ff",
    "line" : 48,
    "diffHunk" : "@@ -1,1 +2963,2967 @@                case SyntaxKind.StringKeyword:\n                case SyntaxKind.NumberKeyword:\n                case SyntaxKind.BigIntKeyword:\n                case SyntaxKind.BooleanKeyword:\n                case SyntaxKind.SymbolKeyword:"
  },
  {
    "id" : "f430dba4-e118-418a-ab4b-4703a1c65010",
    "prId" : 25799,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25799#pullrequestreview-138782785",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "560c8d04-6ee1-451c-b257-e69d7a1e7333",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Does anything bad happen if we just always treat `(` as the start of a parameter? It's a parse error anyway, right?",
        "createdAt" : "2018-07-19T17:25:21Z",
        "updatedAt" : "2018-07-19T17:49:07Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "92056de4-ff60-4421-a0c5-54e9e2adc96d",
        "parentId" : "560c8d04-6ee1-451c-b257-e69d7a1e7333",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Let me try it ...",
        "createdAt" : "2018-07-19T17:43:09Z",
        "updatedAt" : "2018-07-19T17:49:07Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "119269cc-5cd0-427a-8f5f-5bce64444c29",
        "parentId" : "560c8d04-6ee1-451c-b257-e69d7a1e7333",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "It disrupts parsing quite a bit. I'm not sure why, but it appears to cause type parameter lists to be parsed as parameter lists in arrow functions, and it also breaks function expressions inside object literal property assignments.",
        "createdAt" : "2018-07-19T17:48:47Z",
        "updatedAt" : "2018-07-19T17:49:07Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "f5413cf9d0e8cbabc4ad9232570ccb5ead8ced5d",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1512,1516 @@                    return isStartOfParameter(/*isJSDocParameter*/ false);\n                case ParsingContext.JSDocParameters:\n                    return isStartOfParameter(/*isJSDocParameter*/ true);\n                case ParsingContext.TypeArguments:\n                case ParsingContext.TupleElementTypes:"
  },
  {
    "id" : "baf57104-7bfe-4cf5-a173-8fd3f51552f7",
    "prId" : 25411,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25411#pullrequestreview-134116380",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92630edc-828e-44fd-80cb-056649f6bbcb",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "the return type is actually `boolean | undefined`",
        "createdAt" : "2018-07-03T18:16:56Z",
        "updatedAt" : "2018-07-03T18:21:19Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      }
    ],
    "commit" : "17f0b1acf557a2ae51fb388ced6713391e9eae63",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +2101,2105 @@        }\n\n        function isMissingList(arr: NodeArray<Node>): boolean {\n            return !!(arr as MissingList<Node>).isMissingList;\n        }"
  },
  {
    "id" : "1971c316-09d1-4899-bbd8-5313f36e5d89",
    "prId" : 25206,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25206#pullrequestreview-259037426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aba8777a-899b-405f-b083-42111295a482",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Does this handle `{@link}` (malformed tag) well?",
        "createdAt" : "2018-06-25T22:06:45Z",
        "updatedAt" : "2018-06-25T22:06:46Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "413fa896-7ab7-4e2d-b31e-e6334c4f19d9",
        "parentId" : "aba8777a-899b-405f-b083-42111295a482",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "It's basically a skip, so any sequence of `{@link` is handled correctly. It doesn't handle the unbraced `@link ...` or the extra space in `{ @link`, neither of which are legal jsdoc, but could occur.",
        "createdAt" : "2018-06-25T22:15:07Z",
        "updatedAt" : "2018-06-25T22:15:07Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "15d7bb40-a21b-4517-9fe1-ef7c9a53833c",
        "parentId" : "aba8777a-899b-405f-b083-42111295a482",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "After thinking about it a bit more:\r\n1. unbraced `@link` is formatted like a top-level tag, so I think it's fine to treat it as one.\r\n2. skipping arbitrary whitespace between `{` and `@link` is a lot of work with the current tokeniser. We should switch to the normal tokeniser and then revisit this code.",
        "createdAt" : "2018-06-26T16:39:09Z",
        "updatedAt" : "2018-06-26T16:39:09Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "dcf04e63-f124-4fee-aa96-618bf5eb7e55",
        "parentId" : "aba8777a-899b-405f-b083-42111295a482",
        "authorId" : "8aace0d6-0a62-4faa-b645-9caaa6f75113",
        "body" : "So only tags named \"link\" has this special behavior ? Isn't this kind of arbitrary and unexpected behavior? Reminds me something I heard about an old windows version having a code like `if(process.name==='the sims'){increaseSomething()}`. \r\n\r\nWhat's the reason for this? Is it for IDEs trying to support link in JavaScript projects ? Is it really important to hack the parser like this so one or two IDEs have an easy way of locating the parent tag description and position to insert a link  ?  They can still implement that (although it's harder/hacky/slow for them) without this hack in the compiler... \r\n\r\nIn which kind of projects are they trying to support @type ? Which reference syntax are these projects using , the usejsdocs.org one or TypeScript one?  \r\n\r\nIn the later case, these projects are already breaking usejsdocs \"standard\" so they should not be using @link or {@link} but something else\r\n\r\nIn the first case, then I assume the motive for this hack is to support IDEs  so they can *easily/fast* recreate the broken parent tag description and find the position to insert the anchor. If that's the case don't you think **they** should be responsible of solving their own problems? And if, as best case, they are just trying to solve the problem of jsdoc referencing once and for all, do you think this is the correct way of doing it?\r\n\r\nIf this is more or less right, then I'm worried that you didn't consider nor the compiler API user (for which BTW you introduced a breaking change), nor in the jsdoc writer for which TypeScript could provide typechecked references supporting refactors easily, and nor on typeScript developers since althoguh this change affected compiler performance minimally it shows performance place in this project priorities\r\n\r\nI made an informal quick proposal  https://github.com/microsoft/TypeScript/issues/16498#issuecomment-508316922 and I would love to document in more detail discuss and implement it, but I would like first to know if such feature would be accepted ? \r\n\r\nI think TypeScript now has the opportunity to define the definitely and single way of document JavaScript APIs as other languages have, and a feature like this would help a lot in that direction. \r\n\r\nDon't take me wrong, I admire  this project's contributors , but this just surprise me, sorry for the long comment, thanks.",
        "createdAt" : "2019-07-04T05:42:40Z",
        "updatedAt" : "2019-07-04T05:42:41Z",
        "lastEditedBy" : "8aace0d6-0a62-4faa-b645-9caaa6f75113",
        "tags" : [
        ]
      },
      {
        "id" : "6e540e18-a915-4820-a8f6-2642cdf2c3b3",
        "parentId" : "aba8777a-899b-405f-b083-42111295a482",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "was The Sims part of the Windows spec? In this case `@link` is part of jsdoc that Typescript explicitly wants to opt out of. And it's the only non-top-level tag in jsdoc, which means that code to support it (or skip it) will look special.",
        "createdAt" : "2019-07-08T17:03:40Z",
        "updatedAt" : "2019-07-08T17:03:40Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3afc99d4686911b958ddc79e34665772dd00b80",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +6578,6582 @@                                state = JSDocState.SavingComments;\n                                if (lookAhead(() => nextJSDocToken() === SyntaxKind.AtToken && tokenIsIdentifierOrKeyword(nextJSDocToken()) && scanner.getTokenText() === \"link\")) {\n                                    pushComment(scanner.getTokenText());\n                                    nextJSDocToken();\n                                    pushComment(scanner.getTokenText());"
  },
  {
    "id" : "835f68a9-7fc6-4b7e-a930-e6e1cb917b4a",
    "prId" : 24600,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/24600#pullrequestreview-125665935",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "477bc52f-4cf3-4dfe-89e3-a4c387bb5a3f",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Was already this way, but it looks like `parseTemplateTag` is the only tag-parsing method out of 9 that can return undefined. Might be better to call `parseJSDocIdentifierName` with `createIfMissing` set, and a new parameter to allow a custom diagnostic. Than `parseTag` could return `JSDocTag` (without `| undefined`).",
        "createdAt" : "2018-06-04T15:10:53Z",
        "updatedAt" : "2018-06-04T18:21:31Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "6701a504-942b-40da-bec0-c48f1475e209",
        "parentId" : "477bc52f-4cf3-4dfe-89e3-a4c387bb5a3f",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "parseTag returns undefined near the beginning if it can't parseJSDocIdentifierName, too. As-is the change is not worth it in my opinion. It might be worthwhile to have parseJSDocIdentifierName always return a missing node. I tried that and it looks a bit better, but there's a good bit of churn. Would you like to review it as part of this PR or would you like to see it in a separate one?",
        "createdAt" : "2018-06-04T17:07:41Z",
        "updatedAt" : "2018-06-04T18:21:31Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "b1f42efd-33f0-4662-be8e-c7a4fb197f7a",
        "parentId" : "477bc52f-4cf3-4dfe-89e3-a4c387bb5a3f",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Separate is good.",
        "createdAt" : "2018-06-04T17:16:04Z",
        "updatedAt" : "2018-06-04T18:21:31Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "e85d472a79a561255034ecbd5ba744525f5c5a51",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +7027,7031 @@                        if (!tokenIsIdentifierOrKeyword(token())) {\n                            parseErrorAtCurrentToken(Diagnostics.Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces);\n                            return undefined;\n                        }\n                        typeParameter.name = parseJSDocIdentifierName()!;"
  },
  {
    "id" : "dca40504-b394-4c26-b711-4a1244354c54",
    "prId" : 24184,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/24184#pullrequestreview-121212857",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e341f14-6582-4b56-bb96-be3548b55499",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "does this quirk apply to callback tags too?",
        "createdAt" : "2018-05-17T20:35:11Z",
        "updatedAt" : "2018-05-17T21:26:12Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "21265371-2ed6-4d62-ae85-703014f6a0ce",
        "parentId" : "3e341f14-6582-4b56-bb96-be3548b55499",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "From our discussion: yes, and nested `@param` types too, but the problem isn't bad enough to fix right now. Instead we should fix it by fixing the jsdoc scanner to ignore whitespace (and change the way we generate tag descriptions).",
        "createdAt" : "2018-05-17T20:55:38Z",
        "updatedAt" : "2018-05-17T21:26:12Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "93186412f3518a4233bc604b4dc82d36c80c1afe",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +6821,6825 @@\n                    typedefTag.typeExpression = typeExpression;\n                    let end: number;\n                    if (!typeExpression || isObjectOrObjectArrayTypeReference(typeExpression.type)) {\n                        let child: JSDocTypeTag | JSDocPropertyTag | false;"
  },
  {
    "id" : "afcabbe7-3ba0-4380-8504-bf481ed0ea9a",
    "prId" : 23276,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/23276#pullrequestreview-110608123",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61ace23e-3aa7-45d7-a477-256365e4fe7c",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "If only nested `@param`s were missing comments before this change, where was the comment parsed for non-nested ones? Does this change now parse the comments for all `@param`s here?",
        "createdAt" : "2018-04-09T20:10:08Z",
        "updatedAt" : "2018-04-09T20:49:05Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "cbe725bb-f557-4932-aafa-464adcf37ca4",
        "parentId" : "61ace23e-3aa7-45d7-a477-256365e4fe7c",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Yeah, previously it was always done at the bottom of `parseTag`. But that didn't work if the comment had already been skipped.",
        "createdAt" : "2018-04-09T20:38:27Z",
        "updatedAt" : "2018-04-09T20:49:05Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "67cd3ff083082dee3ab8ace9767d38a31768dfa3",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +6528,6532 @@                        <JSDocPropertyTag>createNode(SyntaxKind.JSDocPropertyTag, atToken.pos);\n                    let comment: string | undefined;\n                    if (indent !== undefined) comment = parseTagComments(indent + scanner.getStartPos() - atToken.pos);\n                    const nestedTypeLiteral = parseNestedTypeLiteral(typeExpression, name, target);\n                    if (nestedTypeLiteral) {"
  },
  {
    "id" : "8768c59d-46bc-4fe3-bedc-04d6a236ae25",
    "prId" : 22967,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/22967#pullrequestreview-108115610",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a819b594-6ff4-4c57-8c29-6f9f3c0277bc",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "If we parsed an unexpected child we just drop it?",
        "createdAt" : "2018-03-29T15:08:23Z",
        "updatedAt" : "2018-03-29T15:08:23Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "66c2eac9-9fc8-40c7-bf23-ff885d590b52",
        "parentId" : "a819b594-6ff4-4c57-8c29-6f9f3c0277bc",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "The alternative that I thought was to break here, but it seems worse to pop up a level and start ignoring the prefixes the way we did before this PR.\r\n(You can see an example at the end of the test I added.)\r\n\r\nThis is consistent with our treatment of jsdoc elsewhere, although perhaps we should have an error like \"`@type` in the middle of a nested `@typedef` property\". I don't think this mistake will happen that often though.",
        "createdAt" : "2018-03-29T16:23:54Z",
        "updatedAt" : "2018-03-29T16:23:54Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "1e010c4ae482b610d31fa836ffa8d9421c145196",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +6520,6524 @@                        let children: JSDocPropertyLikeTag[];\n                        while (child = tryParse(() => parseChildParameterOrPropertyTag(target, name))) {\n                            if (child.kind === SyntaxKind.JSDocParameterTag || child.kind === SyntaxKind.JSDocPropertyTag) {\n                                children = append(children, child);\n                            }"
  },
  {
    "id" : "24e70f31-862c-45e4-99bf-7c83806e9d9e",
    "prId" : 22893,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/22893#pullrequestreview-107786368",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bd710212-4b59-4ebe-8476-99c97e633335",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "the two new lines are the two GetKeyword/SetKeyword cases. Everything else is a refactor to use `switch` instead of `if`.",
        "createdAt" : "2018-03-28T17:58:38Z",
        "updatedAt" : "2018-03-28T17:58:54Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf8f664d27227db6663b542b9ddd773ace4e77ce",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +1358,1362 @@                    return nextTokenCanFollowDefaultKeyword();\n                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                    nextToken();"
  },
  {
    "id" : "c6bad581-82e4-4c8e-a956-1b48acd84fe0",
    "prId" : 22167,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/22167#pullrequestreview-116461164",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7976a2c-59c7-4c02-86d6-003d547001ba",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I take it that we didn't parse top-level arrays, etc, in json files until this change?",
        "createdAt" : "2018-04-26T21:36:31Z",
        "updatedAt" : "2018-05-04T18:16:21Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "b9e8a560-be43-42e1-8fd3-c51cb2a2240b",
        "parentId" : "c7976a2c-59c7-4c02-86d6-003d547001ba",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Would it be easier to parseExpression and then have an error for expression kinds that are not legal? I don't think we're checking the contents of, say, parseObjectLiteralExpression either, so there's not actually much point in being strict here.",
        "createdAt" : "2018-04-26T21:37:57Z",
        "updatedAt" : "2018-05-04T18:16:21Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "71604f1c-50ea-481d-a658-8466720b8afe",
        "parentId" : "c7976a2c-59c7-4c02-86d6-003d547001ba",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "The issue in that is we dont do better job with incorrect object literal expression .Eg. There is already test (https://github.com/Microsoft/TypeScript/blob/master/src/harness/unittests/projectErrors.ts#L116) for ```\"files\": something}``` where in the first bracket is missing. We cant default to object literal which would be very likely the contents in json",
        "createdAt" : "2018-04-30T19:23:45Z",
        "updatedAt" : "2018-05-04T18:16:21Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "03b7f7b7-1ce2-427d-9704-af0cddee4c86",
        "parentId" : "c7976a2c-59c7-4c02-86d6-003d547001ba",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Oh, ok. I didn't realise that this approach gives better error recovery.",
        "createdAt" : "2018-04-30T22:40:58Z",
        "updatedAt" : "2018-05-04T18:16:21Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "c4143ae0c15acae0015f5aa00e8e2391ef156388",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +714,718 @@                const statement = createNode(SyntaxKind.ExpressionStatement) as JsonObjectExpressionStatement;\n                switch (token()) {\n                    case SyntaxKind.OpenBracketToken:\n                        statement.expression = parseArrayLiteralExpression();\n                        break;"
  },
  {
    "id" : "cbf45d6d-65a5-409b-977f-4168a61af5f3",
    "prId" : 21316,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/21316#pullrequestreview-90918958",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df875642-0f3e-47bb-83b7-3a3276195ec8",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "A better name is allowConditionalTypes",
        "createdAt" : "2018-01-23T16:06:01Z",
        "updatedAt" : "2018-02-03T16:41:41Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "b915be68-73c6-4034-a9ea-ffbfc49c1edd",
        "parentId" : "df875642-0f3e-47bb-83b7-3a3276195ec8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "That would force us to create yet another function that calls `parseTypeWorker(false)` so we can pass that to `doOutsideOfContext` above. Didn't want to do that.",
        "createdAt" : "2018-01-23T17:40:34Z",
        "updatedAt" : "2018-02-03T16:41:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "76b7dfc7-b4af-4faa-9ad7-b389c51428b1",
        "parentId" : "df875642-0f3e-47bb-83b7-3a3276195ec8",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "OK, I didn't know there was a parameterless usage of `parseTypeWorker`.",
        "createdAt" : "2018-01-23T17:50:19Z",
        "updatedAt" : "2018-02-03T16:41:41Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4dc67aab233f5a8834dff16531baf99b16fea78",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +2965,2969 @@        }\n\n        function parseTypeWorker(noConditionalTypes?: boolean): TypeNode {\n            if (isStartOfFunctionType()) {\n                return parseFunctionOrConstructorType(SyntaxKind.FunctionType);"
  },
  {
    "id" : "9fa0ce46-b806-4359-b890-1564a9f586b8",
    "prId" : 21316,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/21316#pullrequestreview-94121737",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0875f425-529c-47e5-9aa5-588f9c92201b",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Do we want to support conditional types in JSDoc for `// @ts-check` support?",
        "createdAt" : "2018-01-31T21:16:10Z",
        "updatedAt" : "2018-02-03T16:41:41Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "8338b84d-eca5-444a-b4e6-7d7160c1dd86",
        "parentId" : "0875f425-529c-47e5-9aa5-588f9c92201b",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We might consider that, but I'm not sure to what extent we want to permit JSDoc that is only understood type TypeScript.",
        "createdAt" : "2018-02-03T17:09:49Z",
        "updatedAt" : "2018-02-03T17:09:50Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "72441bd1-50c5-496d-8791-d6a9079d7942",
        "parentId" : "0875f425-529c-47e5-9aa5-588f9c92201b",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "We already support mapped and index types in jsdoc, right? Unless there's parse ambiguity, we should probably just continue exposing all type syntaxes in jsdoc.",
        "createdAt" : "2018-02-03T19:18:07Z",
        "updatedAt" : "2018-02-03T19:18:07Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "f3d45ad1-41e5-478b-a5d0-9f2d45043c73",
        "parentId" : "0875f425-529c-47e5-9aa5-588f9c92201b",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "In general, we want to support all Typescript types in JSDoc. The ideal is for eager Typescript users to be able to put Typescript types into jsdoc if they are stuck with vanilla javascript for some reason.\r\n\r\nHowever, I think there is a conflict between the ?-suffix of jsdoc and the ? of the conditional. For example, `S extends JSDocType? ? never : any` has both, but the parser will be unable to tell whether the first ? is a suffix  or part of the conditional syntax.\r\n\r\nI could be wrong, though! It’s really difficult to guess how the parser will behave without testing it.",
        "createdAt" : "2018-02-05T17:56:35Z",
        "updatedAt" : "2018-02-05T17:56:36Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "53772afd-dbca-4642-bd64-9241cf0ac301",
        "parentId" : "0875f425-529c-47e5-9aa5-588f9c92201b",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "We can always make the jsdoc postfix ? have a no-whitespace requirement and make the conditional ? have required whitespace in jsdoc to disambiguate, should it be ambiguous, yeah?",
        "createdAt" : "2018-02-05T18:01:27Z",
        "updatedAt" : "2018-02-05T18:01:27Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "55e7af82-fb9f-4ede-a037-8f9db24f58a9",
        "parentId" : "0875f425-529c-47e5-9aa5-588f9c92201b",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Or we can do speculative parsing to see whether we can parse it as a ConditionalType (e.g. try to parse a true branch) and then fall back to postfix-`?`",
        "createdAt" : "2018-02-05T19:55:49Z",
        "updatedAt" : "2018-02-05T19:55:49Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "d4dc67aab233f5a8834dff16531baf99b16fea78",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +2801,2805 @@                    case SyntaxKind.QuestionToken:\n                        // If not in JSDoc and next token is start of a type we have a conditional type\n                        if (!(contextFlags & NodeFlags.JSDoc) && lookAhead(nextTokenIsStartOfType)) {\n                            return type;\n                        }"
  },
  {
    "id" : "0421182e-3312-466d-a57b-4fb8a588556e",
    "prId" : 21119,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/21119#pullrequestreview-87945488",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2bbfc01-df4f-4ef9-bd81-24583cb94654",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "just to make sure I'm not missing something: This is the only line required to make the tests pass, right? The rest looks like refactoring.",
        "createdAt" : "2018-01-10T18:05:39Z",
        "updatedAt" : "2018-01-11T18:31:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "3bc0274a-a0c0-429e-b750-fa885eb0aed6",
        "parentId" : "c2bbfc01-df4f-4ef9-bd81-24583cb94654",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why isn't isn't indent needed to get the correct offset, like with the other call to parseTagComments? Does tryParseChildTag need to track indent?",
        "createdAt" : "2018-01-10T18:08:03Z",
        "updatedAt" : "2018-01-11T18:31:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "9d86d0e9-7083-442f-8448-a785db8f739d",
        "parentId" : "c2bbfc01-df4f-4ef9-bd81-24583cb94654",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "I needed to make a few other changes to `parser.ts` to avoid skipping the `@` token at the end of a comment and to use `undefined` instead of `\"\"` for the comment.",
        "createdAt" : "2018-01-10T19:04:30Z",
        "updatedAt" : "2018-01-11T18:31:30Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "e91a46d5-3bd8-4872-95dc-abeac1006ee4",
        "parentId" : "c2bbfc01-df4f-4ef9-bd81-24583cb94654",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "It looks like it will be needed to get the best comment text, that will be a bigger change though. Filed #21123",
        "createdAt" : "2018-01-10T19:05:08Z",
        "updatedAt" : "2018-01-11T18:31:30Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "28aa3f17a418bd92c3678cdc76045a9cfb52ad66",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +6840,6844 @@                    }\n                    const tag = parseParameterOrPropertyTag(atToken, tagName, target);\n                    tag.comment = parseTagComments(tag.end - tag.pos);\n                    return tag;\n                }"
  },
  {
    "id" : "77cabfb4-48b2-4d2e-bf39-f4133f1e7cd6",
    "prId" : 20706,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/20706#pullrequestreview-83938029",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe313c64-abe2-486e-ac52-5e337a2b0a5d",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why can't these be shared any more? Are there order conflicts in the current, shared version?",
        "createdAt" : "2017-12-15T18:13:54Z",
        "updatedAt" : "2017-12-15T22:17:12Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "c336433d-0baf-4644-b18f-35dd6474cd27",
        "parentId" : "fe313c64-abe2-486e-ac52-5e337a2b0a5d",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "The union won't allow access to properties that don't exist on every node. Also, this is less polymorphic, so should have slightly better performance.",
        "createdAt" : "2017-12-15T22:06:28Z",
        "updatedAt" : "2017-12-15T22:17:12Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "07c7c6d2e9b2459a7cf7e0a3ee12e12a4a34c339",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +91,95 @@                return visitNodes(cbNode, cbNodes, node.decorators) ||\n                    visitNodes(cbNode, cbNodes, node.modifiers) ||\n                    visitNode(cbNode, (<ParameterDeclaration>node).dotDotDotToken) ||\n                    visitNode(cbNode, (<ParameterDeclaration>node).name) ||\n                    visitNode(cbNode, (<ParameterDeclaration>node).questionToken) ||"
  },
  {
    "id" : "9af5f19d-a662-4b91-b326-45ed2198c64e",
    "prId" : 19249,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/19249#pullrequestreview-69968501",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2ade080e-0b7d-4289-8bf6-32612e57fea5",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Reading the spec, I don't see how we'd legally get into the `inExpressionContext = false` case since you can't write `<foo><><div /></></foo>`",
        "createdAt" : "2017-10-17T17:41:32Z",
        "updatedAt" : "2017-10-31T17:54:21Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "6c9472df-ed59-4b89-8934-639affe04266",
        "parentId" : "2ade080e-0b7d-4289-8bf6-32612e57fea5",
        "authorId" : "a954cad1-2428-49ae-ad5b-caef29f1f30c",
        "body" : "The spec changed, now you can.",
        "createdAt" : "2017-10-17T17:44:51Z",
        "updatedAt" : "2017-10-31T17:54:21Z",
        "lastEditedBy" : "a954cad1-2428-49ae-ad5b-caef29f1f30c",
        "tags" : [
        ]
      },
      {
        "id" : "482d1a4c-457a-49a6-9577-f8a36c47a00b",
        "parentId" : "2ade080e-0b7d-4289-8bf6-32612e57fea5",
        "authorId" : "a954cad1-2428-49ae-ad5b-caef29f1f30c",
        "body" : "https://github.com/facebook/jsx/pull/97",
        "createdAt" : "2017-10-17T17:45:15Z",
        "updatedAt" : "2017-10-31T17:54:21Z",
        "lastEditedBy" : "a954cad1-2428-49ae-ad5b-caef29f1f30c",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ebb2e8a34393cd15838e595ad8054126a8ff425",
    "line" : 131,
    "diffHunk" : "@@ -1,1 +4209,4213 @@        }\n\n        function parseJsxClosingFragment(inExpressionContext: boolean): JsxClosingFragment {\n            const node = <JsxClosingFragment>createNode(SyntaxKind.JsxClosingFragment);\n            parseExpected(SyntaxKind.LessThanSlashToken);"
  },
  {
    "id" : "49355775-a887-422e-b934-02128385ea84",
    "prId" : 17517,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17517#pullrequestreview-53885754",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5a76d84-a7ab-4214-ade0-06938e56d39e",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Conditionally setting `result.variableDeclaration` introduces polymorphism as we now have two `CatchClause` shapes, one with the property and one without. This can cause performance degradation in V8 (NodeJS). I would recommend you add an `else` clause that sets `result.variableDeclaration = undefined` to keep the shape of `CatchClause` the same regardless of which form the user writes.",
        "createdAt" : "2017-08-02T17:17:46Z",
        "updatedAt" : "2017-08-02T19:50:06Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "c698d1f7-9371-4139-9227-48875abb53f5",
        "parentId" : "b5a76d84-a7ab-4214-ade0-06938e56d39e",
        "authorId" : "3ae23f38-5f1a-4286-b485-a4c470edce21",
        "body" : "✔️ ",
        "createdAt" : "2017-08-02T18:13:10Z",
        "updatedAt" : "2017-08-02T19:50:06Z",
        "lastEditedBy" : "3ae23f38-5f1a-4286-b485-a4c470edce21",
        "tags" : [
        ]
      }
    ],
    "commit" : "3da1a53d7ec22a78346e373c9d5f887538a800d8",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +4781,4785 @@\n            if (parseOptional(SyntaxKind.OpenParenToken)) {\n                result.variableDeclaration = parseVariableDeclaration();\n                parseExpected(SyntaxKind.CloseParenToken);\n            }"
  },
  {
    "id" : "459a73fa-946f-4580-919b-4e87891ee0f0",
    "prId" : 17352,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17352#pullrequestreview-52128545",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96284200-3f27-4cf4-8638-8e49978652eb",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "It looks like `name` is a pointer to a node within `fullName`. So it would be visited twice if we were recursively calling `forEachChild`.",
        "createdAt" : "2017-07-24T22:04:04Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "c7687858-fbe4-4740-99fb-686cd412f508",
        "parentId" : "96284200-3f27-4cf4-8638-8e49978652eb",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Nice catch! I added `fullName` later and didn't notice that `name` needed to be removed.",
        "createdAt" : "2017-07-25T16:47:22Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "321ca47c-acd7-49b4-817b-389adbfb1674",
        "parentId" : "96284200-3f27-4cf4-8638-8e49978652eb",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Fixed",
        "createdAt" : "2017-07-25T16:56:26Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd90e7e023bac0646ac8ca9295f763ac22c8c4a",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +429,433 @@                return visitNodes(cbNode, cbNodes, (<JSDocTemplateTag>node).typeParameters);\n            case SyntaxKind.JSDocTypedefTag:\n                if ((node as JSDocTypedefTag).typeExpression &&\n                    (node as JSDocTypedefTag).typeExpression.kind === SyntaxKind.JSDocTypeExpression) {\n                    return visitNode(cbNode, (<JSDocTypedefTag>node).typeExpression) ||"
  },
  {
    "id" : "23c71e35-3a77-42be-a9b1-b72e8cf56e70",
    "prId" : 17352,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17352#pullrequestreview-52509116",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d27db2f-9619-4a37-a47f-e57cdced34c1",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "What happens to `child` in this case? We just drop it with no syntax error?",
        "createdAt" : "2017-07-25T17:00:12Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "a79a16ba-4236-4f6a-8219-1c23096ec643",
        "parentId" : "2d27db2f-9619-4a37-a47f-e57cdced34c1",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "I think this comment is still unaddressed?",
        "createdAt" : "2017-07-26T19:44:22Z",
        "updatedAt" : "2017-07-26T19:44:22Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "84826eb1-178e-454e-b34a-09561c42370e",
        "parentId" : "2d27db2f-9619-4a37-a47f-e57cdced34c1",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Yes. It happens in this case:\r\n\r\n```ts\r\n/**\r\n * @typedef Name\r\n * @type {string}\r\n * @type {Oops} - this is dropped and we stop parsing the @typedef\r\n */\r\n ```\r\n\r\nThis would be a grammar error if we did more thorough checking of jsdoc structure in the checker (along with a lot of other incorrect-but-allowed jsdoc). We don't, which is OK relative to what we used to provide. We should probably improve in the future if jsdoc becomes the source of types for significant, typed codebases.",
        "createdAt" : "2017-07-26T21:35:59Z",
        "updatedAt" : "2017-07-26T21:35:59Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "7f5e438a-5de0-4b9e-9dae-fb05c02d0644",
        "parentId" : "2d27db2f-9619-4a37-a47f-e57cdced34c1",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "OK, added #17442.",
        "createdAt" : "2017-07-26T21:55:20Z",
        "updatedAt" : "2017-07-26T21:55:20Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd90e7e023bac0646ac8ca9295f763ac22c8c4a",
    "line" : 222,
    "diffHunk" : "@@ -1,1 +6650,6654 @@                            if (child.kind === SyntaxKind.JSDocTypeTag) {\n                                if (alreadyHasTypeTag) {\n                                    break;\n                                }\n                                else {"
  },
  {
    "id" : "147c2dfd-eaa6-4174-aff7-0f828ca1bd20",
    "prId" : 17352,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17352#pullrequestreview-52129829",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1405dd86-fb42-4659-9d16-39523e958a5c",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "See earlier comment on casting to `MutableNodeArray`.",
        "createdAt" : "2017-07-25T17:01:05Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd90e7e023bac0646ac8ca9295f763ac22c8c4a",
    "line" : 231,
    "diffHunk" : "@@ -1,1 +6659,6663 @@                            else {\n                                if (!jsdocTypeLiteral.jsDocPropertyTags) {\n                                    jsdocTypeLiteral.jsDocPropertyTags = [] as MutableNodeArray<JSDocPropertyTag>;\n                                }\n                                (jsdocTypeLiteral.jsDocPropertyTags as MutableNodeArray<JSDocPropertyTag>).push(child);"
  },
  {
    "id" : "5a254607-2890-48f6-aa99-9e572b3e446c",
    "prId" : 17352,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17352#pullrequestreview-52411592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bffee20-2b7c-45af-80c9-dc7fba39f7e1",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "What are our performance guidelines on optionally vs unconditionally assigning to a property?",
        "createdAt" : "2017-07-25T17:02:02Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "2e0728b6-246f-4579-9c2f-5e5d1b152648",
        "parentId" : "5bffee20-2b7c-45af-80c9-dc7fba39f7e1",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I thought the standard for booleans was to declare them as `b?: boolean` and only assign them when needed. What difference in performance could arise? Conditional assignment saves space (but how much I don't know) versus unconditional assignment, which could be better for [de]optimisation. @rbuckton do you have an opinion?",
        "createdAt" : "2017-07-26T17:23:16Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd90e7e023bac0646ac8ca9295f763ac22c8c4a",
    "line" : 239,
    "diffHunk" : "@@ -1,1 +6665,6669 @@                        }\n                        if (jsdocTypeLiteral) {\n                            if (typeExpression && typeExpression.type.kind === SyntaxKind.ArrayType) {\n                                jsdocTypeLiteral.isArrayType = true;\n                            }"
  },
  {
    "id" : "f93328d1-d98e-409d-9dd8-b571dc8881cb",
    "prId" : 17352,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17352#pullrequestreview-52411592",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b56942fc-c80a-4809-83ba-8d1777c9e4aa",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Is the information about what tag name was used available in the AST? That might be useful for linting.",
        "createdAt" : "2017-07-25T17:13:10Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "7e0d3c89-7fdd-4181-8c5c-ba3060961959",
        "parentId" : "b56942fc-c80a-4809-83ba-8d1777c9e4aa",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Yes, `JSDocTag.tagName: Identifier`, so it looks like it's preserved on all JSDocTags.\r\n\r\nA more useful lint rule would be to look for mismatched `typedef/param and param/property` nestings, since the compiler currently ignores them:\r\n\r\n```js\r\n/**\r\n * @typedef {object} x\r\n * @param {string} x.a - WRONG! (but ignored by the compiler)\r\n *\r\n * @param {object} y\r\n * @property {string} y.a - WRONG! (but ignored by the compiler)\r\n */\r\n```",
        "createdAt" : "2017-07-26T17:42:40Z",
        "updatedAt" : "2017-07-26T18:09:42Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd90e7e023bac0646ac8ca9295f763ac22c8c4a",
    "line" : 387,
    "diffHunk" : "@@ -1,1 +6761,6765 @@                        case \"property\":\n                            return target === PropertyLikeParse.Property && parseParameterOrPropertyTag(atToken, tagName, target);\n                        case \"arg\":\n                        case \"argument\":\n                        case \"param\":"
  },
  {
    "id" : "68c549b1-fb48-47a7-9dac-172ee8d5c630",
    "prId" : 17352,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17352#pullrequestreview-52469935",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad07bd9c-8be1-4f4b-bb1a-9c09da9c0a79",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Can we `return false;` in the `default` case? It looks like if we keep encountering some other kind of token, we'll go all the way to the end of the file.",
        "createdAt" : "2017-07-26T18:17:56Z",
        "updatedAt" : "2017-07-26T18:17:56Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "183f9cec-0b93-4845-8cf0-b6f67b1be10d",
        "parentId" : "ad07bd9c-8be1-4f4b-bb1a-9c09da9c0a79",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Not really; we hit the default case a lot for punctuation and identifiers that we want to skip as part of the tag's description. \r\n\r\nNote that it's the end of the comment, not the end of the whole file. And we return false as soon as `tryParseChildTag` encounters any tag that is not `param`, `type` or `property`. So runaway parsing shouldn't be a big problem.\r\n\r\nAlso note: Comments aren't handled by this PR but once they are, `default` will probably look like `parseJSDocCommentWorker`, where it just pushes the token into a comment array.",
        "createdAt" : "2017-07-26T19:20:43Z",
        "updatedAt" : "2017-07-26T19:20:43Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "9fd90e7e023bac0646ac8ca9295f763ac22c8c4a",
    "line" : 324,
    "diffHunk" : "@@ -1,1 +6713,6717 @@                    while (true) {\n                        nextJSDocToken();\n                        switch (token()) {\n                            case SyntaxKind.AtToken:\n                                if (canParseTag) {"
  },
  {
    "id" : "fe2ccd38-8417-4bd0-aaea-80c49cf88933",
    "prId" : 17176,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17176#pullrequestreview-50168683",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5cd5bdc0-9562-4a4b-8e4f-d688d7dd89c6",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Move this next to (or into) `parseTypeOperatorOrHigher`.\r\nCan we parse `foo?[]` or `foo![]`? Could merge with `parseArrayTypeOrHigher` (also only called in one place).\r\nI took a stab at making this neater:\r\n```ts\r\nfunction parseJSDocPostfixTypeOrHigher(): TypeNode {\r\n    const type = parseArrayTypeOrHigher();\r\n    const kind = getKind(token());\r\n    if (!kind) return type;\r\n\r\n    const postfix = createNode(kind, type.pos) as JSDocOptionalType | JSDocNonNullableType | JSDocNullableType;\r\n    postfix.type = type;\r\n    return finishNode(postfix);\r\n\r\n    function getKind(tokenKind: SyntaxKind): SyntaxKind | undefined {\r\n        switch (tokenKind) {\r\n            case SyntaxKind.EqualsToken:\r\n                // only parse postfix = inside jsdoc, because it's ambiguous elsewhere\r\n                return contextFlags & NodeFlags.JSDoc ? SyntaxKind.JSDocOptionalType : undefined;\r\n            case SyntaxKind.ExclamationToken:\r\n                return SyntaxKind.JSDocNonNullableType;\r\n            case SyntaxKind.QuestionToken:\r\n                return SyntaxKind.JSDocNullableType;\r\n        }\r\n    }\r\n}\r\n```",
        "createdAt" : "2017-07-14T15:22:06Z",
        "updatedAt" : "2017-07-17T15:29:58Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "6a4c20a2-1a71-479c-997d-80c7e3ff04af",
        "parentId" : "5cd5bdc0-9562-4a4b-8e4f-d688d7dd89c6",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "1. No, `foo?[]` would need to parse inside parseArrayTypeOrHigher. That does seem like it should parse as `Array<foo | null>`.\r\n2. I don't think we should merge functions that would map to individual rules in a grammar.\r\n3. Thanks for the refactor.",
        "createdAt" : "2017-07-14T19:49:18Z",
        "updatedAt" : "2017-07-17T15:29:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "0f7f7b19-940f-4946-a8ef-c9161492a052",
        "parentId" : "5cd5bdc0-9562-4a4b-8e4f-d688d7dd89c6",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Seems like solving 1 would require ditching 2. If we want to be able to parse `foo?[]?[]!`, we would need to handle postfix types in a uniform way.",
        "createdAt" : "2017-07-14T22:53:10Z",
        "updatedAt" : "2017-07-17T15:29:58Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "68e70dee-97dc-474f-bc7c-96885fe36551",
        "parentId" : "5cd5bdc0-9562-4a4b-8e4f-d688d7dd89c6",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "So now I can type syntactically valid jsdoc types in place of swearing.",
        "createdAt" : "2017-07-14T22:54:03Z",
        "updatedAt" : "2017-07-17T15:29:58Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f60364a64de19a102b0b84f7dc32a48d7a3aace",
    "line" : 268,
    "diffHunk" : "@@ -1,1 +2693,2697 @@        }\n\n        function parseJSDocPostfixTypeOrHigher(): TypeNode {\n            const type = parseNonArrayType();\n            const kind = getKind(token());"
  },
  {
    "id" : "ab50fb6f-5de7-41e6-8296-0e5d170464df",
    "prId" : 17176,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/17176#pullrequestreview-50152228",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42280435-716a-41aa-ac6b-2df7d318647e",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "`node.kind === SyntaxKind.ObjectKeyword || isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.text === \"Object\";`",
        "createdAt" : "2017-07-14T15:40:02Z",
        "updatedAt" : "2017-07-17T15:29:58Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "04b4eb7d-e272-44ad-ba6f-15b700e536cd",
        "parentId" : "42280435-716a-41aa-ac6b-2df7d318647e",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Much better.",
        "createdAt" : "2017-07-14T21:08:09Z",
        "updatedAt" : "2017-07-17T15:29:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f60364a64de19a102b0b84f7dc32a48d7a3aace",
    "line" : 664,
    "diffHunk" : "@@ -1,1 +6583,6587 @@                    return finishNode(typedefTag);\n\n                    function isObjectTypeReference(node: TypeNode) {\n                        return node.kind === SyntaxKind.ObjectKeyword ||\n                            isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.text === \"Object\";"
  },
  {
    "id" : "44faa56b-c462-4a0a-9202-2f0926c612e3",
    "prId" : 16915,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/16915#pullrequestreview-48449866",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b95e328-a2b1-4dc7-b88d-9a8a6e2658e7",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "internIdentifier used to escape before interning. Now the code interns, then escapes. Is this correct?",
        "createdAt" : "2017-07-06T18:03:26Z",
        "updatedAt" : "2017-07-06T21:26:22Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "c2d33516-1c40-4aff-807f-b59f051cd761",
        "parentId" : "7b95e328-a2b1-4dc7-b88d-9a8a6e2658e7",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "This is correct for how we use the `identifiers` map the `internIdentifier` function uses (namely, looking for collisions in generated identifiers).",
        "createdAt" : "2017-07-06T20:11:53Z",
        "updatedAt" : "2017-07-06T21:26:22Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "5e6b69a6d8c6ebf8f78ccd7e700ef9e8daaa9412",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1203,1207 @@                    node.originalKeywordKind = token();\n                }\n                node.text = escapeLeadingUnderscores(internIdentifier(scanner.getTokenValue()));\n                nextToken();\n                return finishNode(node);"
  },
  {
    "id" : "ef986ecd-cd11-408e-b5bf-a6b9783364ea",
    "prId" : 15887,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/15887#pullrequestreview-38515520",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e199e450-cffc-432d-835d-784000d977ca",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "The callbacks should also return `T | undefined`.",
        "createdAt" : "2017-05-16T21:17:33Z",
        "updatedAt" : "2017-05-16T21:17:33Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "f40b6bf7c2f0e7e28d3555c3c417d42a647b21bd",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +51,55 @@    // embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns\n    // a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\n    export function forEachChild<T>(node: Node, cbNode: (node: Node) => T, cbNodeArray?: (nodes: Node[]) => T): T | undefined {\n        if (!node) {\n            return;"
  },
  {
    "id" : "dd7d8bf9-7bfa-4f71-840b-45283c27dc4f",
    "prId" : 14496,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/14496#pullrequestreview-28545276",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6b499fc-0322-441e-9d48-9775c4f80748",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I would recommend you pull this out of the function and remove the `g` option. `g` is only really useful if you want to preserve `lastIndex` when using a regular expression in a loop. Also I would remove the `m` option as it should be unnecessary. \r\n\r\nConsider this instead:\r\n```ts\r\nconst checkJsDirectiveRegEx = /^\\/\\/\\/?\\s*@ts-(no)?check\\s*$/i;\r\n...\r\nconst checkJsDirectiveMatchResult = checkJsDirectiveRegEx.exec(comment);\r\nif (checkJsDirectiveMatchResult) {\r\n  checkJsDirective = {\r\n    enabled: !!checkJsDirectiveMatchResult[1],\r\n    end: range.end,\r\n    pos: range.pos\r\n  };\r\n}\r\n```\r\n\r\nCapturing only the `no` allows you to avoid the additional case-insensitive string comparison. ",
        "createdAt" : "2017-03-23T00:25:39Z",
        "updatedAt" : "2017-03-28T04:38:25Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ea961714b6ecd7ecf285568ac3f1418bb203aaf",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +5886,5890 @@                    }\n\n                    const checkJsDirectiveRegEx = /^\\/\\/\\/?\\s*(@ts-check|@ts-nocheck)\\s*$/gim;\n                    const checkJsDirectiveMatchResult = checkJsDirectiveRegEx.exec(comment);\n                    if (checkJsDirectiveMatchResult) {"
  },
  {
    "id" : "4d580452-3d54-401f-ba11-8c37626e4a42",
    "prId" : 13487,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/13487#pullrequestreview-18020439",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "443a1768-9778-44ac-a92c-c11900b456e6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Nit: I would really like for if the parsing was order-agnostic for the purpose of error reporting, and then gave a grammar error later on. This could be done as a separate pass.",
        "createdAt" : "2017-01-23T20:46:10Z",
        "updatedAt" : "2017-02-15T03:19:35Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "23216f9ba14b70ac85492310cffb3b50601953e3",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +2106,2110 @@            if (parseOptional(SyntaxKind.EqualsToken)) {\n                node.default = parseType();\n            }\n\n            return finishNode(node);"
  },
  {
    "id" : "a4e0db0b-603f-4eed-a5d4-1bf80794d2c1",
    "prId" : 12386,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12386#pullrequestreview-9373268",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "488f27b6-0c2d-4d3b-8a3f-fd5dd5f49018",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "You need to also add `SyntaxKind.BarToken` and `SyntaxKind.AmpersandToken` to the `isStartOfType` function.\n",
        "createdAt" : "2016-11-19T23:30:28Z",
        "updatedAt" : "2016-11-20T21:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "ec9ef326-3ad8-465b-8b70-72031ff2813f",
        "parentId" : "488f27b6-0c2d-4d3b-8a3f-fd5dd5f49018",
        "authorId" : "9023bf83-db92-4cf0-93e8-b27a663150c1",
        "body" : "Done. Should I add another test for this?\n",
        "createdAt" : "2016-11-20T09:49:59Z",
        "updatedAt" : "2016-11-20T21:26:39Z",
        "lastEditedBy" : "9023bf83-db92-4cf0-93e8-b27a663150c1",
        "tags" : [
        ]
      },
      {
        "id" : "4cca97a9-2d08-4138-8ac5-4141d674c359",
        "parentId" : "488f27b6-0c2d-4d3b-8a3f-fd5dd5f49018",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Might be a good idea. For example, looking at where `isStartOfType` is called, we wouldn't properly handle a tuple type `[| 0 | 1, | \"foo\" | \"bar\"]` without this change, so maybe add a test for that.\n",
        "createdAt" : "2016-11-20T15:32:42Z",
        "updatedAt" : "2016-11-20T21:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "7b352c47-0f3f-4fbb-bd05-eece063f3f22",
        "parentId" : "488f27b6-0c2d-4d3b-8a3f-fd5dd5f49018",
        "authorId" : "9023bf83-db92-4cf0-93e8-b27a663150c1",
        "body" : "I agree. I've updated both test files.\n",
        "createdAt" : "2016-11-20T21:26:59Z",
        "updatedAt" : "2016-11-20T21:26:59Z",
        "lastEditedBy" : "9023bf83-db92-4cf0-93e8-b27a663150c1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d040db42f51593ee5695a6a24a3ae595ee8aec1d",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +2618,2622 @@\n        function parseUnionOrIntersectionType(kind: SyntaxKind, parseConstituentType: () => TypeNode, operator: SyntaxKind): TypeNode {\n            parseOptional(operator);\n            let type = parseConstituentType();\n            if (token() === operator) {"
  },
  {
    "id" : "d54b3783-fbb8-4261-bc98-72d410cf0dbb",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-43603959",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a14c880-02ea-4286-9aa6-03ebd0eb49a8",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "does this happen often? i am assuming this is to handle `[ \"compilerOptions\" : ...`, but do we need to ?",
        "createdAt" : "2017-01-27T23:31:37Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "09257d79-46c8-49f8-9974-0265a82feb2a",
        "parentId" : "9a14c880-02ea-4286-9aa6-03ebd0eb49a8",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "This is to handle one of the failing test case which was used to sanitize the tsconfig.json",
        "createdAt" : "2017-02-08T18:55:41Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "cbf8f585-3fb7-4a5c-81a5-4fb4044a248d",
        "parentId" : "9a14c880-02ea-4286-9aa6-03ebd0eb49a8",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Could you give a comment why we need a look ahead to be string literal? also would the the property is allow to be identifier since we use `parseObjectLiteralExpression` to parse the object?",
        "createdAt" : "2017-06-07T20:05:51Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "764efc73-191c-40ef-ace0-c0cc17c2d0ae",
        "parentId" : "9a14c880-02ea-4286-9aa6-03ebd0eb49a8",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "According to [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the key for the property of a JSON object must be a string literal.",
        "createdAt" : "2017-06-13T01:46:49Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +653,657 @@            }\n            else if (token() === SyntaxKind.OpenBraceToken ||\n                lookAhead(() => token() === SyntaxKind.StringLiteral)) {\n                result.jsonObject = parseObjectLiteralExpression();\n                sourceFile.endOfFileToken = parseExpectedToken(SyntaxKind.EndOfFileToken, /*reportAtCurrentPosition*/ false, Diagnostics.Unexpected_token);"
  },
  {
    "id" : "e8314819-eff7-41a1-8414-845104683894",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-42455503",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "29ef7dc6-f44c-4e45-968e-2014b0d6ec80",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Probably shouldn't use `createSourceFile`, since that initializes a lot of variables these will never use.",
        "createdAt" : "2017-06-06T21:46:58Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +644,648 @@            initializeState(sourceText, ScriptTarget.ES2015, /*syntaxCursor*/ undefined, ScriptKind.JSON);\n            // Set source file so that errors will be reported with this file name\n            sourceFile = createSourceFile(fileName, ScriptTarget.ES2015, ScriptKind.JSON);\n            const result = <JsonSourceFile>sourceFile;\n"
  },
  {
    "id" : "5f2f6f74-572a-4b30-8cb0-a39eb83b1c95",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-42455503",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78882cb2-46b2-4e6d-9032-10059514e964",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Be sure to use `result` instead of `sourceFile` in property assignments as it is correctly typed.",
        "createdAt" : "2017-06-06T21:47:14Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 31,
    "diffHunk" : "@@ -1,1 +645,649 @@            // Set source file so that errors will be reported with this file name\n            sourceFile = createSourceFile(fileName, ScriptTarget.ES2015, ScriptKind.JSON);\n            const result = <JsonSourceFile>sourceFile;\n\n            // Prime the scanner."
  },
  {
    "id" : "89df4e65-012f-405d-abca-1beb2b16d406",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-42455503",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc14f20b-c263-433b-81da-722a6f7214c2",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "Does this need an EndOfFileToken?",
        "createdAt" : "2017-06-06T21:47:36Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +650,654 @@            nextToken();\n            if (token() === SyntaxKind.EndOfFileToken) {\n                sourceFile.endOfFileToken = <EndOfFileToken>parseTokenNode();\n            }\n            else if (token() === SyntaxKind.OpenBraceToken ||"
  },
  {
    "id" : "c636a983-80b4-4232-ae66-676a41eff241",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-42713845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "43fee27e-41a2-41c4-916b-0329b81f11ae",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "JSON files can't contain JSX anyway.",
        "createdAt" : "2017-06-06T21:48:01Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "e8ffb5da-dfe7-48f8-ad32-b68582369687",
        "parentId" : "43fee27e-41a2-41c4-916b-0329b81f11ae",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Should we `LanguageVariant.JSX` be renamed ? since it is more than just TSX and JSX ",
        "createdAt" : "2017-06-07T20:07:58Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +668,672 @@        function getLanguageVariant(scriptKind: ScriptKind) {\n            // .tsx and .jsx files are treated as jsx language variant.\n            return scriptKind === ScriptKind.TSX || scriptKind === ScriptKind.JSX || scriptKind === ScriptKind.JS  || scriptKind === ScriptKind.JSON ? LanguageVariant.JSX : LanguageVariant.Standard;\n        }\n"
  },
  {
    "id" : "c07fd1e5-3477-42d5-8035-e50e6161b4b4",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-42713845",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1135797-d968-4077-8149-533209f06800",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "this comment probably should be removed",
        "createdAt" : "2017-06-07T20:06:50Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +667,671 @@\n        function getLanguageVariant(scriptKind: ScriptKind) {\n            // .tsx and .jsx files are treated as jsx language variant.\n            return scriptKind === ScriptKind.TSX || scriptKind === ScriptKind.JSX || scriptKind === ScriptKind.JS  || scriptKind === ScriptKind.JSON ? LanguageVariant.JSX : LanguageVariant.Standard;\n        }"
  },
  {
    "id" : "93bf5ed7-e985-4272-9401-8fc5163c4898",
    "prId" : 12336,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12336#pullrequestreview-43602010",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "917ce62d-cedc-4297-984a-f7ca96d879d5",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "If we are only planning on using this to parse _tsconfig.json_, then this is fine. If we are planning on using this to parse other JSON files, there are other legal root objects for a JSON file (e.g. Array Literals, string literals, numeric literals, `true`, `false`, and `null`).",
        "createdAt" : "2017-06-13T01:42:52Z",
        "updatedAt" : "2017-06-15T17:00:05Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "09f0b3471a84e5d4de844b1378f85f737d42ec21",
    "line" : 44,
    "diffHunk" : "@@ -1,1 +658,662 @@            }\n            else {\n                parseExpected(SyntaxKind.OpenBraceToken);\n            }\n"
  },
  {
    "id" : "43267337-689d-41cb-95bb-d58ada3e24f2",
    "prId" : 10671,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/10671#pullrequestreview-68624",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bf548a3-bb97-4045-a2ea-55566da98ae9",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Where'd 4 come from?\n",
        "createdAt" : "2016-09-14T22:59:09Z",
        "updatedAt" : "2016-09-15T18:54:47Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "5fb7e087-97fd-48f7-80fa-a76352fe007b",
        "parentId" : "2bf548a3-bb97-4045-a2ea-55566da98ae9",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Oh. That part is embarassing. `4 === '/** '.length`, basically. I should add a comment like the one on line 6179\n",
        "createdAt" : "2016-09-14T23:22:15Z",
        "updatedAt" : "2016-09-15T18:54:47Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8f244f68a58df0fc7e73857416ffb32e5cf5c1d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6182,6186 @@                    let margin: number | undefined = undefined;\n                    // + 4 for leading '/** '\n                    let indent = start - Math.max(content.lastIndexOf(\"\\n\", start), 0) + 4;\n                    function pushComment(text: string) {\n                        if (!margin) {"
  },
  {
    "id" : "1ece9f30-bf6c-4413-a1a2-fa98cfde9839",
    "prId" : 10270,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf2b823e-746b-453c-ad7d-343cb960db1c",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Could do `=== undefined` to avoid re-interning `\"\"`\n",
        "createdAt" : "2016-08-12T21:14:41Z",
        "updatedAt" : "2016-08-12T21:14:41Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "87393e026eacf038e596156d2f0537d24abfbda6",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1085,1089 @@        function internIdentifier(text: string): string {\n            text = escapeIdentifier(text);\n            return identifiers[text] || (identifiers[text] = text);\n        }\n"
  },
  {
    "id" : "8b5c0051-aa4c-4cd1-8445-166c845f90cd",
    "prId" : 9995,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d08e14cc-d686-40a9-911c-3493afab1d43",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "need `NeverKeyword` and `UndefinedKeyword` here too\n",
        "createdAt" : "2016-08-11T20:38:53Z",
        "updatedAt" : "2016-08-11T20:38:53Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "fec43289-7619-4311-89d3-9a34078effb1",
        "parentId" : "d08e14cc-d686-40a9-911c-3493afab1d43",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "and `NullKeyword` as well.\n",
        "createdAt" : "2016-08-16T22:48:42Z",
        "updatedAt" : "2016-08-16T22:48:42Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "ba11e5d1-b0dc-4d64-a51a-fe8fadfbcda2",
        "parentId" : "d08e14cc-d686-40a9-911c-3493afab1d43",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Actually, those are not literal types, it turns out. In the interests of getting this PR in, I'll do those separately.\n",
        "createdAt" : "2016-08-17T16:53:22Z",
        "updatedAt" : "2016-08-17T16:53:22Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "291ef424-3b4f-4945-89a0-2c852c021476",
        "parentId" : "d08e14cc-d686-40a9-911c-3493afab1d43",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "They probably need their own special handling (see the lines preceding the diff in checker)\n",
        "createdAt" : "2016-08-17T16:57:33Z",
        "updatedAt" : "2016-08-17T16:57:33Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "3c32478b8fd433b5bdf708b27aef04309a107a3d",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +5895,5899 @@                    case SyntaxKind.NumericLiteral:\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                        return parseJSDocLiteralType();\n                }"
  },
  {
    "id" : "f1ed3e1c-f70a-4412-ba4b-768a0568d1cc",
    "prId" : 8444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a997dc8-a35c-4473-82b1-45862a354d85",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "can you check first that  `token === SyntaxKind.AsyncKeyword`  before calling the function?\n",
        "createdAt" : "2016-05-05T00:21:42Z",
        "updatedAt" : "2016-05-05T00:21:42Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "059efc95-b197-44ff-b40c-e90341bfa7c2",
        "parentId" : "8a997dc8-a35c-4473-82b1-45862a354d85",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Sure. I just realize I should do that since `lookAhead` can be expensive\n",
        "createdAt" : "2016-05-05T00:44:03Z",
        "updatedAt" : "2016-05-05T00:44:03Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91e5d538bd70493a408d90e1d43bd528cc5db06f",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +2990,2994 @@\n        function tryParseAsyncSimpleArrowFunctionExpression(): ArrowFunction {\n            const isUnParenthesizedAsyncArrowFunction = lookAhead(isUnParenthesizedAsyncArrowFunctionWorker);\n            if (isUnParenthesizedAsyncArrowFunction === Tristate.True) {\n                const asyncModifier = parseModifiersForArrowFunction();"
  },
  {
    "id" : "c6113f57-9125-472e-a809-17458992d7f9",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "What's the new type annotation and `// !!!` comment for?\n",
        "createdAt" : "2016-04-11T17:30:13Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "58a53732-78da-4b6f-92ff-1f0fc3537cdf",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "b2e5e981-f1bc-47a6-9499-789a8e6f8b59",
        "body" : "Since `Entity` is a type alias of a union, it will be narrowed after its assignment. This creates a circular dependency during the type analysis. Because of this, `node` would be typed as `any` if the type annotation was not given.\n\n@ahejlsberg Would it be possible to give the inference of the type of the initializer precedence over the narrowing after assignments?\n",
        "createdAt" : "2016-04-11T19:40:43Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "b2e5e981-f1bc-47a6-9499-789a8e6f8b59",
        "tags" : [
        ]
      },
      {
        "id" : "224991d0-3864-4b04-8a88-e096be3468e3",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The exact problem here is the following: We infer the type of `node` from the call to `createNode`. To evaluate that call we need to know the type of `entity` so we can find the type of the `pos` property. To find the type of `entity` we look at the preceding code paths. One leads from the top of the function. In that code path, `entity` has type `Identifier`, which is less than its full declared type (`Identifier | QualifiedName`). Therefore we need to also analyze the second code path that comes from the bottom of the while statement (the loop around case). In that code path, we have the assignment `entity = finishNode(node)` which requires us to know the type of `node`. Boom! Circularity. Not exactly clear what rule we'd introduce to break that circularity.\n",
        "createdAt" : "2016-04-11T21:00:06Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "e4082033-9bba-48f1-8a1b-e1fbcbe272ef",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Would just assuming that `entity` has its original declared type be good enough?\n",
        "createdAt" : "2016-04-12T07:25:09Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b7e655f6-a2ac-433a-a521-eda28f649ee2",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "One other idea is that while doing the analysis, if you hit a type assertion, ignore the RHS, and just use the type associated with the type assertion.\n",
        "createdAt" : "2016-04-12T07:46:31Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "c65c1bb8-466f-49bd-a751-492ef8c16b6d",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "@DanielRosenwasser But by exactly what mechanism would we sometimes just use the declared type and other times compute the narrowed type?\n\n@JsonFreeman Yes, but we'd then have to introduce a distinction between _resolving_ the type of an expression (in which case we could defer and ignore the RHS) and _checking_ the type of an expression. We don't have such a distinction currently.\n",
        "createdAt" : "2016-04-12T14:06:39Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "31e5a1e6-0653-4ada-9815-32a4c9ac091a",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "@ahejlsberg - this doesn't seem circular to me, it seems sequential. I'm imagining if the first iteration of the loop were unrolled - don't we just need to take the partially resolved type for entity from the first iteration and use it as input for the type of entity for the second iteration? Once you've reached a stable signature (or cycle of signatures) by this method of loop-unrolling, you'd just need the union of all types made in each iteration for the overall type at that location, no?\n",
        "createdAt" : "2016-04-12T17:00:34Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "75e274e9-44a3-4d23-ac23-3a5a2358586d",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "@weswigham Yes, but the compiler is by and large constructed with the assumption that once we compute a symbol's _declared_ type, that type can and will be cached and never changes. However, to do what you suggest we'd have to compute a new declared type for the `node` symbol in each iteration because `entity` depends on `node`, which depends on `entity`, etc. We're simply not equipped to do that currently.\n",
        "createdAt" : "2016-04-12T17:20:36Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "fa0d75e5-8fce-4c29-8917-1452ec885463",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think the problem of circularities isn't new, this is just a new instance of it. We've looked at this in the past with regard to inferring types of symbols that recursively reference themselves. For these cases, I believe we decided that it's sometimes helpful to resolve an expression without fully diving into it. But it was a challenge to formalize and implement. I think this boils down to the same thing.\n",
        "createdAt" : "2016-04-12T20:45:41Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "4b126936-f20e-47fe-9070-32ed7d78dde6",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Just to make the issue into a concrete, self-contained test, I'll drop this here:\n\n``` ts\ninterface First {first: 'first'}\ninterface Second {second: 'second'}\ninterface Third {third: 'third'}\n\ndeclare function next(obj: Third): undefined;\ndeclare function next(obj: Second): Third;\ndeclare function next(obj: First): Second;\n\ndeclare function isThird(x: any): x is Third;\n\nvar x: First | Second | Third;\nx = {first: 'first'};\nx.first;\nwhile (true) {\n    x = next(x);\n    x.second; // Should be forbidden (x is Third in the second iteration), but is allowed\n    if (isThird(x)) {\n        break;\n    }\n}\n\nx.third; // Should be allowed (loop always exits when x is Third), but is forbidden\n```\n\nEven if we don't _fix_ the issue, the current behavior can be awkward. (`x` ends up typed as `Second` after the loop, which is very incorrect, given it will _never_ be `Second` at that point.)\n",
        "createdAt" : "2016-04-13T05:13:42Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "a42f28e9-7648-4644-9e80-aecbd4c176c8",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "@weswigham good example! I think even if it the system is not always correct, it's better if it is conservative. So in your example, I could envision an acceptable solution where at the two property accesses, `x` is of type `Second | Third`. That way the implementation could get to a point where it is always either correct, or is too conservative because of a reassignment in a loop. And then loops could be fixed up later while people try out the feature.\n",
        "createdAt" : "2016-04-13T06:18:05Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "de0e88ca-69da-4bf1-9065-424136b0b372",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "@JsonFreeman we can't be too conservative, though - for example, in my example above, if I omitted \n\n``` ts\n    if (isThird(x)) {\n        break;\n    }\n```\n\nfrom the while loop, then `next(x)` could return `undefined` (as `x` could be `Three` at the start of the loop) - which isn't assignable to `x` under strict null mode - which should cause an error within the loop! Making it non-cumbersome to use overloads like this could be difficult without a complete fix for the issue.\n",
        "createdAt" : "2016-04-13T06:41:10Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "b0246971-050e-40fd-80d3-f16c31572018",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes that's a good point. It's not a simple matter of using the declared type. But I think the overloaded `next` function wouldn't even accept a union type as an argument.\n",
        "createdAt" : "2016-04-13T06:46:03Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "500a05be-25fc-4f1e-b859-ab3ee9d1bee7",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "No, it wouldn't with how TS resolves signatures at present - at least not without another signature declaring it as taking a parameter of type `any` or a union of the other types. (Which, for some reason feels off to me - if every member of a union of argument types can be fulfilled by an overload and there's no better match, why can't the return be the union of those overloads' return values? Question for another time.)\n",
        "createdAt" : "2016-04-13T06:56:12Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "d7a75763-dcf8-4bc6-b3a7-379a42865e7d",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "(Answer for another time ;)\n",
        "createdAt" : "2016-04-13T06:58:13Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "feeca37b-85a8-439b-9ac6-fff129b2a15e",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "@weswigham @JsonFreeman There are actually several issues being debated here:\n- Circularities occurring because we're more eager than we need to when _resolving_ (as opposed to _checking_) the type of an expression. As Jason points out, that's not a new issue. We could make progress on this issue by making a distinction between _resolving_ and _checking_ an expression, and only evaluate as much as we need to when resolving. Indeed, we could solve the actual cases in the compiler by doing this for type assertion expressions.\n- Inability for symbols to have evolving _declared_ types. This one is much harder. I really don't want to go there unless we absolutely have to.\n- Compute _narrowed_ types by iterating to a fixed point. We only do this in limited form today and, as Wes' example shows, we may need to do more here. I'm not super concerned with crazy examples that walk up a ladder of overloads, but I can indeed imagine real world examples where it occurs without overloading. Although I haven't actually seen any in the wild yet. I will continue to think about this issue.\n",
        "createdAt" : "2016-04-13T16:52:17Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "dd899b44-9a7f-410f-af4d-d02b4008578c",
        "parentId" : "ea5fe484-2575-4772-b3e5-421fd3d24709",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Thanks Anders, I think that's a great breakdown. I'll add that (if I'm not mistaken), this separation of resolution and checking _is_ in place for bodies of function expressions. The idea here would be to generalize it for other expressions.\n\nI agree that iterating to a fixed point may be necessary for loops in which the variable is reassigned in the loop body.\n",
        "createdAt" : "2016-04-13T19:24:56Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1812,1816 @@            let entity: EntityName = parseIdentifier(diagnosticMessage);\n            while (parseOptional(SyntaxKind.DotToken)) {\n                const node: QualifiedName = <QualifiedName>createNode(SyntaxKind.QualifiedName, entity.pos);  // !!!\n                node.left = entity;\n                node.right = parseRightSideOfDot(allowReservedWords);"
  },
  {
    "id" : "b9b9d746-7ea3-4e95-a372-d2200d291645",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef45e87b-bc82-46d2-b948-613d43c6b54a",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Same comment as above:\n\n> What's the new type annotation and `// !!!` comment for?\n",
        "createdAt" : "2016-04-11T17:30:37Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "5b028d7a-5c56-4a3f-860b-a7b0307c6cb6",
        "parentId" : "ef45e87b-bc82-46d2-b948-613d43c6b54a",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Same issue.\n",
        "createdAt" : "2016-04-11T21:01:06Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +3644,3648 @@            while (parseOptional(SyntaxKind.DotToken)) {\n                scanJsxIdentifier();\n                const node: QualifiedName = <QualifiedName>createNode(SyntaxKind.QualifiedName, elementName.pos);  // !!!\n                node.left = elementName;\n                node.right = parseIdentifierName();"
  },
  {
    "id" : "30ef8c98-3039-47db-b6ac-cb53ad478e52",
    "prId" : 6870,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e823ccc4-13b5-4693-beab-9f91e9ed4147",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "I notice this function returns early if `tryParseAccessorDeclaration` is successful (or via `parseMethodDeclaration`@3943). Do we handle those cases, such as getters/setters? (Good tests to add also).\n",
        "createdAt" : "2016-02-03T17:37:04Z",
        "updatedAt" : "2016-02-03T17:37:04Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c7062313d2dde764ea7f7d20f2415b02d8d6fbb",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3961,3965 @@                    shorthandDeclaration.objectAssignmentInitializer = allowInAnd(parseAssignmentExpressionOrHigher);\n                }\n                return addJSDocComment(finishNode(shorthandDeclaration));\n            }\n            else {"
  },
  {
    "id" : "e79a8f05-b685-4d58-9377-6c0358eff68b",
    "prId" : 6851,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49e57c36-ffde-498c-91c8-d8ded2d2166d",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "Is this logic structured correctly to handle generic types in a namespace (e.g. `@type {JQueryStatic.promise<string>}`)? An interesting test to add anyway.\n",
        "createdAt" : "2016-02-02T21:58:24Z",
        "updatedAt" : "2016-02-04T18:14:57Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "c2d289a6-35f6-42ea-855d-8dfad16fedcf",
        "parentId" : "49e57c36-ffde-498c-91c8-d8ded2d2166d",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Yep\n",
        "createdAt" : "2016-02-04T18:15:21Z",
        "updatedAt" : "2016-02-04T18:15:21Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "e347c3711cc4b85eda34f1aba844e1a6576ff40c",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +5739,5743 @@                }\n                else {\n                    while (parseOptional(SyntaxKind.DotToken)) {\n                        if (token === SyntaxKind.LessThanToken) {\n                            result.typeArguments = parseTypeArguments();"
  },
  {
    "id" : "53caa48d-863c-4385-824e-725383bdcf6b",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20247979-07ed-435e-9cc6-a50cff0af162",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "So if there's more than one JSDoc comment, the last one wins?\n",
        "createdAt" : "2015-12-16T17:18:07Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4aba2a21-16a6-40fd-9ca4-bd420f82b6c8",
        "parentId" : "20247979-07ed-435e-9cc6-a50cff0af162",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Yes, that's intentional.\n\nIt's likely to see things like this\n\n``` ts\n/** This is a comment for a commented-out function\n  * @param foo\n  */\n/* function removedTemp(foo) {\n ...\n}\n*/\n/** This is the real JSDoc Comment\n  * @param foo\n  */\nfunction realFunc(foo) { ... }\n```\n\nor this\n\n``` ts\n/** This is just a general comment that applies to the whole file\n  * @summary You can use this file for neat things\n  */\n/** And here's a function\n  * @summary Don't call this\n  */\nfunction fn() { ... }\n```\n",
        "createdAt" : "2015-12-16T19:24:13Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +623,627 @@                        const jsDocComment = JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos);\n                        if (jsDocComment) {\n                            node.jsDocComment = jsDocComment;\n                        }\n                    }"
  },
  {
    "id" : "111d4d50-ad66-4240-8afb-2af7d4872f1a",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e80af053-0c2a-4064-bc7b-053f57f6f042",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "There are several calls to 'fixupParentReferences` from within the JSDoc parser, but only the above call is necessary because JSDoc comments are no longer parsed after the main pass.\n",
        "createdAt" : "2015-12-16T21:37:12Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4c544b85-28b1-445d-8f62-b114b808c284",
        "parentId" : "e80af053-0c2a-4064-bc7b-053f57f6f042",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "One of them was needed and one wasn't -- removed the unneeded one\n",
        "createdAt" : "2016-01-06T18:48:05Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +609,613 @@\n            if (setParentNodes) {\n                fixupParentReferences(sourceFile);\n            }\n"
  },
  {
    "id" : "bdd7074c-d2aa-4b2b-8218-b6673b4970a9",
    "prId" : 5561,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d4ac22a-8eee-4d8f-964b-394b817687d9",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Replace this with:\n\n``` typescript\nconst Node = objectAllocator.getNodeConstructor();\n\nexport function createNode(kind: SyntaxKind, pos?: number, end?: number): Node {\n    return new Node(kind, pos, end);\n}\n```\n",
        "createdAt" : "2015-11-07T16:27:32Z",
        "updatedAt" : "2015-11-07T23:28:46Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f1596bba7e61df6a48a6a445d89245cdef45786",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8,12 @@    let SourceFileConstructor: new (kind: SyntaxKind, pos: number, end: number) => Node;\n\n    export function createNode(kind: SyntaxKind, pos?: number, end?: number): Node {\n        if (kind === SyntaxKind.SourceFile) {\n            return new (SourceFileConstructor || (SourceFileConstructor = objectAllocator.getSourceFileConstructor()))(kind, pos, end);"
  },
  {
    "id" : "9127ab9b-515b-414a-a070-ccc4ceff3d60",
    "prId" : 5559,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66e88134-d807-4997-a304-db476e0293a5",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "So we have nextTokenIsOnSameLineAndCanFollowModifier and nextTokenCanFollowModifier...\n\nThese are supremely easy to confuse.  When would i want one, versus the other?\n",
        "createdAt" : "2015-11-10T19:49:38Z",
        "updatedAt" : "2015-12-04T08:21:16Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "776211d2-7671-4996-b325-89151b5eab45",
        "parentId" : "66e88134-d807-4997-a304-db476e0293a5",
        "authorId" : "fc69c3b5-172f-457e-aa77-cda1ebd0cd76",
        "body" : "It was `nextTokenCanFollowModifierWithoutGrammarRules` before. It seemed more clear to me. Basically, I just need `nextTokenCanFollowModifier` without the leading checks. I can think of several solutions here:\n1. Inline `nextTokenIsOnSameLineAndCanFollowModifier` to `parseModifiers` (It leads to code duplication).\n2. Rename `nextTokenIsOnSameLineAndCanFollowModifier` and use it in `nextTokenCanFollowModifier` as now.\n3. Somehow pass a flag to `tryParse`. It seems like a big change because `tryParse` is a generic function that is used everywhere.\n\nThe option 2 seems reasonable overall.\n",
        "createdAt" : "2015-11-10T20:41:29Z",
        "updatedAt" : "2015-12-04T08:21:16Z",
        "lastEditedBy" : "fc69c3b5-172f-457e-aa77-cda1ebd0cd76",
        "tags" : [
        ]
      },
      {
        "id" : "d1ebf895-1f94-4d6b-8b5f-f66ee9f9d7ee",
        "parentId" : "66e88134-d807-4997-a304-db476e0293a5",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "But why do some people needs checks, and others do not?  That's the part I find confusing.  How would I know from my code?  \n",
        "createdAt" : "2015-11-11T22:31:59Z",
        "updatedAt" : "2015-12-04T08:21:16Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b7dfedae-2461-4f55-be49-870dbb13a457",
        "parentId" : "66e88134-d807-4997-a304-db476e0293a5",
        "authorId" : "fc69c3b5-172f-457e-aa77-cda1ebd0cd76",
        "body" : "Well, to be frank, I don't know why the if statements with `SyntaxKind` in the following code are not a part of `checker.ts` file:\n\n```\n        function nextTokenCanFollowModifier() {\n            if (token === SyntaxKind.ConstKeyword) {\n                // 'const' is only a modifier if followed by 'enum'.\n                return nextToken() === SyntaxKind.EnumKeyword;\n            }\n            if (token === SyntaxKind.ExportKeyword) {\n                nextToken();\n                if (token === SyntaxKind.DefaultKeyword) {\n                    return lookAhead(nextTokenIsClassOrFunction);\n                }\n                return token !== SyntaxKind.AsteriskToken && token !== SyntaxKind.OpenBraceToken && canFollowModifier();\n            }\n            if (token === SyntaxKind.DefaultKeyword) {\n                return nextTokenIsClassOrFunction();\n            }\n            if (token === SyntaxKind.StaticKeyword) {\n                nextToken();\n                return canFollowModifier();\n            }\n\n            nextToken();\n            if (scanner.hasPrecedingLineBreak()) {\n                return false;\n            }\n            return canFollowModifier();\n        }\n```\n\nThat way, one would always have all modifiers for a property or a class (possibly something else?) and they would be checked in `checker.ts` if they are correct. Then there would be no need for special handling of `const` which now seems a bit like a hack. But maybe I'm missing something because I don't know have deep knowledge of the compiler.\n",
        "createdAt" : "2015-11-12T16:37:40Z",
        "updatedAt" : "2015-12-04T08:21:16Z",
        "lastEditedBy" : "fc69c3b5-172f-457e-aa77-cda1ebd0cd76",
        "tags" : [
        ]
      },
      {
        "id" : "f7d249f7-7aca-46d4-9cf8-6be6577a4986",
        "parentId" : "66e88134-d807-4997-a304-db476e0293a5",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I think what Cyrus is sort of getting at is that more than anything else, you should be prescriptive and document why this function exists and where it should be used.\n",
        "createdAt" : "2015-11-18T09:09:32Z",
        "updatedAt" : "2015-12-04T08:21:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f15fe5b335aacc1364fc6bf111dfba0f52b3d14b",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1135,1139 @@        }\n\n        function nextTokenIsOnSameLineAndCanFollowModifier() {\n            nextToken();\n            if (scanner.hasPrecedingLineBreak()) {"
  },
  {
    "id" : "35b10362-ba6e-4b00-a427-d66cda49fb70",
    "prId" : 5559,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bb7cae86-e21b-430a-8d61-bc765c0677ca",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Add a comment above:\n\n``` ts\n// We need to ensure that any subsequent modifiers appear on the same line\n// so that when 'const' is a standalone declaration, we don't issue an error.\n```\n",
        "createdAt" : "2015-11-18T09:19:16Z",
        "updatedAt" : "2015-12-04T08:21:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "f15fe5b335aacc1364fc6bf111dfba0f52b3d14b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4945,4949 @@                    // We need to ensure that any subsequent modifiers appear on the same line\n                    // so that when 'const' is a standalone declaration, we don't issue an error.                \n                    if (!tryParse(nextTokenIsOnSameLineAndCanFollowModifier)) {\n                        break;\n                    }"
  },
  {
    "id" : "42646f31-581a-4cd6-9fca-15259c99d464",
    "prId" : 5185,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b150e6c2-1500-45c6-aa90-bbe291597e50",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Not sure we'd need to do this - strings types aren't directly valid [jsdoc types](https://developers.google.com/closure/compiler/docs/js-for-compiler#types). They'd have to be wrapped up inside an enum, 'a la:\n\n``` js\n/**\n* @enum\n*/\nvar MyEnum = {\n  Member: \"Member\"\n}\n\n/**\n* @param {MyEnum} param\n*/\nfunction foo(param) {\n\n}\n```\n\nSo literal string types should never appear in JSDoc comments, since nothing really supports them.\n",
        "createdAt" : "2015-11-09T20:07:28Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea4e21d96914783c66563850eda52e0aafb7fb9b",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +5618,5622 @@                }\n\n                // TODO (drosen): Parse string literal types in JSDoc as well.\n                return parseJSDocTypeReference();\n            }"
  },
  {
    "id" : "776f27d5-de8c-427b-a161-1eab03603193",
    "prId" : 4914,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4617f4bc-7501-4695-b39d-f3a419b03ae7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "greater\n",
        "createdAt" : "2015-09-29T07:27:58Z",
        "updatedAt" : "2015-10-12T23:14:43Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "90258794a6cfd42b4da7f8f4abbc2c381c285e05",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3038,3042 @@                // - For right associative operator (**), consume the operator, recursively call the function\n                //   and parse binaryExpression as a rightOperand of the caller if the new precendence of\n                //   the operator is strictly grater than the current precendence\n                //   For example:\n                //      a ** b ** c;"
  },
  {
    "id" : "23e4e2c5-d000-4007-92fa-fbf30c287d0b",
    "prId" : 4914,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a79b9665-0b31-4210-9075-2a0c78897c0f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Great comment, this is a very useful visual aid. :D\n",
        "createdAt" : "2015-09-29T07:29:28Z",
        "updatedAt" : "2015-10-12T23:14:43Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "90258794a6cfd42b4da7f8f4abbc2c381c285e05",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +3045,3049 @@                //            ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand\n                //      a ** b - c\n                //             ^token; leftOperand = b. Return b to the caller as a rightOperand\n                const consumeCurrentOperator = token === SyntaxKind.AsteriskAsteriskToken ?\n                    newPrecedence >= precedence :"
  },
  {
    "id" : "aa1a07e9-9308-4692-9747-6f77efe25f9f",
    "prId" : 4494,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00373def-3da1-4819-b62a-6ca9ea164836",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you add a comment above here:\n\n``` TypeScript\n// If we are parsing a dotted namespace name, we want to\n// propagate the 'Namespace' flag across the names if set.\n```\n",
        "createdAt" : "2015-08-27T17:48:01Z",
        "updatedAt" : "2015-08-27T18:04:05Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4db535d9497d4edffbbe840473c704c71ba0fc50",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4944,4948 @@            // If we are parsing a dotted namespace name, we want to\n            // propagate the 'Namespace' flag across the names if set.\n            let namespaceFlag = flags & NodeFlags.Namespace;\n            node.decorators = decorators;\n            setModifiers(node, modifiers);"
  },
  {
    "id" : "96fa63b6-b2ab-4520-90ff-7bdd010d5c48",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f3713ad-bb14-407e-8237-ff2a495efd93",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Nice reuse!\n",
        "createdAt" : "2015-06-30T18:26:17Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +2403,2407 @@        }\n\n        function parseUnionOrIntersectionType(kind: SyntaxKind, parseConstituentType: () => TypeNode, operator: SyntaxKind): TypeNode {\n            let type = parseConstituentType();\n            if (token === operator) {"
  },
  {
    "id" : "eed578f7-ecd8-4fea-aca4-b8bf9c66464e",
    "prId" : 3534,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69a046d7-62a5-42c3-bf0e-7dcde6460214",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i do not really care for this check, `\";\" expected` or `identifier expected` do not seem too bad in such an obscure error case.\n",
        "createdAt" : "2015-06-24T00:58:20Z",
        "updatedAt" : "2015-06-24T15:22:08Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "8ae53a43102ec9b1301ffd8cf8cae0ec18ae203d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1846,1850 @@                    node.flags |= NodeFlags.OctalLiteral;\n                }\n                else if (token === SyntaxKind.Identifier && sourceText.charCodeAt(node.end-1) === CharacterCodes.dot) {\n                    nextCharCode = sourceText.charCodeAt(node.end);\n                    if (!isWhiteSpace(nextCharCode) && !isLineBreak(nextCharCode)) {"
  },
  {
    "id" : "4c477156-42b8-4377-b4de-ab06a4ba1d25",
    "prId" : 3517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f651f5c7-8526-4dab-80e2-20bbc4d76338",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Add a test for this if you haven't already.\n",
        "createdAt" : "2015-06-16T04:39:19Z",
        "updatedAt" : "2015-06-16T06:32:12Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "300089ce2dcf7847bfc6baf9f6d98d09f835ce3a",
    "line" : 223,
    "diffHunk" : "@@ -1,1 +3888,3892 @@            // In ES6 'let' always starts a lexical declaration if followed by an identifier or { \n            // or [.\n            return lookAhead(nextTokenIsIdentifierOrStartOfDestructuring);\n        }\n"
  },
  {
    "id" : "bc8e5546-4cda-4f2d-9432-5cea85f79aab",
    "prId" : 3517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c1190dc5-a4d4-46da-b99f-4d897761e09f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Update comment above.\n",
        "createdAt" : "2015-06-16T04:43:32Z",
        "updatedAt" : "2015-06-16T06:32:12Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "2359153f-4522-435d-9463-c0bbde1521a3",
        "parentId" : "c1190dc5-a4d4-46da-b99f-4d897761e09f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What about\n\n``` ts\nfor (yield of foo) { }\n```\n\nDo we do the right thing here? Same question for `yield instanceOf foo` and `yield in foo`. Does yield have low enough precedence to not even get here?\n",
        "createdAt" : "2015-06-16T04:48:34Z",
        "updatedAt" : "2015-06-16T06:32:12Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "03dbf468-1de2-4721-9712-60fef7a05870",
        "parentId" : "c1190dc5-a4d4-46da-b99f-4d897761e09f",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Those are good points.  Will investigate.  Thanks!\n",
        "createdAt" : "2015-06-16T06:22:23Z",
        "updatedAt" : "2015-06-16T06:32:12Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "300089ce2dcf7847bfc6baf9f6d98d09f835ce3a",
    "line" : 114,
    "diffHunk" : "@@ -1,1 +2627,2631 @@                // can be added here later as necessary.  We just need to make sure that we\n                // don't accidently consume something legal.\n                return lookAhead(nextTokenIsIdentifierOrKeywordOrNumberOnSameLine);\n            }\n"
  },
  {
    "id" : "8f4d449f-ce16-4b08-bb0d-7f2a549e3efc",
    "prId" : 3461,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b266243-7e2f-4f18-b944-b64a008b9abd",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "update the comment.  \n",
        "createdAt" : "2015-06-11T00:05:24Z",
        "updatedAt" : "2015-06-11T00:20:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "745239d9-fe01-442a-b1d0-00e381106541",
        "parentId" : "8b266243-7e2f-4f18-b944-b64a008b9abd",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Fixed.\n",
        "createdAt" : "2015-06-11T00:18:52Z",
        "updatedAt" : "2015-06-11T00:20:58Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "380918c4978610ccb9b20c619d7e25ecd8be0e97",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1790,1794 @@            // In the first case though, ASI will not take effect because there is not a\n            // line terminator after the identifier or keyword.\n            if (scanner.hasPrecedingLineBreak() && isIdentifierOrKeyword()) {\n                let matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);\n"
  },
  {
    "id" : "778bfb9a-96a1-4c6e-b5eb-99e7d2f6bc58",
    "prId" : 3291,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "62fe41a8-17cf-491e-84ef-85e2eb4fdae8",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "when is this set to true? debugging? can you put a comment.\n",
        "createdAt" : "2015-05-28T19:22:12Z",
        "updatedAt" : "2015-05-28T19:22:26Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "6b10efab-0935-49d2-9c14-f0c7eaa93d8c",
        "parentId" : "62fe41a8-17cf-491e-84ef-85e2eb4fdae8",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "This has been removed.  It was only for ascertaining what we could'nt handle on code in the wild.\n",
        "createdAt" : "2015-05-28T21:51:07Z",
        "updatedAt" : "2015-05-28T21:51:07Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "9aab98419b5f8cb54cdcb781854292aa722ee08a",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +3,7 @@\nmodule ts {\n    export var throwOnJSDocErrors = false;\n\n    let nodeConstructors = new Array<new () => Node>(SyntaxKind.Count);"
  },
  {
    "id" : "d6f04318-1b01-41f2-a0c1-549cd074a669",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f540b060-82f6-47ea-830e-42ef3ad756f5",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "parenthesize for clarity.\n",
        "createdAt" : "2015-05-26T22:15:49Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "8b28bafa-6ad1-4ebc-8462-9cf5d7c17b59",
        "parentId" : "f540b060-82f6-47ea-830e-42ef3ad756f5",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No need.\n",
        "createdAt" : "2015-05-26T22:35:06Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3822,3826 @@                    case SyntaxKind.ImportKeyword:\n                        nextToken();\n                        return token === SyntaxKind.StringLiteral || token === SyntaxKind.AsteriskToken ||\n                            token === SyntaxKind.OpenBraceToken || isIdentifierOrKeyword() ?\n                            StatementFlags.ModuleElement : StatementFlags.None;"
  },
  {
    "id" : "ae1aff2f-bcb6-41c5-aece-7ad4fb8b1e03",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fbfd1cd-f846-4ee9-aa49-845f09cbdc10",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "This is very confusing to read.  Can you extract out a helper function and comment how this works.  Or, alternatively, provide comments to make this clearer.\n",
        "createdAt" : "2015-05-26T22:17:29Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "04880f48-bf2d-4c73-b5f4-907686c8920c",
        "parentId" : "1fbfd1cd-f846-4ee9-aa49-845f09cbdc10",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yup, I will add a comment.\n",
        "createdAt" : "2015-05-26T22:37:35Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3896,3900 @@                    // When these don't start a declaration, they may be the start of a class member if an identifier\n                    // immediately follows. Otherwise they're an identifier in an expression statement.\n                    return getDeclarationFlags() ||\n                        (lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? StatementFlags.None : StatementFlags.Statement);\n"
  },
  {
    "id" : "63f7df81-2f87-4d99-aa9a-345137e85d9a",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b51d444e-a663-4eb5-aeb1-79df9eeb99b4",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "rename to parseModuleElement\n",
        "createdAt" : "2015-05-26T22:19:22Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "84a728c5-8a3e-4bc7-afca-57b77267f947",
        "parentId" : "b51d444e-a663-4eb5-aeb1-79df9eeb99b4",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, `parseDeclaration` is the right name. A `ModuleElement` can be many other things that we don't parse here.\n",
        "createdAt" : "2015-05-26T22:40:41Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "9531d35e-03ae-4841-a520-0899f817f348",
        "parentId" : "b51d444e-a663-4eb5-aeb1-79df9eeb99b4",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Shouldn't it return a Declaration then?\n",
        "createdAt" : "2015-05-28T08:27:44Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5b6dc0b1-c859-4db2-ab82-f3ec77470e79",
        "parentId" : "b51d444e-a663-4eb5-aeb1-79df9eeb99b4",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, a `Declaration` can also be many other things we don't parse here.\n",
        "createdAt" : "2015-05-28T16:00:11Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 571,
    "diffHunk" : "@@ -1,1 +4003,4007 @@        }\n\n        function parseDeclaration(): ModuleElement {\n            let fullStart = getNodePos();\n            let decorators = parseDecorators();"
  },
  {
    "id" : "35233990-d6e1-41e6-ae61-bf0dbced3f33",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd293ea8-4bee-4414-8acc-f5e0f3fda9c8",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "On first read I thought the `||` operator was short circuiting the right hand side if the left hand side was truthy.  When that didn't make sense in context, I realized on closer read the conditional operator is even lower precedence than the lowly logical OR operator.  Can we parenthesis the left of the `?` to make this clearer?  (And save dummies like me from having to review the operator precedence table to read code :smile: ).\n",
        "createdAt" : "2015-05-27T01:31:51Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "1033b0f6-ad37-4f61-aeaf-f3388aaf58c0",
        "parentId" : "dd293ea8-4bee-4414-8acc-f5e0f3fda9c8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This same `x || y ? s1 : s2` pattern occurs in a bunch of places elsewhere in the compiler, and we don't parenthesize in those as `(x || y) ? s1 : s2` . If we do it here shouldn't we then do it everywhere? But by what rule would we parenthesize stuff that doesn't need parentheses? Also, not trying to be pedantic, but when I read something that has unnecessary parentheses, it actually makes me stop and wonder why they're there and that maybe I'm missing something.\n",
        "createdAt" : "2015-05-27T13:32:46Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "d42d7756-b512-4d31-9dfd-660c8d1e6029",
        "parentId" : "dd293ea8-4bee-4414-8acc-f5e0f3fda9c8",
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "In general, even for the trivial example above, I find the second (parenthesized) expression far clearer.  Parenthesis remove any assumptions and ambiguity from both the authors intent, and the readers comprehension.\n\nThat said, this is probably more subjective than absolute (as much of the feedback has been) and we should probably agree as a team on a coding guideline to be consistent and avoid future philosophical debates.  For example, the \"C# Coding Conventions\"  (https://msdn.microsoft.com/en-us/library/ff926074.aspx) state:\n\n> Use parentheses to make clauses in an expression apparent, as shown in the following code. `if ((val1 > val2) && (val1 > val3))`\n\n.. and the Java guidelines (http://www.oracle.com/technetwork/java/codeconventions-150003.pdf) state ..\n\n> It is generally a good idea to use parentheses liberally in expressions involving mixed operators to avoid operator precedence problems. Even if the operator precedence seems clear to you, it might not be to others—you shouldn’t assume that other programmers know precedence as well as you do.\n\n``` java\nif (a == b && c == d)     // AVOID!\nif ((a == b) && (c == d)) // RIGHT\n```\n\nYet some of the Google coding guidelines (https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Parentheses) state of parenthesis:\n\n> Use sparingly and in general only where required by the syntax and semantics.\n\nWe should just pick one and make it policy for the codebase.\n",
        "createdAt" : "2015-05-27T15:23:26Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "97d27e05-3a6e-4b74-bf11-d2f24e479821",
        "parentId" : "dd293ea8-4bee-4414-8acc-f5e0f3fda9c8",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "It's definitely subjective.  It also depends on how you format your code.  For example, i find this hard to read:\n\n`Foo() && Bar() || Baz() ? Frob() : Quux()`.   But i woudl find this fine:\n\n``` ts\nFoo() && Bar() || Baz()\n    ? Frob()\n    : Quux()\n```\n\nVisual separation is very helpful in code.  We also need to remember that even though we are writing compilers, we are not compilers ourselves.  Keeping track of precedence, and stacks, and whatnot in my brain is not something i'm particularly efficient at.  It's the same reason why we don't read/write minified code (though it would definitely be unambiguous and crystal clear to the computer).  Our code sits in that area of being both instructions for a computer, but which is intended to be read and authored by us.  As such, it needs concessions toward clarity to help minimize the cost of comprehension and maintenance.  \n\nIn general i do not like hard rules (unless we have a tool to enforce them).  What i would prefer is that developers feel comfortable writing code they feel is clear.  If no one has problems with the code, then the code is fine.  But, if some people find the code confusing, then that's the bar to clarify and improve it .  This provides a very non-onerous approach for developers, likely keeps code minimal in the majority of cases, but allows a nice escape-hatch for when something just tips over the point of being too confusing for team members.\n",
        "createdAt" : "2015-05-27T19:34:59Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "28f07655-0fb3-481d-a364-278bf60a04a2",
        "parentId" : "dd293ea8-4bee-4414-8acc-f5e0f3fda9c8",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Shouldn't ModuleElement here be StatementOrModuleElement? It is only allowed in places where statements are also allowed, no?\n",
        "createdAt" : "2015-05-28T08:26:22Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "117afd53-9cbe-4153-bbb3-27c59497c4aa",
        "parentId" : "dd293ea8-4bee-4414-8acc-f5e0f3fda9c8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "You could do it that way too. With the current classification scheme a construct is either one or the other.\n",
        "createdAt" : "2015-05-28T13:49:02Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 354,
    "diffHunk" : "@@ -1,1 +3819,3823 @@                    case SyntaxKind.NamespaceKeyword:\n                        nextToken();\n                        return isIdentifierOrKeyword() || token === SyntaxKind.StringLiteral ? StatementFlags.ModuleElement : StatementFlags.None;\n                    case SyntaxKind.ImportKeyword:\n                        nextToken();"
  },
  {
    "id" : "5abb67a7-d69b-4865-98e0-ba2737362940",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d18bdc4-4084-4a89-8a08-c1d342582f82",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "Similarly here.  (I'd even argue for an if/else for readability with a condition this long feeding into the conditional.. but just the parens would be helpful).\n",
        "createdAt" : "2015-05-27T01:36:31Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "f4ca3591-9217-4346-a463-a137d23c5f04",
        "parentId" : "5d18bdc4-4084-4a89-8a08-c1d342582f82",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "As before, even just slightly rewriting to: \n\n``` ts\nreturn token === SyntaxKind.StringLiteral || token === SyntaxKind.AsteriskToken || token === SyntaxKind.OpenBraceToken || isIdentifierOrKeyword()\n    ? StatementFlags.ModuleElement\n    : StatementFlags.None;\n```\n\nGoes a long way toward making this more readable.  it's now very easy to find and grok out the true/false sections of the ternary.  it's also clear what acts as the condition portion.\n",
        "createdAt" : "2015-05-27T19:40:06Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 357,
    "diffHunk" : "@@ -1,1 +3822,3826 @@                    case SyntaxKind.ImportKeyword:\n                        nextToken();\n                        return token === SyntaxKind.StringLiteral || token === SyntaxKind.AsteriskToken ||\n                            token === SyntaxKind.OpenBraceToken || isIdentifierOrKeyword() ?\n                            StatementFlags.ModuleElement : StatementFlags.None;"
  },
  {
    "id" : "329a5834-3cc9-4373-bec8-e3fae4f3ce8d",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why is this not just part of ParsingContext?\n",
        "createdAt" : "2015-05-28T08:25:04Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "1d30234c-11bf-496c-9be8-a2071e770111",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "ParsingContext is a different thing. It says something about the context we're parsing a statement in. These flags say something about the statement itself.\n",
        "createdAt" : "2015-05-28T13:26:49Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "6bde07df-602c-4617-aec3-c55bbdd1a19f",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Ah, are you suggesting we use the ParsingContext type instead of StatementFlags? I suppose we could, although it has many other flags that we'd never use.\n",
        "createdAt" : "2015-05-28T13:30:26Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "c24b1d92-eb38-4395-9105-54bc1a782e0a",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "No, your first interpretation of my question was the correct one.\n\nIf these flags are about the statements themselves (as opposed to the context), then why does parseModuleElementOfKind take a StatementFlags instead of a ParsingContext? I thought that parameter represents what we are trying to parse, not a property of the statement.\n",
        "createdAt" : "2015-05-28T18:14:45Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b5d6c34f-b087-47b6-a53b-ec12f5dc645b",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It takes StatementFlags because we need them to test against the StatementFlags returned by getDeclarationFlags within the function.\n",
        "createdAt" : "2015-05-28T20:48:33Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "37407ec8-291b-48ec-b55d-8f4679341c54",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Well, you just need to tell if ModuleElements are allowed. So you just need to know whether to check the ModuleElements bit. Or if you eliminate StatementOrModuleElement, then you need to know whether to check equality to the ModuleElements enum member.\n",
        "createdAt" : "2015-05-28T20:53:10Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ca5923ee-eb25-43c8-a5a0-020294de7cda",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, `parseDeclarationFlags` might return `None` in which case we don't want to parse as a declaration (but rather as an expression because someone used a contextual keyword as an identifier).\n",
        "createdAt" : "2015-05-28T21:12:57Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "0a8c3459-f0ce-49e2-8166-676d4867a72e",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "True, but that aspect could be achieved by checking that the result of `getDeclarationFlags` is not `StatementFlags.None`. It doesn't have anything to do with the flags that are passed in.\n",
        "createdAt" : "2015-05-28T23:12:59Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d499cd08-078f-4450-af4f-6e012ee1d4d1",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "All I'm saying is that getDeclarationFlags will return StatementFlags and it just seems simpler to pass in the appropriate StatementFlags mask to test against. parseModuleElementOfKind is only called from parseStatement, parseModuleElement, and parseSourceElement, and those are the functions that anything else should call.\n",
        "createdAt" : "2015-05-28T23:18:12Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "7b8a4c2a-8bc7-499e-ae26-5191a11c5497",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I know it works that way, but you said \n\n> ParsingContext is a different thing. It says something about the context we're parsing a statement in. These flags say something about the statement itself.\n\nmeaning that StatementFlags are descriptive of a syntactic construct, and (unlike ParsingContext) they are not a normative context marker based on what kinds of nodes you are looking for. Yet, they are passed into parseModuleElementOfKind to filter constructs based on a need. From what you said, it seems like it is more appropriate to pass ParsingContext. The descriptive/normative aspects do not match up.\n",
        "createdAt" : "2015-05-28T23:24:42Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "6dae2c62-f41b-488e-90e9-95f58f8e3eb2",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We're going around in circles. I don't want to translate the flags from one form to another. It adds nothing but noise and opportunity for error. We could potentially get rid of StatementFlags and use (a subset of) ParsingContext for the same purpose. Then we'd be comparing apples to apples. Otherwise, I don't see any point in changing this.\n",
        "createdAt" : "2015-05-28T23:32:27Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "9cfae917-8638-43e2-a7e5-f8e53737fc95",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems fair. In that case, I would be in favor of a subset of ParsingContext.\n",
        "createdAt" : "2015-05-28T23:35:02Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "950cbb83-775e-4ce4-917e-7e8a7ff4bdd0",
        "parentId" : "aa254461-8306-45f8-b5af-53977f2a95ed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I tried and it just doesn't make sense to use ParsingContext. We can discuss in person if you'd like.\n",
        "createdAt" : "2015-05-29T13:54:53Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +494,498 @@        let parseErrorBeforeNextFinishedNode: boolean = false;\n\n        export const enum StatementFlags {\n            None = 0,\n            Statement = 1,"
  },
  {
    "id" : "1c288b5f-51cb-4ab8-9172-a6f2d56176a4",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a2bd87b-9c14-4191-b538-7cec955cec00",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This is not really what I expected. I feel like all Statements are ModuleElements, but not all ModuleElements are statements. So I expected something more along the lines of\n\n``` ts\nNone = 0,\nStatement = 1,\nModuleElement = 3,\n```\n",
        "createdAt" : "2015-05-28T08:25:46Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "1e4bc24e-914b-4633-ac37-f3a2e1181c3f",
        "parentId" : "6a2bd87b-9c14-4191-b538-7cec955cec00",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Either way works.\n",
        "createdAt" : "2015-05-28T13:36:38Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "1762da07-ef4b-4959-bcfa-19ffba3f7afa",
        "parentId" : "6a2bd87b-9c14-4191-b538-7cec955cec00",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can we eliminate StatementOrModuleElement? I feel like it is not clear when to use ModuleElement vs StatementOrModuleElement, because they represent pretty much the same thing, but are not the same numeric value.\n",
        "createdAt" : "2015-05-28T18:10:31Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "cb34c672-c77f-4f22-87fd-c57d41dac0ca",
        "parentId" : "6a2bd87b-9c14-4191-b538-7cec955cec00",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We can't eliminate StatementOrModuleElement. We classify elements as either Statement or ModuleElement. We then want to sometimes only allow those classified as Statement and sometimes allow both classifications. If ModuleElements were also classified as Statements then there'd be no way to exclude them.\n",
        "createdAt" : "2015-05-29T14:01:46Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "2d84d3e0-534a-4126-b424-7afc5163b1b4",
        "parentId" : "6a2bd87b-9c14-4191-b538-7cec955cec00",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh, it is because we use the `&` operator to determine whether it is allowed.\n",
        "createdAt" : "2015-05-29T17:44:50Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +499,503 @@            ModuleElement = 2,\n            StatementOrModuleElement = Statement | ModuleElement\n        }\n\n        export function parseSourceFile(fileName: string, _sourceText: string, languageVersion: ScriptTarget, _syntaxCursor: IncrementalParser.SyntaxCursor, setParentNodes?: boolean): SourceFile {"
  },
  {
    "id" : "5b36fc34-2962-4b32-b412-aad10ce334cf",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3382ebc-2b06-4ddc-aa22-36605073ac2d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "The enum should probably be called DeclarationFlags. Also, what does it mean to parse the declaration flags? Not sure parse is the right verb here.\n",
        "createdAt" : "2015-05-28T08:26:00Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e0bb93f4-8f57-43e8-b93e-abd623604d4c",
        "parentId" : "a3382ebc-2b06-4ddc-aa22-36605073ac2d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think StatementFlags is ok, we also use it for statements. Couldn't come up with a better name than parseDeclarationFlags. It basically parses as much as it needs to produce a classification. Not sure what to call that.\n",
        "createdAt" : "2015-05-28T13:43:56Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 337,
    "diffHunk" : "@@ -1,1 +3802,3806 @@        }\n\n        function parseDeclarationFlags(): StatementFlags {\n            while (true) {\n                switch (token) {"
  },
  {
    "id" : "83fabeab-999c-4cf5-b724-606d47335f43",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "944b0f96-f936-4090-a313-6594ff4becaa",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why do you need to check the next token too? Isn't the interface/type keyword enough? Also, what does returning None correspond to?\n",
        "createdAt" : "2015-05-28T08:26:16Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5461665a-3697-44b9-8254-8cd0fc4101da",
        "parentId" : "944b0f96-f936-4090-a313-6594ff4becaa",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "`interface` and `type` start a declaration only when immediately followed by an identifier. Otherwise they're just identifiers themselves (they're not reserved words).\n\nNone means not a declaration.\n",
        "createdAt" : "2015-05-28T13:47:25Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "fdc4e092-27ac-4524-9fcc-894ab4827f95",
        "parentId" : "944b0f96-f936-4090-a313-6594ff4becaa",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "If this is the case, then we'll also need to make sure they're on the same line.  otherwise we would parse:\n\n``` ts\ninterface\nfoo\n```\n\nas an interface, even though JS says it should be two expression statements (due to ASI).\n",
        "createdAt" : "2015-05-28T16:35:42Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b508b9b6-481c-44ab-805f-10035e72a0ed",
        "parentId" : "944b0f96-f936-4090-a313-6594ff4becaa",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "To be clear, [`interface` is a strict mode future reserved word](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-future-reserved-words).\n\nBut to follow up on Cyrus's comment, see #2995 as well.\n",
        "createdAt" : "2015-05-28T16:54:38Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "075ffa77-47c9-483d-b01c-bca811d19758",
        "parentId" : "944b0f96-f936-4090-a313-6594ff4becaa",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Ok, once we get this PR in let's start a new one for #2995.\n",
        "createdAt" : "2015-05-28T21:15:53Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 350,
    "diffHunk" : "@@ -1,1 +3815,3819 @@                    case SyntaxKind.TypeKeyword:\n                        nextToken();\n                        return isIdentifierOrKeyword() ? StatementFlags.Statement : StatementFlags.None;\n                    case SyntaxKind.ModuleKeyword:\n                    case SyntaxKind.NamespaceKeyword:"
  },
  {
    "id" : "09d92b36-f985-4ef6-9633-4c03039b4c80",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b90583e0-5a6c-46d1-a52a-3012475ef86c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'd add a comment that `continue` means we are looking at the modifier, not the declaration kind\n",
        "createdAt" : "2015-05-28T08:26:30Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 366,
    "diffHunk" : "@@ -1,1 +3831,3835 @@                            return StatementFlags.ModuleElement;\n                        }\n                        continue;\n                    case SyntaxKind.DeclareKeyword:\n                    case SyntaxKind.PublicKeyword:"
  },
  {
    "id" : "67f402fd-ad9c-493d-9a24-60cac90a83e7",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ab591d8c-383a-459e-b5aa-b3e98bac0ff2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why not just combine getDeclarationFlags and getStatementFlags?\n",
        "createdAt" : "2015-05-28T08:26:41Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "58b69629-56ee-4fea-96cc-a2774ac6e7e1",
        "parentId" : "ab591d8c-383a-459e-b5aa-b3e98bac0ff2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Because getDeclarationFlags is the starting point for a lookAhead that we don't otherwise want to do.\n",
        "createdAt" : "2015-05-28T13:55:07Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "3300a444-f167-44b3-8121-79a0f3b6d75e",
        "parentId" : "ab591d8c-383a-459e-b5aa-b3e98bac0ff2",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can we just merge module elements and statements, so that we don't have to do anything with flags? Then in the checker we can disallow module elements in a block context. I think it is much simpler.\n",
        "createdAt" : "2015-05-28T18:08:15Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "383a7839-a332-4e05-b1c1-595cfd7babe0",
        "parentId" : "ab591d8c-383a-459e-b5aa-b3e98bac0ff2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We could potentially do that but I didn't want to chase down all the places we process import and export declarations with the assumption that the immediate parent is a module or source file.\n",
        "createdAt" : "2015-05-28T20:44:34Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "07a6cf47-a677-4fc9-a0b3-733d16f0d053",
        "parentId" : "ab591d8c-383a-459e-b5aa-b3e98bac0ff2",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I know what you mean. I think doing that could be a little annoying in the short term, but I think it would be simpler conceptually, and make it easier to maintain things. Also, I think it gives a better user experience anyway to error in the checker.\n",
        "createdAt" : "2015-05-28T20:52:05Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 419,
    "diffHunk" : "@@ -1,1 +3880,3884 @@                case SyntaxKind.ExportKeyword:\n                case SyntaxKind.ImportKeyword:\n                    return getDeclarationFlags();\n\n                case SyntaxKind.DeclareKeyword:"
  },
  {
    "id" : "e6600d6e-c17b-4b72-bc49-bdd874874afd",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b384eea-e9e1-4fff-b487-2077b45d6afd",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh because export and import can never start a statement, right?\n",
        "createdAt" : "2015-05-28T08:26:47Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0f0bdcea-a1ce-486c-9375-feafe3f8ccb9",
        "parentId" : "5b384eea-e9e1-4fff-b487-2077b45d6afd",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Right, `export` and `import` are actual reserved words.\n",
        "createdAt" : "2015-05-28T13:52:57Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 432,
    "diffHunk" : "@@ -1,1 +3887,3891 @@                case SyntaxKind.NamespaceKeyword:\n                case SyntaxKind.TypeKeyword:\n                    // When these don't start a declaration, they're an identifier in an expression statement\n                    return getDeclarationFlags() || StatementFlags.Statement;\n"
  },
  {
    "id" : "02ba850f-eec7-4ba2-9d6c-ad2d8c7b3460",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4147c82-1f8d-4137-b984-babc303cfc9f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "These tokens can only start a class member if you are parsing in the context of class elements, but will you ever call getStatementFlags in a class element context? So if you are trying to get statement flags, aren't these always the start of a statement?\n\nAgain, I'm not sure what is going to happen when you return None\n",
        "createdAt" : "2015-05-28T08:27:04Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8cfd8767-0871-4bc2-a386-a64db89f6a75",
        "parentId" : "b4147c82-1f8d-4137-b984-babc303cfc9f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "An outer parsing context might be class elements (e.g. you're inside the body of a class method). For error recovery reasons we don't want to consume something that isn't a declaration and isn't a well formed expression, but looks like it might be a class element.\n",
        "createdAt" : "2015-05-28T13:58:48Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "e9f6c88d-bc2a-4ccc-aedb-4e9b87d63a6d",
        "parentId" : "b4147c82-1f8d-4137-b984-babc303cfc9f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh because in error recovery you would pop out of the method and into the class?\n",
        "createdAt" : "2015-05-28T18:05:26Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d33d1bdc-22b3-4726-9f51-18efa2ce17e2",
        "parentId" : "b4147c82-1f8d-4137-b984-babc303cfc9f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Exactly.\n",
        "createdAt" : "2015-05-28T20:41:35Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 447,
    "diffHunk" : "@@ -1,1 +3897,3901 @@                    // immediately follows. Otherwise they're an identifier in an expression statement.\n                    return getDeclarationFlags() ||\n                        (lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? StatementFlags.None : StatementFlags.Statement);\n\n                default:"
  },
  {
    "id" : "e88bcb7b-3c93-4baf-9394-d30daa69c1ca",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a40ea6c5-9583-426a-8154-1c064c274aed",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I am confused about the purpose of the getStatementFlags approach. Why is it better than having isStatement and isModuleElement just make the decisions for themselves? Is it so that there can be just one place (instead of two) to account for all the node kinds here, so we don't forget any?\n",
        "createdAt" : "2015-05-28T08:27:11Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "3ba63558-5b62-4678-a48f-5592dfad9814",
        "parentId" : "a40ea6c5-9583-426a-8154-1c064c274aed",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The problem is modifiers. When modifiers are present we can't tell from the first token what we're looking at. So we need to look ahead, but we don't want to do that more than once. And, as you say, when everything is in one place we're certain that there won't be any subtle differences.\n",
        "createdAt" : "2015-05-28T15:50:03Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3905,3909 @@\n        function isStartOfStatement(): boolean {\n            return (getStatementFlags() & StatementFlags.Statement) !== 0;\n        }\n"
  },
  {
    "id" : "3d24fc04-bbd6-44f8-a0db-1ab34ecbd006",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffb9bbb0-718c-4e98-91a6-aafceac151af",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think it's simpler if this just takes a boolean saying whether a module element is allowed. That's the only thing that varies in the calls to this function.\n\nThen at the spot where do use the flags, just use the boolean to figure out whether you need the declaration flags to say StatementOrModuleElement.\n",
        "createdAt" : "2015-05-28T08:27:26Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ba1e424b-749e-4eb4-831f-0ebd693495bf",
        "parentId" : "ffb9bbb0-718c-4e98-91a6-aafceac151af",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Having a boolean parameter just makes the actual testing more complicated (because you now have to construct a bit mask from the boolean). I tried it that way and it just made it more complex to read.\n",
        "createdAt" : "2015-05-28T15:52:45Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 492,
    "diffHunk" : "@@ -1,1 +3936,3940 @@        }\n\n        function parseModuleElementOfKind(flags: StatementFlags): ModuleElement {\n            switch (token) {\n                case SyntaxKind.SemicolonToken:"
  },
  {
    "id" : "82c4c6f0-3ac0-4cf9-838a-c34f9fa822c1",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f424f9d-f1cc-49a8-8e3a-6ebd5cd26751",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What is the intent here? I do not understand this part?\n\nAlso, what is the commonality among all these cases here? I thought it was all the declarations, but var and let are missing from this.\n",
        "createdAt" : "2015-05-28T08:27:36Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "99bcaff1-edc1-4494-bd45-9930d0429637",
        "parentId" : "1f424f9d-f1cc-49a8-8e3a-6ebd5cd26751",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The commonality here is (a) that we want to use `getDeclarationFlags` to determine if we're looking at a declaration (which involves look-ahead for these starter tokens) and if so (b) call `parseDeclaration` which has common handling for decorators and modifiers.\n",
        "createdAt" : "2015-05-28T15:56:34Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "804118c8-c3df-4818-9ce8-d98bd168a625",
        "parentId" : "1f424f9d-f1cc-49a8-8e3a-6ebd5cd26751",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "`var` and `let` are missing because with those we already know what we're looking at. Thus, it would be a waste of time to look ahead and to check for decorators and modifiers.\n",
        "createdAt" : "2015-05-28T15:58:41Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "bb3ea4ce-9afa-4a37-87f3-7f04e8573dba",
        "parentId" : "1f424f9d-f1cc-49a8-8e3a-6ebd5cd26751",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I still do not understand.\n",
        "createdAt" : "2015-05-28T18:02:30Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 559,
    "diffHunk" : "@@ -1,1 +3995,3999 @@                case SyntaxKind.StaticKeyword:\n                case SyntaxKind.TypeKeyword:\n                    if (getDeclarationFlags() & flags) {\n                        return parseDeclaration();\n                    }"
  },
  {
    "id" : "4fb02529-8653-4417-b197-e588a84efa02",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccce9d90-82e2-4d26-a83a-30375f5a7700",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "can you comment here how/where 'async' arrow functions are handled.\n",
        "createdAt" : "2015-05-08T18:02:14Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3617,3621 @@                    // If we encounter `async [no LineTerminator here] function` then this is an async\n                    // function; otherwise, its an identifier.\n                    if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {\n                        break;\n                    }"
  },
  {
    "id" : "ed390411-b1e0-4d06-8462-4434c84cbbe7",
    "prId" : 2809,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0c21e03-13df-4755-85c3-218953f6332a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Did we decide to not just always parse out a property name, and then error later if the property name turns out to be a keyword?\n",
        "createdAt" : "2015-04-17T19:26:03Z",
        "updatedAt" : "2015-04-17T23:52:05Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "f4e1d129-1a29-4b4c-9c4c-ea19be9fae21",
        "parentId" : "d0c21e03-13df-4755-85c3-218953f6332a",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "That is another approach we are considering. I do prefer it\n",
        "createdAt" : "2015-04-17T20:13:27Z",
        "updatedAt" : "2015-04-17T23:52:05Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4134d799999f121a8da2f003ceba04800635151d",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +3860,3864 @@            let node = <BindingElement>createNode(SyntaxKind.BindingElement);\n            // TODO(andersh): Handle computed properties\n            let tokenIsIdentifier = isIdentifier();\n            let propertyName = parsePropertyName();\n            if (tokenIsIdentifier && token !== SyntaxKind.ColonToken) {"
  },
  {
    "id" : "057d448a-e04c-4d86-81dd-e5b9e20e0c87",
    "prId" : 2567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d4324c99-a979-4baf-8d83-410bf5b4e9e1",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "can be dropped because of `isIdentifier` check below\n",
        "createdAt" : "2015-03-31T23:26:05Z",
        "updatedAt" : "2015-04-01T00:36:18Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc38c2956e0a5cd8b3e27c934bf204e3658b7d1",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +2910,2914 @@                case SyntaxKind.SlashToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.Identifier:\n                    return true;\n                default:"
  },
  {
    "id" : "76b23996-5c8d-4530-a1b0-7d84dc1f2e58",
    "prId" : 2333,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f4497ec2-e6bb-42bf-81ac-f079b395a53b",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I would always enter strict mode once we're in a class.  If that's ES semantics, then that's what we should follow.\n",
        "createdAt" : "2015-03-13T09:30:19Z",
        "updatedAt" : "2015-03-16T23:24:55Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "81c3e93b-fe99-4680-be3a-6a5cd8dc59ae",
        "parentId" : "f4497ec2-e6bb-42bf-81ac-f079b395a53b",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "That will be a breaking change. I have tried running on that mode on RWC and our compiler. Both do have non-strict-mode code in classDeclaration. So, I want to push this version in first. Then, decide if we want to extend this to all classDeclaration later. \n",
        "createdAt" : "2015-03-14T23:31:29Z",
        "updatedAt" : "2015-03-16T23:24:55Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "155184d8-d59b-4a9b-915b-aec2187d919c",
        "parentId" : "f4497ec2-e6bb-42bf-81ac-f079b395a53b",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I am surprised that stuff broke. Do you recall what the particular strict mode errors were?\n",
        "createdAt" : "2015-03-16T18:16:59Z",
        "updatedAt" : "2015-03-16T23:24:55Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d2b89875-e020-42ce-8740-0cbff30d42e5",
        "parentId" : "f4497ec2-e6bb-42bf-81ac-f079b395a53b",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Also, can we bring this to the design meeting.  Technically those classes are broken, and won't work in the future.  Do we want to continue 'pretending' they're ok, or should we be up frong about breaking them.  Can you also possibly email us the examples of where this breaks?\n",
        "createdAt" : "2015-03-16T20:17:04Z",
        "updatedAt" : "2015-03-16T23:24:55Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "32ae9859-939c-460e-9f7c-6cff0109ab6a",
        "parentId" : "f4497ec2-e6bb-42bf-81ac-f079b395a53b",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Yes, using `arguments` as a name of parameters. I will send email of what is broken\n",
        "createdAt" : "2015-03-16T20:21:26Z",
        "updatedAt" : "2015-03-16T23:24:55Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9b3fccd5c4885fc88e40a14fac6fa761a8739cff",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4529,4533 @@            // In ES6 specification, All parts of a ClassDeclaration or a ClassExpression are strict mode code\n            let savedStrictModeContext = inStrictModeContext();\n            if (languageVersion >= ScriptTarget.ES6) {\n                setStrictModeContext(true);\n            }"
  },
  {
    "id" : "2b27e6d1-be62-46d0-8b97-eab93e8e70ac",
    "prId" : 2283,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a0df322-038a-43d1-85e9-74563076cba9",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "This is weird, but I don't mind it terribly.\n",
        "createdAt" : "2015-03-16T01:57:37Z",
        "updatedAt" : "2015-03-16T01:57:37Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "02d356800f36ecd548641d993ab4b70359de2e70",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +96,100 @@                    visitNodes(cbNodes, (<FunctionLikeDeclaration>node).parameters) ||\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).type) ||\n                    visitNode(cbNode, (<ArrowFunction>node).equalsGreaterThanToken) ||\n                    visitNode(cbNode, (<FunctionLikeDeclaration>node).body);\n            case SyntaxKind.TypeReference:"
  },
  {
    "id" : "4c7ca604-38a9-42ad-81fe-729fac190394",
    "prId" : 1983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a71474ed-828f-4919-bed8-1c80be7e2aa0",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "the new import and export node types should be in this list.\n",
        "createdAt" : "2015-02-21T23:00:08Z",
        "updatedAt" : "2015-02-23T19:27:45Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "27529f1d38584189b98e57a526d3854216ab5c45",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1860,1864 @@                switch (node.kind) {\n                    case SyntaxKind.ImportDeclaration:\n                    case SyntaxKind.ImportEqualsDeclaration:\n                    case SyntaxKind.ExportDeclaration:\n                    case SyntaxKind.ExportAssignment:"
  },
  {
    "id" : "d04e7f20-5297-4030-a406-ef68f1e6fc9d",
    "prId" : 1495,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7f7f721-073c-4403-9485-e461e36b3fa3",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "When do we not have refFile?   Can you comment the case where this might happen?\n\nAlso, can we have a test for this?\n",
        "createdAt" : "2014-12-16T02:28:09Z",
        "updatedAt" : "2014-12-16T02:28:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "90954564-7c31-4254-9bdf-172c84d93f67",
        "parentId" : "a7f7f721-073c-4403-9485-e461e36b3fa3",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I can not add a test for this, as the only place this happens is an invalid encoding on cscript. we do not run tests on specific engines, and this would have an engine specific behavior.\nThe issue is we catch the failure to read exception in tsc.ts, then augment it with the reason for failure, \"unsupported encoding\", then raise an error, using the on error message. if the file is one that is a root file, there is no refFile, and then we assert when we call createFileDiagnostics.\n",
        "createdAt" : "2014-12-16T05:23:47Z",
        "updatedAt" : "2014-12-16T05:23:47Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "8a87d519565544b7082510af7547b84919d1b88b",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +5363,5367 @@                // We haven't looked for this file, do so now and cache result\n                var file = filesByName[canonicalName] = host.getSourceFile(filename, options.target, hostErrorMessage => {\n                    if (refFile) {\n                        errors.push(createFileDiagnostic(refFile, refStart, refLength,\n                            Diagnostics.Cannot_read_file_0_Colon_1, filename, hostErrorMessage));"
  },
  {
    "id" : "714c87a5-9b94-4527-9aa5-556d5b0b50f7",
    "prId" : 1434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d965130e-841f-4038-b5ec-6cff1af6d4fb",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The implementation of `containsParseError` (in utilities) uses a `hasFlag` method instead of just checking the flag inline. I really don't like that and we never do that elsewhere.\n",
        "createdAt" : "2014-12-16T22:32:30Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "f5575745-b257-4bc1-b90f-0f687e78810c",
        "parentId" : "d965130e-841f-4038-b5ec-6cff1af6d4fb",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I can change that.  But it becomes a matter of DRY (don't repeat yourself).  This code pattern is used all over the place, instead of unifying in a single place that expresses the concept and can be used uniformly instead.\n",
        "createdAt" : "2014-12-17T01:02:33Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "af6e3b1b-968c-42ee-8f14-4994b981a49a",
        "parentId" : "d965130e-841f-4038-b5ec-6cff1af6d4fb",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Again, this is a matter of consistency. We already use & checks _everywhere_ else and we're not going to change that. The use of `hasFlag` is an unnecessary inconsistency.\n",
        "createdAt" : "2014-12-17T01:29:23Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a08c54f429e486d774b92c4af6858820fb9c55f",
    "line" : 755,
    "diffHunk" : "@@ -1,1 +1699,1703 @@            // Can't reuse a node that contains a parse error.  This is necessary so that we \n            // produce the same set of errors again.\n            if (containsParseError(node)) {\n                return undefined;\n            }"
  },
  {
    "id" : "eac47b43-e974-465b-85b0-a0eabbc96a4c",
    "prId" : 1432,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "add7452b-4ed6-4ce9-beb4-ebaea595c1f9",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Explain that `fixupParentReferences` may be performed in situations when parent pointers are already set - this is currently only implicitly said when you mention incremental parsing.\n",
        "createdAt" : "2014-12-10T20:32:47Z",
        "updatedAt" : "2014-12-10T20:32:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1170a1c43604d8b2b3d3b83f53890ebba0481458",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1022,1026 @@        var parent: Node = sourceFile;\n        function walk(n: Node): void {\n            // walk down setting parents that differ from the parent we think it should be.  This\n            // allows us to quickly bail out of setting parents for subtrees during incremental \n            // parsing"
  },
  {
    "id" : "3d8dedba-241a-4f1e-bd7c-b881389dea54",
    "prId" : 1423,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2bf01494-17c8-467f-9abf-fd08db8cb62b",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "these can likely move to checker.\n",
        "createdAt" : "2014-12-17T03:20:33Z",
        "updatedAt" : "2014-12-17T03:59:37Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "99a189936f2c7449bb6ad2c52190f18f59bdc3de",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +390,394 @@    };\n\n    export function modifierToFlag(token: SyntaxKind): NodeFlags {\n        switch (token) {\n            case SyntaxKind.StaticKeyword: return NodeFlags.Static;"
  },
  {
    "id" : "ec485d18-c1ec-4c78-b084-3e3c26bb4ec1",
    "prId" : 1374,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74d307f7-942f-42b1-9433-1c85b78fd7ef",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "perfect\n",
        "createdAt" : "2014-12-05T01:53:58Z",
        "updatedAt" : "2014-12-05T01:53:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "e29aadb4c4dc13cbd5478fdb8d6e213f0f681cef",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +4176,4180 @@            // It is let declaration if in strict mode or next token is identifier on same line.\n            // otherwise it needs to be treated like identifier\n            return inStrictModeContext() || lookAhead(nextTokenIsIdentifierOnSameLine);\n        }\n"
  },
  {
    "id" : "0c5a0475-f28a-4d36-9fe6-7dac1dcba87c",
    "prId" : 1368,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9604aac2-74eb-40df-9c56-6dd16f183930",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "flags\n",
        "createdAt" : "2014-12-04T20:06:48Z",
        "updatedAt" : "2014-12-04T20:32:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "405508c100934f99d975348015cce735fa10f76c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1167,1171 @@            var saveParseDiagnosticsLength = sourceFile.parseDiagnostics.length;\n\n            // Note: it is not actually necessary to save/restore the context falgs here.  That's\n            // because the saving/restorating of these flags happens naturally through the recursive\n            // descent nature of our parser.  However, we still store this here just so we can "
  },
  {
    "id" : "11e59b19-bc36-4497-be66-a69fecb002ce",
    "prId" : 1368,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1941ec24-06e5-4422-bed9-90b58250009f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "because\nrestoring or restoration\n",
        "createdAt" : "2014-12-04T20:07:20Z",
        "updatedAt" : "2014-12-04T20:32:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "405508c100934f99d975348015cce735fa10f76c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1168,1172 @@\n            // Note: it is not actually necessary to save/restore the context falgs here.  That's\n            // because the saving/restorating of these flags happens naturally through the recursive\n            // descent nature of our parser.  However, we still store this here just so we can \n            // assert that that invariant holds."
  },
  {
    "id" : "fc0fea4a-4336-4d2e-83ff-aabd29c16a03",
    "prId" : 1368,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e8227c7-ac67-4a10-b646-6b58a9224b27",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "this invariant\n",
        "createdAt" : "2014-12-04T20:07:58Z",
        "updatedAt" : "2014-12-04T20:32:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "405508c100934f99d975348015cce735fa10f76c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1170,1174 @@            // because the saving/restorating of these flags happens naturally through the recursive\n            // descent nature of our parser.  However, we still store this here just so we can \n            // assert that that invariant holds.\n            var saveContextFlags = contextFlags;\n"
  },
  {
    "id" : "372c2189-2e58-405d-b909-0db8604db645",
    "prId" : 1363,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9e3c1e0-6584-442c-a8c2-5584cdf5ce7f",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Why do we have to check for `node.kind !== SyntaxKind.EndOfFileToken`\n",
        "createdAt" : "2014-12-04T00:22:36Z",
        "updatedAt" : "2014-12-04T00:22:36Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "7f693257-c9ac-4d63-a88b-77f74911d3df",
        "parentId" : "d9e3c1e0-6584-442c-a8c2-5584cdf5ce7f",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Because an EOF token has no width.\n",
        "createdAt" : "2014-12-04T00:24:21Z",
        "updatedAt" : "2014-12-04T00:24:21Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "498fdcc9-d082-42ff-8d5a-16bc63759a44",
        "parentId" : "d9e3c1e0-6584-442c-a8c2-5584cdf5ce7f",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "More specifically EOF is not a 'missing' token.\n\nEOF may or may not have 0 width.  \n",
        "createdAt" : "2014-12-04T02:37:59Z",
        "updatedAt" : "2014-12-04T02:38:18Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "ee5c689e-b88c-41f3-81c7-053ab5e34bda",
        "parentId" : "d9e3c1e0-6584-442c-a8c2-5584cdf5ce7f",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "But not in our system, correct? The scanner could produce this, but we don't anywhere, right?\n",
        "createdAt" : "2014-12-04T03:04:49Z",
        "updatedAt" : "2014-12-04T03:04:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "38be3bd6-8bef-4eff-b0d2-ffa3d6ae82e5",
        "parentId" : "d9e3c1e0-6584-442c-a8c2-5584cdf5ce7f",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Our scanner produces EOF tokens both with and without a 0-width.    You'll get a non-zero-width EOF token if there is any final trivia (whitespace/newlines/comments) in the file.  You'll get a zero-width EOF token otherwise.  hope that helps! :)\n",
        "createdAt" : "2014-12-04T03:33:10Z",
        "updatedAt" : "2014-12-04T03:33:10Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e9561194bff930f6dbbf7e320ea6db8065142dc",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +45,49 @@\n    export function isMissingNode(node: Node) {\n        return node.pos === node.end && node.kind !== SyntaxKind.EndOfFileToken;\n    }\n"
  },
  {
    "id" : "7f1ef3da-d286-4daa-ba8d-6e54b31b4ae9",
    "prId" : 1363,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "768fb0ed-307b-4d29-9703-6896d7ec6faf",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "As of our discussion, should we use `substr`?\n",
        "createdAt" : "2014-12-04T00:23:08Z",
        "updatedAt" : "2014-12-04T00:23:08Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "66860d4b-f8ba-4995-9947-781e75162eb8",
        "parentId" : "768fb0ed-307b-4d29-9703-6896d7ec6faf",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "It's a pretty nasty edge-case, but I don't think it buys us a lot. The behavior is wonky, but it's not like you'd get \"right\" behavior if you used `substr` anyhow.\n",
        "createdAt" : "2014-12-04T00:26:26Z",
        "updatedAt" : "2014-12-04T00:26:26Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0e9561194bff930f6dbbf7e320ea6db8065142dc",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +72,76 @@        }\n\n        return sourceText.substring(skipTrivia(sourceText, node.pos), node.end);\n    }\n"
  },
  {
    "id" : "4ef2f2bf-f08f-4710-b9d3-885ee573c423",
    "prId" : 1308,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "71d17d8b-f6dd-4aed-9ff3-cb78d9401b69",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What about with multiple `extends` clauses, one of which has no types? Not that you necessarily have to handle that now, but maybe leave a TODO\n",
        "createdAt" : "2014-12-01T06:42:05Z",
        "updatedAt" : "2014-12-01T06:42:05Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1bba41b7-18f0-4642-b987-792f998b6db9",
        "parentId" : "71d17d8b-f6dd-4aed-9ff3-cb78d9401b69",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Sure.  It's something we could consider.  but i'm not sure how valuable it would be.  \n",
        "createdAt" : "2014-12-01T06:48:33Z",
        "updatedAt" : "2014-12-01T06:48:33Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebe8711a21ef7ecca2b877b5fe121b52edcd512e",
    "line" : 209,
    "diffHunk" : "@@ -1,1 +684,688 @@\n    export function getClassBaseTypeNode(node: ClassDeclaration) {\n        var heritageClause = getHeritageClause(node.heritageClauses, SyntaxKind.ExtendsKeyword);\n        return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;\n    }"
  },
  {
    "id" : "b506bf56-f1e6-4c7e-815d-fd72daba269c",
    "prId" : 1272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f2d8fff8-2acf-4361-8106-36a409312f8a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Add grammar productoins from spec. Also, do you need to do anything special for yield/generatorparameter.\n",
        "createdAt" : "2014-11-26T01:31:58Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "7372fa8a-ff72-4ecb-8e4b-e44fa29bf2bf",
        "parentId" : "f2d8fff8-2acf-4361-8106-36a409312f8a",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I do need to adjust it for yield/generatorparameter. However, I can't test that right now because it is only observable in destructuring. Will fix though\n",
        "createdAt" : "2014-11-27T03:36:27Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddebd028288b90c392ef5661a8f18af4f716f77e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1272,1276 @@            //     [ AssignmentExpression[In, ?Yield] ]\n            //\n            var node = <ComputedPropertyName>createNode(SyntaxKind.ComputedPropertyName);\n            parseExpected(SyntaxKind.OpenBracketToken);\n"
  },
  {
    "id" : "67c0ca27-cf9a-4c17-8f1e-01c37be0e5a3",
    "prId" : 1272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "509f3d71-25ae-44ef-8093-0d755e22d707",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Add tests for conditional expression\n",
        "createdAt" : "2014-11-26T01:32:49Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "52ae7492-2891-4c3d-8f7b-4852c5ed407b",
        "parentId" : "509f3d71-25ae-44ef-8093-0d755e22d707",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Done\n",
        "createdAt" : "2014-11-27T03:19:54Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddebd028288b90c392ef5661a8f18af4f716f77e",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +1870,1874 @@\n                // If any of the following tokens are after the question mark, it cannot\n                // be a conditional expression, so treat it as an indexer.\n                return nextToken() === SyntaxKind.ColonToken || token === SyntaxKind.CommaToken || token === SyntaxKind.CloseBracketToken;\n            });"
  },
  {
    "id" : "d1c7f45d-98b4-4c05-af91-8195c12ee1cf",
    "prId" : 1272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4a52f383-8b9e-4a61-a22e-9132acab86ca",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "is this actually something specified by the grammar?\n",
        "createdAt" : "2014-11-26T01:32:50Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "c6d011e4-3bc1-4a79-8c6f-b07b1cb0ed5e",
        "parentId" : "4a52f383-8b9e-4a61-a22e-9132acab86ca",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Accessors are already disallowed in ambient contexts (in the grammar).\n\nThe other stuff is not in the grammar yet because it has to do with computed properties.\nOnce symbols are added, the grammar will allow computed properties, but only of the form Symbol.identifier.\n",
        "createdAt" : "2014-11-27T03:23:41Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "244a9407-a621-444b-a98a-a4b89788b80b",
        "parentId" : "4a52f383-8b9e-4a61-a22e-9132acab86ca",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Alternatively, once symbols are added, the grammar could allow all computed properties, but the type checker would give an error if it's not of the form Symbol.identifier\n",
        "createdAt" : "2014-11-27T03:24:41Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddebd028288b90c392ef5661a8f18af4f716f77e",
    "line" : 279,
    "diffHunk" : "@@ -1,1 +4509,4513 @@                // and accessors are not allowed in ambient contexts in general,\n                // so this error only really matters for methods.\n                if (inAmbientContext) {\n                    return checkForDisallowedComputedProperty(node.name, Diagnostics.Computed_property_names_are_not_allowed_in_an_ambient_context);\n                }"
  },
  {
    "id" : "23ec4244-f115-467e-bf60-3b555041b8cb",
    "prId" : 1272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da037882-bd71-4eb8-b5f5-37ddf0a30906",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Check ecmascript spec if you have to check for name collision in strict mode for computedProperty\n",
        "createdAt" : "2014-11-26T01:43:39Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddebd028288b90c392ef5661a8f18af4f716f77e",
    "line" : 302,
    "diffHunk" : "@@ -1,1 +4570,4574 @@\n            for (var i = 0, n = node.properties.length; i < n; i++) {\n                var prop = <Declaration>node.properties[i];\n                var name = <Identifier>prop.name;\n                if (prop.kind === SyntaxKind.OmittedExpression || name.kind === SyntaxKind.ComputedPropertyName) {"
  },
  {
    "id" : "82c347a3-8386-48d7-9c8a-9df9e573bd35",
    "prId" : 1258,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3655977d-b2d0-4802-af18-97bc1531837d",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "\"hte\" -> \"the\"\n",
        "createdAt" : "2014-11-24T22:45:37Z",
        "updatedAt" : "2014-11-24T23:55:24Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cc78e38623fef7e82d398db39ff82af8de8b6af",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +859,863 @@        //\n        // When adding more parser context flags, consider which is the more common case that the \n        // flag will be in.  This should be hte 'false' state for that flag.  The reason for this is\n        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,\n        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for "
  },
  {
    "id" : "4bae995b-ac28-4aa3-acf8-d6ccfcc8354c",
    "prId" : 1258,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "31cfe759-7488-44a8-8df6-602685413826",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "period -> comma\n",
        "createdAt" : "2014-11-24T22:47:22Z",
        "updatedAt" : "2014-11-24T23:55:24Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cc78e38623fef7e82d398db39ff82af8de8b6af",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +861,865 @@        // flag will be in.  This should be hte 'false' state for that flag.  The reason for this is\n        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,\n        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for \n        // 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost\n        // all nodes would need extra state on them to store this info."
  },
  {
    "id" : "3aa12c4f-f064-49fc-b5ba-bc9484c7c106",
    "prId" : 1258,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f825d07-9bc4-4b52-bfa9-cbff4296c2bb",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "period -> colon\n",
        "createdAt" : "2014-11-24T22:48:03Z",
        "updatedAt" : "2014-11-24T23:55:24Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cc78e38623fef7e82d398db39ff82af8de8b6af",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +868,872 @@        // grammar specification.\n        //\n        // An important thing about these context concepts.  By default they are effectively inherited\n        // while parsing through every grammar production.  i.e. if you don't change them, then when\n        // you parse a sub-production, it will have the same context values as hte parent production."
  },
  {
    "id" : "40009fc4-a988-4249-8993-f51d2e2ab766",
    "prId" : 1258,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7932fefb-b9e9-4e09-851c-b078d26bb780",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "hte -> the\n",
        "createdAt" : "2014-11-24T22:48:21Z",
        "updatedAt" : "2014-11-24T23:55:24Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7cc78e38623fef7e82d398db39ff82af8de8b6af",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +870,874 @@        // An important thing about these context concepts.  By default they are effectively inherited\n        // while parsing through every grammar production.  i.e. if you don't change them, then when\n        // you parse a sub-production, it will have the same context values as hte parent production.\n        // This is great most of the time.  After all, consider all the 'expression' grammar productions\n        // and how nearly all of them pass along the 'in' and 'yield' context values:"
  },
  {
    "id" : "e1668d27-799d-4c56-ba49-edfbea5194b1",
    "prId" : 1245,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7363d7ca-0bc9-4911-90ed-a3efd20556dd",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Consider a rename on `getStartPos` -> `getFullStartPos`\n",
        "createdAt" : "2014-11-22T21:31:53Z",
        "updatedAt" : "2014-11-22T21:31:53Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb541bf8da2457e1a3c452042092282c544b5ca4",
    "line" : 145,
    "diffHunk" : "@@ -1,1 +1608,1612 @@                    return parseSignatureMember(SyntaxKind.CallSignature, SyntaxKind.ColonToken);\n                case SyntaxKind.OpenBracketToken:\n                    return parseIndexSignatureMember(scanner.getStartPos(), /*modifiers:*/ undefined);\n                case SyntaxKind.NewKeyword:\n                    if (lookAhead(() => nextToken() === SyntaxKind.OpenParenToken || token === SyntaxKind.LessThanToken)) {"
  },
  {
    "id" : "764ba19f-2c6e-47d1-9a96-d1a8409a99e1",
    "prId" : 1204,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e55ea52-e010-44bc-85d9-e83776617005",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "What you mean unclosed in this context?\n",
        "createdAt" : "2014-11-20T01:52:39Z",
        "updatedAt" : "2014-11-25T00:34:11Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "2c031f92-6a75-462a-acb8-f2a306de7ba1",
        "parentId" : "8e55ea52-e010-44bc-85d9-e83776617005",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I should probably be more explicit - it kind of sounds like I'm referring to a template expression without a template tail. I really mean unterminated, in the sense that your literal isn't explicitly sealed off with a backtick. I'll clarify it. Thanks!\n",
        "createdAt" : "2014-11-20T04:27:44Z",
        "updatedAt" : "2014-11-25T00:34:11Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ad39bdfb012ec8604664b3e028c499a97cf30525",
    "line" : null,
    "diffHunk" : "@@ -1,1 +820,824 @@\n        // The literal can only be unterminated if it is a template tail or a no-sub template.\n        if (node.kind !== SyntaxKind.TemplateTail && node.kind !== SyntaxKind.NoSubstitutionTemplateLiteral) {\n            return false;\n        }"
  },
  {
    "id" : "5600dcff-4060-4ed4-b210-53adb4be88a6",
    "prId" : 1202,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a397387e-22d7-4087-b20c-0b8bfb713bff",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Above this line, it seems like the question mark check should occur before we parse the function property shorthand.\n\nAlso, I just realized the error message is \"A object member...\" instead of \"An object member...\"\n",
        "createdAt" : "2014-11-19T04:58:02Z",
        "updatedAt" : "2014-11-19T21:24:44Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "34ed601c-6c96-4aed-ae4f-87cf1303eb84",
        "parentId" : "a397387e-22d7-4087-b20c-0b8bfb713bff",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Oops I will fix that. Thanks for the catch \n",
        "createdAt" : "2014-11-19T18:22:42Z",
        "updatedAt" : "2014-11-19T21:24:44Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "49c8e836167ee06d3f204889bc7722f4fb88193d",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +2757,2761 @@                nextToken();\n            }\n\n            // Parse to check if it is short-hand property assignment or normal property assignment\n            if ((token === SyntaxKind.CommaToken || token === SyntaxKind.CloseBraceToken) && tokenIsIdentifier) {"
  },
  {
    "id" : "577fddc9-c5f1-41ef-88b6-0400bb3f05d9",
    "prId" : 1169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fab6c512-bc15-4ea8-b44d-0fb1d7ebc9ec",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why member?\n",
        "createdAt" : "2014-11-15T00:56:29Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa48152eb8329202f604cc2d9c3c8e8da5faf08",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +1886,1890 @@\n        function parseFunctionType(typeKind: SyntaxKind): SignatureDeclaration {\n            var member = <SignatureDeclaration>createNode(typeKind);\n            var sig = parseSignature(typeKind === SyntaxKind.FunctionType ? SyntaxKind.CallSignature : SyntaxKind.ConstructSignature,\n                SyntaxKind.EqualsGreaterThanToken, /* returnTokenRequired */ true);"
  },
  {
    "id" : "bfa73f05-266a-44a1-8b0b-fa2a1e05f341",
    "prId" : 1169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b5236b8d-3000-4e07-87e6-36afec408e79",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Shouldn't the kind just be FunctionType or ConstructorType?\n",
        "createdAt" : "2014-11-15T00:56:59Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa48152eb8329202f604cc2d9c3c8e8da5faf08",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1887,1891 @@        function parseFunctionType(typeKind: SyntaxKind): SignatureDeclaration {\n            var member = <SignatureDeclaration>createNode(typeKind);\n            var sig = parseSignature(typeKind === SyntaxKind.FunctionType ? SyntaxKind.CallSignature : SyntaxKind.ConstructSignature,\n                SyntaxKind.EqualsGreaterThanToken, /* returnTokenRequired */ true);\n"
  },
  {
    "id" : "15a0945e-4394-4818-bf91-d4c5379223d5",
    "prId" : 1169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74136e6a-5439-4001-800b-3c1bd0a778e2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This approach of copying stuff over seems a little odd\n",
        "createdAt" : "2014-11-15T00:58:41Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa48152eb8329202f604cc2d9c3c8e8da5faf08",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +1894,1898 @@            member.type = sig.type;\n            finishNode(member);\n            return member;\n        }\n"
  },
  {
    "id" : "8ff51d17-6e54-4407-afbb-6f132c71cd29",
    "prId" : 1158,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfee2dbb-a21b-4a26-bbba-27b93afebb0f",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Report error for duplicate entry if !amdModuleName?\nAdd test case for same\n",
        "createdAt" : "2014-11-17T19:23:48Z",
        "updatedAt" : "2014-11-18T19:31:08Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "b54143c32644297f7490462194e94a711817fca2",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +4242,4246 @@                    var amdModuleNameRegEx = /^\\/\\/\\/\\s*<amd-module\\s+name\\s*=\\s*('|\")(.+?)\\1/gim;\n                    var amdModuleNameMatchResult = amdModuleNameRegEx.exec(comment);\n                    if(amdModuleNameMatchResult) {\n                        if(amdModuleName) {\n                            errorAtPos(range.pos, range.end - range.pos, Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments);"
  },
  {
    "id" : "14e1e30f-1809-46c6-9796-1f3295c3770b",
    "prId" : 1158,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf764e8b-4604-4988-9b40-926427da0421",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "@mhegazy  should we do any verification on amdModuleName user gave? Like it is all white spaces? all numbers? Should it always be identifier? \n",
        "createdAt" : "2014-11-17T19:25:41Z",
        "updatedAt" : "2014-11-18T19:31:08Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "d4888cf8-6134-43cb-b512-aebcfc62b5a4",
        "parentId" : "bf764e8b-4604-4988-9b40-926427da0421",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "@gisenberg We need test cases for amdModuleName irrespective of what @mhegazy comes back with.\n",
        "createdAt" : "2014-11-17T19:26:39Z",
        "updatedAt" : "2014-11-18T19:31:08Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "4777e854-0d1e-4a26-863a-e14b53e18e03",
        "parentId" : "bf764e8b-4604-4988-9b40-926427da0421",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I think it is fine. user needs to opt in into this scheme, and i would consider it as the amd dependency, what you write is what you get.\n",
        "createdAt" : "2014-11-18T04:11:22Z",
        "updatedAt" : "2014-11-18T19:31:08Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "b54143c32644297f7490462194e94a711817fca2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4246,4250 @@                            errorAtPos(range.pos, range.end - range.pos, Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments);\n                        }\n                        amdModuleName = amdModuleNameMatchResult[2];\n                    }\n"
  },
  {
    "id" : "7e80e733-1207-4728-8ca6-512de93c300e",
    "prId" : 1158,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d02a6d3c-c49c-413c-92c1-c148a0ded7c5",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i would add a \\s\\* before amd in \"<amd-module\"\n\nand probably the same for amd-dependency\n",
        "createdAt" : "2014-11-18T04:12:44Z",
        "updatedAt" : "2014-11-18T19:31:08Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "2031d260-2746-4141-b71c-e6383c5b06c9",
        "parentId" : "d02a6d3c-c49c-413c-92c1-c148a0ded7c5",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "That's not legal xml.  Xml cannot have a space between the < and the start of the name token.\n",
        "createdAt" : "2014-11-18T04:46:35Z",
        "updatedAt" : "2014-11-18T19:31:08Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "b54143c32644297f7490462194e94a711817fca2",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +4240,4244 @@                }\n                else {\n                    var amdModuleNameRegEx = /^\\/\\/\\/\\s*<amd-module\\s+name\\s*=\\s*('|\")(.+?)\\1/gim;\n                    var amdModuleNameMatchResult = amdModuleNameRegEx.exec(comment);\n                    if(amdModuleNameMatchResult) {"
  },
  {
    "id" : "402a59ad-9abd-4d8e-915a-c89efe85dee7",
    "prId" : 1136,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6530d23-f4ea-47bb-99e5-0165b8202272",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "comment this.\n",
        "createdAt" : "2014-11-12T23:23:32Z",
        "updatedAt" : "2014-11-12T23:47:18Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "8a107ffe-4ff0-4f18-81f8-1fb2ae0355e2",
        "parentId" : "f6530d23-f4ea-47bb-99e5-0165b8202272",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "+1\n",
        "createdAt" : "2014-11-12T23:38:25Z",
        "updatedAt" : "2014-11-12T23:47:18Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "c147507de1e0df81cd88fa620d4c63bd168d6bd7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +42,46 @@        // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*\n        // want to skip trivia because this will launch us forward to the next token.\n        if (node.pos === node.end) {\n            return node.pos;\n        }"
  },
  {
    "id" : "d85e6335-d14e-42e9-825b-344d9d0a96c7",
    "prId" : 1131,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e508e546-b998-4a4a-a121-337104a411d2",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I do not understand why noResolve is of any consequence here. we will come here because we decided to resolve references, correct?\n",
        "createdAt" : "2014-11-17T17:39:39Z",
        "updatedAt" : "2014-11-20T23:43:29Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "022440ba-26f8-4e8e-816a-5d6c0283ce7a",
        "parentId" : "e508e546-b998-4a4a-a121-337104a411d2",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I think we just need to compute an absolute path for every file for comparison purposes regardless of --noresolve, just do not make it the main name of the file so that error messages still use the name the user inputed.\n",
        "createdAt" : "2014-11-17T17:44:36Z",
        "updatedAt" : "2014-11-20T23:43:29Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "5f7ae912-14e0-4e7d-9829-8418ab9625a2",
        "parentId" : "e508e546-b998-4a4a-a121-337104a411d2",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "@mhegazy  don't we say if --noResolve is given do not resolve file names on the disk but use whatever is given in to the compiler, so why should we be resolving to full name in case of --noResolve\n",
        "createdAt" : "2014-11-17T19:34:03Z",
        "updatedAt" : "2014-11-20T23:43:29Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "dfd8bd91-10cd-4b89-af59-e05c67518d6e",
        "parentId" : "e508e546-b998-4a4a-a121-337104a411d2",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "--noResolve=true means do not resolve /// references. the path resolution is more of a compiler implementation detail.\n",
        "createdAt" : "2014-11-18T22:36:39Z",
        "updatedAt" : "2014-11-20T23:43:29Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "7d103a1a4526240031c9a2bd9eeb33dbb1b7ecab",
    "line" : null,
    "diffHunk" : "@@ -1,1 +645,649 @@\n    export function tryResolveScriptReference(program: Program, sourceFile: SourceFile, reference: FileReference) {\n        if (!program.getCompilerOptions().noResolve) {\n            var referenceFileName = isRootedDiskPath(reference.filename) ? reference.filename : combinePaths(getDirectoryPath(sourceFile.filename), reference.filename);\n            referenceFileName = getNormalizedAbsolutePath(referenceFileName, program.getCompilerHost().getCurrentDirectory());"
  },
  {
    "id" : "51a18cc2-eb0b-4107-92c6-8948bb62b206",
    "prId" : 1127,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2dae38f-75e9-4031-bf12-4b15f8aacdca",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "this looks correct.  just make sure you have tests for things like:  `var v = { class }`.  In this case, we do not have a shorthand property.\n",
        "createdAt" : "2014-11-11T21:03:29Z",
        "updatedAt" : "2014-11-17T19:35:15Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "eb644740-875d-475e-adfb-13ca1d11e4d3",
        "parentId" : "e2dae38f-75e9-4031-bf12-4b15f8aacdca",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "I will add that test\n",
        "createdAt" : "2014-11-12T01:39:09Z",
        "updatedAt" : "2014-11-17T19:35:15Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1b66ee6f3a7bad2a5ed13f17b1375c29c8439f30",
    "line" : 50,
    "diffHunk" : "@@ -1,1 +2758,2762 @@\n            // Parse to check if it is short-hand property assignment or normal property assignment\n            if (token !== SyntaxKind.ColonToken && nameToken === SyntaxKind.Identifier) {\n                node = <ShortHandPropertyDeclaration>createNode(SyntaxKind.ShorthandPropertyAssignment, nodePos);\n                node.name = propertyName;"
  },
  {
    "id" : "3acb9c41-2ed4-4258-a828-1b437c2c6659",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30f2c36f-1215-47ac-b6a1-a990639cccce",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Interesting that for non-const ambient enums, we check that the initializers are integer literals, but for const, we do not check anything until typecheck. It seems like we might want to do syntactic validation that the const initializers are of the syntactic form of a constant.\n",
        "createdAt" : "2014-10-30T01:34:32Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "91aa16af-170e-4e72-b891-81776be50df7",
        "parentId" : "30f2c36f-1215-47ac-b6a1-a990639cccce",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "I think we should discuss it: definitely we can try to validate that initializer syntactically includes only operations that can be performed in compile time however this won't remove need in check in typechecker (because parser cannot validate that `A.B` can indeed be constant expression).\n",
        "createdAt" : "2014-10-30T05:47:13Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "99b1b1ba-9d02-463a-a606-aac6184db6cd",
        "parentId" : "30f2c36f-1215-47ac-b6a1-a990639cccce",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Right, you would need to check in both places. It would just be more consistent with the integer literal check for ambients.\n",
        "createdAt" : "2014-10-30T17:34:31Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +3926,3930 @@                    }\n                    else if (!inConstantEnumMemberSection && errorCountBeforeEnumMember === file.syntacticErrors.length) {\n                        grammarErrorOnNode(node.name, Diagnostics.Enum_member_must_have_initializer);\n                    }\n                }"
  },
  {
    "id" : "91f26e7e-d79c-455d-9ddf-3288e12cd6e1",
    "prId" : 959,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5359082-ed88-4d07-ae2c-ce5bade080a4",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i would define these as variables outside the function as well.\n",
        "createdAt" : "2014-10-27T20:05:13Z",
        "updatedAt" : "2014-11-07T21:15:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "3d156018-fbca-4224-9491-7d3da7ea3b9f",
        "parentId" : "d5359082-ed88-4d07-ae2c-ce5bade080a4",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "You can't move it outside because in javascript global regex will start matching from the last used index. So if we didn't create new one every time, the last index will not be at zero. Alternatively we can reset the last index to zero though I find that a bit more confused\n",
        "createdAt" : "2014-10-29T21:25:58Z",
        "updatedAt" : "2014-11-07T21:15:05Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc3c5c52f329f3812adfbcfd9f103baa14513ee3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +753,757 @@\n    export function getFileReferenceFromReferencePath(comment: string, commentRange: CommentRange): ReferencePathMatchResult {\n        var simpleReferenceRegEx = /^\\/\\/\\/\\s*<reference\\s+/gim;\n        var isNoDefaultLibRegEx = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*)('|\")(.+?)\\2\\s*\\/>/gim;\n        if (simpleReferenceRegEx.exec(comment)) {"
  },
  {
    "id" : "8107f64a-316f-4e91-aeef-288f3345a59b",
    "prId" : 959,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "14b50f1a-1d33-44f1-8234-fcf7fb8a8aa5",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i would move these outside the function.\n",
        "createdAt" : "2014-10-30T17:55:11Z",
        "updatedAt" : "2014-11-07T21:15:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "a136cbcf-fd21-4f3b-9684-925b8332b7e9",
        "parentId" : "14b50f1a-1d33-44f1-8234-fcf7fb8a8aa5",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "We can't move this out because it is a global regex and when you reuse it, the last index will not be at zero so it will produce wrong result. Alternatively we can set the last index to zero but I think this way is more clear\n",
        "createdAt" : "2014-10-30T19:23:57Z",
        "updatedAt" : "2014-11-07T21:15:05Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc3c5c52f329f3812adfbcfd9f103baa14513ee3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +753,757 @@\n    export function getFileReferenceFromReferencePath(comment: string, commentRange: CommentRange): ReferencePathMatchResult {\n        var simpleReferenceRegEx = /^\\/\\/\\/\\s*<reference\\s+/gim;\n        var isNoDefaultLibRegEx = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*)('|\")(.+?)\\2\\s*\\/>/gim;\n        if (simpleReferenceRegEx.exec(comment)) {"
  },
  {
    "id" : "594f6b46-b1d0-4bcc-aa8a-9b19fb38af48",
    "prId" : 904,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78cdd5be-7fa7-4337-8d47-145f59c510a2",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "i thought we would not allow 'let' here as we're not in a block scope.  or do you check for that later?\n",
        "createdAt" : "2014-10-16T19:36:06Z",
        "updatedAt" : "2014-10-24T17:45:51Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "774c2d3e-090c-406b-a52b-38abde9be62b",
        "parentId" : "78cdd5be-7fa7-4337-8d47-145f59c510a2",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i think you are correct. the ES6 spec makes it clear that lexical scopes do not include switch, try or finally blocks, section 8.1:\n\n> A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a **FunctionDeclaration**, a **BlockStatement**, or a **Catch clause of a TryStatement** and a new Lexical Environment is created each time such code is evaluated.\n\nI will follow up to see if this is intentional or just an error in the spec and update this accordingly.\n",
        "createdAt" : "2014-10-17T16:57:53Z",
        "updatedAt" : "2014-10-24T17:45:51Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "ffbcbfb2-4eec-4bed-bf1b-190171fda9d3",
        "parentId" : "78cdd5be-7fa7-4337-8d47-145f59c510a2",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "They say \"such as\", which I normally interpret as \"including but not limited to\".\n",
        "createdAt" : "2014-10-17T20:01:17Z",
        "updatedAt" : "2014-10-24T17:45:51Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "cfa06256-1b82-4168-af12-cb9a56a87566",
        "parentId" : "78cdd5be-7fa7-4337-8d47-145f59c510a2",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "yeah. checked with @bterlson and he confirmed that that is not the intention. so keeping Switch, try and finally blocks as valid lexical scopes\n",
        "createdAt" : "2014-10-17T20:06:10Z",
        "updatedAt" : "2014-10-24T17:45:51Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "51e101c55eecf89b23f2870684eeb8ddf696fd3c",
    "line" : 98,
    "diffHunk" : "@@ -1,1 +2985,2989 @@            node.expression = parseExpression();\n            parseExpected(SyntaxKind.ColonToken);\n            node.statements = parseList(ParsingContext.SwitchClauseStatements, /*checkForStrictMode*/ false, parseStatementAllowingLetDeclaration);\n            return finishNode(node);\n        }"
  },
  {
    "id" : "3f223e9d-3e8e-4170-b0fa-799296fb904b",
    "prId" : 824,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "right now it looks like it's not possible to have syntax for an array of union types.  That seems like it could be problematic in the future.  For example, say you have htis in your .js:\n\n```\nfunction foo(x: string | number) {\n    return [x];\n}\n```\n\nThis function will have a type that is nonexpressable with the syntax of the language (and thus would be a problem for .d.ts files, as well as anyone who wants to explicitly give typings to things).  \n",
        "createdAt" : "2014-10-05T04:35:24Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "d69177b1-cecd-41b1-ac88-81e5c42bae79",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "We can write this as `Array<string|number>`\n",
        "createdAt" : "2014-10-05T06:34:36Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "0ef42354-3f44-4372-ba1b-baeec8393736",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Great point.  We'll likely have to do that if we don't make additional syntax.  As htis is a perfectly reasonable workaround, i'd prefer this approach before adding more syntax.  thanks!\n",
        "createdAt" : "2014-10-08T20:37:41Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "071100b4-5798-4ca4-befa-a918502d921d",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : null,
        "body" : "It would be great to have union type aliases, to keep the length of type names managable:\n\n```\ndefine number | Array<number> | Matrix<number> = DynamicMatrix;\n```\n\nOther values for the define keyword could be alias, type or class\n",
        "createdAt" : "2014-11-04T08:47:22Z",
        "updatedAt" : "2014-11-04T09:22:47Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "19479486-de47-4087-9f93-f606f610a86f",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : null,
        "body" : "I imagine this will fall out as a default feature, based on the type inference system of TypeScript, but I think it bears repeating. Union types should have anonymous interfaces:\n\n```\nclass A {\n    commonToBoth: string;\n    uniqueToA: string;\n}\n\nclass B {\n    commonToBoth: string;\n    uniqueToB: string;\n}\n\nvar either: A | B = new A();\n\n//Valid because there is an anonymous interface containing the common members\neither.commonToBoth\n```\n\nThe anonymous interface would have the form:\n\n```\ninterface `unnamable {\n    commonToBoth: string;\n}\n```\n\nOr go wild and give this interface a name like:\n\n```\nIntersection[A | B] \nCommon[A | B]\nInterface[A | B] or\nInfc[A | B] //for brevity\n```\n\nThis does not have any use case I can think of, but perhaps I'm not thinking hard enough.\n\n---\n\n@DanielRosenwasser Yes I do. So consider this an upvote. =)\n",
        "createdAt" : "2014-11-04T09:03:51Z",
        "updatedAt" : "2014-11-04T10:01:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "6bf55b65-3bbd-423d-bd26-cd6243f0ff3f",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "@drubino you mean like in #957? :smiley: \n\nThis is a relatively old conversation at this point - you'll find quite a bit has happened recently with respect to union types, such as #914.\n",
        "createdAt" : "2014-11-04T09:04:52Z",
        "updatedAt" : "2014-11-04T09:04:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "4ff95561-da2c-45d8-b12d-7f3d0cc24364",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : null,
        "body" : "Haskell has union types denoted by `Either A B`. From conversations with members of the Haskell community, I've heard that this feature causes a lot of switch statements, leading to verbose, branching code. I'm not sure how to handle this, but perhaps one could create implicit type checks and blocks that use the order of the types as their listed on the union type. This keeps the syntax light-weight. \n\nSomething like:\n\n```\nvar x = A | B | C;\nfor x do {\n    ///Handle A\n} or {\n    ///Handle B\n} or {\n    //Handle c\n}\n```\n\nWhen combined with the anonymous interface idea, along with syntax to combine or skip blocks if logic can be implemented by common members in certain cases, you might be able enable the user to be quite succinct for common scenarios. \n",
        "createdAt" : "2014-11-04T09:15:34Z",
        "updatedAt" : "2014-11-04T09:54:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "84caecc4-e0e3-47bd-bc5a-4549f671b8c5",
        "parentId" : "651ea043-f985-4532-a6aa-724a486c3d91",
        "authorId" : null,
        "body" : "It might also be interesting to have a way of defining union types. Perhaps there is one master type that all others can be cast to, and the cast is specified in the definition. The compiler would then handle optimizations where casting can be proven to be unnecessary:\n\n```\nclass DynamicMatrix contains number | Array<number> | Matrix<number> {\n     super: Matrix<number>\n     (x: number): Array<number> =  x => [x];\n     (x: Array<number>): Matrix<number> = x => new Matrix([x]);\n     (x: Array<number>): number = x => x[0] \n         when x.length === 1\n         otherwise throw 'Array to number conversion is not possible';\n     (x: Matrix<number>): Array<number> = x => x[0] \n          when x.numberOfRows  = 1\n          otherwise throw 'Matrix to Array conversion is not possible';\n} \n```\n\nThis is probably a bit more complex than the design team had in mind for union types, but I thought I'd throw it out there all the same. \n\nI believe this, or features like it, would provide us with language constructs that would help to bridge the gap between dynamically typed languages and statically typed ones.\n",
        "createdAt" : "2014-11-04T09:40:56Z",
        "updatedAt" : "2014-11-04T09:40:56Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "f5cd4145d5e2e02672018c267dbfc00ee1d2ebcb",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1743,1747 @@        }\n\n        function parseType(): TypeNode {\n            var type = parseNonUnionType();\n            if (token === SyntaxKind.BarToken) {"
  },
  {
    "id" : "4c8d041f-5ac9-4d62-bffd-21e9dc3cfcc8",
    "prId" : 801,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "97785057-5320-43bd-8da6-bb22b5b5f870",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Might be worth factoring out into another function.\n",
        "createdAt" : "2014-10-01T23:18:16Z",
        "updatedAt" : "2014-10-01T23:18:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "93e5a94dc85feb67997a80c6e2f6437da8ed3d80",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +4020,4024 @@        function processReferencedFiles(file: SourceFile, basePath: string) {\n            forEach(file.referencedFiles, ref => {\n                var referencedFilename = isRootedDiskPath(ref.filename) ? ref.filename : combinePaths(basePath, ref.filename);\n                processSourceFile(normalizePath(referencedFilename), /* isDefaultLib */ false, file, ref.pos, ref.end);\n            });"
  },
  {
    "id" : "bcd8f82a-ff43-429e-91e0-0932d062ea97",
    "prId" : 676,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d96eff3-d4c6-4130-8b5d-d7490ca6f811",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you do `lookAhead(scanner.isReservedWord)`?\n",
        "createdAt" : "2014-09-15T21:52:10Z",
        "updatedAt" : "2014-09-18T00:31:05Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "150655e7-bb6c-41fc-a191-c880bcaba808",
        "parentId" : "2d96eff3-d4c6-4130-8b5d-d7490ca6f811",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I could but I would rather not. the problem would be in the future, if for whatever reason isReservedWord implementation uses this, it will break. this is also an error case, and not a main line scenario, so I am not too concerned about perf.\n",
        "createdAt" : "2014-09-16T20:21:54Z",
        "updatedAt" : "2014-09-18T00:31:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "e2d852b4-d7d3-4130-a810-b5acdcfb2011",
        "parentId" : "2d96eff3-d4c6-4130-8b5d-d7490ca6f811",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "calling lookAhead(... isREservedWord) doesn't seem right.  It missed hte simple case of:\n\n```\nname.\nclass C\n```\n\nC is not a reserved word, it is just an identifier\n",
        "createdAt" : "2014-09-16T21:58:07Z",
        "updatedAt" : "2014-09-18T00:31:05Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e00693163e7198f694161be62c92a7dd94b479e",
    "line" : 66,
    "diffHunk" : "@@ -1,1 +2256,2260 @@                    // In the first case though, ASI will not take effect because there is not a\n                    // line terminator after the keyword.\n                    if (scanner.hasPrecedingLineBreak() && scanner.isReservedWord() && lookAhead(() => scanner.isReservedWord())) {\n                        grammarErrorAtPos(dotStart, scanner.getStartPos() - dotStart, Diagnostics.Identifier_expected);\n                        var id = <Identifier>createMissingNode();"
  },
  {
    "id" : "f56dd1bd-1e0d-4a41-80b9-be4c6f2cff72",
    "prId" : 671,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "386d7dfa-25cf-446f-8469-28d3dea87534",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can we just check a range, and then check ExportAssignment?\n",
        "createdAt" : "2014-09-16T00:15:59Z",
        "updatedAt" : "2014-09-16T18:29:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "08f446ddf7e7514cda3a2aa4133e55e73b4473a7",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +507,511 @@            case SyntaxKind.WhileStatement:\n            case SyntaxKind.WithStatement:\n            case SyntaxKind.ExportAssignment:\n                return true;\n            default:"
  },
  {
    "id" : "da57f453-81ef-41ee-b18e-6c3cd3a5f00c",
    "prId" : 632,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dd75ac6e-121e-47a2-b726-91b23c453f57",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "return undefined.\n",
        "createdAt" : "2014-09-09T00:27:28Z",
        "updatedAt" : "2014-09-09T19:50:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "f5a4f837-b143-4e9b-85c9-0cd1b643546e",
        "parentId" : "dd75ac6e-121e-47a2-b726-91b23c453f57",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "still return undefined :)\n\nyou can also make this simpler with just:\n\n```\nwhile (node) {\n   switch (node.kind) { ... }\n   node = node.parent;\n}\n```\n",
        "createdAt" : "2014-09-09T19:31:37Z",
        "updatedAt" : "2014-09-09T19:50:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "d569e37a-31db-4bc8-8283-c702ed420aa1",
        "parentId" : "dd75ac6e-121e-47a2-b726-91b23c453f57",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "+1 for the undefined\n",
        "createdAt" : "2014-09-09T19:49:44Z",
        "updatedAt" : "2014-09-09T19:50:25Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "c5a2d4ec-4678-4c3d-8a07-c4538e77c21e",
        "parentId" : "dd75ac6e-121e-47a2-b726-91b23c453f57",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "The people have spoken, the `undefined` has prevailed :wink:.\n",
        "createdAt" : "2014-09-09T19:54:13Z",
        "updatedAt" : "2014-09-09T19:54:13Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "83c35ad059a440c0a49e31365967bcab1c13b10e",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +438,442 @@        while (true) {\n            node = node.parent;\n            if (!node) {\n                return undefined;\n            }"
  },
  {
    "id" : "2306c7f6-af76-4320-813f-28d792634ab8",
    "prId" : 473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "202ef4a1-cc82-49bc-9d5d-c633b5fd0569",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Again, put these back in checker, since they use parent.\n",
        "createdAt" : "2014-08-19T18:59:42Z",
        "updatedAt" : "2014-08-29T22:59:29Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "fb9a4b18-8b81-4d77-80c6-fc4ff5259d8a",
        "parentId" : "202ef4a1-cc82-49bc-9d5d-c633b5fd0569",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Think about moving these to a module, which would contain all syntax utilities that assume parent pointers have been set up\n",
        "createdAt" : "2014-08-19T19:01:41Z",
        "updatedAt" : "2014-08-29T22:59:29Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc0560ae596815838a67606a57b40d4f78a5de76",
    "line" : null,
    "diffHunk" : "@@ -1,1 +402,406 @@        return false;\n    }\n\n    enum ParsingContext {\n        SourceElements,          // Elements in source file"
  },
  {
    "id" : "87e58def-14a7-46c2-b073-0f58e9db230c",
    "prId" : 444,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c5c121d7-e8ef-42c7-950b-090b18368086",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I would make that options.\nthe batch compiler users do not care about version, LS users do, also version is not used in the batch compilation scenarios and all the LS entry points sets that; so you are probably fine with setting the version to undefined in batch.\n",
        "createdAt" : "2014-08-13T20:22:12Z",
        "updatedAt" : "2014-08-13T22:41:53Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "5df52b95-c4fc-4dee-b1ca-2920cd51fbbf",
        "parentId" : "c5c121d7-e8ef-42c7-950b-090b18368086",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "The problem with making things optional is that people forget to pass the right value in.  When i had it optional there were a bunch of places that were missed, thus causing the version of the source file to be wrong.\n",
        "createdAt" : "2014-08-13T21:39:31Z",
        "updatedAt" : "2014-08-13T22:41:53Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "088e58644aacfa734c75a18440e511e3a9cf3364",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +418,422 @@    }\n\n    export function createSourceFile(filename: string, sourceText: string, languageVersion: ScriptTarget, version: string, isOpen: boolean = false): SourceFile {\n        var file: SourceFile;\n        var scanner: Scanner;"
  },
  {
    "id" : "63880a88-faee-467c-bfa5-3bbc76c49c7a",
    "prId" : 365,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "529e4e5d-e6af-4b6a-920a-a94333161f44",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "Error message is a bit misleading since it says only about failed attempt to find .ts file.\n",
        "createdAt" : "2014-08-05T21:48:08Z",
        "updatedAt" : "2014-08-05T21:48:08Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "d290bf89-6e76-47f1-9426-3feaf55059e3",
        "parentId" : "529e4e5d-e6af-4b6a-920a-a94333161f44",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Agreed, but honestly not worth it to add another error message.\n",
        "createdAt" : "2014-08-05T21:50:55Z",
        "updatedAt" : "2014-08-05T21:50:55Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2a6b8a410d43b59b9ea1867d1d328290a2a75fa",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +3604,3608 @@            else {\n                if (!(findSourceFile(filename + \".ts\", isDefaultLib, refFile, refPos, refEnd) || findSourceFile(filename + \".d.ts\", isDefaultLib, refFile, refPos, refEnd))) {\n                    errors.push(createFileDiagnostic(refFile, start, length, Diagnostics.File_0_not_found, filename + \".ts\"));\n                }\n            }"
  },
  {
    "id" : "0c6eeb9e-a3df-44b3-8b8d-1040609586a7",
    "prId" : 256,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1018c920-cafb-47cd-aa09-666ffeab3591",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "when do you report the error for an accessor in an ambient context?  That should be done in the parser yes (as it's not gramattically legal)?\n",
        "createdAt" : "2014-07-29T08:07:04Z",
        "updatedAt" : "2014-07-29T08:07:04Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "dfac3e52-8f22-44e4-ad47-448620810b13",
        "parentId" : "1018c920-cafb-47cd-aa09-666ffeab3591",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Yes, check parser.ts, line 2862 (just 45 lines above this).\n",
        "createdAt" : "2014-07-29T18:29:30Z",
        "updatedAt" : "2014-07-29T18:29:30Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc80c300a0fa01d6eec76766cb8c67d3e8d45fe2",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +2905,2909 @@\n            // A common error is to try to declare an accessor in an ambient class.\n            if (inAmbientContext && canParseSemicolon()) {\n                parseSemicolon();\n                node.body = createMissingNode();"
  },
  {
    "id" : "e60bdebe-46fb-4cb1-ade9-510edc4d3d8b",
    "prId" : 217,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7088237-d417-4146-a9a2-cb175623e289",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "might want to Debug assert this then.\n",
        "createdAt" : "2014-07-23T22:22:39Z",
        "updatedAt" : "2014-07-24T20:12:00Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "82b4ff91-a404-42e5-9e00-7dc67687fd9a",
        "parentId" : "e7088237-d417-4146-a9a2-cb175623e289",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "done\n",
        "createdAt" : "2014-07-24T05:22:19Z",
        "updatedAt" : "2014-07-24T20:12:00Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c70d738dd658809311fa20ab88466e5d91a65cd",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +130,134 @@    }\n\n    /// Should be called only on prologue directives (isPrologueDirective(node) should be true)\n    function isUseStrictPrologueDirective(node: Node): boolean {\n        Debug.assert(isPrologueDirective(node));"
  },
  {
    "id" : "d1eda200-0f61-44a6-a848-e492857c83d5",
    "prId" : 217,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01ff3ad5-0efd-4464-b689-43716daf3194",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I don't think it's correct to set the `checkForStrictMode` flag here. See http://www.ecma-international.org/ecma-262/5.1/#sec-14.1 -- the directive prologue consists of _all_ the leading string literal expression statements, of which any might be \"use strict\"\n\ne.g. this code snippet _is_ strict mode and should error:\n\n``` ts\nfunction foo() {\n     \"extra awesome\";\n     \"use strict\";\n    var static = 0;\n}\n```\n",
        "createdAt" : "2014-07-24T05:49:10Z",
        "updatedAt" : "2014-07-24T20:12:00Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "87c4c178-a0e5-4105-b0e2-2a0f1ff6a714",
        "parentId" : "01ff3ad5-0efd-4464-b689-43716daf3194",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "@RyanCavanaugh  and it will error. `checkForStrictMode` just denotes whether element needs to be tested to be directive. Code will iterate through all directives, once `'use strict'` is found - global `isInStrictMode` flag will be set to `true` and `checkForStrictMode` - to `false` to skip checking other elements\n",
        "createdAt" : "2014-07-24T06:21:43Z",
        "updatedAt" : "2014-07-24T20:12:00Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "5e7976c4-bbd6-4ea0-a774-2d338d7dfde4",
        "parentId" : "01ff3ad5-0efd-4464-b689-43716daf3194",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Misread the `else` structure. :+1: \n",
        "createdAt" : "2014-07-24T19:42:17Z",
        "updatedAt" : "2014-07-24T20:12:00Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c70d738dd658809311fa20ab88466e5d91a65cd",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +807,811 @@                            if (isUseStrictPrologueDirective(element)) {\n                                isInStrictMode = true;\n                                checkForStrictMode = false;\n                            }\n                        }"
  },
  {
    "id" : "9a9c8e6a-5492-48c7-9341-94e03ef0ed2b",
    "prId" : 215,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e67df0c-a756-44b6-bcd8-80e58c1fe63f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Just add a little comment block explaining what this is going to do.\n",
        "createdAt" : "2014-07-24T22:56:49Z",
        "updatedAt" : "2014-07-25T00:48:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "86007cc1379e6d3be706f4834f71ac0c710bf81f",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +427,431 @@        var inSwitchStatement = ControlBlockContext.NotNested;\n        var inIterationStatement = ControlBlockContext.NotNested;\n\n        // The following is a state machine that tracks what labels are in our current parsing\n        // context. So if we are parsing a node that is nested (arbitrarily deeply) in a label,"
  },
  {
    "id" : "bb0ef521-c91c-4367-9de9-806b7a5e12b3",
    "prId" : 203,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8072b45-d49c-48d6-9706-b6ef885850f2",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Why did tihs comment move outside of the block that it is relevant to?\n",
        "createdAt" : "2014-07-23T00:08:44Z",
        "updatedAt" : "2014-07-25T01:20:16Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b49d749f-1a33-4185-9b2c-c09da71fa97f",
        "parentId" : "b8072b45-d49c-48d6-9706-b6ef885850f2",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Felt like it would be more consistent since all the other comment blocks reside outside the checks. I'm feeling against it now.\n",
        "createdAt" : "2014-07-23T00:09:57Z",
        "updatedAt" : "2014-07-25T01:20:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "becbab6f-d622-4700-851f-79b190aca5c7",
        "parentId" : "b8072b45-d49c-48d6-9706-b6ef885850f2",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Actually, with different phrasing, I think it might be fine.\n",
        "createdAt" : "2014-07-23T00:12:16Z",
        "updatedAt" : "2014-07-25T01:20:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0c59e7c376f5bfbbe81c2ff31725d919347fa64",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1518,1522 @@                        // \"(public\" or \"(private\". These would not ever actually be allowed,\n                        // but we could provide a good error message instead of bailing out.\n                        if (!isIdentifier()) {\n                            return Tristate.False;\n                        }"
  },
  {
    "id" : "0d337747-bb7d-4d67-af58-a3a7b6b783a6",
    "prId" : 203,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfa4c6ce-d72e-4204-ae82-ecac1cdb51a5",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What happens in the following case?\n\n``` TS\nvar a = true ? () : false;\n```\n",
        "createdAt" : "2014-07-25T00:04:07Z",
        "updatedAt" : "2014-07-25T01:20:16Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "112d7965-845e-4a98-84a7-46d255a34a3c",
        "parentId" : "dfa4c6ce-d72e-4204-ae82-ecac1cdb51a5",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Good point, but that's not a valid expression anyway. Cyrus and I discussed this offline, and it doesn't seem like you'd get such a big win there.\n\nStill, if you'd like to file a bug for it, I'd be more than happy to take it on.\n",
        "createdAt" : "2014-07-25T01:41:23Z",
        "updatedAt" : "2014-07-25T01:41:23Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "9c1dacb8-4da6-4c72-ba16-0e68c6927ea8",
        "parentId" : "dfa4c6ce-d72e-4204-ae82-ecac1cdb51a5",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think it's ok\n",
        "createdAt" : "2014-07-25T17:13:38Z",
        "updatedAt" : "2014-07-25T17:13:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0c59e7c376f5bfbbe81c2ff31725d919347fa64",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +1499,1503 @@                            switch (third) {\n                                case SyntaxKind.EqualsGreaterThanToken:\n                                case SyntaxKind.ColonToken:\n                                case SyntaxKind.OpenBraceToken:\n                                    return Tristate.True;"
  },
  {
    "id" : "211e0214-d7d7-49be-b5cc-f6ac89a088e3",
    "prId" : 199,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e8d2e27-b9ca-42b5-8c28-b490c28ea03a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "on the right of a dot, shouldn't we always allow reservedWords?\n",
        "createdAt" : "2014-07-22T23:59:06Z",
        "updatedAt" : "2014-07-23T17:21:28Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "086e831a-66d0-4ccb-b8ff-b5325eed3b1b",
        "parentId" : "9e8d2e27-b9ca-42b5-8c28-b490c28ea03a",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Ah, n/m.  i see the subtlety here.  Could you doc the reasoning behind this.  Specifically, that normally an Entity name could never have keywords in it, since it can only refer to module names on the left, and an identifier on the right (and module names can only be identifiers).  however, for typeof, you need to allow identifier names on the right.\n",
        "createdAt" : "2014-07-23T00:05:16Z",
        "updatedAt" : "2014-07-23T17:21:28Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "6fa5b502-cd7e-4c38-b094-cf62f979d800",
        "parentId" : "9e8d2e27-b9ca-42b5-8c28-b490c28ea03a",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Right, it parses an _EntityName_ by default but when you specify true for the optional parameter it parses a _TypeQueryExpression_. I can add a comment to that effect.\n",
        "createdAt" : "2014-07-23T00:30:41Z",
        "updatedAt" : "2014-07-23T17:21:28Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c594d06a234ad095d94dbb53cc044b40956cbb1",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +872,876 @@                var node = <QualifiedName>createNode(SyntaxKind.QualifiedName, entity.pos);\n                node.left = entity;\n                node.right = allowReservedWords ? parseIdentifierName() : parseIdentifier();\n                entity = finishNode(node);\n            }"
  },
  {
    "id" : "96cfae55-0fa3-46ab-83ec-b2d88bb18921",
    "prId" : 173,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44079b4a-b928-4a25-98a3-f65ec40c259c",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "that doesn't sound right.  parseList doesn't have delimeters.\n",
        "createdAt" : "2014-07-22T06:18:57Z",
        "updatedAt" : "2014-07-22T06:18:57Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "34073fa0-057f-40ec-a4e6-97debfb0a62d",
        "parentId" : "44079b4a-b928-4a25-98a3-f65ec40c259c",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Corrected in f37cf1647d406c809d05299a267720cf6128ca91.\n",
        "createdAt" : "2014-07-22T06:44:15Z",
        "updatedAt" : "2014-07-22T06:44:15Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa04d4d699c8122ffcd6d96514aa87804526c21c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +767,771 @@        }\n\n        // Parses a semicolon-delimited list of elements\n        function parseList<T extends Node>(kind: ParsingContext, parseElement: () => T): NodeArray<T> {\n            var saveParsingContext = parsingContext;"
  }
]
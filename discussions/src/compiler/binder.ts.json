[
  {
    "id" : "526ee73f-da34-4739-8d4c-f0de3612866d",
    "prId" : 41094,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/41094#pullrequestreview-520098648",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d3327ae-5702-470b-89f0-bd7e1726d88b",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Doesn't this need to be a (bail) case within `bindBinaryExpressionFlow` to handle when an inner binary expression is a restructuring assignment?",
        "createdAt" : "2020-10-29T03:20:18Z",
        "updatedAt" : "2020-10-29T20:32:42Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "ee16664e-9637-48fd-9104-05e8f54b1fe7",
        "parentId" : "0d3327ae-5702-470b-89f0-bd7e1726d88b",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I've updated to have `maybeBind` exclude destructuring assignments so that it goes through the regular `bind` flow (and thus hits the escape above).",
        "createdAt" : "2020-10-29T21:23:31Z",
        "updatedAt" : "2020-10-29T21:23:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "3b9786a3-f8d7-4384-a566-2e39b1eec7ae",
        "parentId" : "0d3327ae-5702-470b-89f0-bd7e1726d88b",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I've also added test cases for the destructuring assignment appearing on either side of a binary expression.",
        "createdAt" : "2020-10-29T21:24:06Z",
        "updatedAt" : "2020-10-29T21:24:06Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b7e790732b760bb3b6cd49711098e8345b130bb",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +801,805 @@                    break;\n                case SyntaxKind.BinaryExpression:\n                    if (isDestructuringAssignment(node)) {\n                        // Carry over whether we are in an assignment pattern to\n                        // binary expressions that could actually be an initializer"
  },
  {
    "id" : "7af29a92-1310-4cd4-a7f2-caf727add99c",
    "prId" : 40260,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/40260#pullrequestreview-475653997",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ed9bba09-aaaf-4359-9c12-e8002b5d2900",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "😲",
        "createdAt" : "2020-08-26T16:22:18Z",
        "updatedAt" : "2020-09-09T10:42:25Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "cc1768cdb80b601bd7cefd9a7fb2a6586e69ad5d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +661,665 @@                // We create a return control flow graph for IIFEs and constructors. For constructors\n                // we use the return control flow graph in strict property initialization checks.\n                currentReturnTarget = isIIFE || node.kind === SyntaxKind.Constructor || (isInJSFile(node) && (node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.FunctionExpression)) ? createBranchLabel() : undefined;\n                currentExceptionTarget = undefined;\n                currentBreakTarget = undefined;"
  },
  {
    "id" : "776d5fce-dc52-48f4-b20d-5481d3b84958",
    "prId" : 40260,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/40260#pullrequestreview-475654144",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "db86b5a9-8a9a-4392-a89d-980b0f7ea8ce",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "😲 😭",
        "createdAt" : "2020-08-26T16:22:30Z",
        "updatedAt" : "2020-09-09T10:42:25Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "cc1768cdb80b601bd7cefd9a7fb2a6586e69ad5d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +682,686 @@                    addAntecedent(currentReturnTarget, currentFlow);\n                    currentFlow = finishFlowLabel(currentReturnTarget);\n                    if (node.kind === SyntaxKind.Constructor || (isInJSFile(node) && (node.kind === SyntaxKind.FunctionDeclaration || node.kind === SyntaxKind.FunctionExpression))) {\n                        (<FunctionLikeDeclaration>node).returnFlowNode = currentFlow;\n                    }"
  },
  {
    "id" : "8ba61a23-83f2-42bc-b4ab-0e2c54e3ea11",
    "prId" : 39955,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39955#pullrequestreview-466285252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "844c3a4c-0020-436b-a999-30e30ec321ea",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "could this be written positively as\r\n\r\n```suggestion\r\n            if (isJSDocTypedefTag(node) && !!node.fullName) return true;\r\n```\r\nI think enum and typedef are the only two possibilities here. Oh wait, maybe callback is too.",
        "createdAt" : "2020-08-12T21:19:32Z",
        "updatedAt" : "2020-08-12T21:21:33Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6d74dcc1b6f6523ff442656d5b829bdb7674e8a",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +588,592 @@            // jsdoc typedef handling is a bit of a doozy, but to summarize, treat the typedef as exported if:\n            // 1. It has an explicit name (since by default typedefs are always directly exported, either at the top level or in a container), or\n            if (!isJSDocEnumTag(node) && !!node.fullName) return true;\n            // 2. The thing a nameless typedef pulls its name from is implicitly a direct export (either by assignment or actual export flag).\n            const declName = getNameOfDeclaration(node);"
  },
  {
    "id" : "a0e34dea-d7bf-4cd7-8ef4-4fb3b5eff117",
    "prId" : 39955,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39955#pullrequestreview-466285252",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "40fd98ec-39c4-48bc-afb9-1a078c6462f7",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "is the code below here only for nameless typedefs, or can `declName` be a node inside a jsdoc comment?",
        "createdAt" : "2020-08-12T21:20:57Z",
        "updatedAt" : "2020-08-12T21:21:33Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6d74dcc1b6f6523ff442656d5b829bdb7674e8a",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +590,594 @@            if (!isJSDocEnumTag(node) && !!node.fullName) return true;\n            // 2. The thing a nameless typedef pulls its name from is implicitly a direct export (either by assignment or actual export flag).\n            const declName = getNameOfDeclaration(node);\n            if (!declName) return false;\n            if (isPropertyAccessEntityNameExpression(declName.parent) && isTopLevelNamespaceAssignment(declName.parent)) return true;"
  },
  {
    "id" : "d9c6c249-af82-455f-8bc3-0dabc22a572a",
    "prId" : 39770,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/39770#pullrequestreview-456010124",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b33fd912-a015-459f-ad5b-7c7bb9b7efee",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "note that once this works well enough, we could turn it on in TS as well, which would be pretty great.",
        "createdAt" : "2020-07-27T17:57:36Z",
        "updatedAt" : "2020-08-17T20:37:50Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c7897e4d227ce492dedd2e7966d7d7a1aac18b5",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3210,3214 @@\n            if (!isBindingPattern(node.name)) {\n                if (isInJSFile(node) && isRequireVariableDeclaration(node, /*requireStringLiteralLikeArgument*/ true) && !getJSDocTypeTag(node)) {\n                    declareSymbolAndAddToSymbolTable(node as Declaration, SymbolFlags.Alias, SymbolFlags.AliasExcludes);\n                }"
  },
  {
    "id" : "40e2944c-e531-40d5-8945-dd41063071bb",
    "prId" : 38270,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/38270#pullrequestreview-408461539",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9e73902-af43-46be-838e-260370304b0b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "```suggestion\r\n            Debug.assertNotNode(node, isIdentifier);\r\n```",
        "createdAt" : "2020-05-08T19:11:42Z",
        "updatedAt" : "2020-05-08T19:11:42Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "add6bbcfce5f2b317bcb8cbb82852012f4e6acff",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +2993,2997 @@         */\n        function bindStaticPropertyAssignment(node: BindableStaticNameExpression) {\n            Debug.assert(!isIdentifier(node));\n            node.expression.parent = node;\n            bindPropertyAssignment(node.expression, node, /*isPrototypeProperty*/ false, /*containerIsClass*/ false);"
  },
  {
    "id" : "e28c16c0-edcb-4429-a51d-70d28f1022eb",
    "prId" : 38031,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/38031#pullrequestreview-398559726",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4bac4eaa-94f5-4b2f-be8e-f496a228e2d4",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "silly question: what happens if you *just* use blockScopeContainer? I assume that some other tests break.",
        "createdAt" : "2020-04-22T17:41:52Z",
        "updatedAt" : "2020-04-24T15:56:45Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "55bd5580-ae26-4960-a0e3-3f3988c9f97e",
        "parentId" : "4bac4eaa-94f5-4b2f-be8e-f496a228e2d4",
        "authorId" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "body" : "I was pairing with Orta on this and I did try this, and stuff did fail. It was a little surprising to me, but I didn’t have time to dig into why that was the case.",
        "createdAt" : "2020-04-22T17:48:33Z",
        "updatedAt" : "2020-04-24T15:56:45Z",
        "lastEditedBy" : "7b7aae27-4774-41a7-bce2-94c871708547",
        "tags" : [
        ]
      },
      {
        "id" : "e10ef7d0-630a-421a-b810-5eb8a7a0e865",
        "parentId" : "4bac4eaa-94f5-4b2f-be8e-f496a228e2d4",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`blockScopeContaininer` only contains the block scoped (`class`, `const`, `let`) stuff. function-scoped stuff (like function declarations and `var`s), will only be in the function container (assuming they're different).",
        "createdAt" : "2020-04-22T20:26:57Z",
        "updatedAt" : "2020-04-24T15:56:45Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "1c9ca2df0b23a53c7af11842c6b03da386513e47",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +3084,3088 @@\n        function bindPropertyAssignment(name: BindableStaticNameExpression, propertyAccess: BindableStaticAccessExpression, isPrototypeProperty: boolean, containerIsClass: boolean) {\n            let namespaceSymbol = lookupSymbolForPropertyAccess(name, container) || lookupSymbolForPropertyAccess(name, blockScopeContainer);\n            const isToplevel = isTopLevelNamespaceAssignment(propertyAccess);\n            namespaceSymbol = bindPotentiallyMissingNamespaces(namespaceSymbol, propertyAccess.expression, isToplevel, isPrototypeProperty, containerIsClass);"
  },
  {
    "id" : "cc7b7acd-7468-4979-adc2-e9e4c1b61164",
    "prId" : 36387,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/36387#pullrequestreview-348100326",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "92d552dd-1e4d-469f-b522-cebe3b73124b",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "this comment probably isn't needed; we do this in a number of places in the binder and it's an invariant that you'll bump into pretty quickly when writing binder code.",
        "createdAt" : "2020-01-24T17:06:30Z",
        "updatedAt" : "2020-01-24T17:07:08Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "1fb883a7-9371-4d66-81f0-6f1740a94c18",
        "parentId" : "92d552dd-1e4d-469f-b522-cebe3b73124b",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Actually we don't. There's only _one_ other instance of `declareSymbol` being called on a child of the current node - it's in special property handling and notably, it does _not_ set the parent, so very likely may actually be indicative of a similar bug.",
        "createdAt" : "2020-01-24T17:13:36Z",
        "updatedAt" : "2020-01-24T17:13:36Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2908f958823e3ef3955d57a53327c29abddd58d",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2610,2614 @@            else if (isNamespaceExport(node.exportClause)) {\n                // declareSymbol walks up parents to find name text, parent _must_ be set\n                // but won't be set by the normal binder walk until `bindChildren` later on.\n                node.exportClause.parent = node;\n                declareSymbol(container.symbol.exports, container.symbol, node.exportClause, SymbolFlags.Alias, SymbolFlags.AliasExcludes);"
  },
  {
    "id" : "cc8fdf3b-e18a-48dc-98ee-849742d0068a",
    "prId" : 35095,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/35095#pullrequestreview-316798789",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "936478f4-777a-4083-b4ea-12e18a3accb8",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "is this change related to the emitter?\r\nIf so, you probably also want to make the same change in `computePropertyDeclaration` (see #35097 which I erroneously opened)",
        "createdAt" : "2019-11-14T09:05:23Z",
        "updatedAt" : "2019-11-21T18:50:32Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      }
    ],
    "commit" : "c88a9b8b10cac81de7a2fe21ec5e0723621fad49",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3808,3812 @@\n        // Type annotations are TypeScript syntax.\n        if (node.type || node.exclamationToken) {\n            transformFlags |= TransformFlags.AssertTypeScript;\n        }"
  },
  {
    "id" : "39241e3b-cbde-4761-821c-f17f596d223f",
    "prId" : 33220,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/33220#pullrequestreview-285141250",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c534fd4-978a-4cec-b74f-af7a1c3b3005",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "this is such a complicated, yet nearly identical, addition in all 3 places, I wonder if it's possible to de-dupe the code at all. At least the first two changes are basically the same.",
        "createdAt" : "2019-09-06T22:24:59Z",
        "updatedAt" : "2019-09-27T20:31:03Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "93877c12-9f9a-4e09-b183-bbe58eef049d",
        "parentId" : "1c534fd4-978a-4cec-b74f-af7a1c3b3005",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Yeah, I was thinking the same thing when I started to write the 3rd one.",
        "createdAt" : "2019-09-06T23:50:26Z",
        "updatedAt" : "2019-09-27T20:31:03Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "11b344897672d76845b88b720d20d1b52b79e926",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2623,2627 @@                        constructorSymbol.members = constructorSymbol.members || createSymbolTable();\n                        // It's acceptable for multiple 'this' assignments of the same identifier to occur\n                        if (hasDynamicName(node)) {\n                            bindDynamicallyNamedThisPropertyAssignment(node, constructorSymbol);\n                        }"
  },
  {
    "id" : "07e9b0b6-66ab-4316-8e23-d520d4feee7e",
    "prId" : 33220,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/33220#pullrequestreview-292623219",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "454c2009-d2f9-404b-bd08-c8fba012d34a",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "changing the shape of `Symbol` makes me think we should run the perf tests as a precaution.",
        "createdAt" : "2019-09-24T18:36:55Z",
        "updatedAt" : "2019-09-27T20:31:03Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "11b344897672d76845b88b720d20d1b52b79e926",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +2671,2675 @@        function addLateBoundAssignmentDeclarationToSymbol(node: BinaryExpression | DynamicNamedDeclaration, symbol: Symbol | undefined) {\n            if (symbol) {\n                const members = symbol.assignmentDeclarationMembers || (symbol.assignmentDeclarationMembers = createMap());\n                members.set(\"\" + getNodeId(node), node);\n            }"
  },
  {
    "id" : "9cdba9cc-bd53-4255-a71e-405891f9b681",
    "prId" : 32883,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32883#pullrequestreview-284467904",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "860d56ff-89b8-48d7-a731-483488902c97",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Do you also need to handle `isExpandoSymbol` since it has specialization for `||`",
        "createdAt" : "2019-09-05T18:52:10Z",
        "updatedAt" : "2019-09-30T22:14:43Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "b030f730d029422ca7a6767134f51bed48354675",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +3429,3433 @@            transformFlags |= TransformFlags.AssertESNext;\n        }\n        else if (operatorTokenKind === SyntaxKind.EqualsToken && leftKind === SyntaxKind.ObjectLiteralExpression) {\n            // Destructuring object assignments with are ES2015 syntax\n            // and possibly ES2018 if they contain rest"
  },
  {
    "id" : "73dee2e7-ef22-4e3f-b568-3ad94d76293f",
    "prId" : 32883,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32883#pullrequestreview-294038982",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "82813cc0-2d71-4930-a387-5bbe75b855d7",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "`??` isn't really a logical operator. This results in control-flow treating the branch as something \"truthy\" not something defined/undefined. \r\n\r\nI'd like to see some tests for control flow.",
        "createdAt" : "2019-09-26T22:35:02Z",
        "updatedAt" : "2019-09-30T22:14:43Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "b030f730d029422ca7a6767134f51bed48354675",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +1017,1021 @@                        (<BinaryExpression>node).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken ||\n                        (<BinaryExpression>node).operatorToken.kind === SyntaxKind.BarBarToken ||\n                        (<BinaryExpression>node).operatorToken.kind === SyntaxKind.QuestionQuestionToken);\n                }\n            }"
  },
  {
    "id" : "d4bf645c-fd60-4b55-b319-cd33f9042d64",
    "prId" : 32883,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32883#pullrequestreview-294464096",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "648e84e4-7998-453c-9595-f71e26cf58e5",
        "parentId" : null,
        "authorId" : "82099593-2916-4461-9564-9ad9860d81b1",
        "body" : "Nit: This if-chain would be easier to read as a `switch`",
        "createdAt" : "2019-09-27T16:57:34Z",
        "updatedAt" : "2019-09-30T22:14:43Z",
        "lastEditedBy" : "82099593-2916-4461-9564-9ad9860d81b1",
        "tags" : [
        ]
      },
      {
        "id" : "cb9cebb0-7ef0-4437-9e13-353041532274",
        "parentId" : "648e84e4-7998-453c-9595-f71e26cf58e5",
        "authorId" : "b34d84f4-89ab-4dd2-92e3-8e7d670020b5",
        "body" : "I prefer to keep this because of so many other code similar to that.\r\n",
        "createdAt" : "2019-09-27T17:29:43Z",
        "updatedAt" : "2019-09-30T22:14:43Z",
        "lastEditedBy" : "b34d84f4-89ab-4dd2-92e3-8e7d670020b5",
        "tags" : [
        ]
      }
    ],
    "commit" : "b030f730d029422ca7a6767134f51bed48354675",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1468,1472 @@        function bindBinaryExpressionFlow(node: BinaryExpression) {\n            const operator = node.operatorToken.kind;\n            if (operator === SyntaxKind.AmpersandAmpersandToken || operator === SyntaxKind.BarBarToken || operator === SyntaxKind.QuestionQuestionToken) {\n                if (isTopLevelLogicalExpression(node)) {\n                    const postExpressionLabel = createBranchLabel();"
  },
  {
    "id" : "06ff314d-ad2b-4ee4-80f3-b0472152ac73",
    "prId" : 32695,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32695#pullrequestreview-270473990",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b42a5e94-408b-4f13-968f-76672bb36913",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "what's the difference to `isEntityNameExpression`?",
        "createdAt" : "2019-08-03T19:15:19Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "7e2aebd4-f2d1-41e3-ba56-16d70b49b740",
        "parentId" : "b42a5e94-408b-4f13-968f-76672bb36913",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Good catch! No difference, will change to use the existing function.",
        "createdAt" : "2019-08-03T21:54:31Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcdf33d8de066b827e8251875675b7a0084446c5",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +1288,1292 @@        }\n\n        function isDottedName(node: Expression): boolean {\n            return node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.ThisKeyword ||\n                node.kind === SyntaxKind.PropertyAccessExpression && isDottedName((<PropertyAccessExpression>node).expression) ||"
  },
  {
    "id" : "1c7def01-2885-42d4-96e9-f166bf9050ab",
    "prId" : 32695,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32695#pullrequestreview-285780388",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56da0f41-8db2-4b33-a15b-f11c12546db7",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Before I forget: Even if we don't support them, we'll need tests for our behavior of:\r\n* Assertion constructors (arguably reasonable to support, just because construction is just calling with a replaced return value, minimally in the context of callable constructors a la js functions, it should be tested)\r\n* Assertion tagged templates (a tagged template is _actually_ just a call, but given a valid template type signature, the most you could say is something like `function html(text: TemplateStringsArray, holes: any[]): asserts holes[0] is Something` which is... interesting.)\r\n* Assertion decorators (I don't even know what someone would expect here - asserting the type of the class your wrapping?)\r\n* Assertion JSX tags (lolwut - jsx tags are fake calls, so at best you could assert something about one of the props you're passed in?)\r\n* Getter/setter pairs with assertion predicates",
        "createdAt" : "2019-09-09T21:17:05Z",
        "updatedAt" : "2019-09-21T00:44:33Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "bcdf33d8de066b827e8251875675b7a0084446c5",
    "line" : 130,
    "diffHunk" : "@@ -1,1 +1298,1302 @@            // A top level call expression with a dotted function name and at least one argument\n            // is potentially an assertion and is therefore included in the control flow.\n            if (node.expression.kind === SyntaxKind.CallExpression) {\n                const call = <CallExpression>node.expression;\n                if (isDottedName(call.expression)) {"
  },
  {
    "id" : "7f5e5062-a167-4d8a-9965-e73d53f60aa9",
    "prId" : 32610,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32610#pullrequestreview-270423968",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94361d24-0829-4ddc-9f86-bd7cf6a96663",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "over-commenting seems like the right thing for this function. can you add to the explanation above?\r\nedit: it seems like this is just a simple prerequisite to make this not crash, so maybe not.",
        "createdAt" : "2019-08-02T21:53:19Z",
        "updatedAt" : "2019-08-02T22:58:33Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "e4d66ba1-d56d-4d45-801e-0bd7e3cacd26",
        "parentId" : "94361d24-0829-4ddc-9f86-bd7cf6a96663",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Yah, indeed it is. `Assignment`s can occasionally merge into things that have `export`s, but not `local`s (ie, classes), so, y'know.",
        "createdAt" : "2019-08-02T22:53:17Z",
        "updatedAt" : "2019-08-02T22:58:33Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "af569fb68b7c1195b6177379de78bad8deea0a19",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +491,495 @@                if (isJSDocTypeAlias(node)) Debug.assert(isInJSFile(node)); // We shouldn't add symbols for JSDoc nodes if not in a JS file.\n                if ((!isAmbientModule(node) && (hasExportModifier || container.flags & NodeFlags.ExportContext)) || isJSDocTypeAlias(node)) {\n                    if (!container.locals || (hasModifier(node, ModifierFlags.Default) && !getDeclarationName(node))) {\n                        return declareSymbol(container.symbol.exports!, container.symbol, node, symbolFlags, symbolExcludes); // No local symbol for an unnamed default!\n                    }"
  },
  {
    "id" : "69707af1-c49a-470a-ad6f-1b46840d0723",
    "prId" : 32372,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/32372#pullrequestreview-292664471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c503239e-f147-4e73-96cf-24114249e739",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "this very likely obsoletes some syntactic code in the checker. But are you sure it doesn't cause these symbols to take incorrect code paths in the checker sometimes? I guess tests would fail if it did.",
        "createdAt" : "2019-09-24T18:54:49Z",
        "updatedAt" : "2019-09-26T21:10:12Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "d0934317-47fe-4749-a268-e7caaa32bba8",
        "parentId" : "c503239e-f147-4e73-96cf-24114249e739",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Yah, definitely seemed like the symbol was missing an `Assignment` flag.",
        "createdAt" : "2019-09-24T19:45:47Z",
        "updatedAt" : "2019-09-26T21:10:12Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "007b3d4afe7726f7b72cd617e5453c8943e48ad2",
    "line" : 120,
    "diffHunk" : "@@ -1,1 +2637,2641 @@                    const containingClass = thisContainer.parent;\n                    const symbolTable = hasModifier(thisContainer, ModifierFlags.Static) ? containingClass.symbol.exports! : containingClass.symbol.members!;\n                    declareSymbol(symbolTable, containingClass.symbol, node, SymbolFlags.Property | SymbolFlags.Assignment, SymbolFlags.None, /*isReplaceableByMethod*/ true);\n                    break;\n                case SyntaxKind.SourceFile:"
  },
  {
    "id" : "6c906d8b-3de7-4ef2-a52b-83971ea13eae",
    "prId" : 30829,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30829#pullrequestreview-260061659",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ede2af7f-1ca4-49ae-8c11-a1082b2ff806",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "should this be an assert? Or are we going to issue an error later on, in the checker or something?",
        "createdAt" : "2019-07-02T21:14:58Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "101c2913-e06f-4925-9a0d-d27e543641fc",
        "parentId" : "ede2af7f-1ca4-49ae-8c11-a1082b2ff806",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "Currently, this errors in the parser, but we can change that:\r\nDiscussion:\r\nhttps://github.com/microsoft/TypeScript/pull/30829/files/61b95d03685279d2188eaf117500fa2b2083d7e6#r299706018",
        "createdAt" : "2019-07-03T13:21:18Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "7357777d-68b4-4258-b189-4488ad54ef3d",
        "parentId" : "ede2af7f-1ca4-49ae-8c11-a1082b2ff806",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "Added a Debug.fail. I agree it's best not to silently do the wrong thing if we get into this weird state.",
        "createdAt" : "2019-07-03T20:17:33Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "18d9628c-a327-453a-b86c-b4b5e9b2e7e8",
        "parentId" : "ede2af7f-1ca4-49ae-8c11-a1082b2ff806",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "Whoops. Removing the Debug.fail breaks a test. Turns out the behavior without `Debug.fail` is closer to what I think we want:\r\nIn the case where this code path gets hit, the parser has already queued a DiagnosticMessage:\r\n\r\n`error TS18016: Private names are not allowed outside class bodies.`\r\n\r\nThe error message from the parser seems better to me than a Debug.fail, since we get localized error messages and the compiler can keep going.\r\n\r\n\r\n",
        "createdAt" : "2019-07-10T12:35:25Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbb84d1e81b35f944d994f6c71c3eda40f944b85",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +363,367 @@                    // containingClass exists because private names only allowed inside classes\n                    const containingClass = getContainingClass(node);\n                    if (!containingClass) {\n                        // we can get here in cases where there is already a parse error.\n                        return undefined;"
  },
  {
    "id" : "9fafe14a-2349-43b5-ad9b-d1070cb2e75e",
    "prId" : 30829,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/30829#pullrequestreview-267711568",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae5d2141-08b3-40cd-a64e-dca27de6235f",
        "parentId" : null,
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "@sandersn responding to your [question](https://github.com/microsoft/TypeScript/pull/30829#pullrequestreview-262682575)\r\n\r\n> Also still need some js tests, particularly to make sure that this-property assignments in the constructor give a reasonable error suggesting a private property declaration.\r\n\r\n> (I don't think GH provides threaded replies for comments that aren't on a line of code)\r\n\r\nYour example points to something I messed up, We don't currently error on this *in JS files*:\r\n\r\n```js\r\nclass A {\r\n    constructor () {\r\n        this.#foo = 3; // should error here, but we don't yet \r\n    }\r\n}\r\n```\r\n\r\nDo you have other suggestions for things that are different between a JS file and a TS file where everything is `any`? I can't think of other differences.\r\n\r\nThanks for your help!",
        "createdAt" : "2019-07-17T16:51:17Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "132984ab-2eb5-4f9a-8b36-b008af16b353",
        "parentId" : "ae5d2141-08b3-40cd-a64e-dca27de6235f",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Static property assignment should be disallowed too:\r\n\r\n```js\r\nclass A { }\r\nA.#no = 3\r\n```\r\n\r\nPre-property declarations, I think this was the only way to make static properties, right?",
        "createdAt" : "2019-07-19T17:05:38Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "75b5a1e9-ae28-4508-b355-eef464d2c51f",
        "parentId" : "ae5d2141-08b3-40cd-a64e-dca27de6235f",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "prototype assignment shouldn't work, although I think there is very little chance it will:\r\n\r\n```js\r\nfunction A() { }\r\nA.prototype = {\r\n  #x: 1\r\n}\r\nclass B { }\r\n// this is wrong in several ways!\r\nB.prototype = {\r\n  #y: 2\r\n}\r\n```",
        "createdAt" : "2019-07-19T17:07:09Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "f92eb14c-a50f-450a-94a2-23db7edf6e41",
        "parentId" : "ae5d2141-08b3-40cd-a64e-dca27de6235f",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "And exports/prototype property assignment?  \r\n\r\n```js\r\nexports.#nope = 1\r\nfunction A() { }\r\nA.prototype.#no = 2\r\n```\r\n\r\nEdit: this property assignment and static property assignment should give good errors, prototype and prototype property assignment should not give bad errors, and export property assignment doesn't really matter.",
        "createdAt" : "2019-07-19T17:08:50Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "86ebbce8-ec96-4aea-8b11-fcde8f750e0c",
        "parentId" : "ae5d2141-08b3-40cd-a64e-dca27de6235f",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "Thanks very much for these examples! I incorporated them into these new tests:\r\n- `privateNamesJsBadAssignment`\r\n- `privateNamesJsBadDeclaration`\r\n\r\nThe error messages seem OK (imo), but there is a verbosity issue related to something we discussed earlier:\r\n- https://github.com/microsoft/TypeScript/pull/30829/files/f5936ed28c50cf89a803a1556f9f28fed43e7d5f#r305455175\r\n\r\n",
        "createdAt" : "2019-07-22T11:12:08Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      },
      {
        "id" : "6407f5e9-a946-4163-8919-f25cbba2b2db",
        "parentId" : "ae5d2141-08b3-40cd-a64e-dca27de6235f",
        "authorId" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "body" : "consolidating https://github.com/microsoft/TypeScript/pull/30829/files/f5936ed28c50cf89a803a1556f9f28fed43e7d5f#r305455175",
        "createdAt" : "2019-07-29T11:05:00Z",
        "updatedAt" : "2019-12-24T10:22:58Z",
        "lastEditedBy" : "7c818427-dca2-4bb8-94a1-f7e70e4a264a",
        "tags" : [
        ]
      }
    ],
    "commit" : "fbb84d1e81b35f944d994f6c71c3eda40f944b85",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +360,364 @@                    return getPropertyNameForKnownSymbolName(idText(name.name));\n                }\n                if (isPrivateIdentifier(name)) {\n                    // containingClass exists because private names only allowed inside classes\n                    const containingClass = getContainingClass(node);"
  },
  {
    "id" : "7359c67f-e72a-40da-8a6a-45a3c102c1d9",
    "prId" : 29466,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/29466#pullrequestreview-193889378",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e7ef996-a320-41c6-82e7-0bbb4097cf13",
        "parentId" : null,
        "authorId" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "body" : "Does this condition make sense? It's only false if there is a syntax error. ",
        "createdAt" : "2019-01-17T21:46:20Z",
        "updatedAt" : "2019-01-18T21:49:23Z",
        "lastEditedBy" : "fda8894a-88d1-42dd-a55e-7a8592225c11",
        "tags" : [
        ]
      },
      {
        "id" : "e9f50723-2c88-4e0a-8811-3a11655429cf",
        "parentId" : "6e7ef996-a320-41c6-82e7-0bbb4097cf13",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "We still parse code with syntax errors 🤷‍♂️ ",
        "createdAt" : "2019-01-17T23:21:58Z",
        "updatedAt" : "2019-01-18T21:49:23Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8498f3a2db751ef5c8cbb75521a047cc7faa5022",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +1091,1095 @@            // as possible antecedents of the start of the `catch` or `finally` blocks.\n            // Don't bother intercepting the call if there's no finally or catch block that needs the information\n            if (node.catchClause || node.finallyBlock) {\n                flowNodeCreated = node => (tryPriors.push(node), node);\n            }"
  },
  {
    "id" : "5a0578e8-bf40-4736-98fc-331c51c49cb7",
    "prId" : 27208,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/27208#pullrequestreview-163141681",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e6a8dd41-953f-4fb5-aede-4bf0c6100ad1",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Debug.assertNever is better here I think.",
        "createdAt" : "2018-10-09T23:11:12Z",
        "updatedAt" : "2018-10-19T20:11:48Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "fe0fa66b-b601-4d1f-b953-93185ad40d75",
        "parentId" : "e6a8dd41-953f-4fb5-aede-4bf0c6100ad1",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`assignmentKind` has all the non-object-define values still \"possible\" (they're not, because it's a call expression and not a binary expression) and so isn't never; so not quite?",
        "createdAt" : "2018-10-09T23:53:54Z",
        "updatedAt" : "2018-10-19T20:11:48Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8da77c620ad27941a71286374e62b6b73408f75a",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +2200,2204 @@                            break; // Nothing to do\n                        default:\n                            return Debug.fail(\"Unknown call expression assignment declaration kind\");\n                    }\n                    if (isInJSFile(node)) {"
  },
  {
    "id" : "a83a64bf-4cf4-4a9b-9c4e-d3b6a061a582",
    "prId" : 27096,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/27096#pullrequestreview-155586009",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fd9bbb7-2ad9-403f-ab6a-5839815f9d83",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "This is an unrelated change. I moved this condition to the front because it's the most important check, and it was buried behind the complex predicate at the end.",
        "createdAt" : "2018-09-14T17:17:10Z",
        "updatedAt" : "2018-09-17T02:46:57Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9d76b98304b0e257c247b4ef7993d32e30e05bb",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +2523,2527 @@                ? getParentOfBinaryExpression(propertyAccess.parent).parent.kind === SyntaxKind.SourceFile\n                : propertyAccess.parent.parent.kind === SyntaxKind.SourceFile;\n            if (isToplevel && !isPrototypeProperty && (!namespaceSymbol || !(namespaceSymbol.flags & SymbolFlags.Namespace))) {\n                // make symbols or add declarations for intermediate containers\n                const flags = SymbolFlags.Module | SymbolFlags.Assignment;"
  },
  {
    "id" : "0e6def72-dc29-4f82-a03a-815eb45d72f7",
    "prId" : 25886,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25886#pullrequestreview-170925010",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5ae7ec9-1724-48c2-8f37-11f19fa0e8a9",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Do we need to handle `checkStrictModeNumericLiteral` for bigInt?",
        "createdAt" : "2018-11-01T20:10:53Z",
        "updatedAt" : "2018-11-05T20:24:02Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "3f4d3492-2839-4834-888b-53ccaee69895",
        "parentId" : "d5ae7ec9-1724-48c2-8f37-11f19fa0e8a9",
        "authorId" : "2a9ff7d0-9e5d-4e6a-9c76-06f809e7ccca",
        "body" : "Don't think there are any differences between `bigint` literals in strict and non-strict mode. Legacy octal `bigint` literals (e.g. `0777n`) are invalid in both modes.",
        "createdAt" : "2018-11-01T23:32:16Z",
        "updatedAt" : "2018-11-05T20:24:02Z",
        "lastEditedBy" : "2a9ff7d0-9e5d-4e6a-9c76-06f809e7ccca",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb99c4123003ade3e471cf17472be6d3f72d96ff",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +3705,3709 @@            case SyntaxKind.BigIntLiteral:\n                transformFlags |= TransformFlags.AssertESNext;\n                break;\n\n            case SyntaxKind.ForOfStatement:"
  },
  {
    "id" : "ff86cdac-2e4d-4881-8aa4-27b3baaccf52",
    "prId" : 25523,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/25523#pullrequestreview-136323198",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a67a1543-77ad-489d-9c1b-31ddb1ec88f0",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I like this change.",
        "createdAt" : "2018-07-11T16:30:21Z",
        "updatedAt" : "2018-07-11T16:30:22Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "e6cadc7d01e7a6e72ba7fa00c4745b3f08744dec",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +226,230 @@            symbol.declarations = append(symbol.declarations, node);\n\n            if (symbolFlags & (SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.Module | SymbolFlags.Variable) && !symbol.exports) {\n                symbol.exports = createSymbolTable();\n            }"
  },
  {
    "id" : "7a2775f3-b454-44e1-b6b7-e57de8b040fe",
    "prId" : 23723,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/23723#pullrequestreview-116416213",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "34ecdeeb-d176-45f1-b5ff-43ba2a63071b",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "not sure i understand why this is related ot the original change?",
        "createdAt" : "2018-04-30T19:45:55Z",
        "updatedAt" : "2018-04-30T20:30:45Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "4adc30c7-9dd6-4291-9165-4d912fb5870d",
        "parentId" : "34ecdeeb-d176-45f1-b5ff-43ba2a63071b",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Now that `typedef`s are exported, there's a possibility that their names collide, such that there is a difference between\r\n\r\n```ts\r\nlet x: import(\"./a.js\").Foo\r\n// and\r\nimport a = require('./a.js')\r\nvar foo = new Foo()\r\n```\r\n\r\nIn other words, the type reference `Foo` might refer to the typedef, whereas the value referenced in `new Foo` might refer to the class. There should be an error to prevent this.",
        "createdAt" : "2018-04-30T19:57:20Z",
        "updatedAt" : "2018-04-30T20:30:45Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "736b75e0-cede-43cb-aba5-3adb83be396d",
        "parentId" : "34ecdeeb-d176-45f1-b5ff-43ba2a63071b",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i see. thanks.",
        "createdAt" : "2018-04-30T19:59:43Z",
        "updatedAt" : "2018-04-30T20:30:45Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "6e29c5c6d07a5e70088a6c79911a3314823f0802",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +2325,2329 @@            });\n            if (symbol) {\n                const flags = isClassExpression(node.right) ?\n                    SymbolFlags.Property | SymbolFlags.ExportValue | SymbolFlags.Class :\n                    SymbolFlags.Property | SymbolFlags.ExportValue;"
  },
  {
    "id" : "ea03f024-7203-4175-a520-af0eca993c55",
    "prId" : 23038,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/23038#pullrequestreview-108664846",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4774bb51-24b2-4a39-97e2-13201ff5a2fd",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "is there a reason why this function duplicated?",
        "createdAt" : "2018-03-30T23:47:33Z",
        "updatedAt" : "2018-03-30T23:47:33Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "a18e8961-0145-4b27-92b2-0e82f6b16be3",
        "parentId" : "4774bb51-24b2-4a39-97e2-13201ff5a2fd",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I introduced `getParentOfBinaryExpression` and `getInitializerOfBinaryExpression` in this PR. Are you confusing those two?",
        "createdAt" : "2018-04-02T16:43:03Z",
        "updatedAt" : "2018-04-02T16:43:04Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "bea7bc8f7d979dc4912ff4fe54d54c50f0e924aa",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +2479,2483 @@        }\n\n        function getParentOfBinaryExpression(expr: BinaryExpression) {\n            while (isBinaryExpression(expr.parent)) {\n                expr = expr.parent;"
  },
  {
    "id" : "b7a2475f-46de-4ed9-8ef8-95d24b34ad06",
    "prId" : 22643,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/22643#pullrequestreview-104665242",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1ff117ff-871f-4947-b5c3-3a5f6127614f",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "This happens enough that it should be a separate utility. At least the middle 2 or 3 predicates; I found a number of occurrences in utilities.ts, checker.ts and binder.ts.",
        "createdAt" : "2018-03-16T18:01:50Z",
        "updatedAt" : "2018-03-16T18:02:52Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ce39ccb8adda6bc466d1bb1f352b7e1023f06eb",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +2337,2341 @@                    if (isBinaryExpression(thisContainer.parent) && thisContainer.parent.operatorToken.kind === SyntaxKind.EqualsToken) {\n                        const l = thisContainer.parent.left;\n                        if (isPropertyAccessExpression(l) && isPropertyAccessExpression(l.expression) && l.expression.name.escapedText === \"prototype\" && isEntityNameExpression(l.expression.expression)) {\n                            constructorSymbol = getJSInitializerSymbolFromName(l.expression.expression, containerContainer);\n                        }"
  },
  {
    "id" : "2e0e8c36-7d1c-484c-ab5c-24ecf2a71b45",
    "prId" : 20198,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/20198#pullrequestreview-80321183",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a98f8040-568c-4780-9d21-33cc29129215",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we need to handle these recursivelly as well.. i.e. today we handel:\r\n```ts\r\nvar outer;\r\nouter = function() {};\r\nouter.inner = function () {};\r\n```\r\nbut we should also handle:\r\n```ts\r\nvar outer;\r\nouter = function() {};\r\nouter.inner = function () {};\r\nouter.inner.another = function () {};\r\n```",
        "createdAt" : "2017-11-30T20:26:36Z",
        "updatedAt" : "2017-11-30T20:33:56Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "78e84980-eff3-4e6f-86b9-e935f1517aa5",
        "parentId" : "a98f8040-568c-4780-9d21-33cc29129215",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Good idea. I will do that in a follow-up PR. It will require touching even more of the existing code.",
        "createdAt" : "2017-11-30T20:36:29Z",
        "updatedAt" : "2017-11-30T20:36:29Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "720820487744f302c5831afb5cd9c86c784a5dbf",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +2423,2427 @@                isLegalPosition = propertyAccess.parent.parent.kind === SyntaxKind.SourceFile;\n            }\n            if (!isPrototypeProperty && (!targetSymbol || !(targetSymbol.flags & SymbolFlags.Namespace)) && isLegalPosition) {\n                Debug.assert(isIdentifier(propertyAccess.expression));\n                const identifier = propertyAccess.expression as Identifier;"
  },
  {
    "id" : "1b1157ef-f459-444c-82e6-b60b774daf1d",
    "prId" : 19083,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/19083#pullrequestreview-68449245",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fe483bd-8d82-40fa-802f-861d8d425cc8",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "If we always bind one file at a time, why even look up the source file?",
        "createdAt" : "2017-10-10T22:15:37Z",
        "updatedAt" : "2017-10-10T22:15:37Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "0cc8e999-3164-41ca-81da-c21a3bba0409",
        "parentId" : "1fe483bd-8d82-40fa-802f-861d8d425cc8",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "We iterate over `symbol.declarations` to report errors on all duplicate declarations of a symbol; those declarations could be in files we've already bound instead of the current one.",
        "createdAt" : "2017-10-10T22:17:42Z",
        "updatedAt" : "2017-10-10T22:18:11Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "8c6b01dc-cbe2-4448-9c3b-a4d55addbe22",
        "parentId" : "1fe483bd-8d82-40fa-802f-861d8d425cc8",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Good point. 👍 ",
        "createdAt" : "2017-10-10T22:48:15Z",
        "updatedAt" : "2017-10-10T22:48:15Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "f7970884369866882559152feeef7866252ad3e3",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +150,154 @@         */\n        function createDiagnosticForNode(node: Node, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number): Diagnostic {\n            return createDiagnosticForNodeInSourceFile(getSourceFileOfNode(node) || file, node, message, arg0, arg1, arg2);\n        }\n"
  },
  {
    "id" : "f51e7c6b-111e-41dd-93fa-30bad5ef04e9",
    "prId" : 14273,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/14273#pullrequestreview-25406830",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b6a5624-2222-4690-9d1d-a115d5758b92",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Do we care if the member has a dynamic name or preserving control flow? That's part of what is lost by moving away from calling `bindPropertyOrMethodOrAccessor`.",
        "createdAt" : "2017-03-02T00:03:37Z",
        "updatedAt" : "2017-03-07T00:54:03Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "cb9a929b-a187-45b8-9266-823be2afbf34",
        "parentId" : "6b6a5624-2222-4690-9d1d-a115d5758b92",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "We only call this on property expressions, so no reason to get dynamic names here.",
        "createdAt" : "2017-03-07T00:53:11Z",
        "updatedAt" : "2017-03-07T00:54:03Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "3705b87c5c8970ccbf170a2e69ed113339a8141c",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +2314,2318 @@                    // Bind this property to the containing class\n                    const containingClass = container.parent;\n                    const symbol = declareSymbol(hasModifier(container, ModifierFlags.Static) ? containingClass.symbol.exports : containingClass.symbol.members, containingClass.symbol, node, SymbolFlags.Property, SymbolFlags.None);\n                    if (symbol) {\n                        // symbols declared through 'this' property assignements can be overwritten by subsequent method declarations"
  },
  {
    "id" : "3d2d085c-217e-466b-841e-053a4fd122ec",
    "prId" : 12346,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12346#pullrequestreview-17307339",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38502882-bb8e-4127-90d9-c7f2b0b3b71e",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "what about rest destructuring? Is that no longer handled by the ESNext transformer? #Resolved",
        "createdAt" : "2017-01-17T23:58:42Z",
        "updatedAt" : "2017-02-17T01:31:33Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "f64a767a-e609-47f1-b642-bbb2cbb76d7c",
        "parentId" : "38502882-bb8e-4127-90d9-c7f2b0b3b71e",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "The way that the esnext transformer works now is to always descend through the tree if *some* node is marked `ESNext`. The `SpreadAssignment` case handles that further down, so we can reduce false positives in `for..of` triggering the esnext transform when it isn't needed.",
        "createdAt" : "2017-01-18T19:37:49Z",
        "updatedAt" : "2017-02-17T01:31:33Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "11f58ea2f0c193780a660602bb040514c46f5fba",
    "line" : 118,
    "diffHunk" : "@@ -1,1 +3223,3227 @@                // This node is either ES2015 syntax or ES2017 syntax (if it is a for-await-of).\n                if ((<ForOfStatement>node).awaitModifier) {\n                    transformFlags |= TransformFlags.AssertESNext;\n                }\n                transformFlags |= TransformFlags.AssertES2015;"
  },
  {
    "id" : "cbf3dc51-4c8f-49ed-acbc-94571aea5314",
    "prId" : 12114,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/12114#pullrequestreview-8284884",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fde3db4-4bb7-499a-864c-74e9538f0532",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "MappedType seems to behave like a TypeLiteral elsewhere, but I'm not why it has `HasLocals` here like TypeAliasDeclaration does. Is it that MappedType introduces a new name for the parameter type?\n",
        "createdAt" : "2016-11-11T21:40:03Z",
        "updatedAt" : "2016-11-13T23:25:25Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "85df08da-378a-43b0-887d-60af7c5ad9f6",
        "parentId" : "1fde3db4-4bb7-499a-864c-74e9538f0532",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This is because of the type parameter introduced by `[P in ...]`. We want that symbol entered into the `locals` symbol table such that it is accessible within the mapped type, but not from the outside (unlike members).\n",
        "createdAt" : "2016-11-12T00:05:04Z",
        "updatedAt" : "2016-11-13T23:25:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd05c079ce0ebdf8daab9a568f24d0ca86729fc1",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +1309,1313 @@                case SyntaxKind.ModuleDeclaration:\n                case SyntaxKind.TypeAliasDeclaration:\n                case SyntaxKind.MappedType:\n                    return ContainerFlags.IsContainer | ContainerFlags.HasLocals;\n"
  },
  {
    "id" : "f9b93c5b-c108-4a04-999b-d8c47c4131a3",
    "prId" : 11653,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/11653#pullrequestreview-4366848",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec823a10-677f-465e-9791-52f8d8351c3c",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "can you add a test to check this condition? \n",
        "createdAt" : "2016-10-15T03:54:19Z",
        "updatedAt" : "2016-10-16T00:29:11Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "87c51201-8774-4edd-a25a-b44a9fdabeb3",
        "parentId" : "ec823a10-677f-465e-9791-52f8d8351c3c",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "The only new functionality is the test for `node.type`, which is covered by `transformsElideNullUndefinedType`\n",
        "createdAt" : "2016-10-15T04:33:09Z",
        "updatedAt" : "2016-10-16T00:29:11Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "db76a9ca0720199852c39eef1c8956d5c55bacb7",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +2510,2514 @@            || node.type\n            || subtreeFlags & TransformFlags.ContainsDecorators\n            || isThisIdentifier(name)) {\n            transformFlags |= TransformFlags.AssertTypeScript;\n        }"
  },
  {
    "id" : "20f61cce-70e0-4d0b-a2fa-cac8858d64a6",
    "prId" : 11407,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/11407#pullrequestreview-4033746",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba1d69e9-b840-4177-bd6d-48a518457baa",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Since `async` is ES2017, the test at line 2598 is now incorrect.\n",
        "createdAt" : "2016-10-13T00:14:24Z",
        "updatedAt" : "2016-10-15T06:32:50Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "dd3c0791-e048-4f3c-a0e6-f7fb762701ba",
        "parentId" : "ba1d69e9-b840-4177-bd6d-48a518457baa",
        "authorId" : "003be4b5-9fe0-495a-841b-1931d491d9e4",
        "body" : "done\n",
        "createdAt" : "2016-10-13T09:26:56Z",
        "updatedAt" : "2016-10-15T06:32:50Z",
        "lastEditedBy" : "003be4b5-9fe0-495a-841b-1931d491d9e4",
        "tags" : [
        ]
      }
    ],
    "commit" : "17d60d5d8f373ecb61039d71023d3f1f4c9808d4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2652,2656 @@\n        // An async method declaration is ES2017 syntax.\n        if (modifierFlags & ModifierFlags.Async) {\n            transformFlags |= TransformFlags.AssertES2017;\n        }"
  },
  {
    "id" : "ce6b407a-6a7b-4f20-b69c-1322c8ac6804",
    "prId" : 11342,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/11342#pullrequestreview-2649886",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b8660921-0d1b-4ea9-97bf-a6606c80bbd5",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "This was discovered due to the use of the more specific `kind` property.\n",
        "createdAt" : "2016-10-04T05:11:53Z",
        "updatedAt" : "2016-10-06T20:41:28Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "519095f58585398d608cdf0acdee32f70d594dac",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +1112,1116 @@            else {\n                forEachChild(node, bind);\n                if (node.operator === SyntaxKind.PlusPlusToken || node.operator === SyntaxKind.MinusMinusToken) {\n                    bindAssignmentTargetFlow(node.operand);\n                }"
  },
  {
    "id" : "62f38804-e055-4e20-9db4-d9726ace388c",
    "prId" : 10239,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99dd3780-93ad-4e82-87a4-93a10857233a",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "Do we need to do this loop? what if we just do something like:\n\n``` ts\nif (symbol.declarations && symbol.declarations.length && \n   (isDefaultExport || (node.kind === SyntaxKind.ExportAssignment &&  !(<ExportAssignment>node).isExportEquals)) {\n    message = Diagnostics.A_module_cannot_have_multiple_default_exports;\n}\n```\n",
        "createdAt" : "2016-08-18T00:11:25Z",
        "updatedAt" : "2016-09-30T17:43:55Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "f195bd59dfe2f6ec0ff968b5f48e694809285fe4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +356,360 @@                            : Diagnostics.Duplicate_identifier_0;\n\n                        if (symbol.declarations && symbol.declarations.length) {\n                            // If the current node is a default export of some sort, then check if\n                            // there are any other default exports that we need to error on."
  },
  {
    "id" : "f8f662db-2fe1-4222-86d2-4d420893998a",
    "prId" : 10013,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9200b5a4-dcc9-4dc3-9eb9-3f2ab7e8662c",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Are these actually for default clauses, or just for `export =`?\n",
        "createdAt" : "2016-08-02T19:24:24Z",
        "updatedAt" : "2016-08-11T16:44:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "073511e9-2e72-4a59-9996-5197e8bf433c",
        "parentId" : "9200b5a4-dcc9-4dc3-9eb9-3f2ab7e8662c",
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "`export default` and `export =` are both instances of `ExportAssignment`.\n",
        "createdAt" : "2016-08-02T19:28:17Z",
        "updatedAt" : "2016-08-11T16:44:16Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9bd820706fb3a70b404cafabb9e8203bc0b760",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +1896,1900 @@                    // An export default clause with an EntityNameExpression exports all meanings of that identifier\n                    ? SymbolFlags.Alias\n                    // An export default clause with any other expression exports a value\n                    : SymbolFlags.Property;\n                declareSymbol(container.symbol.exports, container.symbol, node, flags, SymbolFlags.PropertyExcludes | SymbolFlags.AliasExcludes);"
  },
  {
    "id" : "1e25874d-7fa8-48f7-9a3c-5757edb38ed3",
    "prId" : 9175,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6d948f5-6b55-4780-867d-a6b19e474ef8",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "I think comment need to be updated?\n",
        "createdAt" : "2016-06-20T20:57:27Z",
        "updatedAt" : "2016-07-18T22:57:12Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "c2857672dcb70b9985220b374ffec6c018346c55",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2678,2682 @@        // lexical this, or the function contains parameters with initializers, then this node is\n        // ES6 syntax.\n        if (subtreeFlags & TransformFlags.ES6FunctionSyntaxMask) {\n            transformFlags |= TransformFlags.AssertES6;\n        }"
  },
  {
    "id" : "ad9a66ad-66e3-4ca6-95b6-566d2dc87783",
    "prId" : 9175,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0bf39c38-dc07-4690-bb38-b43898b199df",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "how can this `node.emitFlags & NodeEmitFlags.AsyncFunctionBody` be observed here since the flag is set in the transformer's factory.\n\nAlso what happen to the case of `asteriskToken` but not AsyncFunctionBody?\n",
        "createdAt" : "2016-06-20T21:14:34Z",
        "updatedAt" : "2016-07-18T22:57:12Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "63e9657b-4702-4df1-8d27-630a301d7f84",
        "parentId" : "0bf39c38-dc07-4690-bb38-b43898b199df",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "`TransformFlags` aggregation happens both during the bind phase and during each successive transformation phase (though usually it has less work to do as it can reuse the flags from unchanged subtrees).\n\nIn this case, we only add the flag if the generator was created as a result of an async function transformation.\n\nWe do not down-level generators that are not the result of an async function transformation.\n",
        "createdAt" : "2016-06-22T01:21:34Z",
        "updatedAt" : "2016-07-18T22:57:12Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "c2857672dcb70b9985220b374ffec6c018346c55",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2687,2691 @@        // Currently we do not support transforming any other generator fucntions\n        // down level.\n        if (asteriskToken && node.emitFlags & NodeEmitFlags.AsyncFunctionBody) {\n            transformFlags |= TransformFlags.AssertGenerator;\n        }"
  },
  {
    "id" : "85c76ef0-3988-4a10-b832-22df0e2d46a9",
    "prId" : 9163,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd5590de-36bd-49ac-9fa6-376115d4c7a7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why is a switch/case non-exhaustive if it has a default? I feel like if it does, it is definitely exhaustive (because it accounts for all cases the user hasn't explicitly accounted for). Can you also document the answer in a comment here?\n",
        "createdAt" : "2016-06-14T18:52:40Z",
        "updatedAt" : "2016-06-14T20:16:00Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1959a8f4-ce1a-48cd-be4d-41681406453b",
        "parentId" : "fd5590de-36bd-49ac-9fa6-376115d4c7a7",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "If it has a default clause it is _definitely_ exhaustive and not just _possibly_ exhaustive. We already handle the definitely exhaustive case through normal control flow analysis (i.e. if all branches exit the post-switch label will have no antecedents).\n",
        "createdAt" : "2016-06-14T20:31:04Z",
        "updatedAt" : "2016-06-14T20:31:04Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a3635ccd8b843862b5f278c339943408f19c922f",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +957,961 @@            addAntecedent(postSwitchLabel, currentFlow);\n            const hasDefault = forEach(node.caseBlock.clauses, c => c.kind === SyntaxKind.DefaultClause);\n            // We mark a switch statement as possibly exhaustive if it has no default clause and if all\n            // case clauses have unreachable end points (e.g. they all return).\n            node.possiblyExhaustive = !hasDefault && !postSwitchLabel.antecedents;"
  },
  {
    "id" : "03d4a23a-c04d-41a9-a59e-263e0e38d4d9",
    "prId" : 8849,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "595ab4d6-85b3-426c-b861-eb7bf32a20cb",
        "parentId" : null,
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Do you also need to save/restore the `currentTrueTarget` and `currentFalseTarget` flow labels here? I see that they are tracked in `bindConditionalExpressionFlow` and `bindPrefixUnaryExpressionFlow`, but what happens when one branch of the condition contains an IIFE?\n",
        "createdAt" : "2016-05-31T18:25:03Z",
        "updatedAt" : "2016-05-31T21:33:09Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "547038f1-e8fc-44cb-af0b-5a6061659c79",
        "parentId" : "595ab4d6-85b3-426c-b861-eb7bf32a20cb",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, there's no need to save those. They're only used when a conditional operator is immediately contained in a conditional statement, and they're saved and restored at that point.\n",
        "createdAt" : "2016-05-31T21:24:22Z",
        "updatedAt" : "2016-05-31T21:33:09Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "41446fe4c27820e5668e6a37ba7a2934d6dfa7ad",
    "line" : 138,
    "diffHunk" : "@@ -1,1 +432,436 @@            }\n            if (containerFlags & ContainerFlags.IsControlFlowContainer) {\n                const saveCurrentFlow = currentFlow;\n                const saveBreakTarget = currentBreakTarget;\n                const saveContinueTarget = currentContinueTarget;"
  },
  {
    "id" : "e6267468-ec4a-4005-b6a8-f5786b4c1753",
    "prId" : 8598,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e70fd9d5-f16b-4349-8dec-391c925d4e1b",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "are we disallow \"computedPropertyName\" with decorators?\n",
        "createdAt" : "2016-05-16T17:35:35Z",
        "updatedAt" : "2016-05-19T22:39:52Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "edca1a0c-5528-49e2-ad6b-dd0d049683b6",
        "parentId" : "e70fd9d5-f16b-4349-8dec-391c925d4e1b",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "No, previously this only set `AssertTypeScript` if the method contained _both_ decorators and a computed property name. Now it sets it if it contains _at least_ decorators.\n",
        "createdAt" : "2016-05-16T20:32:24Z",
        "updatedAt" : "2016-05-19T22:39:52Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "150cecbaf37b959ead6ac1aa3b628d2385e02418",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +2164,2168 @@                    || (<MethodDeclaration>node).typeParameters !== undefined\n                    || hasModifier(node, ModifierFlags.Async | ModifierFlags.Abstract)\n                    || subtreeFlags & TransformFlags.ContainsDecorators) {\n                    transformFlags |= TransformFlags.AssertTypeScript;\n                }"
  },
  {
    "id" : "d9d2f722-b028-4255-954f-2804275b9aee",
    "prId" : 8598,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "23ba252d-c31f-4609-bdf7-cf7f07ea00a0",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Nit: I think it will be easier if it is just inline \n\n``` typescript\nupdateTransformFlags(node, subtreeFlags, isBindingPattern(node.name)  ? TransformFlags.AssertES6 | TransformFlags.ContainsBindingPattern TransformFlags.None, transformFlags.None);\n```\n",
        "createdAt" : "2016-05-16T21:24:55Z",
        "updatedAt" : "2016-05-19T22:39:52Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "6d76ca94-c23f-4ede-bd76-76c3957f0887",
        "parentId" : "23ba252d-c31f-4609-bdf7-cf7f07ea00a0",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "That just becomes one long, hard to read line.\n",
        "createdAt" : "2016-05-16T22:02:16Z",
        "updatedAt" : "2016-05-19T22:39:52Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "150cecbaf37b959ead6ac1aa3b628d2385e02418",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2435,2439 @@        }\n\n        return updateTransformFlags(node, subtreeFlags, transformFlags, TransformFlags.None);\n    }\n"
  },
  {
    "id" : "194de6e0-7ded-4742-87ae-4134dee9edc4",
    "prId" : 8069,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "343acf19-b73c-4ea7-a3e3-0f8ef64a0d60",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Could you add comment about the discussion you have with @rbuckton why you convert this to \"ContainsLexicalThis\"\n",
        "createdAt" : "2016-04-13T23:20:31Z",
        "updatedAt" : "2016-04-14T16:51:52Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d5bf0ee32a39288cee795f190cae5c36eaf2c86",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +1957,1961 @@                    transformFlags = TransformFlags.AssertES6;\n                }\n                if (subtreeFlags & TransformFlags.ContainsLexicalThisInComputedPropertyName) {\n                    // A computed property name containing `this` might need to be rewritten,\n                    // so propagate the ContainsLexicalThis flag upward."
  },
  {
    "id" : "d7482b3c-cab1-4a97-949a-e0815f0d23b4",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc7218b4-276a-4d8f-9249-96cf1ba3d36c",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Should `ElementAccessExpression`s be considered narrowable if their expression is narrowable, just like `PropertyAccessExpression`s?\n",
        "createdAt" : "2016-04-11T17:09:51Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "5b46413d-38d6-439a-b7fe-64c6c3c25d4d",
        "parentId" : "bc7218b4-276a-4d8f-9249-96cf1ba3d36c",
        "authorId" : "b2e5e981-f1bc-47a6-9499-789a8e6f8b59",
        "body" : "That could be done, but only if the expression between the brackets is a constant (string/number literal, enum value etc)\n",
        "createdAt" : "2016-04-11T20:16:10Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "b2e5e981-f1bc-47a6-9499-789a8e6f8b59",
        "tags" : [
        ]
      },
      {
        "id" : "fa388b31-bae5-4492-9c42-8ed26684d40d",
        "parentId" : "bc7218b4-276a-4d8f-9249-96cf1ba3d36c",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "I think we do that kind of special-casing for literal element access expressions elsewhere - we should probably do it here, as well.\n",
        "createdAt" : "2016-04-11T20:21:22Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "d7888178-c65e-4f21-bc1c-8c37865eb0e3",
        "parentId" : "bc7218b4-276a-4d8f-9249-96cf1ba3d36c",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "literals and well-known symbols as well.\n",
        "createdAt" : "2016-04-15T17:15:57Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "2591642f-1907-4ed2-a3a5-e126d624464d",
        "parentId" : "bc7218b4-276a-4d8f-9249-96cf1ba3d36c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, it would be good to support element access expressions with string literals and well known symbols. I think we can cover it in a separate PR though.\n",
        "createdAt" : "2016-04-15T22:20:37Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +595,599 @@            return expr.kind === SyntaxKind.Identifier ||\n                expr.kind === SyntaxKind.ThisKeyword ||\n                expr.kind === SyntaxKind.PropertyAccessExpression && isNarrowableReference((<PropertyAccessExpression>expr).expression);\n        }\n"
  },
  {
    "id" : "8a57c278-1adb-44bd-8222-9300de39faf2",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89b79acf-e32f-44e3-a0e4-42253f933b84",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Could you simply use these types as return types instead of using a type assertion?\n",
        "createdAt" : "2016-04-11T23:23:34Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "ec540ef5-77d3-4650-9f71-8b9e22e46632",
        "parentId" : "89b79acf-e32f-44e3-a0e4-42253f933b84",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes.\n",
        "createdAt" : "2016-04-12T00:06:36Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 294,
    "diffHunk" : "@@ -1,1 +674,678 @@\n        function createFlowAssignment(antecedent: FlowNode, node: Expression | VariableDeclaration | BindingElement): FlowNode {\n            return <FlowAssignment>{\n                kind: FlowKind.Assignment,\n                antecedent,"
  },
  {
    "id" : "11156449-df5a-4334-be7e-da2495e31950",
    "prId" : 8010,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/8010#pullrequestreview-1263569",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01320ebe-ca20-4e5f-a2af-d9b0d393f236",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What exactly makes something top-level? I can pretty much figure if out if I dig into this, but can you document the intent?\n",
        "createdAt" : "2016-04-11T23:57:10Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "285da999-b70c-4c8e-b2bf-4614943874b8",
        "parentId" : "01320ebe-ca20-4e5f-a2af-d9b0d393f236",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "A logical expression (an && or || expression) is top-level if it has no effect on control flow beyond itself. Examples include logical expressions used as statement expressions and logical expressions passed as arguments.\n",
        "createdAt" : "2016-04-12T00:11:21Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "0c3ff591-e586-4184-849a-201ccaa262a9",
        "parentId" : "01320ebe-ca20-4e5f-a2af-d9b0d393f236",
        "authorId" : "44b7845d-0612-4ff2-b8fc-6c0d0ba61c3c",
        "body" : "is it just for logical expressions or for other expressions too? cause I was wondering (language agnostically) what happens if something always raises an exception but isn't a throw statement (like dividing by zero), should one be clever enough to handle it? And should they also resolve constant values first or other statements that are calculatable at checking time, then check for such a case? Or would it be too far fetched, behaving like an AI coprogrammer?\n",
        "createdAt" : "2016-09-23T02:20:51Z",
        "updatedAt" : "2016-09-23T02:20:51Z",
        "lastEditedBy" : "44b7845d-0612-4ff2-b8fc-6c0d0ba61c3c",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 356,
    "diffHunk" : "@@ -1,1 +722,726 @@        }\n\n        function isTopLevelLogicalExpression(node: Node): boolean {\n            while (node.parent.kind === SyntaxKind.ParenthesizedExpression ||\n                node.parent.kind === SyntaxKind.PrefixUnaryExpression &&"
  },
  {
    "id" : "0c7abe42-cd24-47b9-a180-2b92cf14ac15",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2aa9f102-98c0-4a44-9b6e-30bc61ab91b1",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "CommaToken?\n",
        "createdAt" : "2016-04-15T17:19:58Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : null,
    "diffHunk" : "@@ -1,1 +623,627 @@                case SyntaxKind.ExclamationEqualsToken:\n                case SyntaxKind.EqualsEqualsEqualsToken:\n                case SyntaxKind.ExclamationEqualsEqualsToken:\n                    if (isNarrowingExpression(expr.left) && (expr.right.kind === SyntaxKind.NullKeyword || expr.right.kind === SyntaxKind.Identifier)) {\n                        return true;"
  },
  {
    "id" : "dbd9b69a-1a0c-4df3-b43d-9c1ef66b2caf",
    "prId" : 7268,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90853acd-1a50-4a8f-aeda-807a698b2945",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Adapt the above comment:\n\n``` ts\n// It's acceptable for multiple 'Foo.prototype' assignments of the same prototype to occur\n```\n\nor something like that\n",
        "createdAt" : "2016-02-26T23:07:00Z",
        "updatedAt" : "2016-03-01T20:41:00Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "766439ed011a4ae584679146b3058a1d1f06bbea",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1467,1471 @@            // Declare the method/property\n            // It's acceptable for multiple prototype property assignments of the same identifier to occur\n            declareSymbol(funcSymbol.members, funcSymbol, leftSideOfAssignment, SymbolFlags.Property, SymbolFlags.PropertyExcludes & ~SymbolFlags.Property);\n        }\n"
  },
  {
    "id" : "3dba56c5-684b-45af-97ab-53b59489a913",
    "prId" : 7249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6802b44a-9a89-41b0-8136-82a2fc703de7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Consider adding a `Debug.assert` that if `node` is a `BinaryExpression`, you're also in a JS file.\n",
        "createdAt" : "2016-02-26T01:51:25Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8ac66fb381836cb075ea4a6fa3d515ee19842e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +277,281 @@         */\n        function declareSymbol(symbolTable: SymbolTable, parent: Symbol, node: Declaration, includes: SymbolFlags, excludes: SymbolFlags): Symbol {\n            Debug.assert(!hasDynamicName(node));\n\n            const isDefaultExport = node.flags & NodeFlags.Default;"
  },
  {
    "id" : "59be510a-1c11-46f9-af52-643b612023e5",
    "prId" : 7249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47e2d159-6dc4-4831-8dbe-4c49ead942e4",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Is there a reason you're setting with `SymbolFlags.Property`?\n",
        "createdAt" : "2016-03-03T21:45:16Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1a84e28f-8d10-4c75-89b3-0370826f9e52",
        "parentId" : "47e2d159-6dc4-4831-8dbe-4c49ead942e4",
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "In part because 'module.exports' is a property, but mostly because there was some code path that was crapping out without an expected flag set, of which `property` seemed appropriate (the exact code path escapes me, as I wrote this over a week ago, and there were _a lot_ of code paths).\n\nHappy to be corrected on my usage of the mystic arts of SymbolFlags however.\n",
        "createdAt" : "2016-03-04T00:16:06Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "2c121305-5bd8-427a-9e56-8709558dca5c",
        "parentId" : "47e2d159-6dc4-4831-8dbe-4c49ead942e4",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "shouldn't this be just `SymbolFlags.Alias`?\n",
        "createdAt" : "2016-03-09T21:30:50Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "75e4573b-0fdd-4767-882d-954c3f7117ee",
        "parentId" : "47e2d159-6dc4-4831-8dbe-4c49ead942e4",
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "I went down that road and it was a can of worms. I can't remember all the issues I hit, many related to `resolveAlias`, but one of them was the getTargetOfAlias function has a set of explicit SyntaxKinds it expects. It also expects to be able to resolve a target declaration, whereas this is a binaryExpression setting a property from an expression (e.g. it could be `module.exports = someCall()` - as I have a test-case for).\n",
        "createdAt" : "2016-03-09T21:49:23Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "6a26a549-9421-4795-b3e7-289761e2edea",
        "parentId" : "47e2d159-6dc4-4831-8dbe-4c49ead942e4",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i see now that would not work. but we should do it if the right hand side is an identified. this allows us to get a class from JS for instance in TS, and we have this mostly working today, you will just need to add one additional clause in getTargetOfAliasDeclaration.\n\nif it is not, i would give this `Property` | `ValueModule` seems reasonable. not sure i see why we need the Export one though.\n",
        "createdAt" : "2016-03-09T22:13:53Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8ac66fb381836cb075ea4a6fa3d515ee19842e",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1431,1435 @@            // 'module.exports = expr' assignment\n            setCommonJsModuleIndicator(node);\n            declareSymbol(file.symbol.exports, file.symbol, node, SymbolFlags.Property | SymbolFlags.Export | SymbolFlags.ValueModule, SymbolFlags.None);\n        }\n"
  },
  {
    "id" : "48b00f7b-042e-4a2c-b258-9a67439a8bda",
    "prId" : 6983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1660d3ea-177c-4119-ae22-23d03afc4251",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Does this trigger false positives for `const x = ...` variable declarations?\n",
        "createdAt" : "2016-02-10T05:12:00Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "38e14611-0e5e-42f9-aa9c-54466e71c8e1",
        "parentId" : "1660d3ea-177c-4119-ae22-23d03afc4251",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "No, we don't treat `const` as a modifier for variable declarations.\n",
        "createdAt" : "2016-02-10T05:18:26Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "e02af71d-4a39-4fe6-962e-2eaa0ef8185e",
        "parentId" : "1660d3ea-177c-4119-ae22-23d03afc4251",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "how is 'const' has flag of `AssertTypeScript` should it be under `es6`?\n",
        "createdAt" : "2016-02-16T22:43:40Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "c4e9a275-3637-4a5d-a642-ff9e20d1f205",
        "parentId" : "1660d3ea-177c-4119-ae22-23d03afc4251",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "The only ES6 `const` is for `VariableDeclarationList`, which is not stored as a modifier. The only time `const` is a `Modifier` is for a const enum, which is TypeScript only.\n",
        "createdAt" : "2016-02-16T23:31:11Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a212e2b6960ebe4773d9e19c8a314299598ef446",
    "line" : 141,
    "diffHunk" : "@@ -1,1 +1791,1795 @@            case SyntaxKind.DeclareKeyword:\n            case SyntaxKind.AsyncKeyword:\n            case SyntaxKind.ConstKeyword:\n            case SyntaxKind.AwaitExpression:\n            case SyntaxKind.EnumDeclaration:"
  },
  {
    "id" : "bcb04783-6e00-4a71-8168-d15456e2d5b1",
    "prId" : 6983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b96018b-2240-4f02-9eb7-a7a162998508",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Should there be `ForInStatement`?\n",
        "createdAt" : "2016-02-16T23:17:39Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "c51abc17-2923-42c1-9ab4-7bed10fcc3e2",
        "parentId" : "8b96018b-2240-4f02-9eb7-a7a162998508",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "`ForInStatement` is ES3, so there's currently no specific transformation associated with it.\n",
        "createdAt" : "2016-02-16T23:35:49Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "bb321109-8285-4fe7-84dc-a167713b253d",
        "parentId" : "8b96018b-2240-4f02-9eb7-a7a162998508",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Oh right. Sorry, got it mixed up\n",
        "createdAt" : "2016-02-16T23:46:30Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a212e2b6960ebe4773d9e19c8a314299598ef446",
    "line" : 177,
    "diffHunk" : "@@ -1,1 +1827,1831 @@            case SyntaxKind.TaggedTemplateExpression:\n            case SyntaxKind.ShorthandPropertyAssignment:\n            case SyntaxKind.ForOfStatement:\n            case SyntaxKind.YieldExpression:\n                // These nodes are ES6 syntax."
  },
  {
    "id" : "1356f0bb-cab9-432d-9273-adfd2de820bf",
    "prId" : 6983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e28c0f9-32f5-4a5d-9e66-aee1034b7ab8",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "why you care about `ContainsComputedPropertyName` to set the flag with `AssertTypeScript`?\n",
        "createdAt" : "2016-02-16T23:21:03Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "b80772f4-2df0-4435-82cb-135dda4ba25d",
        "parentId" : "4e28c0f9-32f5-4a5d-9e66-aee1034b7ab8",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "This has to do with decorators. We don't want to re-evaluate the expression of the computed property name:\n\n``` ts\n// ts\nclass C {\n  @dec\n  [generateRandomMethodName()]() {\n  }\n}\n\n// js\nclass C {\n  [_a = generateRandomMethodName()]() {\n  }\n}\n__decorate([dec], C.prototype, _a, null);\nvar _a;\n```\n\nWe need to flag the method itself as needing a specific transformation in this case, to transform the computed property name.\n",
        "createdAt" : "2016-02-16T23:39:22Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a212e2b6960ebe4773d9e19c8a314299598ef446",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2056,2060 @@                    || hasModifier(node, ModifierFlags.Async | ModifierFlags.Abstract)\n                    || (subtreeFlags & TransformFlags.ContainsDecorators\n                        && subtreeFlags & TransformFlags.ContainsComputedPropertyName)) {\n                    transformFlags |= TransformFlags.AssertTypeScript;\n                }"
  },
  {
    "id" : "8975c4e1-0e15-4560-869b-0eff8dface70",
    "prId" : 6983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffc94d3b-0d11-4da7-938b-7ea678f8883e",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "you don't need to capture whether the method is static or instance? Wouldn't that affect the emitting?\n",
        "createdAt" : "2016-02-16T23:28:00Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "b9fc6605-35be-480e-ad87-8aaafa4dcecd",
        "parentId" : "ffc94d3b-0d11-4da7-938b-7ea678f8883e",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "We can test the node's `flags` for this. The transformation flags just give us a very high level indication that something needs to happen.\n",
        "createdAt" : "2016-02-16T23:41:09Z",
        "updatedAt" : "2016-03-18T23:39:31Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "a212e2b6960ebe4773d9e19c8a314299598ef446",
    "line" : 396,
    "diffHunk" : "@@ -1,1 +2046,2050 @@\n            case SyntaxKind.MethodDeclaration:\n                // A MethodDeclaration is ES6 syntax.\n                excludeFlags = TransformFlags.MethodOrAccessorExcludes;\n                transformFlags = TransformFlags.AssertES6;"
  },
  {
    "id" : "a4a1e306-9058-4700-a117-725d79cf768d",
    "prId" : 6495,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6bcfc83d-6597-4278-ab4e-f0c14f13d633",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Instead of this, what if you just looked for `await` expressions? Technically you don't need an await helper unless you use `await` right?\n",
        "createdAt" : "2016-01-15T02:20:37Z",
        "updatedAt" : "2016-01-21T18:01:46Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "896cbebc-fac3-4f9f-80b8-2c6291033408",
        "parentId" : "6bcfc83d-6597-4278-ab4e-f0c14f13d633",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I need the helper for any async function, even if it does not have an `await`.\n",
        "createdAt" : "2016-01-15T02:39:45Z",
        "updatedAt" : "2016-01-21T18:01:46Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "831daead55cbb9f1a52a7690950d1a11139ec030",
    "line" : 124,
    "diffHunk" : "@@ -1,1 +1558,1562 @@        function bindFunctionDeclaration(node: FunctionDeclaration) {\n            if (!isDeclarationFile(file) && !isInAmbientContext(node)) {\n                if (isAsyncFunctionLike(node)) {\n                    hasAsyncFunctions = true;\n                }"
  },
  {
    "id" : "331fbf83-caff-4491-91dc-4576d9f8e74f",
    "prId" : 6495,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c9e87e2c-9c1a-4e72-bf8c-095bfb01f5ff",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I don't mind this that much, but if you used a `helperFlags` variable instead of four separate variables, you could just write `flags |= helperFlags & NodeFLags.EmitHelperFlags`.\n",
        "createdAt" : "2016-01-19T21:42:20Z",
        "updatedAt" : "2016-01-21T18:01:46Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "2d79033c-4651-462c-9eb9-7a66e1348301",
        "parentId" : "c9e87e2c-9c1a-4e72-bf8c-095bfb01f5ff",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "As it is currently, its consistent with how we tracked this information in checker.ts and with how similar information is tracked in binder.ts.\n",
        "createdAt" : "2016-01-20T00:36:51Z",
        "updatedAt" : "2016-01-21T18:01:46Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "831daead55cbb9f1a52a7690950d1a11139ec030",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +486,490 @@                    flags |= NodeFlags.HasAsyncFunctions;\n                }\n            }\n\n            node.flags = flags;"
  },
  {
    "id" : "159bf1c3-788d-4a67-9ae8-b111e1553549",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "317e0435-69b8-482e-ba07-6344fd1cdbf0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Will we ever manifest this name to the user?\n",
        "createdAt" : "2015-12-10T00:12:15Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c19b09cf-c1b2-4d78-9c99-cc30445627ea",
        "parentId" : "317e0435-69b8-482e-ba07-6344fd1cdbf0",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Yes\n",
        "createdAt" : "2015-12-14T22:10:23Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +249,253 @@                    let functionType = <JSDocFunctionType>node.parent;\n                    let index = indexOf(functionType.parameters, node);\n                    return \"p\" + index;\n            }\n        }"
  },
  {
    "id" : "ee136d97-4faa-41eb-bba7-0c3dd06fb68a",
    "prId" : 5906,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3beccd19-f4a3-40e3-affb-f1941da4b4d5",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Consider just destructuring `parameterName` and `type`\n",
        "createdAt" : "2015-12-09T22:30:43Z",
        "updatedAt" : "2015-12-10T00:43:53Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "fe3b6b34-06ae-4feb-a2e0-08fefbf7d3b8",
        "parentId" : "3beccd19-f4a3-40e3-affb-f1941da4b4d5",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : ":+1:\n",
        "createdAt" : "2015-12-10T00:08:41Z",
        "updatedAt" : "2015-12-10T00:43:53Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e586943a1b60075e51fc482af2d9be278eab08b",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +1277,1281 @@        }\n\n        function checkTypePredicate(node: TypePredicateNode) {\n            const { parameterName, type } = node;\n            if (parameterName && parameterName.kind === SyntaxKind.Identifier) {"
  },
  {
    "id" : "a22468b1-daf2-409f-9aab-8b5b7268d209",
    "prId" : 5876,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "01578138-049a-46af-ae0a-d3ded4b83383",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This doesn't guarantee that the prototype assignment _immediately_ follows. Also, what if `classId` denotes a non-function, such as a variable or an interface declaration? I'm thinking you should instead check that the prototype assignment is immediately contained in a statement list and that the immediately preceding statement is a function declaration.\n",
        "createdAt" : "2015-12-04T17:10:36Z",
        "updatedAt" : "2015-12-14T19:32:30Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "37f3ff8d05efc6b3717bc7ead63bc746d509c3ee",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1381,1385 @@            // follow the function declaration\n            const classId = <Identifier>(<PropertyAccessExpression>(<PropertyAccessExpression>node.left).expression).expression;\n            const funcSymbol = container.locals[classId.text];\n            if (!funcSymbol || !(funcSymbol.flags & SymbolFlags.Function)) {\n                return;"
  },
  {
    "id" : "9363da0b-70a9-4e5c-be41-f19ec69bd222",
    "prId" : 5266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f4d473e-16ee-477c-8797-af9b9ca1ed38",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I would move the `!file.commonJsModuleIndicator` test into `bindCallExpression` so we have all the logic in one place.\n",
        "createdAt" : "2015-10-16T20:56:57Z",
        "updatedAt" : "2015-11-09T22:48:42Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "69ca1f2e1dd95889cfd0e5cd3b3f00daa71d894c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1230,1234 @@                case SyntaxKind.CallExpression:\n                    if (isInJavaScriptFile(node)) {\n                        bindCallExpression(<CallExpression>node);\n                    }\n                    break;"
  },
  {
    "id" : "5bec025d-d1ef-4475-b24b-dee69c1c753e",
    "prId" : 5084,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87fa215f-7c78-4e00-a34b-b82efc375fe5",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Indent both branches\n",
        "createdAt" : "2015-10-07T22:29:17Z",
        "updatedAt" : "2015-10-09T19:38:54Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "69ff6f50903aee59cd0aade2ad67558e599976ca",
    "line" : null,
    "diffHunk" : "@@ -1,1 +228,232 @@                    let message = symbol.flags & SymbolFlags.BlockScopedVariable\n                        ? Diagnostics.Cannot_redeclare_block_scoped_variable_0\n                        : Diagnostics.Duplicate_identifier_0;\n\n                    forEach(symbol.declarations, declaration => {"
  },
  {
    "id" : "3ffb00fe-ba08-4334-8de0-0ed28d24caaa",
    "prId" : 4954,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9de53d5b-7e07-4d03-a898-3c0d880d8dd8",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I think you also want to check whether the argument is a string literal.\n",
        "createdAt" : "2015-09-24T18:01:38Z",
        "updatedAt" : "2015-09-24T21:56:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "7fa74793-59c6-4d70-b149-60fc0409b6ff",
        "parentId" : "9de53d5b-7e07-4d03-a898-3c0d880d8dd8",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Actually, never mind, since this is just for ensuring module scoping rules, right?\n",
        "createdAt" : "2015-09-24T18:05:16Z",
        "updatedAt" : "2015-09-24T21:56:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b78acf46-1bb4-4d97-93e9-1ea3fc0f4162",
        "parentId" : "9de53d5b-7e07-4d03-a898-3c0d880d8dd8",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Correct. I'm ambivalent on checking the argument syntactic form\n",
        "createdAt" : "2015-09-24T19:11:53Z",
        "updatedAt" : "2015-09-24T21:56:49Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "885755fb8f70142a8c27b8d84db4f15e614c003e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +226,230 @@                if (call.expression.kind === SyntaxKind.Identifier &&\n                    (<Identifier>call.expression).text === 'require' &&\n                    call.arguments.length === 1) {\n\n                    return node;"
  },
  {
    "id" : "b9563bc1-803d-4d69-ad24-d13809eb8173",
    "prId" : 4954,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d9e12ec6-0a9b-4293-acf3-d6a87a956e15",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "so why not put this in the parser, so that SourceFile.externalModuleIndicator is sufficient all the time?\n",
        "createdAt" : "2015-09-25T23:26:49Z",
        "updatedAt" : "2015-09-25T23:26:49Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "885755fb8f70142a8c27b8d84db4f15e614c003e",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +221,225 @@         * or undefined if that none exist.\n         */\n        function findCommonJSRequireCalls(node: Node): Node {\n            if (node.kind === SyntaxKind.CallExpression) {\n                let call = <CallExpression>node;"
  },
  {
    "id" : "2c3c008a-0a1d-4c5f-8cb1-186055425c6c",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fac13b7e-5542-40d9-9be3-ff62447bfa8e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "This reads very strangely - it can be read as \"the reachability of `if (true)` than the state within the `if` block. Maybe a quick comment would help.\n",
        "createdAt" : "2015-09-15T04:44:18Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +554,558 @@            // denotes reachability state when entering 'thenStatement' part of the if statement: \n            // i.e. if condition is false then thenStatement is unreachable\n            const ifTrueState = n.expression.kind === SyntaxKind.FalseKeyword ? Reachability.Unreachable : currentReachabilityState;\n            // denotes reachability state when entering 'elseStatement':\n            // i.e. if condition is true then elseStatement is unreachable"
  },
  {
    "id" : "fc3926e0-13ff-4f39-b0a1-956e719e7348",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3b07390a-92eb-40d3-aa41-a73d6f1eed56",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Maybe call this `reportIfUnreachable`\n",
        "createdAt" : "2015-09-15T05:20:37Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1450,1454 @@        }\n\n        function checkUnreachable(node: Node): boolean {\n            switch (currentReachabilityState) {\n                case Reachability.Unreachable:"
  },
  {
    "id" : "155852c1-fe54-4fdf-89a2-41a8a630fa54",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00a25ef7-7a17-4ee7-af2c-d34b4f3e67e1",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "isn't all  `var` hoisted regardless of whether it is initialized?\n",
        "createdAt" : "2015-09-16T18:34:17Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "4a280039-9419-43c8-abfe-12f9b8890d16",
        "parentId" : "00a25ef7-7a17-4ee7-af2c-d34b4f3e67e1",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "var is hoisted but initializer is not and I'd prefer to have consistent error reporting for vars\\lets\\consts\n",
        "createdAt" : "2015-09-16T19:23:06Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1473,1477 @@                        //   - node is block scoped variable statement OR\n                        //   - node is not block scoped variable statement and at least one variable declaration has initializer\n                        //   Rationale: we don't want to report errors on non-initialized var's since they are hoisted\n                        //   On the other side we do want to report errors on non-initialized 'lets' because of TDZ\n                        const reportUnreachableCode ="
  },
  {
    "id" : "a2fea957-629b-4278-bf21-c6dd98fa3c6c",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bdf4170a-4dfd-473f-a843-8fa57fb0870a",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Why can't you  `currentReachabilityState = or(isTrueState, isFalseState)` here? Does calling bind(n.theStatement) or bind(n.elseStatement) change the reachabilityState ?\n",
        "createdAt" : "2015-09-16T19:00:36Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "aeb4b3b3-d38e-47f0-b5d7-de234d5a4e04",
        "parentId" : "bdf4170a-4dfd-473f-a843-8fa57fb0870a",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "no. binder itself still needs to do its work and we still want to do reachability checks in `then` and `else` statements\n",
        "createdAt" : "2015-09-16T19:23:48Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : 283,
    "diffHunk" : "@@ -1,1 +559,563 @@            const ifFalseState = n.expression.kind === SyntaxKind.TrueKeyword ? Reachability.Unreachable : currentReachabilityState;\n\n            currentReachabilityState = ifTrueState;\n\n            // bind expression (don't affect reachability)"
  },
  {
    "id" : "e9b05e1e-130c-40bd-b120-1f585cd0fa6c",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3a890cb-d6e2-434c-87d8-5a9e16b7f993",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Would prefer different name as `thenStatementReachability` and `elseStatementReachability`?\n",
        "createdAt" : "2015-09-16T19:02:05Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +554,558 @@            // denotes reachability state when entering 'thenStatement' part of the if statement: \n            // i.e. if condition is false then thenStatement is unreachable\n            const ifTrueState = n.expression.kind === SyntaxKind.FalseKeyword ? Reachability.Unreachable : currentReachabilityState;\n            // denotes reachability state when entering 'elseStatement':\n            // i.e. if condition is true then elseStatement is unreachable"
  },
  {
    "id" : "4f4898d3-b65a-4b07-9b12-8a7d252a0af4",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a08cf6e-2c28-4a12-8012-e60206d1d02d",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "I don't understand reachability of switch-statement. Why being exhaustive prevent post switch to be reachable? \n",
        "createdAt" : "2015-09-16T21:32:18Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "cad96ca4-5fee-4ff9-a716-a355ceb5b8f7",
        "parentId" : "8a08cf6e-2c28-4a12-8012-e60206d1d02d",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "discussed offline\n",
        "createdAt" : "2015-09-17T23:03:41Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "13d8349a-1c94-40e8-bb2c-4c11a10d2528",
        "parentId" : "8a08cf6e-2c28-4a12-8012-e60206d1d02d",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : ":cookie: :cake: \n",
        "createdAt" : "2015-09-17T23:28:10Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +626,630 @@\n            // post switch state is unreachable if switch is exaustive (has a default case ) and does not have fallthrough from the last case\n            const postSwitchState = hasDefault && currentReachabilityState !== Reachability.Reachable ? Reachability.Unreachable : preSwitchState;\n\n            popImplicitLabel(postSwitchLabel, postSwitchState);"
  },
  {
    "id" : "188b64b5-8286-4822-9421-ce4458708bb9",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af8e6a2d-e419-46f3-8a7c-2cc41d104b29",
        "parentId" : null,
        "authorId" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "body" : "Would be nice if parser could set a HasDefault flag and avoid the loop. Seems to require a solution so incremental parsing could track 'state' and reset ~ `resetStateAtPos(node.pos)`\n",
        "createdAt" : "2015-10-13T10:56:32Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "tags" : [
        ]
      },
      {
        "id" : "c61ee589-21e8-41b4-8da7-6ead5ff9e01a",
        "parentId" : "af8e6a2d-e419-46f3-8a7c-2cc41d104b29",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "It's fine for parent nodes to set state based on their children.  That's because if a cihld is even touched by an edit, the parent will _always_ be recreated.  So, conceptually there would be no incremental problem with adding such a flag to the 'switch' node.  That said, we've also tried to keep AST nodes pretty lightweight and consistent.  We don't want everyone hanging data off them willy nilly.  Also, even if we store the data on the node, we're just pushing the perf cost elsewhere.  After all, the parser will then have to do the same determination if there's a default clause as it doesn't really \"know\" during parsing.  After all, the clauses are just parsed during the recursive child parsing loop, and aren't done specially inside the switch parsing code.\n",
        "createdAt" : "2015-10-13T16:20:11Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "d8070a0c-ced6-440a-894c-b442a5a5e1e0",
        "parentId" : "af8e6a2d-e419-46f3-8a7c-2cc41d104b29",
        "authorId" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "body" : "@CyrusNajmabadi You're likely right about pushing perf cost elsewhere. Have lots of bad ideas so maybe this is one of those. My motivation mainly for looking into this is #3003. Adding some flags or keeping track of state as you're parsing just seems more intuitive then messing around in the binder. \n",
        "createdAt" : "2015-10-16T16:10:40Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : 347,
    "diffHunk" : "@@ -1,1 +623,627 @@            bind(n.caseBlock);\n\n            const hasDefault = forEach(n.caseBlock.clauses, c => c.kind === SyntaxKind.DefaultClause);\n\n            // post switch state is unreachable if switch is exaustive (has a default case ) and does not have fallthrough from the last case"
  },
  {
    "id" : "4a83d44b-1709-4054-aa0b-e3e63ac6b7ab",
    "prId" : 4788,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "264794d3-fc8a-47f6-8c43-f6e4015a54e3",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Now that binding depends on compiler options, do we appropriately invalidate the computed binding state when the compiler options change?\n",
        "createdAt" : "2015-10-13T15:18:01Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "d86561c7-a0a4-41d1-9994-69f43c196e6e",
        "parentId" : "264794d3-fc8a-47f6-8c43-f6e4015a54e3",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "good point, will make sure that we do it\n",
        "createdAt" : "2015-10-13T15:59:21Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "0ae56830-d6ee-4b8e-9a7a-00e0d36cc00b",
        "parentId" : "264794d3-fc8a-47f6-8c43-f6e4015a54e3",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : ":white_check_mark: \n",
        "createdAt" : "2015-10-13T16:45:30Z",
        "updatedAt" : "2015-10-29T16:34:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "3f11c0b2debb0dbf53ebc0a34a436a72c69007cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +95,99 @@    const binder = createBinder();\n\n    export function bindSourceFile(file: SourceFile, options: CompilerOptions) {\n        let start = new Date().getTime();\n        binder(file, options);"
  },
  {
    "id" : "aeba01d5-ad8c-47bd-bbc6-8628f2879675",
    "prId" : 4008,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "parentId" : null,
        "authorId" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "body" : "this seems like  the kind of place you want to mix quotes instead of using escapes (except for the hilarious inversion of ' and \" on each side of the ||)\n",
        "createdAt" : "2015-07-24T00:46:26Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "tags" : [
        ]
      },
      {
        "id" : "30f07de2-a9ad-4a4b-a6f7-b3f5d00642e2",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "There's a number of places where that's true... but quote consistency is there for quote consistency, not for convenience, I suppose.\n",
        "createdAt" : "2015-07-24T00:50:10Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "378b7ef8-956c-4a7b-9a18-c14595c9db0b",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "body" : "Yeah I saw a bunch more and didn't bother commenting again. I don't feel super strongly here but I always found mixing ' and \" handy for cases like this but I can live without it.\n",
        "createdAt" : "2015-07-24T00:52:14Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "062f3bee-c17a-4517-ad46-ba1c73ac0962",
        "tags" : [
        ]
      },
      {
        "id" : "28ddddd4-3814-4c3a-8210-c63f2a5defc0",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "I've actually been wondering this for awhile - since template strings are a thing in JS now, why don't linters have an option to prefer those? I think they're a bit more flexible and generally easier to keep consistent with. Plus, it reduces what you have as far as string literals go from quotes and backticks to just backticks. (Since you're likely using backticks for interpolation anyway!)\n",
        "createdAt" : "2015-07-24T00:54:06Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "bcc0f249-94ff-41d8-8ac8-77831b5a5cb6",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "a6a85419-5aa5-4f84-b340-c8d9d45bc098",
        "body" : "@weswigham TSLint supports string templates for the quote rule -- it does this by simply ignoring the contents of template strings. So a \"double\" quote rule really means only allow double quotes or string templates.\n",
        "createdAt" : "2015-07-24T03:12:26Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "a6a85419-5aa5-4f84-b340-c8d9d45bc098",
        "tags" : [
        ]
      },
      {
        "id" : "ad60e8d6-b94b-48b6-9c2b-c6e862cad209",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "No, I mean, why not forbid all quotes (single and double)? Template string literals can function as string literals handily, and it further unifies what string literals get used. Not really relevant here, I was just wondering why no linting tools seemed to support this option.\n",
        "createdAt" : "2015-07-24T03:53:35Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "17415b20-e865-45c2-80df-a187b2c92664",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "ce212718-9579-45e4-8c78-e5f795a9053b",
        "body" : "@weswigham that's a valid suggestion. filed that feature request here: https://github.com/palantir/tslint/issues/539\n",
        "createdAt" : "2015-08-01T17:54:08Z",
        "updatedAt" : "2015-08-04T20:38:21Z",
        "lastEditedBy" : "ce212718-9579-45e4-8c78-e5f795a9053b",
        "tags" : [
        ]
      },
      {
        "id" : "eba75e4c-f586-43a7-b65e-1c7259d541a2",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd still prefer to be able to mix quotes. I think it would be preferable for TSLint to support \"double quotes unless the string contains a double quote.\"\n",
        "createdAt" : "2015-08-05T21:58:59Z",
        "updatedAt" : "2015-08-05T21:58:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "0a10b8b0-5e57-46de-beeb-50ba3a8a74a1",
        "parentId" : "b4c41c78-3726-454d-b84d-673d3c6040d9",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Wouldn't be a problem if you used `backtick`s for all the quotes. Until you needed to include `backtick`s. :smile: \n\nBut no really - try not to mix quotes. It makes sense not to mix quotes if you consider searching for strings in the source code. Knowing the exact quotes used lets you (plaintext) search with much higher precision - knowing you can always Ctrl-Shift-F \"Joe's \\\"Error\\\" Message\" (over 'Joe\\'s \"Error\" Message') is way easier than not knowing if it's in one of many possible string formats. Generally speaking it's worth the effort of needing to toss in a `\\` in your string literals every so often.\n",
        "createdAt" : "2015-08-05T22:19:55Z",
        "updatedAt" : "2015-08-05T22:19:55Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "5324f8bf4cf91b877da7869634183443ec4702f9",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +831,835 @@            // Note: the node text must be exactly \"use strict\" or 'use strict'.  It is not ok for the\n            // string to contain unicode escapes (as per ES5).\n            return nodeText === \"\\\"use strict\\\"\" || nodeText === \"'use strict'\";\n        }\n"
  },
  {
    "id" : "a2770575-7308-4d47-8c1d-684ec2f9f3a6",
    "prId" : 3517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee8b7490-9e42-4ddd-8bbf-b3d5b65f19d4",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Share logic with getStrictModeIdentifierMessage?\n",
        "createdAt" : "2015-06-16T04:29:47Z",
        "updatedAt" : "2015-06-16T06:32:12Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "4ceef0e9-0b25-4220-972f-75a04624fcee",
        "parentId" : "ee8b7490-9e42-4ddd-8bbf-b3d5b65f19d4",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I couldn't figure out a way.  Suggestions? :)\n",
        "createdAt" : "2015-06-16T06:20:52Z",
        "updatedAt" : "2015-06-16T06:32:12Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "eb1c9942-b1de-44ad-90d8-4e71b891e0db",
        "parentId" : "ee8b7490-9e42-4ddd-8bbf-b3d5b65f19d4",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I started to write it out, and then realized that while it is possible, it seems really silly. It's fine how it is.\n",
        "createdAt" : "2015-06-16T17:44:45Z",
        "updatedAt" : "2015-06-16T17:44:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "300089ce2dcf7847bfc6baf9f6d98d09f835ce3a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +686,690 @@        }\n\n        function getStrictModeEvalOrArgumentsMessage(node: Node) {\n            // Provide specialized messages to help the user understand why we think they're in \n            // strict mode."
  },
  {
    "id" : "17f33f44-14d0-465f-bf2c-b3e35af5cc54",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dfeafb62-7331-4e74-9006-f3dfc21cb211",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why is this a container with locals, but classes and interfaces are not?\n",
        "createdAt" : "2015-06-05T22:59:10Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +339,343 @@                case SyntaxKind.ModuleDeclaration:\n                case SyntaxKind.SourceFile:\n                case SyntaxKind.TypeAliasDeclaration:\n                    return ContainerFlags.IsContainerWithLocals;\n"
  },
  {
    "id" : "7a5ac8e1-3395-44f8-829f-decc9897b152",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c62e8a54-2a6e-449c-92e4-78af4947bd02",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why does this get its type parameters added to `.locals`, but Class and Interface do not? Are the type parameters added to the locals for generic signatures as well?\n",
        "createdAt" : "2015-06-05T23:02:57Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "2ebd8af7-8b2b-40a8-815d-8fb8f183d5d0",
        "parentId" : "c62e8a54-2a6e-449c-92e4-78af4947bd02",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Type parameters of classes and interfaces are in the `members` collection, whereas type parameters of generic signatures are in the `locals` collection. Since a type alias doesn't have any notion of members, `locals` seems like the best choice. Also, it is a bit less work in `resolveName` because we don't have to add an extra case to the switch (we look for `locals` on every ancestor node).\n",
        "createdAt" : "2015-06-06T14:46:01Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "69b69a4b-d1c7-4870-8d09-d61ff03697e2",
        "parentId" : "c62e8a54-2a6e-449c-92e4-78af4947bd02",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can we move the class and interface type parameters to the locals as well (and create a locals if we don't have one already)? Seems really strange that they are stored in the members, and certainly not consistent with type aliases.\n",
        "createdAt" : "2015-06-06T22:38:35Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d29e07c6-8ce5-4e89-84ca-0b92d54ac155",
        "parentId" : "c62e8a54-2a6e-449c-92e4-78af4947bd02",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, I'd like to leave it this way. We wouldn't gain anything from the move, in fact it would just introduce another symbol table that needs to be visited. Also, the spec actually calls for type parameters and members to be in the same declaration space (even though it isn't observable right now because all members are values, but it would be if we ever support local types in classes and/or interfaces).\n",
        "createdAt" : "2015-06-06T23:19:07Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "e9790e77-31fe-4f3b-a979-e687225180f0",
        "parentId" : "c62e8a54-2a6e-449c-92e4-78af4947bd02",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I always thought of locals as entities that could be accessed without qualification (they are in scope), whereas members require qualification (they are not in scope). This is why it seemed natural that type parameters would be locals, while class elements would be members. If that is not the difference between locals and members, what is the difference?\n",
        "createdAt" : "2015-06-07T06:14:15Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +427,431 @@                case SyntaxKind.FunctionExpression:\n                case SyntaxKind.ArrowFunction:\n                case SyntaxKind.TypeAliasDeclaration:\n                    // All the children of these container types are never visible through another\n                    // symbol (i.e. through another symbol's 'exports' or 'members').  Instead,"
  },
  {
    "id" : "66ef223e-e4a0-48c5-960b-debd6881ebc2",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78478e4a-2481-4ac8-988e-59c7e84d5e22",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I guess classes are already block scoped?\n",
        "createdAt" : "2015-05-28T08:24:24Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "92e843ab-9965-43f8-a259-d2c937371242",
        "parentId" : "78478e4a-2481-4ac8-988e-59c7e84d5e22",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Correct.\n",
        "createdAt" : "2015-05-28T12:59:30Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +530,534 @@                    }\n                    else {\n                        bindBlockScopedDeclaration(<Declaration>node, SymbolFlags.RegularEnum, SymbolFlags.RegularEnumExcludes);\n                    }\n                    break;"
  },
  {
    "id" : "d3ffb662-9d7e-4125-81a0-b06f03ddc5e2",
    "prId" : 2843,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "319fe12e-64f6-4e47-9c4d-8f34e795bc40",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "can be moved closer to use site\n",
        "createdAt" : "2015-04-21T19:44:17Z",
        "updatedAt" : "2015-06-03T00:42:11Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "0bc7544e-339a-49b8-b95a-cf3a2d9389ae",
        "parentId" : "319fe12e-64f6-4e47-9c4d-8f34e795bc40",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "never mind, didn't notice its usage in else branch\n",
        "createdAt" : "2015-04-21T20:02:54Z",
        "updatedAt" : "2015-06-03T00:42:11Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "4c18b2bcf814b8d91c655eedcb1e5926634eb2dc",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +224,228 @@\n        function declareModuleMember(node: Declaration, symbolFlags: SymbolFlags, symbolExcludes: SymbolFlags): Symbol {\n            let hasExportModifier = getCombinedNodeFlags(node) & NodeFlags.Export;\n            if (symbolFlags & SymbolFlags.Alias) {\n                if (node.kind === SyntaxKind.ExportSpecifier || (node.kind === SyntaxKind.ImportEqualsDeclaration && hasExportModifier)) {"
  },
  {
    "id" : "9f9f81cd-f021-4c42-b35f-1fa781620159",
    "prId" : 2460,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eefa6dec-a988-4d59-9a72-fbd0396a1066",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "this is a fairly odd name to give this entity.  Is it used elsewhere?  if so, we should put it in a common location so we don't have magic strings like this floating around.  \n",
        "createdAt" : "2015-03-23T04:54:06Z",
        "updatedAt" : "2015-03-25T16:47:45Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "04d2088a-7a3f-4ba1-8fde-73b74f3e57a1",
        "parentId" : "eefa6dec-a988-4d59-9a72-fbd0396a1066",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It needs a name that can meaningfully be shown in error messages (such as duplicate symbol 'export=' when there is more than one). It is used in a few other places, but so are all the other ones here.\n",
        "createdAt" : "2015-03-23T05:01:49Z",
        "updatedAt" : "2015-03-25T16:47:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a05f1e8d8595237f7d877021849b1de302c5f2d1",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +124,128 @@                    return \"__export\";\n                case SyntaxKind.ExportAssignment:\n                    return (<ExportAssignment>node).isExportEquals ? \"export=\" : \"default\";\n                case SyntaxKind.FunctionDeclaration:\n                case SyntaxKind.ClassDeclaration:"
  },
  {
    "id" : "af811800-d174-47e1-82ca-01494c012a81",
    "prId" : 2382,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e8fc969-fd8c-4ccb-9fb8-d3b2788acf86",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems like in the following case, node.symbol.constEnumOnlyModule would be false, but should be true:\n\n``` ts\nmodule M {\n    export interface I { }\n}\nmodule M {\n    export const enum E { x }\n}\n```\n",
        "createdAt" : "2015-03-17T04:38:00Z",
        "updatedAt" : "2015-03-17T04:38:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "dbf301f9-2f9e-428b-ae31-0c3f87575fb1",
        "parentId" : "4e8fc969-fd8c-4ccb-9fb8-d3b2788acf86",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "it will be true; \n- binding first module - it is not instantiated so node.symbol.constEnumOnlyModule remains undefined,\n- binding second module - it is is const-enum-only - node.symbol.constEnumOnlyModule will be set to true\n",
        "createdAt" : "2015-03-17T05:09:16Z",
        "updatedAt" : "2015-03-17T05:09:16Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "5723b45c-87a8-4702-8aff-825a94ada9b6",
        "parentId" : "4e8fc969-fd8c-4ccb-9fb8-d3b2788acf86",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "RIght\n",
        "createdAt" : "2015-03-17T17:41:53Z",
        "updatedAt" : "2015-03-17T17:41:53Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "74eb96a5b906d68c42e509432caad5c07a314f84",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +330,334 @@                    else {\n                        // merged case: module is const enum only if all its pieces are non-instantiated or const enum\n                        node.symbol.constEnumOnlyModule = node.symbol.constEnumOnlyModule && currentModuleIsConstEnumOnly;\n                    }\n                }"
  },
  {
    "id" : "278187b3-aaef-4b25-bf61-727a23f31d93",
    "prId" : 2161,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2c8c90db-bee8-4b04-8d4f-0fca9174d823",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I don't know what `cleanLocals` means without reading the function, and even then I don't know what the implications for this are. Can you leave a comment regarding the situations in which this is useful?\n",
        "createdAt" : "2015-02-27T23:02:31Z",
        "updatedAt" : "2015-02-28T01:24:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "3e1efb25-79a2-4b16-a09f-6808801417d0",
        "parentId" : "2c8c90db-bee8-4b04-8d4f-0fca9174d823",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't understand this. Why is blockScopedContainer.locals populated? I thought it should always be empty to start.\n",
        "createdAt" : "2015-02-27T23:39:33Z",
        "updatedAt" : "2015-02-28T01:24:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b3a94c7d7bea54baec55507d67dc458004da59d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +79,83 @@        }\n\n        function setBlockScopeContainer(node: Node, cleanLocals: boolean) {\n            blockScopeContainer = node;\n            if (cleanLocals) {"
  },
  {
    "id" : "74d93021-641f-4825-a771-f7d59925eea0",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "656d065b-e6fc-4da6-99fb-982996cb9b7e",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So you are saying that you want vars and lets to go to one place, because you want them to collide. The choice of function locals as opposed to block locals is arbitrary, it just has to be the same for both declaration kinds. Correct? \n",
        "createdAt" : "2015-02-13T18:54:06Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8279ec28-6acd-4366-a8ff-13d9b6065fac",
        "parentId" : "656d065b-e6fc-4da6-99fb-982996cb9b7e",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Yeah, i'd add a comment to that effect.  I think using hte function as the location makes sense though, as that's where we put parameters.  (we should also add tests for parameters/locals/lets (if they collide or not))\n",
        "createdAt" : "2015-02-13T19:26:04Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "941728de074a93488d8d7d6bebd3725d5276f205",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +490,494 @@                    //  var x;\n                    // }\n                    // 'var x' will be placed into the function locals and 'let x' - into the locals of the block\n                    bindChildren(node, 0, /*isBlockScopeContainer*/ !isAnyFunction(node.parent));\n                    break;"
  },
  {
    "id" : "355e4572-82e1-4484-80b2-15df77c66b7f",
    "prId" : 1272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74535db0-404c-4662-85aa-e3803e7f8060",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "what is meant by 'unknown' here?\n",
        "createdAt" : "2014-11-26T01:27:23Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "143f3f4b-20fb-4b55-b276-0ccd6896cb8e",
        "parentId" : "74535db0-404c-4662-85aa-e3803e7f8060",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It means, not of the form \"Symbol.something\"\n",
        "createdAt" : "2014-11-26T19:07:31Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8b9a2aa7-5dca-42a0-90cc-8734d586d1fc",
        "parentId" : "74535db0-404c-4662-85aa-e3803e7f8060",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Then either rename this `hasNonSymbolComputedName` or add a sufficient comment explaining that it means this and why it's particularly important to check (i.e. we're specially supporting computed names of the form `Symbol.*`).\n",
        "createdAt" : "2014-11-27T01:17:37Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b4280e3b-6d00-4e2a-bedb-c1572624ba06",
        "parentId" : "74535db0-404c-4662-85aa-e3803e7f8060",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I can change it to `hasNonSymbolComputedName`. But I think I prefer `hasComputedNameWithUnknownValue`\n",
        "createdAt" : "2014-11-27T02:25:12Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b0faa3af-b080-43d8-8318-368830ea72d7",
        "parentId" : "74535db0-404c-4662-85aa-e3803e7f8060",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Or `hasComputedNameButNotSymbol`\n",
        "createdAt" : "2014-11-27T02:25:52Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddebd028288b90c392ef5661a8f18af4f716f77e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +61,65 @@     */\n    export function hasComputedNameButNotSymbol(declaration: Declaration): boolean {\n        return declaration.name && declaration.name.kind === SyntaxKind.ComputedPropertyName;\n    }\n"
  },
  {
    "id" : "0d98c153-cd59-4944-81c1-57931af78496",
    "prId" : 1169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a9ffd4e-1c0e-49a1-9422-fe55b5d566ff",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Took me a while to read this correctly. Can the return statements be moved to new lines?\n",
        "createdAt" : "2014-11-15T00:34:50Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "2efe0a3a-dc3d-463d-9b60-f93539291cd1",
        "parentId" : "2a9ffd4e-1c0e-49a1-9422-fe55b5d566ff",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "sure.\n",
        "createdAt" : "2014-11-15T00:38:04Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa48152eb8329202f604cc2d9c3c8e8da5faf08",
    "line" : null,
    "diffHunk" : "@@ -1,1 +97,101 @@                case SyntaxKind.Constructor:\n                    return \"__constructor\";\n                case SyntaxKind.FunctionType:\n                case SyntaxKind.CallSignature:\n                    return \"__call\";"
  },
  {
    "id" : "05536100-01c9-450a-b2b0-428292d96efb",
    "prId" : 1169,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "881164d6-6175-47c9-b1fd-24e36d29e81f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why not SymbolFlags.TypeLiteral?\n",
        "createdAt" : "2014-11-15T00:44:59Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "fc2e3757-53a8-4327-814a-194394422c26",
        "parentId" : "881164d6-6175-47c9-b1fd-24e36d29e81f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Actually I guess if this is going to be the member symbol, you do want CallSignature/ConstructSignature\n",
        "createdAt" : "2014-11-15T00:45:41Z",
        "updatedAt" : "2014-11-15T01:15:57Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa48152eb8329202f604cc2d9c3c8e8da5faf08",
    "line" : null,
    "diffHunk" : "@@ -1,1 +314,318 @@            // from an actual type literal symbol you would have gotten had you used the long form.\n\n            var symbolKind = node.kind === SyntaxKind.FunctionType ? SymbolFlags.CallSignature : SymbolFlags.ConstructSignature;\n            var symbol = createSymbol(symbolKind, getDeclarationName(node));\n            addDeclarationToSymbol(symbol, node, symbolKind);"
  },
  {
    "id" : "dbb8e0e6-bd7c-432e-854b-793a1b855365",
    "prId" : 688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5edc8519-f3ac-4823-b349-67625c1c3ba6",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I have recently added NodeFlags.AccessibilityModifier, a merge should bring it to your branch\n",
        "createdAt" : "2014-09-17T19:44:35Z",
        "updatedAt" : "2014-09-19T21:01:30Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5b0777ad51fa6e7de362fad5e10db95a5ab91a3",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +227,231 @@            bindDeclaration(node, SymbolFlags.Constructor, 0);\n            forEach(node.parameters, p => {\n                if (p.flags & (NodeFlags.Public | NodeFlags.Private | NodeFlags.Protected)) {\n                    bindDeclaration(p, SymbolFlags.Property, SymbolFlags.PropertyExcludes);\n                }"
  },
  {
    "id" : "3d7c0bb6-5827-41d6-925a-98e4c9ba5801",
    "prId" : 330,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aebf7f6f-5de3-4a73-bfec-8aa5f24fc7e6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'm awfully confused - why are we binding on the catch block instead of the variable? It seems inherently wrong, and is otherwise undocumented.\n",
        "createdAt" : "2014-08-02T18:24:29Z",
        "updatedAt" : "2014-08-04T18:41:13Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "ca5e0532-fb56-4a4e-9401-76131ac4cee9",
        "parentId" : "aebf7f6f-5de3-4a73-bfec-8aa5f24fc7e6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Symbols are supposed to be bound to the declaration node that _contains_ their identifier, but a catch block was erroneously bound to the identifier itself.\n",
        "createdAt" : "2014-08-03T22:27:29Z",
        "updatedAt" : "2014-08-04T18:41:13Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b26e3797642c396a1e70c787dd3ffe2b0e2cc06",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +251,255 @@        function bindCatchVariableDeclaration(node: CatchBlock) {\n            var symbol = createSymbol(SymbolFlags.Variable, node.variable.text || \"__missing\");\n            addDeclarationToSymbol(symbol, node, SymbolFlags.Variable);\n            var saveParent = parent;\n            parent = node;"
  }
]
[
  {
    "id" : "ec1c44b7-a44f-40c8-a534-88d668ab5872",
    "prId" : 21203,
    "prUrl" : "https://github.com/microsoft/TypeScript/pull/21203#pullrequestreview-89219717",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e0733963-b9b3-48bb-8fb1-e0bd151aca8f",
        "parentId" : null,
        "authorId" : "39105c25-586e-496a-9515-4fce35443a7c",
        "body" : "It looks like we're using `TypeFormatFlags.UseStructuralFallback` in all the same places we already use `TypeFormatFlags.UseTypeOfFunction`. Can they be combined?",
        "createdAt" : "2018-01-16T19:25:25Z",
        "updatedAt" : "2018-01-16T19:39:10Z",
        "lastEditedBy" : "39105c25-586e-496a-9515-4fce35443a7c",
        "tags" : [
        ]
      },
      {
        "id" : "9a892d05-46b3-4603-86ac-74091bad53c6",
        "parentId" : "e0733963-b9b3-48bb-8fb1-e0bd151aca8f",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "They could be, but then external consumers lose the choice of allowing the structural fallback or not. I'm erring on the side of being more configurable here, since they are seperate behaviors. This way allows something like a quickfix to try to build a node using typeof with no fallback, see if there's an error, then decide not to offer the fix, for example.",
        "createdAt" : "2018-01-16T19:29:09Z",
        "updatedAt" : "2018-01-16T19:41:52Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "f2bd77eddcd792ceba399bb750c5473038656cd6",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +359,363 @@            else {\n                errorNameNode = declaration.name;\n                const format = TypeFormatFlags.UseTypeOfFunction | TypeFormatFlags.UseStructuralFallback | TypeFormatFlags.WriteDefaultSymbolWithoutName |\n                    TypeFormatFlags.WriteClassExpressionAsTypeLiteral |\n                    (shouldUseResolverType ? TypeFormatFlags.AddUndefined : 0);"
  },
  {
    "id" : "24631153-6257-46b0-94a5-a44139d88687",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8f75f80f-f850-4541-b6c7-05bf7d493736",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "what about external modules with no exports or no module augmentation? soemthing like:\n\n``` ts\nimport {a} from \"./mod\";\n// do something with a\n```\n",
        "createdAt" : "2016-01-13T18:51:44Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "6a797ef5-855a-47e4-bbe2-3956bbc98b63",
        "parentId" : "8f75f80f-f850-4541-b6c7-05bf7d493736",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i thought we will do this for any external module, that we never emitted any import, export, or module augmentation for.\n",
        "createdAt" : "2016-01-13T18:52:58Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +143,147 @@            }\n\n            if (!isBundledEmit && isExternalModule(sourceFile) && sourceFile.moduleAugmentations.length && !resultHasExternalModuleIndicator) {\n                // if file was external module with augmentations - this fact should be preserved in .d.ts as well.\n                // in case if we didn't write any external module specifiers in .d.ts we need to emit something "
  },
  {
    "id" : "8889d246-c706-41cb-9192-47deae2b7124",
    "prId" : 5471,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "defdcfcf-14d5-44c1-91fd-7de365e2a612",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "lost `this`, use arrow function instead\n",
        "createdAt" : "2015-11-16T22:52:14Z",
        "updatedAt" : "2015-11-18T19:27:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "27a0b6af-c4dc-4b8c-b121-2ab11f091495",
        "parentId" : "defdcfcf-14d5-44c1-91fd-7de365e2a612",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "But I am not using this?\n",
        "createdAt" : "2015-11-17T01:15:33Z",
        "updatedAt" : "2015-11-18T19:27:06Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "25000892-90ca-45e6-ad5e-eeaed460530d",
        "parentId" : "defdcfcf-14d5-44c1-91fd-7de365e2a612",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "ok, sorry, I thought it was `CompilerHost` not `EmitHost`. There are users who use classes to implement host interfaces and for them losing this can be problematic. I've seen such implementations for `CompilerHost`, maybe it is less critical for `EmitHost` since we use this interface for internal decomposition, not as extensibility point for external customers\n",
        "createdAt" : "2015-11-17T01:20:40Z",
        "updatedAt" : "2015-11-18T19:27:06Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "24d5c392-1ab9-4330-83cd-819595e01d32",
        "parentId" : "defdcfcf-14d5-44c1-91fd-7de365e2a612",
        "authorId" : "6feba8ca-0b6a-496c-83fb-5fdd3b4e56f3",
        "body" : "A short comment in code would help though!\n",
        "createdAt" : "2015-11-20T10:05:13Z",
        "updatedAt" : "2015-11-20T10:05:13Z",
        "lastEditedBy" : "6feba8ca-0b6a-496c-83fb-5fdd3b4e56f3",
        "tags" : [
        ]
      }
    ],
    "commit" : "a19307d533d646d3366f7d4a512718460e065d52",
    "line" : 264,
    "diffHunk" : "@@ -1,1 +1644,1648 @@                    declFileName,\n                    host.getCurrentDirectory(),\n                    host.getCanonicalFileName,\n                    /*isAbsolutePathAnUrl*/ false);\n"
  },
  {
    "id" : "29e998bf-3ef0-4db9-ae81-2dc8b9ccbd68",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efa76e50-1fd5-4bb8-8edf-50de28f862e8",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "can you add a test for `export default abstract class foo {}` \n",
        "createdAt" : "2015-06-20T23:58:37Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "8c5b859c-29d3-4abd-bec4-befcce28debc",
        "parentId" : "efa76e50-1fd5-4bb8-8edf-50de28f862e8",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "I hadn't thought of this case and the more general behavior of exports? What would we like to support? Currently this is a parsing error.\n",
        "createdAt" : "2015-06-22T21:17:34Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      },
      {
        "id" : "ccf3fae4-e2ee-477d-a408-980ef8a3bc03",
        "parentId" : "efa76e50-1fd5-4bb8-8edf-50de28f862e8",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I would wait on this. i would add a test though.\n",
        "createdAt" : "2015-06-24T18:04:46Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "1960e865-ed8a-48e4-b26e-45b3a15ebcd8",
        "parentId" : "efa76e50-1fd5-4bb8-8edf-50de28f862e8",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "In principle, I see no reason to disallow default abstract classes. Why are they any different from concrete classes from an export default standpoint?\n",
        "createdAt" : "2015-06-29T19:50:43Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +916,920 @@            emitJsDocComments(node);\n            emitModuleElementDeclarationFlags(node);\n            if (node.flags & NodeFlags.Abstract) {\n                write(\"abstract \");\n            }"
  },
  {
    "id" : "9e57a844-e534-4f73-8327-e1e0d22768f7",
    "prId" : 3545,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e4b8737-1865-424e-883e-1f1250bae8aa",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "By the way, before I realized you fixed this issue (I just created a branch), I found that this is the only place we ever use `NodeFlags.Namespace`. Just kind of weird.\n",
        "createdAt" : "2015-06-18T05:27:35Z",
        "updatedAt" : "2015-06-18T06:44:22Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f651d72f-ddb4-4abe-ac1e-7e2ff693ce39",
        "parentId" : "4e4b8737-1865-424e-883e-1f1250bae8aa",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we stored the info but never used it. this is the first use.\n",
        "createdAt" : "2015-06-18T06:37:59Z",
        "updatedAt" : "2015-06-18T06:44:22Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "53579f089e920c811b6b7de848f0f52dbf702790",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +710,714 @@            emitJsDocComments(node);\n            emitModuleElementDeclarationFlags(node);\n            if (node.flags & NodeFlags.Namespace) {\n                write(\"namespace \");\n            }"
  }
]
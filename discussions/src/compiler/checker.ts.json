[
  {
    "id" : "40888a2f-3f01-46fa-8aaa-442181dc1e64",
    "prId" : 9180,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c3da7fd-c556-4736-86ab-386cdb07eace",
        "parentId" : null,
        "authorId" : "9f1f7c23-b07f-4d8c-b6cf-0442ffcf7c85",
        "body" : "`getAncestor` cannot be used here because it will confuse with `class A extends generateClass(Interface) {}`.\nSee the test case `classExtendsInterfaceInExpression`\n",
        "createdAt" : "2016-06-17T03:15:43Z",
        "updatedAt" : "2016-06-17T03:32:20Z",
        "lastEditedBy" : "9f1f7c23-b07f-4d8c-b6cf-0442ffcf7c85",
        "tags" : [
        ]
      }
    ],
    "commit" : "2a9636b1beb87581536af331c90c343d821b76bc",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +941,945 @@        function checkAndReportErrorForExtendingInterface(errorLocation: Node): boolean {\n            let parentClassExpression = errorLocation;\n            while (parentClassExpression) {\n                const kind = parentClassExpression.kind;\n                if (kind === SyntaxKind.Identifier || kind === SyntaxKind.PropertyAccessExpression) {"
  },
  {
    "id" : "74582128-8cc4-4c78-8535-090d5792a971",
    "prId" : 9013,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d07935d5-0901-49c7-9284-9dd188707590",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Technically you should consider the compound assignment operators here as well (e.g. `+=`, `-=` etc)\n",
        "createdAt" : "2016-06-08T06:17:05Z",
        "updatedAt" : "2016-06-08T06:17:05Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "516ce8ac-0cbf-44b5-bc22-2146211bcc58",
        "parentId" : "d07935d5-0901-49c7-9284-9dd188707590",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Compound operators aren't included in control flow analysis in our current design, so that would be a separate issue. But as I see it they wouldn't affect the type because they both a read and a write operation (you're basically storing a value of the same type back into the variable). Did you have something in mind?\n",
        "createdAt" : "2016-06-08T16:50:41Z",
        "updatedAt" : "2016-06-08T16:50:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "927e9fc9-aeb3-44a6-8685-e0a4a8c2a998",
        "parentId" : "d07935d5-0901-49c7-9284-9dd188707590",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Nothing other than odd cases like this:\n\n``` ts\nvar x: number | string = getNumberOrString();\nx += \"hello\";\nx; // currently has type 'string | number'\n```\n\nwhereas in this case you get a different result\n\n``` ts\nvar x: number | string = getNumberOrString();\nx = x + \"hello\";\nx; // currently has type 'string'\n```\n\nI don't know how often something like that comes up in practice though.\n",
        "createdAt" : "2016-06-08T16:59:26Z",
        "updatedAt" : "2016-06-08T16:59:57Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "cdf5b7aeb382be8ccc946a687be0c803c6ff89ab",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +7669,7673 @@                case SyntaxKind.BinaryExpression:\n                    switch ((<BinaryExpression>node).operatorToken.kind) {\n                        case SyntaxKind.EqualsToken:\n                            return getReferenceFromExpression((<BinaryExpression>node).left);\n                        case SyntaxKind.CommaToken:"
  },
  {
    "id" : "91c08bb4-8f31-4607-9e55-0e0e7d67c466",
    "prId" : 8970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "228ebf42-097f-41ba-be7b-3fc00ffadf3d",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Does this cover computed properties?\n\n``` ts\nconst LANG = \"German\";\nclass WurstLanguage {\n    [LANG]() {\n    }\n}\n```\n\nMaybe the class itself should be a control flow container.\n",
        "createdAt" : "2016-06-05T04:51:07Z",
        "updatedAt" : "2016-06-05T04:51:07Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "9f92f6fe-93f6-43ac-8a04-088a783bab69",
        "parentId" : "228ebf42-097f-41ba-be7b-3fc00ffadf3d",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Actually, it should work since the parent will be a method declaration with a computed property name. It still might be worth adding as a test.\n",
        "createdAt" : "2016-06-05T04:52:12Z",
        "updatedAt" : "2016-06-05T04:52:12Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b1effb7df5e6221260652280d47b78ae9ecbfac",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +8095,8099 @@            while (true) {\n                node = node.parent;\n                if (isFunctionLike(node) || node.kind === SyntaxKind.ModuleBlock || node.kind === SyntaxKind.SourceFile || node.kind === SyntaxKind.PropertyDeclaration) {\n                    return node;\n                }"
  },
  {
    "id" : "dbf8b2f0-90fb-4c7a-b6d7-d9f9e03703d4",
    "prId" : 8605,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6014687-191b-4d77-912f-29437054e66a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I wonder if you could do a copy-on-write sort of thing where you don't need a new map until you create a new symbol - but it's probably not worth the complexity.\n",
        "createdAt" : "2016-05-23T20:33:34Z",
        "updatedAt" : "2016-05-23T21:56:56Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "462607c8ecf37b4fc397f86eed15ba38623c2081",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6842,6846 @@                const original = getTypeOfSymbol(property);\n                const updated = f(original);\n                members[property.name] = updated === original ? property : createTransientSymbol(property, updated);\n            };\n            return members;"
  },
  {
    "id" : "957bb046-6811-4ec7-9981-af5dfb1c8e55",
    "prId" : 8502,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bbe2dab9-465a-4ce1-825f-a5f8fdc9a297",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "consider adding a check for decorators for when we enable them or at least add a test with a comment so that we know we need to check for it here.\n",
        "createdAt" : "2016-05-06T22:12:52Z",
        "updatedAt" : "2016-05-06T22:12:52Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "c36c074f378ae66c7f6e31e2bdafa0da8892c21e",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +14210,14214 @@                            // computed property names/initializers in instance property declaration of class like entities\n                            // are executed in constructor and thus deferred\n                            if (current.parent.kind === SyntaxKind.PropertyDeclaration &&\n                                !(current.parent.flags & NodeFlags.Static) &&\n                                isClassLike(current.parent.parent)) {"
  },
  {
    "id" : "f380f0f1-5bc9-48af-a8ae-db3112306373",
    "prId" : 8125,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a24e3d5-05dd-44c4-9c32-3a2c2cf345dc",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "nice üëç \n",
        "createdAt" : "2016-04-18T17:03:18Z",
        "updatedAt" : "2016-04-18T17:08:57Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "25d7229cbb020828c8f65224d3db8acd6dcb659b",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1825,1829 @@                const needsElementAccess = !isIdentifierStart(firstChar, languageVersion);\n\n                if (needsElementAccess) {\n                    writePunctuation(writer, SyntaxKind.OpenBracketToken);\n                    if (isSingleOrDoubleQuote(firstChar)) {"
  },
  {
    "id" : "5fecf431-98cb-4a24-92bd-75b10be00cca",
    "prId" : 8104,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2711fd1c-e9d0-42ab-9015-527b31684db4",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "There's also a case for `import =` declarations above that reports this error in global module augmentations.\n",
        "createdAt" : "2016-04-15T00:24:21Z",
        "updatedAt" : "2016-04-15T18:31:34Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f3f690a8d7409db87ef4a5ab322f83f305ce26c",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +15598,15602 @@                case SyntaxKind.InterfaceDeclaration:\n                case SyntaxKind.ModuleDeclaration:\n                case SyntaxKind.TypeAliasDeclaration:\n                    if (isGlobalAugmentation) {\n                        return;"
  },
  {
    "id" : "6bf4dfc5-189f-4d0e-9597-11ad0fcb0a6b",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e40a4d87-152a-4483-a8c1-7d73c472cea8",
        "parentId" : null,
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "This function is duplicated both here and in the binder. Should it be shared?\n",
        "createdAt" : "2016-04-11T17:19:58Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 418,
    "diffHunk" : "@@ -1,1 +7310,7314 @@        }\n\n        function isNarrowableReference(expr: Node): boolean {\n            return expr.kind === SyntaxKind.Identifier ||\n                expr.kind === SyntaxKind.ThisKeyword ||"
  },
  {
    "id" : "2aca2dc0-3793-4914-9ebd-c62c52e55692",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a4a6853-a4bd-4a7c-8fdf-a0271ace1095",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "`TypeFacts` is an odd name for this. Maybe `TypeNarrowFlags`?\n",
        "createdAt" : "2016-04-12T00:30:37Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f47b825a-cf5f-45b6-a746-39f4aaabb556",
        "parentId" : "2a4a6853-a4bd-4a7c-8fdf-a0271ace1095",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "I dunno, `TypeFacts` seems right to me - it's a flag which aggregates the facts (is truthy, is not null, etc) a program has proven about a type at a given location.\n",
        "createdAt" : "2016-04-12T01:11:13Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "2f74c595-bce4-4df2-a0c1-9831987dc0c5",
        "parentId" : "2a4a6853-a4bd-4a7c-8fdf-a0271ace1095",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Maybe, though, when I think `____Facts`, I either think of [SyntaxFacts](http://source.roslyn.codeplex.com/Microsoft.CodeAnalysis.CSharp/Syntax/SyntaxFacts.cs.html) (which we also used to have) or [this](http://imgur.com/gallery/rsQ93).\n",
        "createdAt" : "2016-04-12T07:13:20Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +204,208 @@        const diagnostics = createDiagnosticCollection();\n\n        const enum TypeFacts {\n            None = 0,\n            TypeofEQString = 1 << 0,      // typeof x === \"string\""
  },
  {
    "id" : "838e29a9-c25c-494a-8e94-9555b5ed7950",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c587e6a-b560-48dd-b734-0931cd10ae01",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What is HostObject?\n",
        "createdAt" : "2016-04-12T07:19:10Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "de36f081-aef0-46b3-9ca5-26cb12a57a5f",
        "parentId" : "5c587e6a-b560-48dd-b734-0931cd10ae01",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Objects defined by the ECMAScript standard are called native objects. Other objects, such as DOM objects, are called host objects. From a TS point of view, anything for which `typeof` returns a value other than `string`, `number`, `boolean`, `symbol`, `object`, `function`, or `undefined` is considered a host object.\n",
        "createdAt" : "2016-04-12T13:57:12Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "1cf69ef4-c19c-41c2-9de1-84de9b335f2b",
        "parentId" : "5c587e6a-b560-48dd-b734-0931cd10ae01",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh yes, like the DOMElements\n",
        "createdAt" : "2016-04-12T20:22:14Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 75,
    "diffHunk" : "@@ -1,1 +219,223 @@            TypeofNEObject = 1 << 11,     // typeof x !== \"object\"\n            TypeofNEFunction = 1 << 12,   // typeof x !== \"function\"\n            TypeofNEHostObject = 1 << 13, // typeof x !== \"xxx\"\n            EQUndefined = 1 << 14,        // x === undefined\n            EQNull = 1 << 15,             // x === null"
  },
  {
    "id" : "d07d2c8b-774e-4f52-807d-efe39cb9bf76",
    "prId" : 8010,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9ecf9dd-60ce-42e6-ad92-c61eb4e2e8a8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Here, we are using `anySignature` to signal that we are in the middle of a flow analysis. Why not use `inFlowCheck`? I think I am confused about the difference.\n",
        "createdAt" : "2016-04-16T23:09:57Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "704dc33b-fa84-40cb-93c4-4088c2c72f56",
        "parentId" : "f9ecf9dd-60ce-42e6-ad92-c61eb4e2e8a8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, we're using `anySignature` to signal that we're in the process of resolving the call signature (for any reason, flow analysis or not). When obtaining contextual types we never want to kick off resolution if we're already in the process of resolving, so we return `anySignature` in circular scenarios. Effectively there are two circular scenarios interacting here, flow analysis and contextual typing, and only the flow analysis scenario can kick off resolution when resolution is already ongoing.\n",
        "createdAt" : "2016-04-16T23:53:26Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4ab2d817-c113-4811-9269-7339dbaa18e7",
        "parentId" : "f9ecf9dd-60ce-42e6-ad92-c61eb4e2e8a8",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh ok, got it\n",
        "createdAt" : "2016-04-16T23:57:03Z",
        "updatedAt" : "2016-04-22T13:53:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0dee5addf3b129d9241e7dd57e895cea8ec7dfac",
    "line" : 1273,
    "diffHunk" : "@@ -1,1 +11125,11129 @@            // If we're already in the process of resolving the given signature, don't resolve again as\n            // that could cause infinite recursion. Instead, return anySignature.\n            return getNodeLinks(node).resolvedSignature === anySignature ? anySignature : getResolvedSignature(node);\n        }\n"
  },
  {
    "id" : "347c078b-0585-4776-a371-b43ea9d3b80c",
    "prId" : 7969,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d91afaf4-98b6-4a68-a0b9-18fb5ca45530",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "is this needed to make the new tests fail properly? If not, then does there need to be some test case that does need it to get the correct error message?\n",
        "createdAt" : "2016-04-08T20:00:05Z",
        "updatedAt" : "2016-04-08T20:00:05Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "afe94d2d-e931-4854-9cc3-813daae69ee7",
        "parentId" : "d91afaf4-98b6-4a68-a0b9-18fb5ca45530",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "this is needed for new test cases it gets covered by scenarios like\n\n``` ts\nf([a=undefined]) {\n}\n```\n",
        "createdAt" : "2016-04-08T20:31:07Z",
        "updatedAt" : "2016-04-08T20:31:07Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d2730790e00e2780e0771fe876194e2f859a933",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +2838,2842 @@            if (element.initializer) {\n                const type = checkExpressionCached(element.initializer);\n                reportErrorsFromWidening(element, type);\n                return getWidenedType(type);\n            }"
  },
  {
    "id" : "79fa11b6-2547-4df7-b48c-806abe3bb80d",
    "prId" : 7945,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a4e0a57-444d-45bf-8495-4195ebbadb94",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Does this implicitly return `undefined`? Invert the conditions here to reduce nesting and make the returns explicit.\n",
        "createdAt" : "2016-04-11T20:44:15Z",
        "updatedAt" : "2016-04-13T21:54:38Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c492fc6369f1319003695f8c0d8302fb3bc39f1d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11854,11858 @@            const elements = node.elements;\n            const element = elements[elementIndex];\n            if (element.kind !== SyntaxKind.OmittedExpression) {\n                if (element.kind !== SyntaxKind.SpreadElementExpression) {\n                    const propName = \"\" + elementIndex;"
  },
  {
    "id" : "e78a8d6f-573a-4f6a-aab3-8c91863b6183",
    "prId" : 7945,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "64854866-7caa-45c2-a501-5943ef7b60b0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Is `expr` the initializer? Or the assignment expression? Can you document that explicit with a comment and potentially using a slightly more precise type than `Expression`?\n",
        "createdAt" : "2016-04-11T20:51:51Z",
        "updatedAt" : "2016-04-13T21:54:38Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c492fc6369f1319003695f8c0d8302fb3bc39f1d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +16568,16572 @@        // [ a ] from \n        //     [a] = [ some array ...]\n        function getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr: Expression): Type {\n            Debug.assert(expr.kind === SyntaxKind.ObjectLiteralExpression || expr.kind === SyntaxKind.ArrayLiteralExpression);\n            // If this is from \"for of\""
  },
  {
    "id" : "d089a58b-b2e5-41a5-a07f-af689d0ddcea",
    "prId" : 7945,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55d77aad-5ba1-4eed-8996-c533b5d50a45",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "is not this the same as `getTypeFromBindingPattern`\n",
        "createdAt" : "2016-04-11T23:36:24Z",
        "updatedAt" : "2016-04-13T21:54:38Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "273db9cf-727c-47bc-a6e0-50557d8d9f36",
        "parentId" : "55d77aad-5ba1-4eed-8996-c533b5d50a45",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Its kind of higher level and gets the type of binding patterns object literal or array literal from binding pattern assignment. `GetTypeFromBindingPattern` needs `BindingPattern`. These are object literals and array literals from assignment so different node kinds\n",
        "createdAt" : "2016-04-11T23:46:59Z",
        "updatedAt" : "2016-04-13T21:54:38Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "6106a9d2-6b19-466d-b2b1-f61a14fd5f64",
        "parentId" : "55d77aad-5ba1-4eed-8996-c533b5d50a45",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we should then change the entry point to return a targetSymbol for a bindingPattern instead of a type.\n",
        "createdAt" : "2016-04-13T21:32:22Z",
        "updatedAt" : "2016-04-13T21:54:38Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "c84de480-2c0b-4206-a7bb-58e81d0f544c",
        "parentId" : "55d77aad-5ba1-4eed-8996-c533b5d50a45",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "@mhegazy done.\n",
        "createdAt" : "2016-04-13T21:55:00Z",
        "updatedAt" : "2016-04-13T21:55:00Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c492fc6369f1319003695f8c0d8302fb3bc39f1d",
    "line" : 166,
    "diffHunk" : "@@ -1,1 +16568,16572 @@        // [ a ] from \n        //     [a] = [ some array ...]\n        function getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr: Expression): Type {\n            Debug.assert(expr.kind === SyntaxKind.ObjectLiteralExpression || expr.kind === SyntaxKind.ArrayLiteralExpression);\n            // If this is from \"for of\""
  },
  {
    "id" : "74dc4c4d-77a8-4c03-9b6c-d2e0f44cc6f2",
    "prId" : 7715,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "adda41ae-6897-4323-924e-c24ce9994e0a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What exactly is the reason these are lazy again?\n",
        "createdAt" : "2016-03-28T22:07:25Z",
        "updatedAt" : "2016-03-30T21:03:36Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b800252d-78db-4f80-99b5-0ba99a78b039",
        "parentId" : "adda41ae-6897-4323-924e-c24ce9994e0a",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Because we don't want to give an error even when you don't use any of these feature. For example, if you code only use es6-array features and you specify `--lib es2015.array` you should not get an error of \"can't find 'Symbol' or 'Iterator'\": Being lazy allows us to do that \n",
        "createdAt" : "2016-03-28T22:47:07Z",
        "updatedAt" : "2016-03-30T21:03:36Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "e12671df-a493-4054-8cd1-2186a71a1ac9",
        "parentId" : "adda41ae-6897-4323-924e-c24ce9994e0a",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Sounds great! Can you leave that comment above these declarations?\n",
        "createdAt" : "2016-03-28T22:58:55Z",
        "updatedAt" : "2016-03-30T21:03:36Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "288f54a5-fcf1-445e-b9cb-4548d9404e69",
        "parentId" : "adda41ae-6897-4323-924e-c24ce9994e0a",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Yep :cake: \n",
        "createdAt" : "2016-03-29T17:53:37Z",
        "updatedAt" : "2016-03-30T21:03:36Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "1490547f889a2efafac865cdb794b083b53bb010",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +162,166 @@        let getGlobalIterableType: () => GenericType;\n        let getGlobalIteratorType: () => GenericType;\n        let getGlobalIterableIteratorType: () => GenericType;\n\n        let getGlobalClassDecoratorType: () => ObjectType;"
  },
  {
    "id" : "3a8ed7ce-b53b-4af4-be01-ec4692bacd72",
    "prId" : 7583,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ec518e6d-b166-4573-9785-214a1cf03f04",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "This means that previously we would correctly catch unexported functions, right? Like:\n\n``` ts\nimport {f} from \"f1\"\nfunction f() { }\n```\n",
        "createdAt" : "2016-03-18T18:00:34Z",
        "updatedAt" : "2016-03-18T18:00:34Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "1981e968-0792-4045-96be-778a99c458a0",
        "parentId" : "ec518e6d-b166-4573-9785-214a1cf03f04",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "yes and we still do this\n",
        "createdAt" : "2016-03-18T18:10:09Z",
        "updatedAt" : "2016-03-18T18:10:28Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ed389b6b48edd489e5f185e20eb319fed89422b",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +15069,15073 @@                // Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,\n                // otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export* \n                // in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names). \n                const excludedMeanings =\n                    (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) |"
  },
  {
    "id" : "947096d0-be12-4170-8d24-711be9789397",
    "prId" : 7450,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26d5dc23-8a29-46d2-bf75-b53357380cd4",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "not related, but this error message could be better. may be `Implicit returns not allowed.`\n",
        "createdAt" : "2016-03-09T20:17:58Z",
        "updatedAt" : "2016-03-09T20:18:04Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "907ce8fb385d84ef8ac50de9dcf616cbbd44d76b",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +13905,13909 @@                else if (compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(func, returnType)) {\n                    // The function has a return type, but the return statement doesn't have an expression.\n                    error(node, Diagnostics.Not_all_code_paths_return_a_value);\n                }\n            }"
  },
  {
    "id" : "0a4b7904-e0dd-430b-9826-8f0476eb459d",
    "prId" : 7448,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "801d34a5-4195-4b1d-9162-0c6be099bb47",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "why does it work to say `d.symbol` directly when normally you have to say `getSymbolOfNode(node)`? (for example, in the thisType case below).\n",
        "createdAt" : "2016-03-09T17:32:38Z",
        "updatedAt" : "2016-03-09T19:37:48Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "528f4b48-6b48-49aa-95c6-3e3da292202a",
        "parentId" : "801d34a5-4195-4b1d-9162-0c6be099bb47",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We know that type parameters are never subject to global symbol merging, so `getSymbolOfNode(d)` will always be the same as `d.symbol`. We do the same thing in a few other places in the compiler.\n",
        "createdAt" : "2016-03-09T17:59:07Z",
        "updatedAt" : "2016-03-09T19:37:48Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f441bd5533d1eec6520c64adef11892c3b5f9c4",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +5220,5224 @@                        if (declaration.typeParameters) {\n                            for (const d of declaration.typeParameters) {\n                                if (contains(mappedTypes, getDeclaredTypeOfTypeParameter(d.symbol))) {\n                                    return true;\n                                }"
  },
  {
    "id" : "d4ef8c8d-8342-43f8-995d-b9f1f9c54b2c",
    "prId" : 7448,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58c7de15-ced0-491d-bcb5-443c1451faf5",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "In #7138 I had the equivalent of `mapper1.mappedTypes.concat(mapper2.mappedTypes)` which I'm pretty sure is wrong. But it should really be `mapper1.mappedTypes.intersect(mapper2.mappedTypes)`, I think.\n\nSince this is an optimization, I don't think it will make a practical difference, because constructing a pathological case would be _very_ difficult.\n",
        "createdAt" : "2016-03-09T17:43:56Z",
        "updatedAt" : "2016-03-09T19:37:48Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "caa69f03-ee94-4ba7-8fd2-0eef9f846047",
        "parentId" : "58c7de15-ced0-491d-bcb5-443c1451faf5",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, from an outside point of view, a combined mapper only re-maps the type parameters of `mapper1` (the one in front). The fact that more mapping happens below is really irrelevant. Either way, with the current analysis we should never actually see a combined mapper because that only happens when we're instantiating already instantiated types (and we don't analyse those now).\n",
        "createdAt" : "2016-03-09T18:03:52Z",
        "updatedAt" : "2016-03-09T19:37:48Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f441bd5533d1eec6520c64adef11892c3b5f9c4",
    "line" : 68,
    "diffHunk" : "@@ -1,1 +5096,5100 @@        function combineTypeMappers(mapper1: TypeMapper, mapper2: TypeMapper): TypeMapper {\n            const mapper: TypeMapper = t => instantiateType(mapper1(t), mapper2);\n            mapper.mappedTypes = mapper1.mappedTypes;\n            return mapper;\n        }"
  },
  {
    "id" : "87c0363f-fc1e-478a-ba40-7a1e30f840aa",
    "prId" : 7358,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16dbc03c-1bd9-4717-a02f-64f416dc3bcf",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "4 spaces per indentation\n",
        "createdAt" : "2016-03-03T02:02:27Z",
        "updatedAt" : "2016-03-03T20:18:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5132ea64ea379099ec0db00442e60e1bdfbeab13",
    "line" : null,
    "diffHunk" : "@@ -1,1 +13884,13888 @@                else if (compilerOptions.noImplicitReturns && !maybeTypeOfKind(returnType, TypeFlags.Void | TypeFlags.Any)) {\n                    // The function has a return type, but the return statement doesn't have an expression.\n                    error(node, Diagnostics.Not_all_code_paths_return_a_value);\n                }\n            }"
  },
  {
    "id" : "c1fa2ea7-3616-4e19-b031-4faa6616523b",
    "prId" : 7309,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d67fc4be-d954-4fbb-a3bc-006c20f1fb8f",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "what about the param type of the setter function, we do this in TS..\n",
        "createdAt" : "2016-03-01T22:03:21Z",
        "updatedAt" : "2016-03-01T23:09:22Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "65f09d66ad723c3109c996c47579369d53f284b6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2963,2967 @@\n                if (getter && getter.flags & NodeFlags.JavaScriptFile) {\n                    const jsDocType = getTypeForVariableLikeDeclarationFromJSDocComment(getter);\n                    if (jsDocType) {\n                        return links.type = jsDocType;"
  },
  {
    "id" : "621772e2-f52c-4886-95b4-78dd4d1e2030",
    "prId" : 7262,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ce36d6d-3cdd-4877-b60e-10d876746217",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd consider removing `PropertyAccessExpression` but I don't really mind I suppose.\n",
        "createdAt" : "2016-02-26T22:26:52Z",
        "updatedAt" : "2016-02-26T22:43:21Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c432ade0-5018-4d7a-adf6-5a70e69a87af",
        "parentId" : "4ce36d6d-3cdd-4877-b60e-10d876746217",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "node.kind can be PropertyAccessExpression (`o.x`) or VariableLikeDeclaration (`{x} = o`). So PropertyAccessExpression is necessary.\n",
        "createdAt" : "2016-02-26T22:31:54Z",
        "updatedAt" : "2016-02-26T22:43:21Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "85e35acf-83a0-4934-b50d-45644d133ee1",
        "parentId" : "4ce36d6d-3cdd-4877-b60e-10d876746217",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I mean that you're switching the error node from the property access itself.\n",
        "createdAt" : "2016-02-26T22:34:10Z",
        "updatedAt" : "2016-02-26T22:43:21Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c6a007715b7fc6848c0c7db6d974fadda9f244d",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +8975,8979 @@            const flags = getDeclarationFlagsFromSymbol(prop);\n            const declaringClass = <InterfaceType>getDeclaredTypeOfSymbol(getParentOfSymbol(prop));\n            const errorNode = node.kind === SyntaxKind.PropertyAccessExpression || node.kind === SyntaxKind.VariableDeclaration ?\n                (<PropertyAccessExpression | VariableDeclaration>node).name :\n                (<QualifiedName>node).right;"
  },
  {
    "id" : "8aae9150-f4f3-40d6-84ed-be95c62f2f4c",
    "prId" : 7249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44c3f807-e636-438e-a243-e3b9681e9430",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "what about namespace imports? we should add handling in `getTargetOfNamespaceImport`\n",
        "createdAt" : "2016-03-09T21:46:50Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "aa96db2e-2184-4c1a-bef4-a1d346244426",
        "parentId" : "44c3f807-e636-438e-a243-e3b9681e9430",
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "See test below `JavaScriptModules20` that tests namespace imports - they now work with this change as written (didn't before).\n",
        "createdAt" : "2016-03-09T22:00:26Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8ac66fb381836cb075ea4a6fa3d515ee19842e",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +964,968 @@            if (targetSymbol) {\n                const name = specifier.propertyName || specifier.name;\n                if (name.text) {\n                    let symbolFromVariable: Symbol;\n                    // First check if module was specified with \"export=\". If so, get the member from the resolved type"
  },
  {
    "id" : "7e34e59c-9831-4c23-9927-4c45a87ea73d",
    "prId" : 7249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f871079-4a35-462f-bdaa-40a26208463e",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "that means that this now is allowed in TS `export = { \"default\" : 0 }`, is this correct?\n",
        "createdAt" : "2016-03-09T22:21:19Z",
        "updatedAt" : "2016-03-09T23:00:47Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "c675463d-c268-422e-a819-cd9f9cd3aeb9",
        "parentId" : "3f871079-4a35-462f-bdaa-40a26208463e",
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "That does indeed seem to work for `import val from './mod'` syntax. Interesting that `import * as m from './mod'` doesn't allow the type of assignment you write above.\n\nWhat is the expected behavior with `export = <expr>`? The spec (section 11.3.5) still states the grammar is `export‚ÄÉ=‚ÄÉ<IdentifierReference>;`, so I was expecting a parse error (but apparently we changed this?)\n",
        "createdAt" : "2016-03-09T23:37:48Z",
        "updatedAt" : "2016-03-09T23:37:48Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bc8ac66fb381836cb075ea4a6fa3d515ee19842e",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +892,896 @@            if (moduleSymbol) {\n                const exportDefaultSymbol = moduleSymbol.exports[\"export=\"] ?\n                    getPropertyOfType(getTypeOfSymbol(moduleSymbol.exports[\"export=\"]), \"default\") :\n                    resolveSymbol(moduleSymbol.exports[\"default\"]);\n"
  },
  {
    "id" : "21a5b2df-e3b5-424c-8fc0-fc459114f84c",
    "prId" : 7226,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44560c15-0b4f-4fd4-8a1b-9f36126bb906",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why would `elements` be undefined?\n",
        "createdAt" : "2016-02-24T21:36:37Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "87a00c30f6701aef173dfd602dcc28f2e73cde33",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2203,2207 @@                    const elements = bindingPattern.elements;\n                    buildDisplayForCommaSeparatedList(elements, writer, e => buildBindingElementDisplay(e, writer, enclosingDeclaration, flags, symbolStack));\n                    if (elements && elements.hasTrailingComma) {\n                        writePunctuation(writer, SyntaxKind.CommaToken);\n                    }"
  },
  {
    "id" : "8ebb2fc0-860f-48fb-8555-fff493ba81b9",
    "prId" : 7226,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67f293fb-a516-4e21-80b9-914eadeb59c0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Write a space afterwards\n",
        "createdAt" : "2016-02-25T07:01:49Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "87a00c30f6701aef173dfd602dcc28f2e73cde33",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +2217,2221 @@                if (bindingElement.propertyName) {\n                    writer.writeSymbol(getTextOfNode(bindingElement.propertyName), bindingElement.symbol);\n                    writePunctuation(writer, SyntaxKind.ColonToken);\n                    writeSpace(writer);\n                }"
  },
  {
    "id" : "0089781a-636f-450e-a01b-97e078be0f13",
    "prId" : 7226,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "069276bc-30b0-4302-a630-badce66bad72",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Emit a space before this\n",
        "createdAt" : "2016-02-25T07:02:08Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "9717c121-d802-4675-9434-a029e560de7b",
        "parentId" : "069276bc-30b0-4302-a630-badce66bad72",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we do not do this in declaration emit nor in formatting.\n",
        "createdAt" : "2016-02-25T20:41:56Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "87a00c30f6701aef173dfd602dcc28f2e73cde33",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2206,2210 @@                        writePunctuation(writer, SyntaxKind.CommaToken);\n                    }\n                    writePunctuation(writer, SyntaxKind.CloseBracketToken);\n                }\n            }"
  },
  {
    "id" : "1eb71ae7-d4ee-4e46-9f66-dce81baa237d",
    "prId" : 7226,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa002c8d-2d99-4247-a70c-403e5ac0971e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Emit a space before this\n",
        "createdAt" : "2016-02-25T07:02:17Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "72fb0f67-bad2-4ce2-bfc9-42d393af6b8b",
        "parentId" : "aa002c8d-2d99-4247-a70c-403e5ac0971e",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we do not do this in declaration emit nor in formatting.\n",
        "createdAt" : "2016-02-25T20:42:06Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "87a00c30f6701aef173dfd602dcc28f2e73cde33",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2197,2201 @@                    writePunctuation(writer, SyntaxKind.OpenBraceToken);\n                    buildDisplayForCommaSeparatedList(bindingPattern.elements, writer, e => buildBindingElementDisplay(e, writer, enclosingDeclaration, flags, symbolStack));\n                    writePunctuation(writer, SyntaxKind.CloseBraceToken);\n                }\n                else if (bindingPattern.kind === SyntaxKind.ArrayBindingPattern) {"
  },
  {
    "id" : "7c8b4698-4e9b-4e38-9487-c2ecb8c01f56",
    "prId" : 7226,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "78cbf5c8-9cb0-4ee9-b956-78036f781f05",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Space after this\n",
        "createdAt" : "2016-02-25T07:02:24Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "87a00c30f6701aef173dfd602dcc28f2e73cde33",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2195,2199 @@                // We have to explicitly emit square bracket and bracket because these tokens are not stored inside the node.\n                if (bindingPattern.kind === SyntaxKind.ObjectBindingPattern) {\n                    writePunctuation(writer, SyntaxKind.OpenBraceToken);\n                    buildDisplayForCommaSeparatedList(bindingPattern.elements, writer, e => buildBindingElementDisplay(e, writer, enclosingDeclaration, flags, symbolStack));\n                    writePunctuation(writer, SyntaxKind.CloseBraceToken);"
  },
  {
    "id" : "fd187f88-3ab1-411b-982a-543090ac726c",
    "prId" : 7226,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6b786e8-c626-411f-bab5-d9fd1e2a2a0a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Space after this\n",
        "createdAt" : "2016-02-25T07:02:34Z",
        "updatedAt" : "2016-02-25T21:25:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "87a00c30f6701aef173dfd602dcc28f2e73cde33",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2200,2204 @@                }\n                else if (bindingPattern.kind === SyntaxKind.ArrayBindingPattern) {\n                    writePunctuation(writer, SyntaxKind.OpenBracketToken);\n                    const elements = bindingPattern.elements;\n                    buildDisplayForCommaSeparatedList(elements, writer, e => buildBindingElementDisplay(e, writer, enclosingDeclaration, flags, symbolStack));"
  },
  {
    "id" : "c7d89ab7-0a2a-499c-bcc2-8ce3ed322602",
    "prId" : 7029,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c15e70e0-8152-4c5b-b1c4-98704a435e8c",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "... \" with no call/construct signatures\"\n",
        "createdAt" : "2016-02-11T21:35:24Z",
        "updatedAt" : "2016-02-12T00:00:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "a1040f02c4f844d86c791194f1da17e263609c5f",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +6267,6271 @@\n        /**\n         * Return true if type was inferred from an object literal or written as an object type literal\n         * with no call or construct signatures.\n         */"
  },
  {
    "id" : "995a6768-4102-4c18-94ec-9dd34b35c1f9",
    "prId" : 6932,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a8656f3-4bfd-4338-9500-511c53308080",
        "parentId" : null,
        "authorId" : "6feba8ca-0b6a-496c-83fb-5fdd3b4e56f3",
        "body" : "Is it 11.1.5?\n\nIt's not, according to the [ECMA web site](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-initializer)\n\n> 12.2.6 Object Initializer\n> NOTE 1 An object initializer is an expression describing the initialization of an Object, written in a form resembling a literal. It is a list of zero or more pairs of property keys and associated values, enclosed in curly brackets. The values need not be literals; they are evaluated each time the object initializer is evaluated.\n",
        "createdAt" : "2016-02-10T11:41:24Z",
        "updatedAt" : "2016-02-10T11:41:24Z",
        "lastEditedBy" : "6feba8ca-0b6a-496c-83fb-5fdd3b4e56f3",
        "tags" : [
        ]
      },
      {
        "id" : "c522730c-68dc-4de6-90d1-aa3dc3e32139",
        "parentId" : "3a8656f3-4bfd-4338-9500-511c53308080",
        "authorId" : "87ee8318-1e00-41df-b072-89d319444190",
        "body" : "Happy to fix that, but it's not a spelling mistake. And amusingly, I've at least (accidentally) fixed the spelling to match the spec... (I wonder how it got out of sync...)\n",
        "createdAt" : "2016-02-10T14:05:40Z",
        "updatedAt" : "2016-02-10T14:05:40Z",
        "lastEditedBy" : "87ee8318-1e00-41df-b072-89d319444190",
        "tags" : [
        ]
      },
      {
        "id" : "fc0d7565-0a66-416e-b364-b7d9964c7e5e",
        "parentId" : "3a8656f3-4bfd-4338-9500-511c53308080",
        "authorId" : "87ee8318-1e00-41df-b072-89d319444190",
        "body" : "Filed #7009\n",
        "createdAt" : "2016-02-10T21:52:25Z",
        "updatedAt" : "2016-02-10T21:52:25Z",
        "lastEditedBy" : "87ee8318-1e00-41df-b072-89d319444190",
        "tags" : [
        ]
      }
    ],
    "commit" : "e848e95babd29f9fa42632faa469696899017f7f",
    "line" : 300,
    "diffHunk" : "@@ -1,1 +16719,16723 @@                });\n\n                // ECMA-262 11.1.5 Object Initializer\n                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true\n                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and"
  },
  {
    "id" : "7d7f6e9c-6be0-4b16-8b52-919da5befa22",
    "prId" : 6885,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c0839ad-a8d9-42e7-8734-11eff11e7191",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "If you don't get rid of the `if`, please add an explicit `return` statement.\n",
        "createdAt" : "2016-02-04T23:48:09Z",
        "updatedAt" : "2016-02-16T22:55:28Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "de23e2ff74087262448c13f005b5631ae69366f3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6101,6105 @@\n                return false;\n            }\n        }\n"
  },
  {
    "id" : "39f4fc64-0b0f-4082-beae-9c63367c33b3",
    "prId" : 6860,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dee6ed92-4ffb-4888-85f2-3cd4a3145eb4",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "what if constructor does not have `super` call? does it mean that we'll repeat the traversal on every call?\n",
        "createdAt" : "2016-02-03T01:10:55Z",
        "updatedAt" : "2016-02-11T18:11:47Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "a7234b3a-a701-45e4-9915-d3c6c3259298",
        "parentId" : "dee6ed92-4ffb-4888-85f2-3cd4a3145eb4",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Yes, unfortunately.\n",
        "createdAt" : "2016-02-03T18:06:24Z",
        "updatedAt" : "2016-02-11T18:11:47Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "61e954bbc6a18ae21609d93221672b34d238ce9a",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7324,7328 @@         */\n        function getSuperCallInConstructor(constructor: ConstructorDeclaration): ExpressionStatement {\n            const links = getNodeLinks(constructor);\n\n            // Only trying to find super-call if we haven't yet tried to find one.  Once we try, we will record the result"
  },
  {
    "id" : "b7e1d469-4f3f-4b68-900d-44892a91ffb8",
    "prId" : 6860,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c4dcd3e-723f-4a7c-a6f6-73c282f60cc7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "The funny thing is that you don't actually use the returned value except to determine whether you've found a super call - so you should consider reducing your needs to `NodeLinks.hasSuperCall` or `NodeLinks.superCall`, but not both.\n",
        "createdAt" : "2016-02-08T20:14:23Z",
        "updatedAt" : "2016-02-11T18:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "0a9a0958-b8ee-47ce-b2a2-db15ea82b83b",
        "parentId" : "8c4dcd3e-723f-4a7c-a6f6-73c282f60cc7",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "used down below.\n",
        "createdAt" : "2016-02-09T17:45:29Z",
        "updatedAt" : "2016-02-11T18:11:47Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "61e954bbc6a18ae21609d93221672b34d238ce9a",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +7323,7327 @@         * @param constructor constructor-function to look for super statement\n         */\n        function getSuperCallInConstructor(constructor: ConstructorDeclaration): ExpressionStatement {\n            const links = getNodeLinks(constructor);\n"
  },
  {
    "id" : "4eb6f3d0-3de7-4c70-a6a0-21f2f043dfca",
    "prId" : 6744,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6b7f9fbf-7dac-46b3-90e2-fe3d42cda8c5",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "not specific to this PR, but error messages refer to this sometimes as \"type guards\" and others as \"type predicate\"\n",
        "createdAt" : "2016-02-12T00:08:09Z",
        "updatedAt" : "2016-02-12T22:13:02Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "69bc2f4d-6b30-45a8-9447-5768a4491dbd",
        "parentId" : "6b7f9fbf-7dac-46b3-90e2-fe3d42cda8c5",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Good point I'll file an issue\n",
        "createdAt" : "2016-02-12T00:46:20Z",
        "updatedAt" : "2016-02-12T22:13:02Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "74b1e3f446cda098877e84f64ef16593647d3760",
    "line" : 282,
    "diffHunk" : "@@ -1,1 +5284,5288 @@                if (reportErrors) {\n                    errorReporter(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);\n                    errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));\n                }\n                return Ternary.False;"
  },
  {
    "id" : "11870232-3b69-438c-957d-4706b5caa61b",
    "prId" : 6739,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9007c944-5bf7-4f9c-a5df-1ff887ab042f",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This isn't going to work when the containing function has a contextually typed `this` because the signature will appear to have no `this` type. I think you need to `getTypeOfSymbol(getSymbolOfNode(container))` and then fish the `this` type out of the signatures of the type.\n",
        "createdAt" : "2016-02-03T22:03:58Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a8fb3896-4d42-4e39-a91b-c7105ca65a3a",
        "parentId" : "9007c944-5bf7-4f9c-a5df-1ff887ab042f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Actually, `getTypeOfSymbol` won't work either. In fact, I'm unclear on when you contextually type `this`? Your writeup for the PR states that you contextually type `this` in methods in object literals, but it doesn't seem to work. I haven't been able to see any contextual typing of `this` in snippets I have written. We should discuss our intended design here.\n",
        "createdAt" : "2016-02-04T17:47:25Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c735b5cbf889cc703ed6d415d0af972439ddbbf",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8082,8086 @@                    return type;\n                }\n                const signature = getSignatureFromDeclaration(container);\n                if (signature.thisType) {\n                    return signature.thisType;"
  },
  {
    "id" : "d400315d-861f-4475-981a-313897f14641",
    "prId" : 6739,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "37349ed7-1150-4bcc-a74c-d3ce496c4d71",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "See my comments for the corresponding code in `checkApplicableSignature`.\n",
        "createdAt" : "2016-02-04T18:15:59Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c735b5cbf889cc703ed6d415d0af972439ddbbf",
    "line" : null,
    "diffHunk" : "@@ -1,1 +10142,10146 @@                inferTypes(context, thisArgumentType, signature.thisType);\n            }\n\n            // We perform two passes over the arguments. In the first pass we infer from all arguments, but use\n            // wildcards for all context sensitive function expressions."
  },
  {
    "id" : "27696a39-a399-4c92-8008-fc997dbeae14",
    "prId" : 6739,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7513dccd-bbc0-440b-b061-2d93760389e3",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "still missing constructorType.\n\n`var x: new (this: number)=> number`\n",
        "createdAt" : "2016-03-31T18:46:55Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "db4d6a01-b036-472f-a999-822d668d886e",
        "parentId" : "7513dccd-bbc0-440b-b061-2d93760389e3",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Are you looking at the latest commits? I added to the check on line 12419 and an associated test (with an interface, not a variable, but they fail the same way) in thisTypeInFunctionsNegative.ts\n",
        "createdAt" : "2016-03-31T21:31:31Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "b7537485-a850-4142-8473-fdb8695b721e",
        "parentId" : "7513dccd-bbc0-440b-b061-2d93760389e3",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "you have construct signature covered, i.e. `{ new(this: T): T; }`, i am talking about `ConstructorType` i.e. `var x: new (this: number)=> number`. this still fails on the latest from this branch.\n",
        "createdAt" : "2016-04-01T18:47:28Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c735b5cbf889cc703ed6d415d0af972439ddbbf",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12420,12424 @@                    error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter);\n                }\n                if (func.kind === SyntaxKind.SetAccessor) {\n                    error(node, Diagnostics.A_setter_cannot_have_a_this_parameter);\n                }"
  },
  {
    "id" : "0d5bf5f3-4d43-4b12-8629-cdca0d420cc9",
    "prId" : 6739,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa40bf40-ce47-4bfb-808a-62be72c361a0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Huh - we should add a regression test to ensure that a set of mutually recursive object literal methods type-checks properly.\n\n``` ts\nvar x = {\n    a: 100,\n\n    start() {\n        return this.doX(this.a);\n    }    \n\n    doX(n: number) {\n        this.doY(n);\n    }\n\n    doY(n: number): number {\n        if (n > 10) {\n            return this.doX(n - 10);\n        }\n        if (n > 5) {\n            return this.doY(n - 1);\n        }\n        return n;\n    }\n}\n\nvar i: number = x.start();\n```\n\nAnd maybe create an interface with the same shape, create a variable of that type, and assign `x` to it.\n",
        "createdAt" : "2016-04-01T22:41:34Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "505acc40-4d8e-43dc-9a4c-d0fb04ecc944",
        "parentId" : "fa40bf40-ce47-4bfb-808a-62be72c361a0",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "done\n",
        "createdAt" : "2016-04-07T14:44:17Z",
        "updatedAt" : "2016-04-07T15:02:00Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "6c735b5cbf889cc703ed6d415d0af972439ddbbf",
    "line" : 313,
    "diffHunk" : "@@ -1,1 +8089,8093 @@                    // Note: this works because object literal methods are deferred,\n                    // which means that the type of the containing object literal is already known.\n                    const type = checkExpressionCached(<ObjectLiteralExpression>container.parent);\n                    if (type) {\n                        return type;"
  },
  {
    "id" : "2ac0a5b7-ff86-4a35-93a6-65545ca16f30",
    "prId" : 6709,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b157b2fd-0425-4277-be8f-a102bde2ea57",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you explicitly return `undefined`?\n",
        "createdAt" : "2016-01-29T00:03:17Z",
        "updatedAt" : "2016-02-02T05:48:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e79e7a62-4341-47ce-8c82-6d8699575445",
        "parentId" : "b157b2fd-0425-4277-be8f-a102bde2ea57",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Or should you be returning the `unknownType` instead?\n",
        "createdAt" : "2016-01-29T00:03:38Z",
        "updatedAt" : "2016-02-02T05:48:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c3abfc2b-84bb-496b-bb54-e0b3a13756db",
        "parentId" : "b157b2fd-0425-4277-be8f-a102bde2ea57",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "undefined is fine.\n",
        "createdAt" : "2016-02-01T18:22:58Z",
        "updatedAt" : "2016-02-02T05:48:25Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "b15ff81384f33e17bb8e10e10d5992cd6727e68c",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +10347,10351 @@            if (returnTag && returnTag.typeExpression) {\n                return getTypeFromTypeNode(returnTag.typeExpression.type);\n            }\n\n            return undefined;"
  },
  {
    "id" : "a56f7daa-6e6c-4c11-9915-a1196e643757",
    "prId" : 6709,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9de300e9-049b-4550-a69d-f23e3ba3b0d2",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "Do we have tests for malformed types in other tags (e.g. `@param`)?\n",
        "createdAt" : "2016-02-01T18:21:35Z",
        "updatedAt" : "2016-02-02T05:48:25Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b15ff81384f33e17bb8e10e10d5992cd6727e68c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +10345,10349 @@        function getReturnTypeFromJSDocComment(func: SignatureDeclaration | FunctionDeclaration): Type {\n            const returnTag = getJSDocReturnTag(func);\n            if (returnTag && returnTag.typeExpression) {\n                return getTypeFromTypeNode(returnTag.typeExpression.type);\n            }"
  },
  {
    "id" : "05d5f88f-0c67-45c5-ae6e-250ae2b37741",
    "prId" : 6632,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25e56f7e-cda7-4eac-906b-123728e02ec0",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "I assume in most cases it won't be a \"specialPropertyAssignmentKind\" and you will just fall through here? Can you make this clear in the code by explicitly adding a `default:` with just a comment to this effect, or wrapping the `switch` in an `if(specialPropertyAssignmentKind...)`?\n",
        "createdAt" : "2016-01-28T17:10:07Z",
        "updatedAt" : "2016-01-28T19:27:01Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bf897c29393e7e7ee92a71e123e502ca3d0ba12f",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +15367,15371 @@                    case SpecialPropertyAssignmentKind.ThisProperty:\n                    case SpecialPropertyAssignmentKind.ModuleExports:\n                        return getSymbolOfNode(entityName.parent.parent);\n                    default:\n                        // Fall through if it is not a special property assignment"
  },
  {
    "id" : "604be6b1-82f2-4ef5-8025-3eab56fef22e",
    "prId" : 6631,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc789626-578d-42da-a417-34eea3cc1cc1",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "since it is already jsdoc. could you add the parameter annotation as well?\n",
        "createdAt" : "2016-01-26T23:09:48Z",
        "updatedAt" : "2016-01-27T01:34:34Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4c0c0028704f637a6417b67879132343532a261",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +12511,12515 @@        /**\n         * Checks that the return type provided is an instantiation of the global Promise<T> type\n         * and returns the awaited type of the return type.\n         *\n         * @param returnType The return type of a FunctionLikeDeclaration"
  },
  {
    "id" : "7d89236a-2f96-4a5b-a43d-2bdbd71b1c89",
    "prId" : 6631,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "287cf542-0948-4a43-9950-f212652ceb76",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "why >= ES6? I thought need to resolve global Promise when down-leveling?\n",
        "createdAt" : "2016-01-26T23:12:40Z",
        "updatedAt" : "2016-01-27T01:34:34Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "3857da6c-2870-4d7d-b283-9c5f0cfbe593",
        "parentId" : "287cf542-0948-4a43-9950-f212652ceb76",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "@rbuckton  explains off-line. ES6 has native Promise. I misunderstood that fact\n",
        "createdAt" : "2016-01-26T23:27:18Z",
        "updatedAt" : "2016-01-27T01:34:34Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "352d3b69-ac19-447f-b5c0-2d34d048a0a0",
        "parentId" : "287cf542-0948-4a43-9950-f212652ceb76",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "ES5 and earlier do not have a global Promise. We fall back to the existing behavior for ES5 as we plan to support async functions via tree transformation for target ES5 and users will need to be able to supply a Promise implementation.\n",
        "createdAt" : "2016-01-26T23:32:56Z",
        "updatedAt" : "2016-01-27T01:34:34Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4c0c0028704f637a6417b67879132343532a261",
    "line" : 121,
    "diffHunk" : "@@ -1,1 +12553,12557 @@          */\n        function checkAsyncFunctionReturnType(node: FunctionLikeDeclaration): Type {\n            if (languageVersion >= ScriptTarget.ES6) {\n                const returnType = getTypeFromTypeNode(node.type);\n                return checkCorrectPromiseType(returnType, node.type);"
  },
  {
    "id" : "0a1105ea-3b09-480c-94b6-36538fe6e7d0",
    "prId" : 6631,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "parentId" : null,
        "authorId" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "body" : "What is the reason for the compiler to reject type annotations that are known compatible with `Promise`? This won't catch any type errors, but rejects valid annotations. Generator functions handle this consistently IMO. Why not use the same approach here for consistency?\n\n``` typescript\nfunction* bar() {}                  // Returns IterableIterator<any>\nfunction* bar2(): any {}            // OK: compatible annotation\nfunction* bar3(): Iterator<any> {}  // OK: comtatible annotation\nfunction* bar4(): { next } {}       // OK: comtatible annotation\n\nasync function foo() {}                     // Returns Promise<void>\nasync function foo1(): any {}               // ERROR with this PR, but why?\nasync function foo2(): PromiseLike<any> {}  // ERROR with this PR. but why?\n```\n",
        "createdAt" : "2016-01-27T00:32:51Z",
        "updatedAt" : "2016-01-27T01:34:34Z",
        "lastEditedBy" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "tags" : [
        ]
      },
      {
        "id" : "afb458af-5a7d-40db-b032-e41af8deea2a",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "body" : "The `checker.ts` code for generator functions uses `checkTypeAssignableTo` to check the return type annotation ([L11625](https://github.com/Microsoft/TypeScript/blob/master/src/compiler/checker.ts#L11625)). Why is `checkTypeAssignableTo` not used for async functions?\n",
        "createdAt" : "2016-01-27T00:54:40Z",
        "updatedAt" : "2016-01-27T07:10:01Z",
        "lastEditedBy" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "tags" : [
        ]
      },
      {
        "id" : "1b0c17f2-ffeb-44be-8e82-2f35cf409efd",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "This is the result of an offline discussion with @mhegazy. Supporting an assignable interface is not currently compatible with our goals for future down-level support for async functions for ES5. As a result, async functions will for the time being be more restrictive than generators with respect to the return type annotation.\n",
        "createdAt" : "2016-01-27T01:27:31Z",
        "updatedAt" : "2016-01-27T01:34:34Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "ea926bfb-3c60-48c2-91bc-6ae5b9f5a782",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "body" : "ES3/5 restrictions need not be applied to ES6 code. Why not this:\n\n``` typescript\nif (languageVersion >= ScriptTarget.ES6) {\n    // use checkTypeAssignableTo to check return type annotation\n}\nelse {\n    // more restrictive return type annotation rules for ES3/5...\n}\n```\n",
        "createdAt" : "2016-01-27T02:53:35Z",
        "updatedAt" : "2016-01-27T02:53:35Z",
        "lastEditedBy" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "tags" : [
        ]
      },
      {
        "id" : "4514649d-a062-4664-af64-d0491d516dd5",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "body" : "@mhegazy you gave qualitied support [back in December](https://github.com/Microsoft/TypeScript/issues/5911#issuecomment-162979457) for treating return type annotations one way for ES3/5 (improve the error message), and another way for ES6+ (use `checkTypeAssignableTo`). Is this still the case?\n",
        "createdAt" : "2016-01-27T05:53:17Z",
        "updatedAt" : "2016-01-27T05:53:17Z",
        "lastEditedBy" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "tags" : [
        ]
      },
      {
        "id" : "f3a4ee99-d7d8-46f7-b237-4ad228893219",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "The current support we have in TypeScript 1.7.x for async functions allows you to specify a custom Promise implementation in the return type annotation. This was intended to support runtimes that do not yet define a global Promise implementation, and was primarily intended to support down-level emit for async functions in ES5, which is a goal for TypeScript 2.0.  This allows you to write an async function in the following fashion:\n\n``` ts\nimport * as bluebird from 'bluebird';\n\nexport async function fn(): bluebird.Promise {\n}\n\nconsole.log(fn() instanceof bluebird.Promise); // true \n```\n\nHowever, this approach is not compatible with the ES7 approach to async functions which only leverages the native Promise implementation. As this native Promise is specified as part of ES6, we have elected to only allow you to supply a global `Promise<T>` return type for ES6, but reserve the previous functionality to eventually support async functions down-level.\n\nIf we were to then allow you to specify the return type of an async function as any type to which `Promise<T>` is assignable, then the above sample would still compile successfully, due to how \"bluebird.d.ts\" is currently implemented on DefinitelyTyped. The result is that upgrading from TypeScript 1.7.x to TypeScript 1.8 would result in completely different runtime semantics with _no indication to the developer_ that anything had changed.\n\n``` ts\nimport * as bluebird from 'bluebird';\n\nexport async function fn(): bluebird.Promise {\n}\n\nconsole.log(fn() instanceof bluebird.Promise); // false?! \n```\n\nBy restricting the return type annotation to **only** the global `Promise<T>` type, we have the ability to loosen this restriction in the future. Yes, this does not fully align with how we support type annotations on generator functions; however, this is the only reliable way forward. We may, in a future release, opt to add a different mechanism for defining a compatible Promise implementation for ES5 async functions. If that does indeed become the case, we would be able to loosen the return type restriction. \n\nAs this is a breaking change from TypeScript 1.7 behavior, it also is best to be more conservative for one to two releases to ensure any existing implementations have adjusted to this change before examining the feasibility of relaxing this restriction.\n",
        "createdAt" : "2016-01-27T19:58:46Z",
        "updatedAt" : "2016-01-27T19:58:46Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "bee7881c-8531-4f14-838d-d3e62f16da7c",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "f2b19330-eb30-4612-ac1d-f1474fd89ba0",
        "body" : "The fact that the return type must be strictly equal to `Promise` might become a hindrance in scenarios involving interfaces and/or methods overriding.\n\nYou can work around it by adding a layer of indirection (like all CS problems :wink:) but it doesn't feel nice.\n\nHere's one example: in frameworks such as Aurelia, many methods can return a value or a Promise for a value. Not mandating a Promise is both convenient when implementing trivial methods (like `canSave() { return true; }`) and good for perf.\n\nSay I have a base class that exposes such a function and is meant to be overriden. Assume that the base default implementation is async.\n\nThe natural way is this:\n\n``` typescript\nclass BaseViewModel {\n  async isValid() : boolean | Promise<boolean> { \n    /* some async implementation, maybe server call */  \n  }\n}\n\nclass DerivedViewModel extends BaseViewModel {\n  isValid() : boolean | Promise<boolean> {\n    return true;  // Non-async implementation\n  }\n}\n```\n\nbut this wouldn't work :(\n",
        "createdAt" : "2016-01-29T12:56:57Z",
        "updatedAt" : "2016-01-29T12:56:57Z",
        "lastEditedBy" : "f2b19330-eb30-4612-ac1d-f1474fd89ba0",
        "tags" : [
        ]
      },
      {
        "id" : "b7c02c4e-ecbb-4a19-86d9-c51ce4ad4702",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "body" : "@jods4 good real world example. Current behaviour:\n\n``` typescript\nvar q: () => boolean | Promise<boolean>;\nq = () => true;                                          // OK\nq = () => Promise.resolve(true);                         // OK\nq = async () => true;                                    // OK\n(): boolean | Promise<boolean> => true;                  // OK\n(): boolean | Promise<boolean> => Promise.resolve(true); // OK\nasync (): boolean | Promise<boolean> => true;            // ERROR\n```\n",
        "createdAt" : "2016-01-29T13:19:53Z",
        "updatedAt" : "2016-01-29T13:21:14Z",
        "lastEditedBy" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "tags" : [
        ]
      },
      {
        "id" : "71d0ee66-ecf2-4f63-bd10-325ac796fccf",
        "parentId" : "cb148e37-754a-4ab4-8dac-dcdd847d101d",
        "authorId" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "body" : "@jods4 since this PR is done and closed may I suggest taking your example across to #6686 where I think it would be quite relevent.\n",
        "createdAt" : "2016-01-29T13:25:53Z",
        "updatedAt" : "2016-01-29T13:25:53Z",
        "lastEditedBy" : "6076f5bb-9307-4760-bf33-72504731d96f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4c0c0028704f637a6417b67879132343532a261",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +12510,12514 @@\n        /**\n         * Checks that the return type provided is an instantiation of the global Promise<T> type\n         * and returns the awaited type of the return type.\n         *"
  },
  {
    "id" : "c56e6e9e-a9ea-42be-89b9-3f73bf1a6f88",
    "prId" : 6628,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dad9d70a-fcf9-4ff1-b55d-6693455a618b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd rather you move the new check into the body and `break` with a comment explaining why you need to do this.\n",
        "createdAt" : "2016-01-26T19:40:00Z",
        "updatedAt" : "2016-01-26T19:40:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "4d1dea3a-5912-4cf7-8980-b9596f111935",
        "parentId" : "dad9d70a-fcf9-4ff1-b55d-6693455a618b",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, the check is fine here with all the other checks.\n",
        "createdAt" : "2016-01-26T22:13:20Z",
        "updatedAt" : "2016-01-26T22:13:27Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "910fbba1568c745e94ce32f4a27fe19a54961474",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +4286,4290 @@        function hasConstraintReferenceTo(type: Type, target: TypeParameter): boolean {\n            let checked: Type[];\n            while (type && !(type.flags & TypeFlags.ThisType) && type.flags & TypeFlags.TypeParameter && !contains(checked, type)) {\n                if (type === target) {\n                    return true;"
  },
  {
    "id" : "53751b7a-511c-4625-a537-6ed3d8634cea",
    "prId" : 6469,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2c5cec3-5c56-4187-8e71-21a528e737e3",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Space after \n",
        "createdAt" : "2016-01-13T21:16:20Z",
        "updatedAt" : "2016-01-13T23:20:36Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "21baedfebab8224ac5ed0168b35b38fbd7ed6f4f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +783,787 @@            if (!errorLocation || (errorLocation.kind === SyntaxKind.Identifier && (isTypeReferenceIdentifier(<Identifier>errorLocation)) || isInTypeQuery(errorLocation))) {\n                return false;\n            }\n\n            const container = getThisContainer(errorLocation, /* includeArrowFunctions */ true);"
  },
  {
    "id" : "13ff4d0f-4b5e-4e06-bc76-725b17c29367",
    "prId" : 6379,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "252f6b6b-b99c-46b4-8f23-6fa4ffa7ccb2",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why do you need to climb up? Can't you look up the variable declaration from the symbol and just check if the parent is a ForInStatement?\n",
        "createdAt" : "2016-01-07T18:25:05Z",
        "updatedAt" : "2016-01-07T18:40:48Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "8d06c855-c77d-414f-be8d-41bf9df85bed",
        "parentId" : "252f6b6b-b99c-46b4-8f23-6fa4ffa7ccb2",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Actually, I realized it's partially because you might have multiple variable declarations. But in that case, you'll have gotten an error on inconsistent types between the two variables anyway, so maybe it doesn't matter.\n",
        "createdAt" : "2016-01-07T18:27:09Z",
        "updatedAt" : "2016-01-07T18:40:48Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "818168a3-df97-43bc-b624-7bfc693600e7",
        "parentId" : "252f6b6b-b99c-46b4-8f23-6fa4ffa7ccb2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Several reasons we need to climb up. Multiple declarations is one, making sure we're actually within a for-in statement is another, supporting for-in that _references_ a variable instead of _declaring_ one is a third.\n",
        "createdAt" : "2016-01-07T18:44:01Z",
        "updatedAt" : "2016-01-07T18:44:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "c7055a99-cca6-4e8d-b3e9-7b27620d4887",
        "parentId" : "252f6b6b-b99c-46b4-8f23-6fa4ffa7ccb2",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Ah, gotcha. Maybe you should add a comment in case anyone stumbles along and tries to \"optimize\" it in the future\n",
        "createdAt" : "2016-01-07T18:46:34Z",
        "updatedAt" : "2016-01-07T18:46:34Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a0fcc0f45a3f66708cf00d9bd07600cdd3e93524",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +8599,8603 @@                    let child: Node = expr;\n                    let node = expr.parent;\n                    while (node) {\n                        if (node.kind === SyntaxKind.ForInStatement &&\n                            child === (<ForInStatement>node).statement &&"
  },
  {
    "id" : "fce9eb04-4c42-42e7-8ac8-6e6b5c37fd6b",
    "prId" : 6330,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0874bc68-bb2e-44af-b881-ecf1cdf1a8bf",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "This comment should be updated. It's only sort-of true now that there are up to two decisions made before returning.\n",
        "createdAt" : "2016-01-04T17:56:22Z",
        "updatedAt" : "2016-01-04T17:56:22Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bb2ee56d050c6dd2d1525cbbe0ebdfb6aad4423",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +6683,6687 @@                    flags = TypeFlags.NumberLike | TypeFlags.StringLike | TypeFlags.ESSymbol | TypeFlags.Boolean;\n                }\n                // At this point we can bail if it's not a union\n                if (!(type.flags & TypeFlags.Union)) {\n                    // If we're on the true branch and the type is a subtype, we should return the primitive type"
  },
  {
    "id" : "3bfaf4ba-2f9f-4023-a67e-bfa96956525f",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c62c302c-3d0e-40b2-af13-a0167dfe340e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "This comment needs to be updated.\n",
        "createdAt" : "2015-12-23T09:45:16Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "a5d68f12-88ea-4ec5-992d-7cc56e7d07b7",
        "parentId" : "c62c302c-3d0e-40b2-af13-a0167dfe340e",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "why? it still describes the intended behavior for ambient modules\n",
        "createdAt" : "2015-12-23T17:46:38Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : 342,
    "diffHunk" : "@@ -1,1 +14413,14417 @@                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference\n                    // other external modules only through top - level external module names.\n                    // Relative external module names are not permitted.\n                    error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);\n                    return false;"
  },
  {
    "id" : "02271f1f-a1ee-4771-91f1-2d761d16d051",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "089800aa-1245-4e19-88da-3151ab0148db",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "This should be `An import or export declaration in an ambient module declaration cannot reference modules with relative path names.`\n",
        "createdAt" : "2015-12-23T09:45:44Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : 343,
    "diffHunk" : "@@ -1,1 +14414,14418 @@                    // other external modules only through top - level external module names.\n                    // Relative external module names are not permitted.\n                    error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);\n                    return false;\n                }"
  },
  {
    "id" : "caa9239f-5e0f-4b9b-834b-0e5010960ace",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dee7e440-185e-4a54-ac77-89a3ae913e91",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Pretty sure this can just be turned into a for-of\n",
        "createdAt" : "2015-12-23T23:06:13Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "cf7f20ae-8856-4e49-905c-77ffd199ed51",
        "parentId" : "dee7e440-185e-4a54-ac77-89a3ae913e91",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "it can and I think we should make a sweep over the compiler to convert `forEach` to `for..of` at some point. But this should be a separate PR.\n",
        "createdAt" : "2015-12-23T23:20:21Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "f7abe6dc-6df6-4765-90f1-ae9618e643f6",
        "parentId" : "dee7e440-185e-4a54-ac77-89a3ae913e91",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I did that and I don't remember why we never got it pulled in (#2428)\n",
        "createdAt" : "2015-12-23T23:53:49Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : null,
    "diffHunk" : "@@ -1,1 +15714,15718 @@            let augmentations: LiteralExpression[][];\n            // Initialize global symbol table\n            forEach(host.getSourceFiles(), file => {\n                if (!isExternalOrCommonJsModule(file)) {\n                    mergeSymbolTable(globals, file.locals);"
  },
  {
    "id" : "8b3d1892-99ac-4bf9-aaf4-10cd153b6db6",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "45084ce0-b5bc-40cb-8a6a-386c44c51ddd",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "can we just say \"Augmentations_for_the_global_scope_should_have_declare_modifier\", we know they do not appear in one.\n",
        "createdAt" : "2016-01-13T19:24:08Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +14229,14233 @@                const inAmbientContext = isInAmbientContext(node);\n                if (isGlobalAugmentation && !inAmbientContext) {\n                    error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);\n                }\n"
  },
  {
    "id" : "7322d8ed-1e37-433d-a7a2-d84d94fd38fe",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c0b173f8-8754-4d9d-8a10-80cc73b75b75",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we should also add ExportAssignment.\n",
        "createdAt" : "2016-01-13T19:39:57Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "5548219f-86ed-483e-b9b6-c20a9334ddf6",
        "parentId" : "c0b173f8-8754-4d9d-8a10-80cc73b75b75",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "done\n",
        "createdAt" : "2016-01-13T20:54:01Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : null,
    "diffHunk" : "@@ -1,1 +14316,14320 @@        function checkModuleAugmentationElement(node: Node, isGlobalAugmentation: boolean): void {\n            switch (node.kind) {\n                case SyntaxKind.VariableStatement:\n                    // error each individual name in variable statement instead of marking the entire variable statement\n                    for (const decl of (<VariableStatement>node).declarationList.declarations) {"
  },
  {
    "id" : "218a7b26-a77c-4772-9a36-3d16934d7a1a",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3990366-61aa-4f59-bdc4-0403d47cdef4",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "But just so I'm clear, this is because the module to augment wasn't found, and we'll have reported that error elsewhere?\n",
        "createdAt" : "2016-01-14T17:47:02Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4e8f1d3c-0380-431b-b2f4-aca46da8048f",
        "parentId" : "b3990366-61aa-4f59-bdc4-0403d47cdef4",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "yes, it is done [here](https://github.com/Microsoft/TypeScript/pull/6213/files#diff-c3ed224e4daa84352f7f1abcd23e8ccaR394)\n",
        "createdAt" : "2016-01-14T18:03:03Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : 217,
    "diffHunk" : "@@ -1,1 +14282,14286 @@                        // We can detect if augmentation was applied using following rules:\n                        // - augmentation for a global scope is always applied\n                        // - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module). \n                        const checkBody = isGlobalAugmentation || (getSymbolOfNode(node).flags & SymbolFlags.Merged);\n                        if (checkBody) {"
  },
  {
    "id" : "67f1d4a0-1b71-4189-838c-c88df867b3d1",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8402633-f3ed-4a37-8d05-1ce93d5ba94f",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "You're assuming here that `getSymbolOfNode` can be called on _any_ possible top-level node, and if that produces a symbol, the node is a declaration node. Not sure this is safe, particularly since you might see statements here (that would be flagged as errors elsewhere). I think the `default:` clause above should be replaced with a list of actual node kinds that you want to check.\n",
        "createdAt" : "2016-01-14T18:04:31Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "7463f3c3-38ce-42bf-b3c2-a52d182a32bf",
        "parentId" : "d8402633-f3ed-4a37-8d05-1ce93d5ba94f",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "what about checking `isDeclaration(node)` first?\n",
        "createdAt" : "2016-01-14T18:08:23Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "9a091ee9-2ed2-4b2f-b247-14585cc8a76a",
        "parentId" : "d8402633-f3ed-4a37-8d05-1ce93d5ba94f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think you need the real list of nodes. It is a relatively short list no doubt, where `isDeclaration` has a whole bunch of node kinds you don't want.\n",
        "createdAt" : "2016-01-14T18:19:33Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "cba1f863-65bc-49c1-b0db-ce6dfa1b0550",
        "parentId" : "d8402633-f3ed-4a37-8d05-1ce93d5ba94f",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "ok, then if we need to check only top level items we can limit the list to\n\n``` ts\n                case SyntaxKind.ClassDeclaration:\n                case SyntaxKind.EnumDeclaration:\n                case SyntaxKind.FunctionDeclaration:\n                case SyntaxKind.InterfaceDeclaration:\n                case SyntaxKind.ModuleDeclaration:\n                case SyntaxKind.TypeAliasDeclaration:\n                case SyntaxKind.VariableDeclaration:\n                case SyntaxKind.BindingElement:\n```\n\n`ImportDeclaration`, `ImportEqualsDeclaration`, `ExportDeclaration`, `ExportAssignment` and `VariableStatement` are handled in cases above\n\n:white_check_mark: \n",
        "createdAt" : "2016-01-14T18:24:49Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : null,
    "diffHunk" : "@@ -1,1 +14352,14356 @@                case SyntaxKind.ModuleDeclaration:\n                case SyntaxKind.TypeAliasDeclaration:\n                    const symbol = getSymbolOfNode(node);\n                    if (symbol) {\n                        // module augmentations cannot introduce new names on the top level scope of the module"
  },
  {
    "id" : "56bd95c7-a289-4202-b976-edce230a7677",
    "prId" : 6213,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3b65e17-2298-4a6f-b0a0-d54e2698dda6",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The error message below seems a bit odd for this case, but maybe it's fine.\n",
        "createdAt" : "2016-01-14T22:12:04Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "7cdf9794-7030-4398-8bad-723e13d9c98c",
        "parentId" : "d3b65e17-2298-4a6f-b0a0-d54e2698dda6",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "for global case we can easily lift this restriction since it is possible to add new entries to global scope from within a module. Currently the fact that we have it is only because of consistency in behavior for augmentations.\n",
        "createdAt" : "2016-01-14T22:21:03Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "0a1c8426-52a9-499d-8746-5393bb50ff38",
        "parentId" : "d3b65e17-2298-4a6f-b0a0-d54e2698dda6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No sure I understand, maybe we're talking about different issues. This code is saying that you get an error when you have an exported member in a global augmentation block, right? I'm thinking it should never be valid to use `export` in a global augmentation block.\n",
        "createdAt" : "2016-01-14T22:28:40Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "08daa4d9-d818-4085-9089-e44a1d767297",
        "parentId" : "d3b65e17-2298-4a6f-b0a0-d54e2698dda6",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "the idea of this check is following: `symbol.parent`  will be `undefined` if symbol was initially defined in the global scope. If `symbol.parent` is not `undefined` this means that this symbol was  declared inside augmentation and will declare new entry in the global scope which is disallowed in current design\n",
        "createdAt" : "2016-01-14T23:37:47Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "d72d0b23-d050-46b4-a5e9-7e0813af7e76",
        "parentId" : "d3b65e17-2298-4a6f-b0a0-d54e2698dda6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "> If symbol.parent is not undefined this means that this symbol was declared inside augmentation\n\nWhy is that so? `symbol.parent` is non-undefined when the symbol is exported, but it might still be declared inside the augmentation. I'm not getting this.\n",
        "createdAt" : "2016-01-14T23:51:32Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "2bb08cfb-72f9-4a6a-8d63-3d1d67b241b8",
        "parentId" : "d3b65e17-2298-4a6f-b0a0-d54e2698dda6",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "symbols whose initial declaration is in global scope are never exported and `symbol.parent` for them is always `undefined`. if `symbol.parent !== undefined` this means that this symbol is exported from somewhere and as a consequence initially defined in augmentation not in global scope\n",
        "createdAt" : "2016-01-15T00:14:04Z",
        "updatedAt" : "2016-01-15T01:12:49Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "36c489c8dbea802c85a188670e163304d75da8fe",
    "line" : 299,
    "diffHunk" : "@@ -1,1 +14362,14366 @@                            if (isGlobalAugmentation) {\n                                // global symbol should not have parent since it is not explicitly exported\n                                reportError = symbol.parent !== undefined;\n                            }\n                            else {"
  },
  {
    "id" : "eb4c4700-5bb4-4cf0-99d3-15127eb2d987",
    "prId" : 6142,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9931cd3e-82f7-411a-92de-a33a5c1c3912",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'm not sure about this name... what is it trying to say that is different from isTypeAssignableTo?\n",
        "createdAt" : "2015-12-18T06:36:59Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "74293a4b1d3dbe5d7d447cf03fb33434f5093de7",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +4898,4902 @@        }\n\n        function compareTypesAssignable(source: Type, target: Type): Ternary {\n            return checkTypeRelatedTo(source, target, assignableRelation, /*errorNode*/ undefined) ? Ternary.True : Ternary.False;\n        }"
  },
  {
    "id" : "20bcaef4-1931-4160-a292-a0a370e653c7",
    "prId" : 6142,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d71f53ec-dd9c-4590-8bfe-df18cd40ab6e",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think compareSignatures is fine, or checkSignatureRelatedTo. I'm having trouble figuring out the pattern with this naming scheme.\n",
        "createdAt" : "2015-12-18T06:38:32Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "63081829-e3e3-4117-a53d-0c871241ccef",
        "parentId" : "d71f53ec-dd9c-4590-8bfe-df18cd40ab6e",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I've got `compareX: Ternary` and `isX: boolean`. Not sure about the suffixes yet though.\n",
        "createdAt" : "2015-12-18T21:04:00Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "ed701bff-56a7-4f83-aa1c-9bfc3858f32b",
        "parentId" : "d71f53ec-dd9c-4590-8bfe-df18cd40ab6e",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "The problem is that there's a `compareSignaturesIdentical` (previously called `compareSignatures`!) and so I'm trying to differentiate the two here.\n",
        "createdAt" : "2015-12-20T05:26:47Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "981950b4-1e05-464b-8031-c38828d0940d",
        "parentId" : "d71f53ec-dd9c-4590-8bfe-df18cd40ab6e",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "But all the `isX` functions nested in checkTypeRelatedTo return Ternary. I would just call them `isSignatureIdenticalTo`, `isSignatureRelatedTo`, and `isSignatureAssignableTo`. I don't think the prefix `compare` is illuminating in any way. Then if there are any further distinctions to be made, they can be encoded more explicitly into the name, and consistently across all of these functions.\n",
        "createdAt" : "2015-12-20T06:25:45Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "7b8e00c5-2df3-4346-86fe-2ca8e0211abe",
        "parentId" : "d71f53ec-dd9c-4590-8bfe-df18cd40ab6e",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I suppose; I'm mostly trying to expose an easier interface with the `is*` functions by making them return `boolean` instead of `Ternary`.\n",
        "createdAt" : "2015-12-20T07:12:36Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "74293a4b1d3dbe5d7d447cf03fb33434f5093de7",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +4927,4931 @@         * See signatureRelatedTo, compareSignaturesIdentical\n         */\n        function compareSignaturesRelated(source: Signature,\n                                          target: Signature,\n                                          ignoreReturnTypes: boolean,"
  },
  {
    "id" : "3104eecd-5ee6-47f8-a559-80f3f4531c0f",
    "prId" : 6142,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a164276-e836-44a2-839e-d730c7e637df",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "This comment needs to be updated now that everybody calls this function, right?\n",
        "createdAt" : "2015-12-18T21:03:11Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "74293a4b1d3dbe5d7d447cf03fb33434f5093de7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4925,4929 @@\n        /**\n         * See signatureRelatedTo, compareSignaturesIdentical\n         */\n        function compareSignaturesRelated(source: Signature,"
  },
  {
    "id" : "9269ea85-2b1c-474e-88d6-d9e11f9d2c99",
    "prId" : 6142,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f06e9b53-b2ff-4b17-adda-8cbd6dfe3240",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Can you move all three pieces of code together?\nAlso, wasn't there a third nearly identical piece of code?\n",
        "createdAt" : "2015-12-18T21:18:42Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "2c3f99ef-edba-4273-a31d-455edc4f7532",
        "parentId" : "f06e9b53-b2ff-4b17-adda-8cbd6dfe3240",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "signatureIsRelatedTo will have to stay inside checkTypeRelatedTo though, because it references isRelatedTo.\n",
        "createdAt" : "2015-12-18T22:46:08Z",
        "updatedAt" : "2016-01-14T21:14:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "74293a4b1d3dbe5d7d447cf03fb33434f5093de7",
    "line" : 201,
    "diffHunk" : "@@ -1,1 +5623,5627 @@             * See signatureAssignableTo, compareSignaturesIdentical\n             */\n            function signatureRelatedTo(source: Signature, target: Signature, reportErrors: boolean): Ternary {\n                return compareSignaturesRelated(source, target, /*ignoreReturnTypes*/ false, reportErrors, reportError, isRelatedTo);\n            }"
  },
  {
    "id" : "7275dc70-d170-4ea1-b328-bc60c392d45d",
    "prId" : 6129,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "020a01c8-9d14-4d83-b9ea-a74cb003462e",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "`ts.` is not necessary\n",
        "createdAt" : "2015-12-17T22:41:07Z",
        "updatedAt" : "2015-12-17T22:41:07Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "411e90df44c64d067a0a352be5b643e652424482",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +15545,15549 @@            }\n            if (!nodeCanBeDecorated(node)) {\n                if (node.kind === SyntaxKind.MethodDeclaration && !ts.nodeIsPresent((<MethodDeclaration>node).body)) {\n                    return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);\n                }"
  },
  {
    "id" : "fb386a80-0483-416a-aad6-b8358901c9cf",
    "prId" : 6111,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac6b6495-1c6b-4447-b3c7-ba6462022897",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you elaborate why this needs to be anonymous?\n",
        "createdAt" : "2015-12-17T21:44:31Z",
        "updatedAt" : "2015-12-17T21:44:31Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1335bbba-8ab0-45e6-afa2-8937ea46d863",
        "parentId" : "ac6b6495-1c6b-4447-b3c7-ba6462022897",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Because the static side of a class is an anonymous object type.\n",
        "createdAt" : "2015-12-17T21:54:31Z",
        "updatedAt" : "2015-12-17T21:54:31Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "ef4e2c66-81d5-4caf-80a4-23ebd09bd081",
        "parentId" : "ac6b6495-1c6b-4447-b3c7-ba6462022897",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you add that in as a quick comment then? It's not entirely obvious at first glance.\n",
        "createdAt" : "2015-12-18T22:20:39Z",
        "updatedAt" : "2015-12-18T22:20:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "c21193a0b871de5368fdd73327adb5d659dd8b0b",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +5743,5747 @@        // Return true if the given type is the constructor type for an abstract class\n        function isAbstractConstructorType(type: Type) {\n            if (type.flags & TypeFlags.Anonymous) {\n                const symbol = type.symbol;\n                if (symbol && symbol.flags & SymbolFlags.Class) {"
  },
  {
    "id" : "87f47840-c103-4d0a-a3d7-68ab5a29eadb",
    "prId" : 6104,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5f1c5ba-40a4-428e-9e41-44752423bbe7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Much better than mine\n",
        "createdAt" : "2015-12-15T20:22:03Z",
        "updatedAt" : "2015-12-15T20:22:03Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2b6e8c2c0f6e5bf9ac259c16b399791e3f1ca13",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +3768,3772 @@            let props: Symbol[];\n            // Flags we want to propagate to the result if they exist in all source symbols\n            let commonFlags = (containingType.flags & TypeFlags.Intersection) ? SymbolFlags.Optional : SymbolFlags.None;\n            for (const current of types) {\n                const type = getApparentType(current);"
  },
  {
    "id" : "52cb8b27-0865-474b-a9fa-6b0ca88cbee1",
    "prId" : 6104,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba0db6a3-fdac-4243-9685-cf8b4942365f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't think this actually prevents it from being a union type though. It could be a type parameter, which is later instantiated to a union type.\n\nOr for that matter it could be an intersection of unions, like this:\n\n``` ts\ninterface PropsA {\n    a: string\n}\ninterface PropsB {\n    b: string\n}\ninterface PropsC {\n    C: string\n}\nclass Component {\n     props: (PropsA | PropsB) & PropsC;\n}\nvar c = <Component a=\"...\" b=\"...\" /> // what should be the types for a and b?\n```\n",
        "createdAt" : "2015-12-18T22:51:10Z",
        "updatedAt" : "2015-12-18T23:03:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "a2b6e8c2c0f6e5bf9ac259c16b399791e3f1ca13",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +8241,8245 @@                            return links.resolvedJsxType = attributesType;\n                        }\n                        else if (attributesType.flags & TypeFlags.Union) {\n                            // Props cannot be a union type\n                            error(node.tagName, Diagnostics.JSX_element_attributes_type_0_may_not_be_a_union_type, typeToString(attributesType));"
  },
  {
    "id" : "eca41d21-f084-4249-8aa7-5cb12b3bc950",
    "prId" : 6084,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "41dcce4d-93aa-4a30-87fc-b83a0790a96c",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I wonder if the return type here should make it explicit over which is which (i.e.`{ parameterSymbol: Symbol; propertySymbol: Symbol; }`). Perhaps that's overkill. Thoughts @vladima, @CyrusNajmabadi?\n",
        "createdAt" : "2015-12-15T09:24:02Z",
        "updatedAt" : "2015-12-18T05:29:53Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a5c632cd5a104935a737b58eb41adb79e57cbc84",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +438,442 @@         * @return a tuple of two symbols \n         */\n        function getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): [Symbol, Symbol] {\n            const constructoDeclaration = parameter.parent;\n            const classDeclaration = parameter.parent.parent;"
  },
  {
    "id" : "47a62b00-1601-44bc-bbef-34202ef8296f",
    "prId" : 6083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48ea9f35-021b-4462-8033-c68bc8f02bda",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "`deferredCheckNodes` and leave a decent comment about why these need to be deferred until the end.\n",
        "createdAt" : "2015-12-13T19:57:41Z",
        "updatedAt" : "2015-12-13T19:57:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "546f62ca-d44b-4fd2-b23a-77ebf8cb636a",
        "parentId" : "48ea9f35-021b-4462-8033-c68bc8f02bda",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Are you ever going to not have deferred nodes for most purposes? Seems like you'd have more overhead on a large project from checking over and over whether to defer than to create a one-time array allocation.\n",
        "createdAt" : "2015-12-13T19:58:46Z",
        "updatedAt" : "2015-12-13T19:58:46Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "01652242-5c03-4f34-8049-29b6d81b2c64",
        "parentId" : "48ea9f35-021b-4462-8033-c68bc8f02bda",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The `deferredNodes` array is used only when doing a full type check. When called from the language service (i.e. when \"helicoptering in\") we don't use it.\n",
        "createdAt" : "2015-12-13T21:31:55Z",
        "updatedAt" : "2015-12-13T21:31:55Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91b93439f12a911bc83fbc3399a9a739a619721a",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +162,166 @@        let jsxElementClassType: Type;\n\n        let deferredNodes: Node[];\n\n        const tupleTypes: Map<TupleType> = {};"
  },
  {
    "id" : "d2d6d90c-a333-4b9c-b91a-6b48b2d0e72e",
    "prId" : 6083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd2453e3-6e4b-4896-bbb1-5aa0da0d2f5c",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Move the comment up to the definition of `deferredCheckNodes` and reword the comment appropriately.\n",
        "createdAt" : "2015-12-13T20:01:43Z",
        "updatedAt" : "2015-12-13T20:01:43Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "91b93439f12a911bc83fbc3399a9a739a619721a",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +14479,14483 @@        // Here, performing a full type check of the body of the function expression whilst in the process of\n        // determining the type of foo would cause foo to be given type any because of the recursive reference.\n        // Delaying the type check of the body ensures foo has been assigned a type.\n        function checkNodeDeferred(node: Node) {\n            if (deferredNodes) {"
  },
  {
    "id" : "87d6b76b-1fff-4ff0-81fd-cbf85322ec49",
    "prId" : 6083,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f3cf54dc-6662-4c87-a271-7866b7e8eef0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I can't see what's above this because it's above the 11K mark, but does that mean that this is unconditionally initialized? If so, you can remove the initialization check in `checkNodeDeferred`.\n",
        "createdAt" : "2015-12-13T20:03:06Z",
        "updatedAt" : "2015-12-13T20:03:06Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c9537f82-346d-46da-907d-80cd7eeff933",
        "parentId" : "f3cf54dc-6662-4c87-a271-7866b7e8eef0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, it is not unconditional. See my earlier comment.\n",
        "createdAt" : "2015-12-13T21:32:34Z",
        "updatedAt" : "2015-12-13T21:32:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "91b93439f12a911bc83fbc3399a9a739a619721a",
    "line" : 222,
    "diffHunk" : "@@ -1,1 +14537,14541 @@                potentialThisCollisions.length = 0;\n\n                deferredNodes = [];\n                forEach(node.statements, checkSourceElement);\n                checkDeferredNodes();"
  },
  {
    "id" : "6502d818-45d3-472b-96ca-5a7f09c60181",
    "prId" : 6075,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7f7813f-2f2a-47ec-8c6c-1a8cbdd22380",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "In response to @weswigham's point https://github.com/Microsoft/TypeScript/issues/943#issuecomment-164242517, I believe the special casing of signature return types wouldn't come into play here. The return types are being compared solely as types, and not signature return types. So I think boolean would be assignable to a type predicate in this context, which is indeed desirable.\n",
        "createdAt" : "2015-12-13T20:24:48Z",
        "updatedAt" : "2015-12-16T04:56:03Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5eb23c24-9f03-498a-9fe7-00108e087979",
        "parentId" : "c7f7813f-2f2a-47ec-8c6c-1a8cbdd22380",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Exactly, and you can see that in `stringLiteralTypesAsTags01.ts`. I'll have to add more test cases though.\n",
        "createdAt" : "2015-12-13T21:28:41Z",
        "updatedAt" : "2015-12-16T04:56:03Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d66f7363-f2b1-4181-9e3d-ccfa27fca0f1",
        "parentId" : "c7f7813f-2f2a-47ec-8c6c-1a8cbdd22380",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "My ultimate point is that concern number 2 in https://github.com/Microsoft/TypeScript/issues/943#issuecomment-164066127 is not an issue, since `boolean` would work in the `/*????*/` slot.\n",
        "createdAt" : "2015-12-13T21:31:12Z",
        "updatedAt" : "2015-12-16T04:56:03Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "731925bffeb356e3ee18628bc8d8997d6c79c83f",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +5034,5038 @@            if (targetReturnType === voidType\n                || checkTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation, /*errorNode*/ undefined)\n                || checkTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation, /*errorNode*/ undefined)) {\n\n                return isSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);"
  },
  {
    "id" : "cdda52ab-58dd-4937-bc15-2935aaa35c2e",
    "prId" : 6075,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48858e8d-de10-4b66-8652-9a012625692c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, this is concerning. There is a lot of duplicated functionality here.\n",
        "createdAt" : "2015-12-16T04:10:08Z",
        "updatedAt" : "2015-12-16T04:56:03Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b666d500-7642-45a5-a51e-195ab2c89840",
        "parentId" : "48858e8d-de10-4b66-8652-9a012625692c",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I have a separate branch for that work right now, but I'd like to get it in as part of a separate PR.\n",
        "createdAt" : "2015-12-16T04:55:38Z",
        "updatedAt" : "2015-12-16T04:56:03Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "0e22d43c-5397-4604-b743-32c4f025e61d",
        "parentId" : "48858e8d-de10-4b66-8652-9a012625692c",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "It looks like it's mostly down to `isRelatedTo` vs `isSignatureAssignableTo` and `Ternary` vs `boolean`. Am I missing something?\n",
        "createdAt" : "2015-12-17T22:34:34Z",
        "updatedAt" : "2015-12-17T22:34:34Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "731925bffeb356e3ee18628bc8d8997d6c79c83f",
    "line" : 136,
    "diffHunk" : "@@ -1,1 +5703,5707 @@             */\n            function signatureRelatedTo(source: Signature, target: Signature, reportErrors: boolean): Ternary {\n                // TODO (drosen): De-duplicate code between related functions.\n                if (source === target) {\n                    return Ternary.True;"
  },
  {
    "id" : "55462858-0263-4a10-a064-21d544c3d774",
    "prId" : 6075,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "11e15d53-4ac8-40af-ab0c-babcced6067a",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I think you can use fewer words here: Just say \"Preserve behaviour forbidding boolean functions from being assignable to type guards.\"\n",
        "createdAt" : "2015-12-17T22:21:09Z",
        "updatedAt" : "2015-12-17T22:21:09Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "def89697-2587-48fe-81c2-e83ccb3d002e",
        "parentId" : "11e15d53-4ac8-40af-ab0c-babcced6067a",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Might as well change the original in `signatureRelatedTo` also\n",
        "createdAt" : "2015-12-17T22:21:53Z",
        "updatedAt" : "2015-12-17T22:22:02Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "731925bffeb356e3ee18628bc8d8997d6c79c83f",
    "line" : 62,
    "diffHunk" : "@@ -1,1 +5012,5016 @@                const sourceReturnType = getReturnTypeOfSignature(source);\n\n                // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions\n                if (targetReturnType.flags & TypeFlags.PredicateType && (targetReturnType as PredicateType).predicate.kind === TypePredicateKind.Identifier) {\n                    if (!(sourceReturnType.flags & TypeFlags.PredicateType)) {"
  },
  {
    "id" : "d59664c7-bb55-48ce-867e-7a6acffdd817",
    "prId" : 6075,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55ef8d4a-c2a9-446b-a1d3-3bcb677bd6c4",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "can you break the line here?\n",
        "createdAt" : "2015-12-17T22:30:17Z",
        "updatedAt" : "2015-12-17T22:30:17Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "e4b5e5b4-3a10-49c2-8142-117649217432",
        "parentId" : "55ef8d4a-c2a9-446b-a1d3-3bcb677bd6c4",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "What's the other allowed kind for `predicate.kind`, `ThisType` ?\n",
        "createdAt" : "2015-12-17T22:32:04Z",
        "updatedAt" : "2015-12-17T22:32:04Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "211835c1-4f60-42ac-8b42-5426781de0f0",
        "parentId" : "55ef8d4a-c2a9-446b-a1d3-3bcb677bd6c4",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Yeah; actually, we might consider disallowing those too when not dealing with a get-accessor? It's an orthogonal change for now.\n",
        "createdAt" : "2015-12-18T01:14:50Z",
        "updatedAt" : "2015-12-18T01:14:50Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "731925bffeb356e3ee18628bc8d8997d6c79c83f",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +5013,5017 @@\n                // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions\n                if (targetReturnType.flags & TypeFlags.PredicateType && (targetReturnType as PredicateType).predicate.kind === TypePredicateKind.Identifier) {\n                    if (!(sourceReturnType.flags & TypeFlags.PredicateType)) {\n                        return false;"
  },
  {
    "id" : "cc82ef7c-05f2-495b-9ed2-c4cf8766e853",
    "prId" : 6058,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ca052723-20fe-4830-8fd8-89d1ef5b3ed6",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "this doesn't do the `node.name && ...` check that `checkFunctionLikeDeclaration` does. Is this because `node.name` is guaranteed to be defined for accessors?\n",
        "createdAt" : "2015-12-11T01:07:06Z",
        "updatedAt" : "2015-12-11T18:53:05Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "7f954e24-b3bb-4102-8f42-777346695f5e",
        "parentId" : "ca052723-20fe-4830-8fd8-89d1ef5b3ed6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, accessors always have a name even if they are malformed (it is then a `SyntaxKind.Missing` node). However, function expressions might not have a name, so `checkFunctionLikeDeclaration` needs to compensate for that.\n",
        "createdAt" : "2015-12-11T01:12:09Z",
        "updatedAt" : "2015-12-11T18:53:05Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "18e23a1b90d78afe709ea51dfe04ab649d92bebc",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +11315,11319 @@                // We want to perform checkComputedPropertyName for all computed properties, including\n                // well known symbols.\n                if (node.name.kind === SyntaxKind.ComputedPropertyName) {\n                    checkComputedPropertyName(<ComputedPropertyName>node.name);\n                }"
  },
  {
    "id" : "303a1488-7cea-4af0-ab15-55513081c489",
    "prId" : 6058,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b0443973-f995-40a0-b2cf-7c13e3d3fd9e",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Does `checkFunctionLikeDeclaration` ever check accessors now? If not, then the line `if(!isAccessor(node.kind) && !node.asteriskToken)` can become `if(!node.asteriskToken)`.\n",
        "createdAt" : "2015-12-11T01:09:33Z",
        "updatedAt" : "2015-12-11T18:53:05Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "d8eb3a49-a705-42f9-8264-b39ce2a2c408",
        "parentId" : "b0443973-f995-40a0-b2cf-7c13e3d3fd9e",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Right, I think we can get rid of that check now.\n",
        "createdAt" : "2015-12-11T18:41:53Z",
        "updatedAt" : "2015-12-11T18:53:05Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "18e23a1b90d78afe709ea51dfe04ab649d92bebc",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +11343,11347 @@            if (node.parent.kind !== SyntaxKind.ObjectLiteralExpression) {\n                checkSourceElement(node.body);\n            }\n        }\n"
  },
  {
    "id" : "861262fb-6c45-44a3-883a-453fd1f5828f",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fac19778-fa3e-46ad-86a6-c3cb5d851442",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "Can you add a brief comment as to why this check is needed here? I'm having trouble groking where this might be an issue based on how this while loop walks up the parents.\n",
        "createdAt" : "2016-01-05T16:47:40Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : null,
    "diffHunk" : "@@ -1,1 +550,554 @@                            // This restriction does not apply to JSDoc comment types because they are parented\n                            // at a higher level than type parameters would normally be\n                            if (meaning & result.flags & SymbolFlags.Type && lastLocation.kind !== SyntaxKind.JSDocComment) {\n                                useResult = result.flags & SymbolFlags.TypeParameter\n                                    // type parameters are visible in parameter list, return type and type parameter list"
  },
  {
    "id" : "6d46ecd9-26d5-4db5-991a-d61409adb98d",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89453e16-6fd0-4132-a587-ec1de2d2c18c",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "It might be more readable just to create a type alias for \"TypeReferenceNode | ExpressionWithTypeArguments | JSDocTypeReference\". It's used repeatedly (7 times) in the following code.\n",
        "createdAt" : "2016-01-05T17:17:57Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      },
      {
        "id" : "4c36cfe9-3293-4d03-b8bb-77994aedff88",
        "parentId" : "89453e16-6fd0-4132-a587-ec1de2d2c18c",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Nathan and I tried for a while and couldn't come up with a good name that wasn't taken. Open to suggestions.\n",
        "createdAt" : "2016-01-06T18:49:46Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "172b22c0-3673-4d29-a4f3-b240c545b0e2",
        "parentId" : "89453e16-6fd0-4132-a587-ec1de2d2c18c",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`TypeReferenceContainingNode`?\n",
        "createdAt" : "2016-01-06T18:52:24Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "27424d1e-2064-40fa-8683-63fbe7284e8e",
        "parentId" : "89453e16-6fd0-4132-a587-ec1de2d2c18c",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Sounds pretty good to me.\n",
        "createdAt" : "2016-01-06T21:12:20Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 183,
    "diffHunk" : "@@ -1,1 +4298,4302 @@\n        // Get type from reference to class or interface\n        function getTypeFromClassOrInterfaceReference(node: TypeReferenceNode | ExpressionWithTypeArguments | JSDocTypeReference, symbol: Symbol): Type {\n            const type = <InterfaceType>getDeclaredTypeOfSymbol(symbol);\n            const typeParameters = type.localTypeParameters;"
  },
  {
    "id" : "5682e5a4-13b4-4176-babb-63a2159af434",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9f404dd4-962f-41be-866d-464581a00be1",
        "parentId" : null,
        "authorId" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "body" : "Not sure where all the below changes are coming from, but not JsDoc related.\n",
        "createdAt" : "2016-01-05T17:43:12Z",
        "updatedAt" : "2016-01-12T23:33:40Z",
        "lastEditedBy" : "d70b5be0-1cc6-43f7-b8db-3c51654d174d",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : null,
    "diffHunk" : "@@ -1,1 +9413,9417 @@          *    element, depending on whether the element is declared static.\n          */\n        function getEffectiveDecoratorFirstArgumentType(node: Node): Type {\n            // The first argument to a decorator is its `target`.\n            if (node.kind === SyntaxKind.ClassDeclaration) {"
  },
  {
    "id" : "3f818500-7478-4ea0-9150-6bae6cc45440",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a6b15da3-405d-469a-8529-2f4f8f4f6bd5",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think this should be `getTypeParametersFromJSDocTemplate` or something such.\n",
        "createdAt" : "2016-01-21T19:37:28Z",
        "updatedAt" : "2016-01-21T19:37:28Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "94b946e0-b93a-4b64-b0ff-1b4f72a7db59",
        "parentId" : "a6b15da3-405d-469a-8529-2f4f8f4f6bd5",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : ":heavy_check_mark: \n",
        "createdAt" : "2016-01-22T18:33:11Z",
        "updatedAt" : "2016-01-22T18:33:11Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 70,
    "diffHunk" : "@@ -1,1 +3887,3891 @@        }\n\n        function getTypeParametersFromSignatureDeclaration(declaration: SignatureDeclaration): TypeParameter[] {\n            if (declaration.parserContextFlags & ParserContextFlags.JavaScriptFile) {\n                const templateTag = getJSDocTemplateTag(declaration);"
  },
  {
    "id" : "57d68a0c-9c2d-44c1-b55c-434c0d7d5e03",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89d8a1ca-5128-41d0-af0c-3982a80ed6b6",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This test will always be false (given the one place the function is called), so the `if` should be removed.\n",
        "createdAt" : "2016-01-21T19:38:38Z",
        "updatedAt" : "2016-01-21T19:38:38Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "860c9d8f-8f87-4893-9954-0ecd046aa52f",
        "parentId" : "89d8a1ca-5128-41d0-af0c-3982a80ed6b6",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : ":heavy_check_mark: \n",
        "createdAt" : "2016-01-22T18:33:05Z",
        "updatedAt" : "2016-01-22T18:33:05Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +3895,3899 @@            }\n\n            if (declaration.typeParameters) {\n                return getTypeParametersFromDeclaration(declaration.typeParameters);\n            }"
  },
  {
    "id" : "1caabf72-ecb1-4e80-8531-30dec811f953",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "39bd6410-8195-4a72-b861-e0567dea1749",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I never liked the extra `parserContextFlags` property that Cyrus introduced. Those flags should just be in the regular `flags` property where there is ample room. The problem is that most nodes don't have the property, so this will be a cache miss most of the time when you're not a JavaScript file. We really should just consolidate the two.\n",
        "createdAt" : "2016-01-21T19:55:45Z",
        "updatedAt" : "2016-01-21T19:55:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "2c9c0703-4ef6-40ee-b4cc-b48e75a9d541",
        "parentId" : "39bd6410-8195-4a72-b861-e0567dea1749",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : ":heavy_check_mark: \n",
        "createdAt" : "2016-01-22T18:33:03Z",
        "updatedAt" : "2016-01-22T18:33:03Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "589101a0-f8e2-415f-beac-e686bedafa8b",
        "parentId" : "39bd6410-8195-4a72-b861-e0567dea1749",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "We actually don't have enough room left in `NodeFlags`...\n",
        "createdAt" : "2016-01-22T20:07:25Z",
        "updatedAt" : "2016-01-22T20:07:34Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "584da877-1bee-441d-a770-f5f5c53e32e0",
        "parentId" : "39bd6410-8195-4a72-b861-e0567dea1749",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Logged #6578 to address this at a later date\n",
        "createdAt" : "2016-01-22T22:44:54Z",
        "updatedAt" : "2016-01-22T22:44:54Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 92,
    "diffHunk" : "@@ -1,1 +3926,3930 @@\n        function isOptionalParameter(node: ParameterDeclaration) {\n            if (node.parserContextFlags & ParserContextFlags.JavaScriptFile) {\n                if (node.type && node.type.kind === SyntaxKind.JSDocOptionalType) {\n                    return true;"
  },
  {
    "id" : "8413d503-d20c-4063-8f94-6e570141efa2",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f99446ed-8d4e-49d5-916e-41f113dea4a8",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think I've commented before that this seems rather ad hoc. Are we sure that's the behavior we want?\n",
        "createdAt" : "2016-01-21T19:58:09Z",
        "updatedAt" : "2016-01-21T19:58:09Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "e363df21-c167-4023-8d20-64109d3cdf21",
        "parentId" : "f99446ed-8d4e-49d5-916e-41f113dea4a8",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I'm not sure what the motivation behind this was. I'll remove it and we can see how it goes in practice.\n",
        "createdAt" : "2016-01-22T18:34:12Z",
        "updatedAt" : "2016-01-22T18:34:12Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "58ce54ac-fa6d-4691-b2cf-1dd7f52284a8",
        "parentId" : "f99446ed-8d4e-49d5-916e-41f113dea4a8",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Here's the test we have that I'm removing:\n\n``` ts\n//// function f(a,b) { }\n//// /** @type {f} */\n//// var v/**/\n\ngoTo.marker();\nverify.quickInfoIs('var v: (a: any, b: any) => void');\n```\n",
        "createdAt" : "2016-01-22T19:36:56Z",
        "updatedAt" : "2016-01-22T19:36:56Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 241,
    "diffHunk" : "@@ -1,1 +4381,4385 @@                // If the reference didn't resolve to a type, try seeing if results to a \n                // value.  If it does, get the type of that value.\n                symbol = resolveEntityName(typeReferenceName, SymbolFlags.Value);\n            }\n"
  },
  {
    "id" : "a07c1ac6-6aaa-4cb5-9a03-78c1dfa37e12",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5da49a8a-a857-49c9-9640-bc3b10a53cc9",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It seems this branch of the `if` is strictly a superset of the other branch. Could we just remove the test and the `else` branch?\n",
        "createdAt" : "2016-01-21T19:59:58Z",
        "updatedAt" : "2016-01-21T20:00:03Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4f2dfbe1-d620-4b30-a226-0bed1d442334",
        "parentId" : "5da49a8a-a857-49c9-9640-bc3b10a53cc9",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Giving it a go :smile:\n",
        "createdAt" : "2016-01-22T18:38:40Z",
        "updatedAt" : "2016-01-22T18:38:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "875015f8-a566-4772-97be-2473ddfd71b0",
        "parentId" : "5da49a8a-a857-49c9-9640-bc3b10a53cc9",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "These turn out to not be equivalent for reasons I have not yet investigated\n",
        "createdAt" : "2016-01-22T22:29:05Z",
        "updatedAt" : "2016-01-22T22:29:05Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 284,
    "diffHunk" : "@@ -1,1 +4415,4419 @@                let symbol: Symbol;\n                let type: Type;\n                if (node.kind === SyntaxKind.JSDocTypeReference) {\n                    const typeReferenceName = getTypeReferenceName(node);\n                    symbol = resolveTypeReferenceName(node, typeReferenceName);"
  },
  {
    "id" : "e8304d6d-578c-4f17-918a-47af91c6157e",
    "prId" : 6024,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4c3908f5-28ca-416a-943b-daf4fb7057f5",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This `if` and the following `if` should both be in a single `if (isInJavaScriptFile(node))`.\n",
        "createdAt" : "2016-01-21T20:06:10Z",
        "updatedAt" : "2016-01-21T20:06:10Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "69168129-7a9c-4a88-80b7-9f5c7fe51f83",
        "parentId" : "4c3908f5-28ca-416a-943b-daf4fb7057f5",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : ":heavy_check_mark: \n",
        "createdAt" : "2016-01-22T22:29:14Z",
        "updatedAt" : "2016-01-22T22:29:14Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "120fa190d22fda462df989ce04268c67c0523305",
    "line" : 392,
    "diffHunk" : "@@ -1,1 +7270,7274 @@            }\n\n            if (container.parserContextFlags & ParserContextFlags.JavaScriptFile) {\n                const type = getTypeForThisExpressionFromJSDoc(container);\n                if (type && type !== unknownType) {"
  },
  {
    "id" : "5d34d498-a3f4-4c01-a3b9-841b584e0e0e",
    "prId" : 5992,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "115ff1b8-c654-408f-bc43-e8cba0884b5a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Instead of this, can't you just get the applicable declaration and climb up the parents, deciding whether you are in a binding pattern on the way up?\n",
        "createdAt" : "2016-01-06T18:21:41Z",
        "updatedAt" : "2016-01-13T17:36:20Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "7a16d6ea-5266-4df0-abdf-cf0407483337",
        "parentId" : "115ff1b8-c654-408f-bc43-e8cba0884b5a",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Probably? I'd have to try it. I'm going to punt on that for this change since it's a bugfix together with a structural refactoring.\n\nI'll create a followup issue though.\n",
        "createdAt" : "2016-01-06T18:39:33Z",
        "updatedAt" : "2016-01-13T17:36:20Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "7d523bd9-899f-4fcc-86b0-dddf9129a22e",
        "parentId" : "115ff1b8-c654-408f-bc43-e8cba0884b5a",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "While writing up the new issue, I realised that this whole branch is an error case because `parameterIndex` is unknown (`<0` actually). `getTypePredicateParameterIndex` couldn't find it in the top-level so the applicable declaration is in turn unknown. It falls to `checkIfTypePredicateVariableIsDeclaredInBindingPattern` to retrieve the erroneously nested declaration.\n\nIn this example, `a` is illegal because it's found in a binding pattern:\n\n``` ts\ndeclare f([nested, b]: [any, number], [unused, irrelevant]: [string, string]): nested is number;\n```\n",
        "createdAt" : "2016-01-06T18:57:32Z",
        "updatedAt" : "2016-01-13T17:36:20Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "a9f2cb6d6e791a0c1e7d588369da4bae6811653b",
    "line" : 33,
    "diffHunk" : "@@ -1,1 +11162,11166 @@                else if (parameterName) {\n                    let hasReportedError = false;\n                    for (const { name } of parent.parameters) {\n                        if ((name.kind === SyntaxKind.ObjectBindingPattern ||\n                            name.kind === SyntaxKind.ArrayBindingPattern) &&"
  },
  {
    "id" : "a56da773-2752-41fb-8700-7e3f6711f814",
    "prId" : 5949,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "02b143e4-3bf8-44b4-a32e-e497b5167a2a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Invert the condition to reduce nesting.\n",
        "createdAt" : "2015-12-06T06:37:32Z",
        "updatedAt" : "2015-12-10T22:09:37Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "5662619f-b906-407e-b926-fa3992e8759f",
        "parentId" : "02b143e4-3bf8-44b4-a32e-e497b5167a2a",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Not sure what you mean. There's a shared return statement at the bottom of the function and no else clause that would be reversed.\n",
        "createdAt" : "2015-12-06T23:45:57Z",
        "updatedAt" : "2015-12-10T22:09:37Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a82db3c0-a61b-4b65-ae32-8b6979f9c947",
        "parentId" : "02b143e4-3bf8-44b4-a32e-e497b5167a2a",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I meant to just repeat the `return` statement, but it's not really a big deal.\n",
        "createdAt" : "2015-12-09T00:25:18Z",
        "updatedAt" : "2015-12-10T22:09:37Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5cb2b6afded47aee8251dde8567033d656ab7e6a",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +4720,4724 @@\n        function getInferenceMapper(context: InferenceContext): TypeMapper {\n            if (!context.mapper) {\n                const mapper: TypeMapper = t => {\n                    const typeParameters = context.typeParameters;"
  },
  {
    "id" : "e06b26ad-84d3-459e-b1bf-60943d3a1772",
    "prId" : 5906,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58f43ed3-cf91-41fd-a4dc-ffacceed321e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Is this intentionally supposed to return `void`? It's returned within another function.\n",
        "createdAt" : "2015-12-09T22:41:04Z",
        "updatedAt" : "2015-12-10T00:43:53Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "fba038a0-d42d-457e-9cb1-6b9fa5d783bd",
        "parentId" : "58f43ed3-cf91-41fd-a4dc-ffacceed321e",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "In this case, we're just using it for its error reporting (and caching of the type for later), rather then returning it immediately.\n",
        "createdAt" : "2015-12-09T23:04:41Z",
        "updatedAt" : "2015-12-10T00:43:53Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e586943a1b60075e51fc482af2d9be278eab08b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +14341,14345 @@                    getTypeFromThisTypeNode(parameterName as ThisTypeNode);\n                }\n            }\n        }\n"
  },
  {
    "id" : "9c2d4c1f-3079-4a32-9a22-4a3e6712d095",
    "prId" : 5906,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "862ab3a0-fafc-4750-a052-0bf2ae923305",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I think this should be a `Debug.assert`\n",
        "createdAt" : "2015-12-09T22:45:05Z",
        "updatedAt" : "2015-12-10T00:43:53Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "31d617c6-998c-4d0e-8050-c45dbf195e7b",
        "parentId" : "862ab3a0-fafc-4750-a052-0bf2ae923305",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Can't make it into an assertion since it can be `false` in error cases when a predicate type is found in an invalid position (for example, an index signature)\n",
        "createdAt" : "2015-12-09T23:31:59Z",
        "updatedAt" : "2015-12-10T00:43:53Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "8e586943a1b60075e51fc482af2d9be278eab08b",
    "line" : 564,
    "diffHunk" : "@@ -1,1 +11129,11133 @@                if (node.type.kind === SyntaxKind.TypePredicate) {\n                    const returnType = getReturnTypeOfSignature(getSignatureFromDeclaration(node));\n                    if (!returnType || !(returnType.flags & TypeFlags.PredicateType)) {\n                        return;\n                    }"
  },
  {
    "id" : "4a34be74-fee6-41cd-b51d-2c1caf33b6db",
    "prId" : 5870,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b688b131-f1e7-49ad-b254-fccc93f0d4e5",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Add a comment including example of the case where flags is `NodeCheckFlags.AsyncMethodWithSuperBinding`\n",
        "createdAt" : "2016-01-25T19:45:43Z",
        "updatedAt" : "2016-01-26T20:55:09Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "05803f528549cd5bbf953f71170e978a538a8e8d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7437,7441 @@            if (container.kind === SyntaxKind.MethodDeclaration && container.flags & NodeFlags.Async) {\n                if (isSuperPropertyOrElementAccess(node.parent) && isAssignmentTarget(node.parent)) {\n                    getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuperBinding;\n                }\n                else {"
  },
  {
    "id" : "6f8c3203-2510-4e28-a0f9-1c937483d88f",
    "prId" : 5870,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2c5b029-c0fb-4d53-822c-8607b861a4d3",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Excellent write-up! :100: \n",
        "createdAt" : "2016-01-26T06:36:42Z",
        "updatedAt" : "2016-01-26T20:55:09Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "05803f528549cd5bbf953f71170e978a538a8e8d",
    "line" : 105,
    "diffHunk" : "@@ -1,1 +7434,7438 @@            // This helper creates an object with a \"value\" property that wraps the `super` property or indexed access for both get and set.\n            // This is required for destructuring assignments, as a call expression cannot be used as the target of a destructuring assignment\n            // while a property access can.\n            if (container.kind === SyntaxKind.MethodDeclaration && container.flags & NodeFlags.Async) {\n                if (isSuperPropertyOrElementAccess(node.parent) && isAssignmentTarget(node.parent)) {"
  },
  {
    "id" : "30838cf8-5e2e-463c-81b4-e102fd95f17b",
    "prId" : 5824,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "493d8a66-d0b7-4025-91f0-f4ed2fdc5f8d",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "remove \"explicitly specified\"\n",
        "createdAt" : "2015-11-30T08:46:05Z",
        "updatedAt" : "2015-11-30T17:34:58Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c31bd804-06ba-4ae7-b650-21e4ac5af505",
        "parentId" : "493d8a66-d0b7-4025-91f0-f4ed2fdc5f8d",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "'explicitly specified' reflects what is checked in the `if` below - if function has explicit type annotation and it is `void` / `any`\n",
        "createdAt" : "2015-11-30T15:24:22Z",
        "updatedAt" : "2015-11-30T17:34:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "7a5e8902-d45b-4c60-9fa6-99f92b67e4c8",
        "parentId" : "493d8a66-d0b7-4025-91f0-f4ed2fdc5f8d",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Remove the second \"with\"\n",
        "createdAt" : "2015-11-30T22:55:58Z",
        "updatedAt" : "2015-11-30T22:55:58Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ff567927408665ef68062061ac2b9102d6ef053",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +9871,9875 @@            }\n\n            // Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.\n            if (returnType === voidType || isTypeAny(returnType)) {\n                return;"
  },
  {
    "id" : "baae4c02-40f7-47b2-b3ba-04d479a3a7b7",
    "prId" : 5824,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff9221e4-b221-4336-9310-32207c5af365",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What about `func.type || func.name || func`\n",
        "createdAt" : "2015-11-30T08:49:30Z",
        "updatedAt" : "2015-11-30T17:34:58Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "fe7edb56-18a5-4148-aa7a-e809bee33292",
        "parentId" : "ff9221e4-b221-4336-9310-32207c5af365",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "`error` already picks `name` as a best error span for functions if this is possible\n",
        "createdAt" : "2015-11-30T15:25:15Z",
        "updatedAt" : "2015-11-30T17:34:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ff567927408665ef68062061ac2b9102d6ef053",
    "line" : 49,
    "diffHunk" : "@@ -1,1 +9903,9907 @@                    }\n                }\n                error(func.type || func, Diagnostics.Not_all_code_paths_return_a_value);\n            }\n        }"
  },
  {
    "id" : "f5ce2c50-991b-4ea6-a846-5072d299c0f8",
    "prId" : 5738,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ec5e423-5c5d-4cfa-b451-e1d813fe08a0",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "How about\n\n``` ts\nreturn forEach(target.types, t => isTypeIdenticalTo(source, t) || undefined);\n```\n",
        "createdAt" : "2015-11-20T22:19:39Z",
        "updatedAt" : "2015-11-20T23:32:27Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "1ff9c965-7240-4fdb-91ee-cfe602f3c051",
        "parentId" : "4ec5e423-5c5d-4cfa-b451-e1d813fe08a0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Definitely an option, but not quite as efficient. I will keep what's there.\n",
        "createdAt" : "2015-11-24T16:26:18Z",
        "updatedAt" : "2015-11-24T16:26:18Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "add5146aea063fda49367c5d750709efe0c83d9e",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +6255,6259 @@        }\n\n        function typeIdenticalToSomeType(source: Type, target: UnionOrIntersectionType): boolean {\n            for (const t of target.types) {\n                if (isTypeIdenticalTo(source, t)) {"
  },
  {
    "id" : "438e033d-1a33-4538-a83a-5ac7a7e7da24",
    "prId" : 5738,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "335fde66-5cd5-4266-a4e2-461fb1e17a14",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I don't think I understand the mutability discipline for the checker. It looks like `splice` modifies `source.types`. Is this OK? How do we know that nobody else refers to `source`? (even though `inferFromTypes` no longer does after the call to `reduceUnionOrIntersection`.)\n",
        "createdAt" : "2015-11-20T22:29:29Z",
        "updatedAt" : "2015-11-20T23:32:27Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "b35dcc53-6201-4e7c-938b-861d2a78fe18",
        "parentId" : "335fde66-5cd5-4266-a4e2-461fb1e17a14",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Never mind, I just saw the call to .slice(0) above.\n",
        "createdAt" : "2015-11-20T22:30:38Z",
        "updatedAt" : "2015-11-20T23:32:27Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "0318ba8d-3c2d-429f-bef6-630c27b5805a",
        "parentId" : "335fde66-5cd5-4266-a4e2-461fb1e17a14",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Yeah, while it seems obvious now, it'd be worthwhile to add a quick comment so that people taking a cursory glance don't think they've found a bug.\n",
        "createdAt" : "2015-11-23T05:05:41Z",
        "updatedAt" : "2015-11-23T05:05:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "add5146aea063fda49367c5d750709efe0c83d9e",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +6278,6282 @@                        modified = true;\n                    }\n                    sourceTypes.splice(sourceIndex, 1);\n                }\n                else {"
  },
  {
    "id" : "732ebe9b-48c0-4df5-bc77-7f4bf5678bbd",
    "prId" : 5738,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bebdced6-5bf0-42bf-872d-40391da76ae3",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you break this into multiple lines?\n",
        "createdAt" : "2015-11-23T05:04:44Z",
        "updatedAt" : "2015-11-23T05:04:44Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f8c1f7e7-6412-4fea-8dff-6fbe469bc249",
        "parentId" : "bebdced6-5bf0-42bf-872d-40391da76ae3",
        "authorId" : "d65e4089-434e-479a-bf31-45bf8dbd0d2f",
        "body" : "Use wordwrapping man.\n",
        "createdAt" : "2015-12-07T17:58:24Z",
        "updatedAt" : "2015-12-07T17:58:24Z",
        "lastEditedBy" : "d65e4089-434e-479a-bf31-45bf8dbd0d2f",
        "tags" : [
        ]
      }
    ],
    "commit" : "add5146aea063fda49367c5d750709efe0c83d9e",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +6285,6289 @@            }\n            if (modified) {\n                return source.flags & TypeFlags.Union ? getUnionType(sourceTypes, /*noSubtypeReduction*/ true) : getIntersectionType(sourceTypes);\n            }\n            return source;"
  },
  {
    "id" : "6d2a02cf-e5ac-4617-9b25-c20f8c0453cd",
    "prId" : 5733,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b16a645-5f9f-43ae-9025-1eff3946ba2f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What about a `Promise<void>` in an async function?\n",
        "createdAt" : "2015-11-23T04:57:28Z",
        "updatedAt" : "2015-11-23T06:06:27Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "023e7d05-1b2a-42e0-8b32-d772323e1074",
        "parentId" : "2b16a645-5f9f-43ae-9025-1eff3946ba2f",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "for async functions returnType is contain promised type so in case of `Promise<void>` return type will be just `void`\n",
        "createdAt" : "2015-11-23T05:45:09Z",
        "updatedAt" : "2015-11-23T06:06:27Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "5eb8f71ee1962cfeb5441d9029121cef182e8e2b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +9825,9829 @@\n            // Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.\n            if (returnType && (returnType === voidType || isTypeAny(returnType))) {\n                return;\n            }"
  },
  {
    "id" : "21f87996-d37e-4565-8c11-8cbf19ae74e6",
    "prId" : 5733,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a7560453-7ae7-4f97-95da-6ff60e8d4930",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "duplicate 'with with'\n",
        "createdAt" : "2015-11-23T16:35:08Z",
        "updatedAt" : "2015-11-23T16:35:08Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "2170b9d2-aae0-40df-b7d0-bd0abcaefe75",
        "parentId" : "a7560453-7ae7-4f97-95da-6ff60e8d4930",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "done\n",
        "createdAt" : "2015-11-23T17:27:02Z",
        "updatedAt" : "2015-11-23T17:27:02Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "5eb8f71ee1962cfeb5441d9029121cef182e8e2b",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +9824,9828 @@            }\n\n            // Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.\n            if (returnType && (returnType === voidType || isTypeAny(returnType))) {\n                return;"
  },
  {
    "id" : "1a3c6a72-b754-4dac-837f-0022fefb2cbd",
    "prId" : 5733,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cdd2144-77c0-45e4-9b7f-d781261c9f47",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Looks like a couple of places where we have to choose between `checkAsyncFunctionReturnType` and `getTypeFromTypeNode`. I think it would be a good idea to have a `getFunctionReturnType` that just wraps the decision. (And it's quite possible that additional calls to `getTypeFromTypeNode` need to switch.)\n",
        "createdAt" : "2015-11-23T16:46:17Z",
        "updatedAt" : "2015-11-23T16:46:17Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "c2711aec-694f-46b6-bfba-4542b2807190",
        "parentId" : "4cdd2144-77c0-45e4-9b7f-d781261c9f47",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Currently, it looks like these are the only two calls to `checkAsyncFunctionReturnType`, so perhaps it should just have a name change.\n",
        "createdAt" : "2015-11-23T16:50:30Z",
        "updatedAt" : "2015-11-23T16:50:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "5eb8f71ee1962cfeb5441d9029121cef182e8e2b",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +9922,9926 @@            }\n\n            const returnOrPromisedType = node.type && (isAsync ? checkAsyncFunctionReturnType(node) : getTypeFromTypeNode(node.type));\n            if (!node.asteriskToken) {\n                // return is not necessary in the body of generators"
  },
  {
    "id" : "acdb2476-de9f-4aff-bcf8-3877a623df6d",
    "prId" : 5725,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3c85609-9d89-42d5-92e5-8a63dce349f1",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you add a `// TODO (drosen): Use this function in 'checkStringLiteralExpression'.`?\n\nI need to see how this affects things, but I don't want it to affect your work.\n",
        "createdAt" : "2015-11-20T01:44:26Z",
        "updatedAt" : "2015-11-20T01:50:34Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "20b6a1ab-a6cf-4228-8e59-acd01733078f",
        "parentId" : "b3c85609-9d89-42d5-92e5-8a63dce349f1",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "I'll put a comment in checkStringLiteralExpression instead. The big difference is that getTypeFromStringLiteral caches the type on the resolvedType of the node's NodeLinks.\n",
        "createdAt" : "2015-11-20T01:47:42Z",
        "updatedAt" : "2015-11-20T01:50:34Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "9b0231d9b897b44b75d7828afe61bb1048beff38",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +4542,4546 @@        }\n\n        function getTypeFromStringLiteral(node: StringLiteral | StringLiteralTypeNode): Type {\n            const links = getNodeLinks(node);\n            if (!links.resolvedType) {"
  },
  {
    "id" : "fe29fdf3-453a-46cc-a69f-781fa5124450",
    "prId" : 5626,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "So now `getNarrowedTypeOfSymbol` walks up the parent chain twice, and further than it used to. Is there any performance impact?\n",
        "createdAt" : "2015-11-12T00:08:47Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "ff0a813f-256d-4916-a25c-a82adfa90f8b",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "+1\n",
        "createdAt" : "2015-11-12T00:20:21Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "f18e8db6-a534-43c0-912e-ff6f24e0bddc",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`getDeclarationOfKind` doesn't walk up any tree, it just iterates over a symbol's declarations. `getDeclarationContainer` walks out of a binding pattern (which is unavoidable, but also not highly nested) but then just does `node.parent.parent.parent` or `node.parent`. I'm not seeing a secondary walk here at all, just static overhead. _Now_ as for weather it's worth doing this just to bail early rather than walking to the top of file... no idea. It probably depends on how deeply nested your code gets. I'll run some perf tests with and without the bailout.\n",
        "createdAt" : "2015-11-12T00:28:35Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "83fd2c97-31b5-4c82-adde-2d6ec364e5a0",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "you are walking once to find `top` then another time until you hit `top`. we can put them together, and walk up once, and just stop when you find what would be `top` otherwise.\n",
        "createdAt" : "2015-11-12T00:38:09Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "580ceeac-91f6-4eb8-8c62-fea60c691fc5",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Finding `top` doesn't involve a walk (beyond moving out of a binding pattern in the declaration), though?\n\nFinding `top` is a matter of going from here:\n\n``` ts\nfunction foo() {\n  let {x}: {x: string | number} = {x: 1};\n  //   ^\n  if (typeof x === \"string\") {\n    x;\n  }\n}\n```\n\nto the enclosing block.\n\nThe actual walk up starts at the node to narrow at:\n\n``` ts\nfunction foo() {\n  let {x}: {x: string | number} = {x: 1};\n  if (typeof x === \"string\") {\n    x;\n // ^\n  }\n}\n```\n\nand can either go up to the top level of the file/namespace (though this could traverse a lot of excess nodes if this is the only terminating condition), or can stop at the location defined by `top` - the scope within which the symbol in question is defined.\n",
        "createdAt" : "2015-11-12T00:50:00Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "ec1b1ded-e0ed-4523-86d5-b8b8054d25ae",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Yes, I meant `getDeclarationContainer` but put the comment one line too high by mistake.\n",
        "createdAt" : "2015-11-12T16:37:07Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "c61238fe-94a0-41fa-a216-77c189e9ddcc",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Yeah, `getDeclarationContainer` isn't a heavy walk. It's a static 2 or 4 references up (based on declaration kind) after walking out of the binding pattern in the declaration. I can't merge these walks as @mhegazy suggests because I'm not walking the same section of the tree twice (declaration -> up to declaration container vs use site -> up to declaration container - I mean, I could merge them, but I'd have to recur into all siblings at each level looking for the declaration, which seems _really bad_). If `k` is the stack of nodes between the file/module container and the node we're narrowing at (which is how many nodes I would walk in the simple case without looking for the declaration container of the symbol's declaration), and `n` is the number of nodes I walk up when computing narrowing before stopping at `top`, and `m` is the number of nodes I walk up when computing the declaration container to compute `top` (which is to say the recursive depth of the binding pattern), I'm wagering that walking over `m+n` is practically more performant than than `k`, given that `m` has a tendency to be very small and `k` has a tendency to be very large.\n\nNow, if it turns out that the declaration container _is_ the top level of the namespace/module, then calculating it was extra work we didn't need to do as `n=k` and we've walked over `m+k` nodes rather than potentially just `k` nodes.\n\nReally, this could be avoided if a declaration just kept a reference somewhere to its container, but that would be awkward, I suppose.\n\nIn effect, I'm trying to assert that `getDeclarationContainer` is close enough to constant time in all real-world cases, that its usage is warranted to be able to bail out of our narrowing walk up the tree early.\n",
        "createdAt" : "2015-11-14T00:30:41Z",
        "updatedAt" : "2015-11-17T22:34:08Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      },
      {
        "id" : "00d5fb10-626e-44cd-bc05-2060d652d593",
        "parentId" : "65b61336-932a-4e49-aaac-d94773db2cca",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "Current changes vs master baseline (5 iterations of perf test):\n\n```\nProject                         Baseline (ms)     Current (ms)      Delta (%) Best (ms) Worst (ms)\n-------                         -------------     ------------      --------- --------- ----------\nCompiler - tsc (ParseTime)      0.73 (¬± 46.94 %)  0.60 (¬± 2.76 %)   -17.71 %       0.59       0.62\nCompiler - tsc (BindTime)       0.24 (¬± 4.36 %)   0.24 (¬± 2.88 %)   -0.84 %        0.23       0.24\nCompiler - tsc (CheckTime)      1.11 (¬± 2.55 %)   1.07 (¬± 1.32 %)   -3.42 %        1.06       1.09\nCompiler - tsc (EmitTime)       2.02 (¬± 12.41 %)  1.92 (¬± 7.18 %)   -4.94 %        1.73       1.99\nCompiler - tsc (TotalTime)      4.11 (¬± 13.65 %)  3.83 (¬± 3.09 %)   -6.62 %        3.67        3.9\nMonaco - tsc (ParseTime)        2.47 (¬± 70.11 %)  1.70 (¬± 1.11 %)   -31.45 %       1.68       1.72\nMonaco - tsc (BindTime)         0.70 (¬± 2.67 %)   0.66 (¬± 1.69 %)   -6.82 %        0.65       0.67\nMonaco - tsc (CheckTime)        3.35 (¬± 12.81 %)  3.22 (¬± 11.00 %)  -3.88 %        2.99       3.57\nMonaco - tsc (EmitTime)         6.61 (¬± 22.60 %)  6.30 (¬± 15.68 %)  -4.69 %        5.55       7.22\nMonaco - tsc (TotalTime)        13.14 (¬± 18.82 %) 11.87 (¬± 11.16 %) -9.62 %       10.93      13.14\nTFS - tsc (ParseTime)           1.46 (¬± 70.93 %)  1.08 (¬± 1.41 %)   -26.23 %       1.06       1.09\nTFS - tsc (BindTime)            0.49 (¬± 14.66 %)  0.46 (¬± 1.47 %)   -4.92 %        0.46       0.47\nTFS - tsc (CheckTime)           2.28 (¬± 1.83 %)   2.45 (¬± 6.33 %)   7.73 %         2.29       2.57\nTFS - tsc (EmitTime)            3.65 (¬± 5.27 %)   3.85 (¬± 22.65 %)  5.59 %         3.49       5.11\nTFS - tsc (TotalTime)           7.88 (¬± 16.79 %)  7.85 (¬± 12.08 %)  -0.41 %        7.36        9.2\nEncyclopedia - tsc (ParseTime)  0.42 (¬± 22.49 %)  0.38 (¬± 1.81 %)   -9.62 %        0.37       0.38\nEncyclopedia - tsc (BindTime)   0.14 (¬± 9.58 %)   0.14 (¬± 7.71 %)   1.41 %         0.13       0.15\nEncyclopedia - tsc (CheckTime)  0.50 (¬± 1.11 %)   0.51 (¬± 4.71 %)   3.21 %          0.5       0.54\nEncyclopedia - tsc (EmitTime)   0.08 (¬± 28.47 %)  0.08 (¬± 28.47 %)  0.00 %         0.07       0.11\nEncyclopedia - tsc (TotalTime)  1.13 (¬± 10.39 %)  1.11 (¬± 3.40 %)   -2.12 %        1.08       1.15\nCompiler - node (ParseTime)     0.78 (¬± 8.57 %)   0.75 (¬± 1.81 %)   -4.08 %        0.74       0.76\nCompiler - node (BindTime)      0.39 (¬± 10.07 %)  0.36 (¬± 2.90 %)   -8.21 %        0.35       0.37\nCompiler - node (CheckTime)     1.70 (¬± 10.04 %)  1.64 (¬± 3.80 %)   -3.30 %        1.57       1.69\nCompiler - node (EmitTime)      1.97 (¬± 4.16 %)   1.90 (¬± 11.51 %)  -3.26 %        1.74       2.18\nCompiler - node (TotalTime)     4.84 (¬± 6.30 %)   4.66 (¬± 5.44 %)   -3.84 %        4.42       4.98\nMonaco - node (ParseTime)       1.92 (¬± 8.11 %)   1.90 (¬± 7.76 %)   -1.14 %        1.78       2.08\nMonaco - node (BindTime)        0.99 (¬± 7.98 %)   0.95 (¬± 6.98 %)   -4.23 %        0.89       1.03\nMonaco - node (CheckTime)       5.59 (¬± 4.20 %)   5.60 (¬± 4.81 %)   0.07 %         5.32       5.88\nMonaco - node (EmitTime)        5.96 (¬± 1.06 %)   5.87 (¬± 5.12 %)   -1.48 %        5.62       6.21\nMonaco - node (TotalTime)       14.47 (¬± 2.89 %)  14.32 (¬± 4.56 %)  -1.05 %        13.6      14.81\nTFS - node (ParseTime)          1.33 (¬± 4.01 %)   1.32 (¬± 3.88 %)   -0.45 %        1.28       1.39\nTFS - node (BindTime)           0.83 (¬± 2.36 %)   0.84 (¬± 2.25 %)   0.72 %         0.82       0.86\nTFS - node (CheckTime)          3.75 (¬± 2.66 %)   3.77 (¬± 2.40 %)   0.53 %         3.65       3.84\nTFS - node (EmitTime)           4.13 (¬± 4.28 %)   4.20 (¬± 2.82 %)   1.55 %         4.13       4.36\nTFS - node (TotalTime)          10.04 (¬± 2.89 %)  10.13 (¬± 2.27 %)  0.82 %         9.98      10.45\nEncyclopedia - node (ParseTime) 0.29 (¬± 1.93 %)   0.30 (¬± 1.86 %)   3.47 %         0.29        0.3\nEncyclopedia - node (BindTime)  0.22 (¬± 2.50 %)   0.23 (¬± 4.75 %)   5.41 %         0.22       0.24\nEncyclopedia - node (CheckTime) 1.03 (¬± 2.41 %)   1.08 (¬± 3.40 %)   4.66 %         1.03        1.1\nEncyclopedia - node (EmitTime)  0.13 (¬± 13.22 %)  0.13 (¬± 12.65 %)  1.59 %         0.12       0.15\nEncyclopedia - node (TotalTime) 1.67 (¬± 1.93 %)   1.73 (¬± 2.17 %)   3.84 %         1.68       1.75\n```\n\nIt causes minimal/no changes to overall perf in real-world scenarios. (Though I imagine this is the kind of change were you'd only see perf changes in a micro-benchmark anyway)\n",
        "createdAt" : "2015-11-18T20:54:07Z",
        "updatedAt" : "2015-11-18T20:54:07Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "9531d929c703dade551c2d0497574b9e8b2f1dff",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +6402,6406 @@            if (node && symbol.flags & SymbolFlags.Variable) {\n                if (isTypeAny(type) || type.flags & (TypeFlags.ObjectType | TypeFlags.Union | TypeFlags.TypeParameter)) {\n                    const declaration = getDeclarationOfKind(symbol, SyntaxKind.VariableDeclaration);\n                    const top = declaration && getDeclarationContainer(declaration);\n                    const originalType = type;"
  },
  {
    "id" : "4bf9353c-bf7b-4343-9fa5-50c7c1e6bf80",
    "prId" : 5575,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7185c2be-7fe0-482e-94a0-5c0940ba849e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you leave a comment about why we can get away with just checking the last type parameter instead of the whole list? It's not necessarily clear to someone stumbling upon this code for the first time.\n",
        "createdAt" : "2015-11-10T18:28:47Z",
        "updatedAt" : "2015-11-10T21:14:30Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "980a4c38-e5d7-4477-9692-d81701da1558",
        "parentId" : "7185c2be-7fe0-482e-94a0-5c0940ba849e",
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "done\n",
        "createdAt" : "2015-11-10T21:05:45Z",
        "updatedAt" : "2015-11-10T21:14:30Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3d2963ff7a985c827aaf2a882427fe401fe5d29",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2923,2927 @@                const last = outerTypeParameters.length - 1;\n                const typeArguments = (<TypeReference>type).typeArguments;\n                return outerTypeParameters[last].symbol !== typeArguments[last].symbol;\n            }\n            return true;"
  },
  {
    "id" : "61ee28cc-aac8-4328-b792-88fe958e10a3",
    "prId" : 5566,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d820104f-f20b-4a2f-aa4e-032cfc1c64f9",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you add a comment that you need this test because garbage declarations may be introduced between overloads and cause issues according to our expectations\n",
        "createdAt" : "2015-11-24T00:05:26Z",
        "updatedAt" : "2015-11-28T18:42:13Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "084d8b9b-cca1-4251-a1e0-aa456b5661e7",
        "parentId" : "d820104f-f20b-4a2f-aa4e-032cfc1c64f9",
        "authorId" : "1ff7a89e-6f91-4779-af47-675f0dd3fc7b",
        "body" : "Done\n",
        "createdAt" : "2015-11-28T19:01:12Z",
        "updatedAt" : "2015-11-28T19:01:12Z",
        "lastEditedBy" : "1ff7a89e-6f91-4779-af47-675f0dd3fc7b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ed453ddcfc8c578aaacccd9fb05368f89987e611",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11208,11212 @@                // We may be here because of some extra junk between overloads that could not be parsed into a valid node.\n                // In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.\n                if (subsequentNode && subsequentNode.pos === node.end) {\n                    if (subsequentNode.kind === node.kind) {\n                        const errorNode: Node = (<FunctionLikeDeclaration>subsequentNode).name || subsequentNode;"
  },
  {
    "id" : "593b0bc0-c78d-4513-8a65-0cfa03a66b95",
    "prId" : 5517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e0db4b0-32a0-4e14-b94d-11a54fea91b3",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "nit: This function is hard to read on a portrait (1200 px) monitor with github's generous margins cutting it down to about 700 px. Might not be worth fixing.\n",
        "createdAt" : "2015-11-04T16:34:16Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cc64cbd296dfde5444279d2d5c37df58f709183",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5418,5422 @@         * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.\n         */\n        function checkTypeComparableTo(source: Type, target: Type, errorNode: Node, headMessage?: DiagnosticMessage, containingMessageChain?: DiagnosticMessageChain): boolean {\n            return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);\n        }"
  },
  {
    "id" : "c75ebd8a-c9d0-4168-ad2e-7bd013f71c21",
    "prId" : 5517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "219be292-a524-40af-93d2-8c20e5844b52",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Is this true of `isTypeAssignableTo` too? Its former usage in this diff indicates 'yes'.\n",
        "createdAt" : "2015-11-04T16:42:07Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "556f83bd-b740-4fec-be8f-862fc50e3b47",
        "parentId" : "219be292-a524-40af-93d2-8c20e5844b52",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "It is true of `isTypeAssignableTo` but `isTypeAssignableTo` has a clear direction; on the other hand, `isTypeComparableTo` is vague enough that it warrants a comment. One would think that `A` being comparable to `B` implies that `B` is comarable to `A`, but that's not quite the case.\n\nI _could_ have made `isTypeComparableTo` a bidirectional relation, but I decided not to based on the way in which we use the relation in type assertions. Specifically, with type assertions, we check whether the expression type is comparable to the asserted type and that the asserted type is comparable to the _widened_ type of the expression.\n\nActually, I'm not sure if there is any reason we don't check against the widened type for both. I'll experiment with it.\n",
        "createdAt" : "2015-11-04T20:32:51Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "7d34239c-264c-4027-a9ae-f2cf1cfea3ad",
        "parentId" : "219be292-a524-40af-93d2-8c20e5844b52",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "As discussed offline, I think that's a bug. I will change that in a later PR\n",
        "createdAt" : "2015-11-04T21:38:24Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cc64cbd296dfde5444279d2d5c37df58f709183",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +5399,5403 @@\n        /**\n         * This is *not* a bi-directional relationship.\n         * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.\n         */"
  },
  {
    "id" : "021c606a-df77-48f1-ac3d-f7a42e933fcd",
    "prId" : 5517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7a31fa92-74ad-442d-83ca-1b3e6d0c0d41",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "All uses _do_ need to check both directions, so probably you should have a version that does that. You might not even need the uni-directional ones except for consistency with the other relations.\n",
        "createdAt" : "2015-11-04T16:44:04Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      },
      {
        "id" : "a631ef67-9e79-4be5-9985-410eb633e3bd",
        "parentId" : "7a31fa92-74ad-442d-83ca-1b3e6d0c0d41",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "See [this comment](https://github.com/Microsoft/TypeScript/pull/5517#discussion_r43935354)\n",
        "createdAt" : "2015-11-04T20:33:06Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cc64cbd296dfde5444279d2d5c37df58f709183",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +5400,5404 @@        /**\n         * This is *not* a bi-directional relationship.\n         * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.\n         */\n        function isTypeComparableTo(source: Type, target: Type): boolean {"
  },
  {
    "id" : "01f0a9ae-eac2-48a9-a807-2aa29504a922",
    "prId" : 5517,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6bdef111-3dc6-4fd2-a7da-8db065230926",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "Please choose one cast syntax and make at least the changed lines use it, preferably something like all the casts in the function.\n",
        "createdAt" : "2015-11-04T16:49:16Z",
        "updatedAt" : "2016-03-30T08:03:41Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "3cc64cbd296dfde5444279d2d5c37df58f709183",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5695,5699 @@                if (source.flags & TypeFlags.Union) {\n                    if (relation === comparableRelation) {\n                        result = someTypeRelatedToType(source as UnionType, target, reportErrors);\n                    }\n                    else {"
  },
  {
    "id" : "158a3124-5e2a-42dd-bfec-299c82332011",
    "prId" : 5442,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d19f5a8a-2824-46f2-8a5a-2ad0877c99d8",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "You should just check `isFunctionLike`\n",
        "createdAt" : "2015-11-11T20:13:27Z",
        "updatedAt" : "2015-11-11T20:13:27Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "2e69e4e9-2ae8-497f-9c4b-264e017dabbe",
        "parentId" : "d19f5a8a-2824-46f2-8a5a-2ad0877c99d8",
        "authorId" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "body" : "`isFunctionLike` also returns affirmatively for `FunctionExpression`, `ArrowFunction`, `CallSignature`, `ConstructSignature`, `IndexSignature`, `FunctionType`, and `ConstructorType` - the difference visibly changes our behavior (as in: tests fail). I think these kinds are moreso to find \"top-level\" declarations where logic outside of it is unlikely to affect the type within the declaration.\n",
        "createdAt" : "2015-11-11T20:39:25Z",
        "updatedAt" : "2015-11-11T20:39:25Z",
        "lastEditedBy" : "f7813195-22a2-4200-9f53-7aadb83a2cc9",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f184866af2902ab7c4ccc94256472375d32e719",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +6323,6327 @@                            case SyntaxKind.GetAccessor:\n                            case SyntaxKind.SetAccessor:\n                            case SyntaxKind.Constructor:\n                                // Stop at the first containing function or module declaration\n                                break loop;"
  },
  {
    "id" : "920450f1-4661-4d1b-95a8-e2ce5b7f5524",
    "prId" : 5429,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80508485-6775-4523-b255-6e118af30c3e",
        "parentId" : null,
        "authorId" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "body" : "I'm still trying to learn how the checker works, so this change is unsettling to me. Are there two almost-equivalent ways of getting the same information? \n\nWhy can't there be just one that always does the right thing, or at least has a default that works for almost all cases?\n",
        "createdAt" : "2015-10-28T15:32:20Z",
        "updatedAt" : "2015-10-28T20:48:47Z",
        "lastEditedBy" : "2b0d3f17-3eae-4173-ad8a-73c9440bf608",
        "tags" : [
        ]
      }
    ],
    "commit" : "fdac86fab991fe4ca351e3686f2869423f88bb9f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11640,11644 @@            }\n\n            let promiseConstructor = getNodeLinks(node.type).resolvedSymbol;\n            if (!promiseConstructor || !symbolIsValue(promiseConstructor)) {\n                let typeName = promiseConstructor"
  },
  {
    "id" : "51df1dde-e4c2-4592-a84b-c0cac7fb5db0",
    "prId" : 5390,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f83cee78-d13f-446d-913a-ea4a2c848952",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Even though it's not part of the spec, can you amend the grammar in the comment to reflect the change, and then add a `// TODO: The spec needs to be amended to reflect this grammar.` below the grammar?\n",
        "createdAt" : "2015-10-25T01:03:29Z",
        "updatedAt" : "2015-10-25T02:26:11Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "1d6f5c6781509715430eac337067273e5cae90c0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +15920,15924 @@            // TODO: The spec needs to be amended to reflect this grammar.\n            if (node.kind === SyntaxKind.InterfaceDeclaration ||\n                node.kind === SyntaxKind.TypeAliasDeclaration ||\n                node.kind === SyntaxKind.ImportDeclaration ||\n                node.kind === SyntaxKind.ImportEqualsDeclaration ||"
  },
  {
    "id" : "3f720323-717e-49fc-ae57-4a92302482e6",
    "prId" : 5185,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "parentId" : null,
        "authorId" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "body" : "Not that I want to sound negative but for every string literal, this gets called. \n\nIt's a huge slowdown.\n",
        "createdAt" : "2015-10-08T23:14:50Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "tags" : [
        ]
      },
      {
        "id" : "bb2784ed-2d23-4566-951e-3948af919a85",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "What kind of numbers are you seeing (and on what codebase)?\n",
        "createdAt" : "2015-10-09T03:43:56Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "9208c570-e350-4a24-92a8-ca7891d550e5",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "3ae23f38-5f1a-4286-b485-a4c470edce21",
        "body" : "> If you consider that every string has on average 5 bytes, you're making 1-5 integer checks for every comparison:\n\nI think the VM already optimize for this?\nhttp://jsperf.com/string-vs-int-comparison-1\n",
        "createdAt" : "2015-10-09T15:29:10Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "3ae23f38-5f1a-4286-b485-a4c470edce21",
        "tags" : [
        ]
      },
      {
        "id" : "78d3709d-9173-44a4-a990-0c0a5ae76fae",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "It's useless to speculate about what's fast and what's not. Measure it.\n",
        "createdAt" : "2015-10-09T16:17:24Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "2cfcc570-7ae9-4b89-aa58-6c02ef8ae6bb",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "body" : "Meh. Measure it in 1 version of Chrome, it changes in the next. You measure it, I've said what I had to say.\n",
        "createdAt" : "2015-10-09T16:27:28Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "5337ef4d-94c8-4e5c-879e-f0cdd297fcaa",
        "tags" : [
        ]
      },
      {
        "id" : "9e6d46fd-84bb-4ca3-82b3-70a3927629d0",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "3ae23f38-5f1a-4286-b485-a4c470edce21",
        "body" : "@jbondc :+1: for the benchmark test.\n",
        "createdAt" : "2015-10-12T15:47:14Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "3ae23f38-5f1a-4286-b485-a4c470edce21",
        "tags" : [
        ]
      },
      {
        "id" : "c548d652-899f-4cab-a124-9ccfa68b8892",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I don't think the original issue was so terrible. You only ran into this case when you were contextually typed by a type with a string literal constituent to begin with. In practice, this is not frequently encountered.\n\nHowever, @jbondc, I think you'll like the the current implementation a lot better. We now only create a string literal type if the constituent types have a string literal type, not just if their content is equal.\n\nFurthermore, the types are cached in a map of strings to string literal types. Whenever testing the assignability of two string literal types, reference equality kicks in (which is fast).\n\nAdditionally, error messages are slightly better because you have a specific literal type to report (i.e. `Type '\"Foo\"' is not assignable to '\"Bar\"'.` instead of `Type 'string' is not assignable to '\"Bar\"'.`).\n",
        "createdAt" : "2015-10-20T20:11:29Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "23aac9b6-2511-4df7-afaf-218753a87b9a",
        "parentId" : "c72b8266-cc21-4c9d-bc13-85647768e2cf",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "@jbondc at worst that's probably much faster than trying to resolve the 100 different overloads. Though, I'm going to try to avoid speculating. I wasn't seeing a real perf hit in our benchmarks even with the initial change.\n",
        "createdAt" : "2015-10-20T22:19:22Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea4e21d96914783c66563850eda52e0aafb7fb9b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +10541,10545 @@                case SyntaxKind.StringLiteral:\n                    return checkStringLiteralExpression(<StringLiteral>node);\n                case SyntaxKind.NoSubstitutionTemplateLiteral:\n                    return stringType;\n                case SyntaxKind.RegularExpressionLiteral:"
  },
  {
    "id" : "6d45e0f0-90a3-49a1-acb1-4590f478db8e",
    "prId" : 5185,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9dd319d8-2a56-4999-8a35-df212b83e152",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah... that was why I named it Worker...\n",
        "createdAt" : "2015-10-13T06:16:55Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "45d63d47-3aa2-449b-a81c-931b884a8593",
        "parentId" : "9dd319d8-2a56-4999-8a35-df212b83e152",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Ah, that makes sense, though it feels strange to get the actual contextual type when its name is worker. If you think it'd be better to rename it back to worker, I can do that.\n\nI also suspect that we could shave off some time by using this function (instead of `getApparentTypeOfContextualType`) for array literals as well. I'll probably do it as part of another change.\n",
        "createdAt" : "2015-10-15T20:09:21Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "460d5076-d0b5-474d-be57-dbf3583fd175",
        "parentId" : "9dd319d8-2a56-4999-8a35-df212b83e152",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "The idea (however it is achieved) is to make the apparent type the default behavior when you don't specify anything. Getting the contextual type without its apparent type is quite an odd thing to do, so I prefer that to be the marked form. You can also call them getContextualType and getContextualTypeWithoutApparentType.\n",
        "createdAt" : "2015-10-16T03:31:01Z",
        "updatedAt" : "2015-11-09T21:27:23Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ea4e21d96914783c66563850eda52e0aafb7fb9b",
    "line" : 107,
    "diffHunk" : "@@ -1,1 +7113,7117 @@\n        /**\n         * Woah! Do you really want to use this function?\n         *\n         * Unless you're trying to get the *non-apparent* type for a value-literal type,"
  },
  {
    "id" : "b89a904e-491d-4ce1-89e5-daaadb751645",
    "prId" : 5108,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5aff173-ebb1-4758-9911-be0778c78301",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "if you can add a comment here, it would be great.\n",
        "createdAt" : "2015-12-08T20:07:07Z",
        "updatedAt" : "2015-12-08T21:29:33Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3e4befc3efac6ba80c4fa5d2d918a123635edc4",
    "line" : null,
    "diffHunk" : "@@ -1,1 +15028,15032 @@            // if module has export assignment then 'resolveExternalModuleSymbol' will return resolved symbol for export assignment\n            // otherwise it will return moduleSymbol itself\n            moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);\n\n            const symbolLinks = getSymbolLinks(moduleSymbol);"
  },
  {
    "id" : "77d11d54-f546-460f-be25-767415c54d41",
    "prId" : 5092,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74b95bc3-3267-445d-9788-1c5c4fd5b7bb",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "@RyanCavanaugh what happened with the idea that if the RHS type isn't a subtype of any types in the union, that we just discard the LHS type and take the RHS type? Is that something that we eventually went with?\n",
        "createdAt" : "2015-10-03T18:38:22Z",
        "updatedAt" : "2015-10-06T11:02:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "daf3aa75-2d58-4b02-85c3-6253d11b54b3",
        "parentId" : "74b95bc3-3267-445d-9788-1c5c4fd5b7bb",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I don't remember what we decided on that.\n",
        "createdAt" : "2015-10-05T18:12:25Z",
        "updatedAt" : "2015-10-06T11:02:52Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd54b7a36f15da93748282eab3298071943f2969",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +6400,6404 @@                    if (!assumeTrue) {\n                        if (type.flags & TypeFlags.Union) {\n                            return getUnionType(filter((<UnionType>type).types, t => !isTypeSubtypeOf(t, targetType)));\n                        }\n                        return type;"
  },
  {
    "id" : "b4bf3076-5424-4830-a41b-2b133fcd7a1c",
    "prId" : 4946,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f58064b-8670-4a41-beec-b8a9bfb2a4ee",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "nit: since u only use this variable here, just do `autoValue === undefined`\n",
        "createdAt" : "2015-09-24T22:56:53Z",
        "updatedAt" : "2015-09-24T22:56:53Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "f5ee0c56-62e8-4a1a-8c42-6daf3586d6a8",
        "parentId" : "1f58064b-8670-4a41-beec-b8a9bfb2a4ee",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd prefer to have the constant since it makes it clearer\n",
        "createdAt" : "2015-09-24T22:58:36Z",
        "updatedAt" : "2015-09-24T22:58:36Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa3d9f3997db907bf3cce66674bfe5ad1a0d4de0",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +12964,12968 @@                        autoValue = undefined;\n                    }\n                    else if (previousEnumMemberIsNonConstant) {\n                        // If the member declaration specifies no value, the member is considered a constant enum member. \n                        // If the member is the first member in the enum declaration, it is assigned the value zero. "
  },
  {
    "id" : "afbc2919-67d0-4604-b722-a39e44409c38",
    "prId" : 4946,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc9b0688-ba9b-48de-8beb-d2fa0603b311",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "comment :+1: \n",
        "createdAt" : "2015-09-24T22:57:02Z",
        "updatedAt" : "2015-09-24T22:57:02Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fa3d9f3997db907bf3cce66674bfe5ad1a0d4de0",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +12941,12945 @@                let enumSymbol = getSymbolOfNode(node);\n                let enumType = getDeclaredTypeOfSymbol(enumSymbol);\n                let autoValue = 0; // set to undefined when enum member is non-constant\n                let ambient = isInAmbientContext(node);\n                let enumIsConst = isConst(node);"
  },
  {
    "id" : "06f4d10f-155b-4ad8-94f9-fa1d9a9a60af",
    "prId" : 4910,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9d745c99-f22b-4262-8424-24e8a47e02a2",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "How does this handle the case where an interface `extends` a `class` that uses `this` ?\n",
        "createdAt" : "2015-09-22T19:28:04Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "fe2de884-54ac-4f23-8883-bd3bd6216100",
        "parentId" : "9d745c99-f22b-4262-8424-24e8a47e02a2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "If one of the base types is a class (i.e. not an interface) we simply return true (because every class has a `this` type). We only return false from this function if the interface itself doesn't reference this, if every base type is an interface, and if no base interface has a `this` type.\n",
        "createdAt" : "2015-09-22T19:35:20Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "82c010e12ae9f8780f2c37f5ed87c6cf209699a4",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +2909,2913 @@                            if (isSupportedExpressionWithTypeArguments(node)) {\n                                let baseSymbol = resolveEntityName(node.expression, SymbolFlags.Type, /*ignoreErrors*/ true);\n                                if (!baseSymbol || !(baseSymbol.flags & SymbolFlags.Interface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {\n                                    return false;\n                                }"
  },
  {
    "id" : "fda0374f-7712-4d63-a9bb-3e469c40e22c",
    "prId" : 4910,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eee06aef-6f79-46aa-b981-d31f434ee33f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Is `type` the `this` type? If so can you document it?\n",
        "createdAt" : "2015-09-23T20:37:18Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "dc6322bd-e080-4df7-915a-7feab7ca1ea0",
        "parentId" : "eee06aef-6f79-46aa-b981-d31f434ee33f",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Actually, would it be possible to just make it independent of the type argument list?\n",
        "createdAt" : "2015-09-23T20:39:40Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "cfa047cd-19c2-4ce6-bba8-23fb444d01fc",
        "parentId" : "eee06aef-6f79-46aa-b981-d31f434ee33f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I assume you mean is `type` the type argument for the `this` type parameter? If so, yes. We don't want to keep it separate from the type argument list because we cache instantiations based on their type arguments.\n",
        "createdAt" : "2015-09-23T20:46:28Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a795d20b-a7bd-4f3f-bf06-69995869974c",
        "parentId" : "eee06aef-6f79-46aa-b981-d31f434ee33f",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Have the similar question, what is the `type`?\n",
        "createdAt" : "2015-09-23T22:11:21Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "6b609566-98ca-4930-8998-0932768411f7",
        "parentId" : "eee06aef-6f79-46aa-b981-d31f434ee33f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "`type` is the type reference this function is resolving. Unless a type reference explicitly includes a type argument for `this` (which will appear as an extra type argument beyond what the type parameter list calls for), the type reference _itself_ is added as a type argument for `this`. [See comment here for an explanation](https://github.com/Microsoft/TypeScript/pull/4910/files#diff-4b8bd1eea29904f1be39cd864e1a45c0R1862).\n",
        "createdAt" : "2015-09-23T23:03:17Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "82c010e12ae9f8780f2c37f5ed87c6cf209699a4",
    "line" : 341,
    "diffHunk" : "@@ -1,1 +3199,3203 @@            let typeParameters = concatenate(source.typeParameters, [source.thisType]);\n            let typeArguments = type.typeArguments && type.typeArguments.length === typeParameters.length ?\n                type.typeArguments : concatenate(type.typeArguments, [type]);\n            resolveObjectTypeMembers(type, source, typeParameters, typeArguments);\n        }"
  },
  {
    "id" : "0e4adcda-cb1e-4b6d-b5b3-696afe3ff62a",
    "prId" : 4910,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3379a88-299b-4047-ba58-ed520bcad234",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "nit: use jsdoc. I know we are not really consistent around comment format but it is very helpful to get jsdoc in the language service\n",
        "createdAt" : "2015-09-23T22:14:41Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "82c010e12ae9f8780f2c37f5ed87c6cf209699a4",
    "line" : 108,
    "diffHunk" : "@@ -1,1 +2895,2899 @@        }\n\n        // Returns true if the interface given by the symbol is free of \"this\" references. Specifically, the result is\n        // true if the interface itself contains no references to \"this\" in its body, if all base types are interfaces,\n        // and if none of the base interfaces have a \"this\" type."
  },
  {
    "id" : "755682dc-be0b-4f3d-afec-edab41bacfd4",
    "prId" : 4910,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd43dce5-370e-4ea8-a231-c8798e2bda6e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why did this guard become necessary?\n",
        "createdAt" : "2015-09-23T22:23:11Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "2cb0e520-fc7c-455c-ba5e-4f3c4ab40a3a",
        "parentId" : "cd43dce5-370e-4ea8-a231-c8798e2bda6e",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Because a type argument list may now be empty (i.e. undefined) in a type reference. There's a [comment](https://github.com/Microsoft/TypeScript/pull/4910/files#diff-4b8bd1eea29904f1be39cd864e1a45c0R1862) on the `TypeReference` interface in types.ts that explains how it works.\n",
        "createdAt" : "2015-09-23T22:57:16Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "82c010e12ae9f8780f2c37f5ed87c6cf209699a4",
    "line" : 393,
    "diffHunk" : "@@ -1,1 +3899,3903 @@\n        function getTypeListId(types: Type[]) {\n            if (types) {\n                switch (types.length) {\n                    case 1:"
  },
  {
    "id" : "9f2cd444-ad68-491c-a40d-94526f2db7a8",
    "prId" : 4910,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2f12317a-8a3b-4e07-bdbe-f485526105c7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Was this something we just weren't accounting for?\n",
        "createdAt" : "2015-09-28T20:14:36Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "69870082-dee2-4124-9faf-b4ecc989237e",
        "parentId" : "2f12317a-8a3b-4e07-bdbe-f485526105c7",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, we were only showing the number of symbols created by the binder and not including the transient symbols created by the checker.\n",
        "createdAt" : "2015-09-28T20:18:03Z",
        "updatedAt" : "2015-09-29T22:26:40Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "82c010e12ae9f8780f2c37f5ed87c6cf209699a4",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +39,43 @@\n        let typeCount = 0;\n        let symbolCount = 0;\n\n        let emptyArray: any[] = [];"
  },
  {
    "id" : "1de0f26c-81ad-434e-b735-e17a820e8adb",
    "prId" : 4537,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af6ed523-50c1-4148-8dc8-5e944f355c3f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Perhaps `isExpectedProperty` would better describe this.\n",
        "createdAt" : "2015-08-28T23:42:51Z",
        "updatedAt" : "2015-08-29T00:39:56Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "603eb86302f5dd9336fb9907c46d513635e210c3",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +4744,4748 @@            // index signatures, or if the property is actually declared in the object type. In a union or intersection\n            // type, a property is considered known if it is known in any constituent type.\n            function isKnownProperty(type: Type, name: string): boolean {\n                if (type.flags & TypeFlags.ObjectType) {\n                    const resolved = resolveStructuredTypeMembers(type);"
  },
  {
    "id" : "10b155b8-1a5c-40bf-a884-41517ff1ac53",
    "prId" : 4205,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03a1d84b-eb81-4233-9695-5681e9a5771b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I think you could just make this `=`\n",
        "createdAt" : "2015-08-07T22:44:43Z",
        "updatedAt" : "2015-08-07T22:44:43Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "410e4e4df7b5698312e323a63477c429cf4919d6",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +5108,5112 @@                    let targetSig = targetSignatures[0];\n\n                    result &= abstractSignatureRelatedTo(source, sourceSig, target, targetSig);\n                    if (result !== Ternary.True) {\n                        return result;"
  },
  {
    "id" : "e92ef606-af61-4354-9bf9-7ce5f8a99f70",
    "prId" : 4205,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f870c4c-13ce-46f1-8042-ecf88bb27a4b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you distribute the `!` so that its the following?\n\n``` TypeScript\nif (sourceIsAbstract && (!targetIsAbstract || !targetDecl)) {\n```\n",
        "createdAt" : "2015-08-07T22:48:38Z",
        "updatedAt" : "2015-08-07T22:48:38Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "410e4e4df7b5698312e323a63477c429cf4919d6",
    "line" : 87,
    "diffHunk" : "@@ -1,1 +5158,5162 @@                        let targetIsAbstract = targetReturnDecl && targetReturnDecl.flags & NodeFlags.Abstract;\n\n                        if (sourceIsAbstract && !(targetIsAbstract && targetDecl)) {\n                            // if target isn't a class-declaration type, then it can be new'd, so we forbid the assignment.\n                            if (reportErrors) {"
  },
  {
    "id" : "ea2821a7-6bef-4c3b-8bc7-7ee660e55622",
    "prId" : 4205,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf462a37-77d1-48af-8936-521bf3c21c9a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Consider wrapping the `&` in parentheses\n",
        "createdAt" : "2015-08-07T22:49:40Z",
        "updatedAt" : "2015-08-07T22:49:57Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "410e4e4df7b5698312e323a63477c429cf4919d6",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +5156,5160 @@                        let targetReturnDecl = targetReturnType && targetReturnType.symbol && getDeclarationOfKind(targetReturnType.symbol, SyntaxKind.ClassDeclaration);\n                        let sourceIsAbstract = sourceReturnDecl && sourceReturnDecl.flags & NodeFlags.Abstract;\n                        let targetIsAbstract = targetReturnDecl && targetReturnDecl.flags & NodeFlags.Abstract;\n\n                        if (sourceIsAbstract && !(targetIsAbstract && targetDecl)) {"
  },
  {
    "id" : "a070ce1f-6dd7-41af-bf2f-aa01318bed84",
    "prId" : 4200,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dbf37ab3-0947-414f-b1c5-8b6276781fc9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems like the signatures could be in a funky order now in the resulting overload set. Do you think the order should still be based on the first constituent?\n",
        "createdAt" : "2015-08-07T00:42:45Z",
        "updatedAt" : "2015-08-07T15:06:36Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "53eaeccc-cd96-4af1-a7b7-481bdb201b0a",
        "parentId" : "dbf37ab3-0947-414f-b1c5-8b6276781fc9",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The \"canonical\" ordering is order of constituent types followed by order of signature declarations. For an intersection type, that is the exact list you get. For union types, we reduce that list to contain only signatures that have matches, _in the order of the source of the match_. In other words, the signatures appear in the positions they were declared and we never move a signature to a position of one of its partial matches. I think this is a reasonable way to do it. Anything having to do with reordering of partially matched signatures is going to be rather speculative anyway.\n",
        "createdAt" : "2015-08-07T13:47:41Z",
        "updatedAt" : "2015-08-07T15:06:36Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "2bb655c8-7a1d-42d9-b9b3-0daaa75a0983",
        "parentId" : "dbf37ab3-0947-414f-b1c5-8b6276781fc9",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, and I think the most important thing is that the order is deterministic, which it is. I think you're right, this order is not bad.\n",
        "createdAt" : "2015-08-07T21:37:54Z",
        "updatedAt" : "2015-08-07T21:37:54Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ed089e27-9633-4ad7-9db7-d03f20cb72b7",
        "parentId" : "dbf37ab3-0947-414f-b1c5-8b6276781fc9",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "And as you say, the parallel with intersection types is nice.\n",
        "createdAt" : "2015-08-07T21:38:16Z",
        "updatedAt" : "2015-08-07T21:38:16Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a53a38fb08c8ab1be1994fbc1dbb9e249a4cc09",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +3179,3183 @@                    // Only process signatures with parameter lists that aren't already in the result list\n                    if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ true)) {\n                        let unionSignatures = findMatchingSignatures(signatureLists, signature, i);\n                        if (unionSignatures) {\n                            let s = signature;"
  },
  {
    "id" : "35eaba43-076b-46cf-a040-431c15bd2a60",
    "prId" : 4200,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "591a6ab6-6fa4-42fb-813d-cb3ef12e1618",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'd consider making partialMatch true here since you want to be as lax as possible for contextual signatures.\n",
        "createdAt" : "2015-08-07T01:09:06Z",
        "updatedAt" : "2015-08-07T15:06:36Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "73c1176b-07b0-4e44-9206-9ba16ae8bd6d",
        "parentId" : "591a6ab6-6fa4-42fb-813d-cb3ef12e1618",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Possibly, but it is a bit different here in that were trying to find the most informative signature, not the least common denominator. For example:\n\n``` typescript\nvar f: ((x: string) => void) | (() => void) = x => { ... };\n```\n\nHere you'd really like the contextual signature to be `(x: string) => void` so `x` can be contextually typed. But then it get complicated in situations like this:\n\n``` typescript\nvar f: ((x: string) => void) | ((x: number) => void) | () => void) = x => { ... };\n```\n\nHere we'd have to go with `() => void` and no contextual type for `x`.\n\nAnyway, not clear that there is a simple solution so I'm leaving the existing rule in place.\n",
        "createdAt" : "2015-08-07T14:01:28Z",
        "updatedAt" : "2015-08-07T15:06:36Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "3b8b1c87-ea24-45ee-a36b-f9426e6bd173",
        "parentId" : "591a6ab6-6fa4-42fb-813d-cb3ef12e1618",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It seems like in both of those examples, you'd get no contextual signature, whether or not you accept partial matches. But something like the following would give you a contextual signature _only_ if you accept partial matches:\n\n``` ts\ntype RequiredCallable = (s: string) => string;\ntype OptionalCallable = (s?: string) => string;\nvar func: RequiredCallable | OptionalCallable = x => x.charAt(0); // x is string only if partialMatches is true\n```\n\nIt's a pretty silly example, but my point is that partialMatches will only make it more likely that a contextual signature will emerge at all.\n",
        "createdAt" : "2015-08-07T21:48:15Z",
        "updatedAt" : "2015-08-07T21:48:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "1a53a38fb08c8ab1be1994fbc1dbb9e249a4cc09",
    "line" : 166,
    "diffHunk" : "@@ -1,1 +6951,6955 @@                        signatureList = [signature];\n                    }\n                    else if (!compareSignatures(signatureList[0], signature, /*partialMatch*/ false, /*ignoreReturnTypes*/ true, compareTypes)) {\n                        // Signatures aren't identical, do not use\n                        return undefined;"
  },
  {
    "id" : "567214e3-89de-493a-8737-bfe1b87b39f5",
    "prId" : 4165,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2b53257-01f7-4d9b-876d-51153f06c348",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Curious, why did you move this assignability check to the bottom?\n",
        "createdAt" : "2015-08-05T20:05:35Z",
        "updatedAt" : "2015-08-05T20:30:53Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "748d7564a6806b610fe8cce07f7c91f5d4c1af3b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6217,6221 @@                }\n                \n                if (isTypeAssignableTo(narrowedTypeCandidate, originalType)) {\n                    // Narrow to the target type if it's assignable to the current type\n                    return narrowedTypeCandidate;"
  },
  {
    "id" : "6e2b854b-fdaa-4386-bb43-7bcfa435ea9f",
    "prId" : 4074,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9386a947-9e25-49cd-a1f8-f3f54bc58f0d",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Use `isTypeAny`\n",
        "createdAt" : "2015-07-29T18:34:28Z",
        "updatedAt" : "2015-07-30T17:01:47Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "ef498f98-eb01-4141-a06c-fbddd92de889",
        "parentId" : "9386a947-9e25-49cd-a1f8-f3f54bc58f0d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "That would just add function call and a redundant null check.\n",
        "createdAt" : "2015-07-29T20:37:40Z",
        "updatedAt" : "2015-07-30T17:01:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d39fd95d2b8ef2753dce80f27edc83f4f64f008",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +5252,5256 @@                }\n                let targetType = getIndexTypeOfType(target, IndexKind.String);\n                if (targetType && !(targetType.flags & TypeFlags.Any)) {\n                    let sourceType = getIndexTypeOfType(source, IndexKind.String);\n                    if (!sourceType) {"
  },
  {
    "id" : "22b8aacb-c5de-48da-b453-09c383c289f8",
    "prId" : 3942,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b3ef4b6-ba51-475f-ad50-2cdc8273317a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Under what situations does `getJsxElementInstanceType` return `undefined`?\n",
        "createdAt" : "2015-07-21T03:25:45Z",
        "updatedAt" : "2015-07-27T19:31:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "8d4ffcec-8b88-4b79-9276-a34ca0219500",
        "parentId" : "7b3ef4b6-ba51-475f-ad50-2cdc8273317a",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "When type of the specified element has no call or construct signatures\n",
        "createdAt" : "2015-07-21T18:37:32Z",
        "updatedAt" : "2015-07-27T19:31:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "13d21b4b-8709-40ac-95b5-1f2655a417dd",
        "parentId" : "7b3ef4b6-ba51-475f-ad50-2cdc8273317a",
        "authorId" : "c8f55754-d6a6-4147-a13c-1ee8df607107",
        "body" : "@RyanCavanaugh  just tried the solution we discussed in #3960 and it fails to:\n\n``` ts\nimport * as React from 'react';\n\nclass C extends React.Component<any, any> {\n    render() {\n        return null\n    }\n}\n\ntype ReactCtor<P, S> = new() => React.Component<P, S> & { render(): React.ReactElement<P> };\nlet C1: ReactCtor<any, any> = C;\nlet a = <C1 />;\n```\n\nSo maybe the error is not because of call or construct signature?\n\nhttps://github.com/s-panferov/ts-jsx-issue\n",
        "createdAt" : "2015-07-22T06:35:10Z",
        "updatedAt" : "2015-07-27T19:31:59Z",
        "lastEditedBy" : "c8f55754-d6a6-4147-a13c-1ee8df607107",
        "tags" : [
        ]
      },
      {
        "id" : "ec6a8f94-d19d-41d5-9663-02739ba53007",
        "parentId" : "7b3ef4b6-ba51-475f-ad50-2cdc8273317a",
        "authorId" : "c8f55754-d6a6-4147-a13c-1ee8df607107",
        "body" : "@RyanCavanaugh  output from your branch:\n\n```\n‚ûú  ts-jsx-issue git:(master) ‚úó ../TypeScript/bin/tsc --target es6 --jsx react issue.tsx\nissue.tsx(17,10): error TS2601: The return type of a JSX element constructor must return an object type.\n```\n",
        "createdAt" : "2015-07-22T06:49:11Z",
        "updatedAt" : "2015-07-27T19:31:59Z",
        "lastEditedBy" : "c8f55754-d6a6-4147-a13c-1ee8df607107",
        "tags" : [
        ]
      },
      {
        "id" : "6896ee80-0828-4bcf-bb07-bc0285652933",
        "parentId" : "7b3ef4b6-ba51-475f-ad50-2cdc8273317a",
        "authorId" : "c8f55754-d6a6-4147-a13c-1ee8df607107",
        "body" : "@RyanCavanaugh  I found a working example\n\n``` ts\ninterface JsxClass<P, S> extends React.Component<P, S> {\n    render(): React.ReactElement<P>\n}\n\ninterface ReactCtor<P, S> {\n    new(props: P): JsxClass<P, S>;\n}\n\nlet C1: ReactCtor<any, any> = C;\nlet a = <C1 />;\n```\n",
        "createdAt" : "2015-07-22T06:52:51Z",
        "updatedAt" : "2015-07-27T19:31:59Z",
        "lastEditedBy" : "c8f55754-d6a6-4147-a13c-1ee8df607107",
        "tags" : [
        ]
      },
      {
        "id" : "efac2815-b347-458b-8fd2-e60bc354a9fd",
        "parentId" : "7b3ef4b6-ba51-475f-ad50-2cdc8273317a",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Hadn't tested with intersection types before. Updating.\n",
        "createdAt" : "2015-07-22T16:24:33Z",
        "updatedAt" : "2015-07-27T19:31:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "4e3751c07c1e7a89966c6efe962f6c790d11438f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7411,7415 @@\n                if (links.jsxFlags & JsxFlags.ClassElement) {\n                    let elemInstanceType = getJsxElementInstanceType(node);\n\n                    if (isTypeAny(elemInstanceType)) {"
  },
  {
    "id" : "7eee1db4-f1a4-4822-83bf-a27d1aac652d",
    "prId" : 3913,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1e3a1a0e-e8b5-45ac-92ab-e2b9da12e56b",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Let's add a comment above:\n\n``` TypeScript\n// Skip past any prologue directives to find the first statement\n// to ensure that it was a super call.\n```\n",
        "createdAt" : "2015-07-17T23:38:18Z",
        "updatedAt" : "2015-07-17T23:45:48Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "58cf926b2677a1c2f994beb5c42555210d1927e2",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +10275,10279 @@                        let statements = (<Block>node.body).statements;\n                        let superCallStatement: ExpressionStatement;\n                        for (let statement of statements) {\n                            if (statement.kind === SyntaxKind.ExpressionStatement && isSuperCallExpression((<ExpressionStatement>statement).expression)) {\n                                superCallStatement = <ExpressionStatement>statement;"
  },
  {
    "id" : "3e92644f-0442-4fe7-9b7d-6470276d8d09",
    "prId" : 3856,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bf1b6bb9-024b-4e4f-95d5-b965d1ae0937",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "You _might_ want `isTupleLikeType`\n",
        "createdAt" : "2015-07-14T20:15:41Z",
        "updatedAt" : "2015-07-14T20:44:46Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "61bf474e-8cdb-4853-8798-7edf6e4e3cfd",
        "parentId" : "bf1b6bb9-024b-4e4f-95d5-b965d1ae0937",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "No, that is for language policies. This is an implementation step.\n",
        "createdAt" : "2015-07-14T20:32:38Z",
        "updatedAt" : "2015-07-14T20:44:46Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6fc08ea3e62baee65235abcb23c7572b8c61140d",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +5342,5346 @@                    return createArrayType(getWidenedType((<TypeReference>type).typeArguments[0]));\n                }\n                if (isTupleType(type)) {\n                    return createTupleType(map(type.elementTypes, getWidenedType));\n                }"
  },
  {
    "id" : "9f3f4649-1829-4f9f-b9a8-3aa1b77bf8e3",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35558773-082f-4098-800f-74b49a31603c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why does an assignment expression give the regular type of the right as opposed to the original type? I thought the type that gets assigned to the left is the regular type, but the type of the expression should be the original right type.\n",
        "createdAt" : "2015-07-13T02:59:47Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "48683567-c52f-4464-a1ab-49dd027b4b85",
        "parentId" : "35558773-082f-4098-800f-74b49a31603c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I added this because of code similar to the following in tsserver:\n\n``` typescript\ninterface A { a: number }\ninterface B extends A { b: number }\nvar last: B;\nfunction foo(): A {\n    return last = { a: 1, b: 2 };\n}\n```\n\nOnce the object literal is successfully assigned to a variable it seems pedantic to insist that `b` is an unknown property. And, really, following an assignment, the object literal isn't \"fresh\" anymore.\n",
        "createdAt" : "2015-07-13T16:31:50Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "9461091a-786f-44cc-b74c-da6591bc38f6",
        "parentId" : "35558773-082f-4098-800f-74b49a31603c",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "My reasoning was that assigning it to `last` only renders the object \"not fresh\" if you refer to it via `last`. In this case, you are still returning the object literal, and it has excess properties with respect to `A`.\n\nMaybe we could rationalize it by saying that if we tried to assign it to `last` and it had excess properties relative to `last`, then we would have already given an error. But then again, this seems weird when you consider overload resolution.\n\nUsing the same A and B that you've defined:\n\n``` ts\ndeclare function foo(param: A): A;\ndeclare function foo(param: B): B;\nvar last: B;\n\nfoo({a: 1, b: 2 }); // returns B\nfoo(last = {a: 1, b: 2 }); // returns A\n```\n\nI don't think taking the regular type here makes sense.\n",
        "createdAt" : "2015-07-13T18:14:58Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "23ddc97e-408a-4966-b6f5-7dbe33ae235a",
        "parentId" : "35558773-082f-4098-800f-74b49a31603c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Hmm. Contextual typing only comes from the first assignment target, so we're currently consistent with that. I suppose you could argue we should check against a union of _all_ assignment targets, i.e. as long as each property is known in _some_ assignment target we're good. But that would add a bunch of complexity that I don't think is justified.\n",
        "createdAt" : "2015-07-13T18:29:13Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "33b1c3c4-83ab-4c04-8b7a-29eb5441dd50",
        "parentId" : "35558773-082f-4098-800f-74b49a31603c",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't think we would need to explicitly check against the union of all assignment targets. Each assignment target does an assignability check, and if a certain source type passes all the assignability checks, it's good. So the correct behavior should just fall out if we remove the call to getRegularTypeOfObjectLiteral, no?\n\nIt's true that contextual typing only comes from the first target, but I'm not sure why contextual typing is relevant. We chose to build this check into a mechanism other than contextual typing, so I don't see why we would consider contextual typing a factor here.\n",
        "createdAt" : "2015-07-13T18:42:50Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : 436,
    "diffHunk" : "@@ -1,1 +9792,9796 @@                case SyntaxKind.EqualsToken:\n                    checkAssignmentOperator(rightType);\n                    return getRegularTypeOfObjectLiteral(rightType);\n                case SyntaxKind.CommaToken:\n                    return rightType;"
  },
  {
    "id" : "9f833ee6-16c3-4756-b372-0f866bed2871",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12169a47-e230-4a8d-a0d1-8734c152584c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would just make this take a FreshObjectLiteralType\n",
        "createdAt" : "2015-07-13T03:04:53Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "dd08a429-8006-4d3c-a85d-d5431e34c973",
        "parentId" : "12169a47-e230-4a8d-a0d1-8734c152584c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, the point of the method is to remove \"freshness\" from the type regardless of the kind of type. I suppose we could call it `getRegularTypeOfType`.\n",
        "createdAt" : "2015-07-13T16:44:17Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "7a285725-a234-4f34-885d-f7040947e4e6",
        "parentId" : "12169a47-e230-4a8d-a0d1-8734c152584c",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Okay, that sounds fine\n",
        "createdAt" : "2015-07-13T18:03:38Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5402,5406 @@        }\n\n        function getRegularTypeOfObjectLiteral(type: Type): Type {\n            if (type.flags & TypeFlags.FreshObjectLiteral) {\n                let regularType = (<FreshObjectLiteralType>type).regularType;"
  },
  {
    "id" : "1d59264f-522b-4d05-bd2b-4b7de3c91748",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7e331572-7b6d-4ca9-ad21-e8a6aa3e055d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why is it necessary to do this?\n",
        "createdAt" : "2015-07-13T03:06:10Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d6456131-8526-4286-b833-7b56120dd0fb",
        "parentId" : "7e331572-7b6d-4ca9-ad21-e8a6aa3e055d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Because we otherwise will fail in cases like this:\n\n``` typescript\ninterface A { a: number }\ninterface B { b: number }\nvar x: A & B = { a: 1, b: 2 };\n```\n\nWe make the check upfront for the entire target type, but then as we descend into the structure of the target type we no longer want to make the check again (as it would now fail).\n",
        "createdAt" : "2015-07-13T16:41:04Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4609,4613 @@                    // make the check again (as it might fail for a partial target type). Therefore we obtain\n                    // the regular source type and proceed with that.\n                    source = getRegularTypeOfObjectLiteral(source);\n                }\n"
  },
  {
    "id" : "6fbb1c96-6ef5-4451-bba4-39867a210858",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "010e2313-c8b5-4917-a477-aa585a33ebad",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ah, so you do these checks on the target side as opposed to when contextually typing the object literal. Actually, this is probably a good thing, because not every assignability check is guaranteed to be accompanied by contextual typing. So if the object did not get contextually typed, the assignment would still be allowed, which is good I think.\n",
        "createdAt" : "2015-07-13T03:27:56Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ea97039a-d7ca-477f-96b1-77a3a50b16ff",
        "parentId" : "010e2313-c8b5-4917-a477-aa585a33ebad",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "But I would add some comments explaining the rationale behind these heuristics.\n",
        "createdAt" : "2015-07-13T03:28:12Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3387,3391 @@                return !!(resolved.properties.length === 0 ||\n                    resolved.stringIndexType ||\n                    resolved.numberIndexType ||\n                    getPropertyOfType(type, name));\n            }"
  },
  {
    "id" : "525b7b36-3a52-4d52-8a22-e73f9bd3e33a",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27faff79-6b85-4e41-b7fa-4716155100a9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I agree that this loop is doing the right thing for intersections. For unions, I would not say that a property is known if some constituent has it. Doesn't it seem more correct to demand that all union constituents have the property?\n\nActually, this does make sense. Really you're trying to figure out if you have heard of this property anywhere in the target. If you have, then it would not be considered excess in the source. So it's not that the target is _known_ to have this property, it's that this property was mentioned as a _potential_ property of the target. This also why optional property are \"known\" even though they might not actually be present on the target.\n",
        "createdAt" : "2015-07-13T03:34:08Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "84fdf06c-e515-467c-9e55-6e50371fc832",
        "parentId" : "27faff79-6b85-4e41-b7fa-4716155100a9",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Exactly.\n",
        "createdAt" : "2015-07-13T16:46:14Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +3392,3396 @@            if (type.flags & TypeFlags.UnionOrIntersection) {\n                for (let t of (<UnionOrIntersectionType>type).types) {\n                    if (isKnownProperty(t, name)) {\n                        return true;\n                    }"
  },
  {
    "id" : "fa4b2e7f-b137-4076-a0db-4084c35fcaac",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c073a98c-faaf-43e2-b174-d21274decb02",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Thanks. This makes sense now\n",
        "createdAt" : "2015-07-13T18:06:51Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : 348,
    "diffHunk" : "@@ -1,1 +4608,4612 @@                    // and intersection types are further deconstructed on the target side, we don't want to\n                    // make the check again (as it might fail for a partial target type). Therefore we obtain\n                    // the regular source type and proceed with that.\n                    source = getRegularTypeOfObjectLiteral(source);\n                }"
  },
  {
    "id" : "a3d1a99f-df0b-4954-b1f3-c8b02b28847b",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21afb93f-d292-4ab0-8387-cbc4f67fb8cb",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you leave a comment that `signature` should be a signature within `signatureLists[0]`?\n",
        "createdAt" : "2015-07-20T19:01:37Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +3075,3079 @@        }\n\n        function findMatchingSignatures(signature: Signature, signatureLists: Signature[][]): Signature[] {\n            let result: Signature[] = undefined;\n            for (let i = 1; i < signatureLists.length; i++) {"
  },
  {
    "id" : "3ef9beb2-5f40-45c5-b41e-39b7f0a60398",
    "prId" : 3823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "363b45c0-19a2-4c37-a366-61c0fe9d017d",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I actually like this, but you could also consider\n\n``` TypeScript\nif (result) {\n    result.push(signature);\n}\nelse {\n    result = [signature];\n}\n```\n",
        "createdAt" : "2015-07-20T19:05:33Z",
        "updatedAt" : "2015-07-21T18:20:38Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "5f7bc51a1064b6dd901ba12c749121d9da69082b",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +3111,3115 @@                        signature.unionSignatures = unionSignatures;\n                    }\n                    (result || (result = [])).push(signature);\n                }\n            }"
  },
  {
    "id" : "d02a022a-df33-4394-82c5-785e19f344d5",
    "prId" : 3787,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4cf0680a-8e69-407a-832f-2e90ea5d0e01",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "why you have to check `mightFixTypeParameters` again?\n",
        "createdAt" : "2015-07-10T20:44:16Z",
        "updatedAt" : "2015-07-17T21:52:30Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "115ed2ce-550c-488b-96bb-6c358470afb0",
        "parentId" : "4cf0680a-8e69-407a-832f-2e90ea5d0e01",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Good question. In this case, I noticed that we are passing the contextualMapper into getReturnTypeFromBody. That indicates to me that we may fix some type parameters if the return expression contains a function expression. So I am ensuring that anywhere that it's possible to fix type parameters, we go through that code path.\n",
        "createdAt" : "2015-07-10T21:35:59Z",
        "updatedAt" : "2015-07-17T21:52:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6df0f3d4aa5fe90aee4a6fe64b2a55d814083dba",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +9168,9172 @@                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);\n                        }\n                        if (mightFixTypeParameters || !node.type && !signature.resolvedReturnType) {\n                            let returnType = getReturnTypeFromBody(node, contextualMapper);\n                            if (!signature.resolvedReturnType) {"
  },
  {
    "id" : "df858724-dbcf-4a68-aa2b-99d3fbdf8f8e",
    "prId" : 3787,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7febd0dd-a27c-455e-8d55-c3f876c8403e",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Same- Why you have to check `mightFixTypeParameters` again?\n",
        "createdAt" : "2015-07-10T20:44:41Z",
        "updatedAt" : "2015-07-17T21:52:30Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "3772ee93-e0a9-4c75-8b31-8fa7446e2405",
        "parentId" : "7febd0dd-a27c-455e-8d55-c3f876c8403e",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Because if I didn't check it, and we already checked this function expression, we would not go through this code path. We need to go through the code path in order to fix type parameters.\n",
        "createdAt" : "2015-07-10T21:34:16Z",
        "updatedAt" : "2015-07-17T21:52:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6df0f3d4aa5fe90aee4a6fe64b2a55d814083dba",
    "line" : 135,
    "diffHunk" : "@@ -1,1 +9161,9165 @@                // already assigned contextual types.\n                let contextChecked = !!(links.flags & NodeCheckFlags.ContextChecked);\n                if (mightFixTypeParameters || !contextChecked) {\n                    links.flags |= NodeCheckFlags.ContextChecked;\n                    if (contextualSignature) {"
  },
  {
    "id" : "0cbc7fb0-a8ca-49e6-a615-0902ef80fd28",
    "prId" : 3643,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9c8b2c6e-1177-49c8-866d-fb36ba640082",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "what does line do?\n",
        "createdAt" : "2015-06-26T17:45:18Z",
        "updatedAt" : "2015-07-10T18:10:49Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "b1bfc9b2-dc17-45a2-b5bb-8d5dfdba75e3",
        "parentId" : "9c8b2c6e-1177-49c8-866d-fb36ba640082",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "which line ?\n",
        "createdAt" : "2015-06-26T19:42:39Z",
        "updatedAt" : "2015-07-10T18:10:49Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "b9664ea0-7d3b-45ea-87e1-e30fa20e9ed9",
        "parentId" : "9c8b2c6e-1177-49c8-866d-fb36ba640082",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "the logic  below, GitHub doesn't show it\n",
        "createdAt" : "2015-06-26T20:12:43Z",
        "updatedAt" : "2015-07-10T18:10:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "517f87f4-fe23-48a9-996e-9a74b7c276ab",
        "parentId" : "9c8b2c6e-1177-49c8-866d-fb36ba640082",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Thanks @JsonFreeman for explaining this. This is the logic so that if we didn't come from static member of class or interface, add the type parameters into the symbol table (type-parameters of class Declaration and interface are in member property of the symbol.\nNote: that the memberFlags come from previous iteration\n",
        "createdAt" : "2015-07-02T01:31:44Z",
        "updatedAt" : "2015-07-10T18:10:49Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "a11abf9a-da2b-4fcd-b2ba-20d41898f8e9",
        "parentId" : "9c8b2c6e-1177-49c8-866d-fb36ba640082",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Also note that for type aliases and signatures, the type parameters are in the locals, but for classes and interfaces, the type parameters are in the members.\n",
        "createdAt" : "2015-07-02T01:42:12Z",
        "updatedAt" : "2015-07-10T18:10:49Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "f16f9d129a4ffa17723930de208f563894a4ddb8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +13427,13431 @@                            // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.\n                            // Note: that the memberFlags come from previous iteration.\n                            if (!(memberFlags & NodeFlags.Static)) {\n                                copySymbols(getSymbolOfNode(location).members, meaning & SymbolFlags.Type);\n                            }"
  },
  {
    "id" : "4e119599-e1b7-469e-957a-2766c235ca3c",
    "prId" : 3636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "621c9d12-3a47-4ea2-b403-1037f2888cca",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This is getSymbolInfo.\n",
        "createdAt" : "2015-07-01T19:45:04Z",
        "updatedAt" : "2015-07-15T23:47:17Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca3c14f8a298d5726f43b7887a5bb581472faee5",
    "line" : 65,
    "diffHunk" : "@@ -1,1 +13677,13681 @@            if (isDeclarationName(node)) {\n                // This is a declaration, call getSymbolOfNode\n                return getSymbolOfNode(node.parent);\n            }\n"
  },
  {
    "id" : "35dc311d-054c-464d-b753-1b44d8f6ec0b",
    "prId" : 3636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "86f2e125-404c-4679-bcf2-aa06a9a88f83",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why do you need to check node.parent.parent at all?\n",
        "createdAt" : "2015-07-01T19:47:02Z",
        "updatedAt" : "2015-07-15T23:47:17Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca3c14f8a298d5726f43b7887a5bb581472faee5",
    "line" : 79,
    "diffHunk" : "@@ -1,1 +13687,13691 @@                }\n                else if (node.parent.kind === SyntaxKind.BindingElement &&\n                        node.parent.parent.kind === SyntaxKind.ObjectBindingPattern &&\n                        node === (<BindingElement>node.parent).propertyName) {\n                    let typeOfPattern = getTypeAtLocation(node.parent.parent);"
  },
  {
    "id" : "f2277ce2-076d-435e-a473-d22612f0252b",
    "prId" : 3636,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9137b00-0195-4364-966c-388daad79d9b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "For a parameter with a binding pattern with no default initializer and no type annotation, this will return undefined, as you've noticed in the next line. This is because getTypeAtLocation ultimately calls getTypeForVariableLikeDeclaration, which doesn't handle the parameter case. If you were instead to hit getWidenedTypeForVariableLikeDeclaration, you would get to the call to getTypeFromBindingPattern, which handles the parameter case.\n",
        "createdAt" : "2015-07-01T20:15:48Z",
        "updatedAt" : "2015-07-15T23:47:17Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "7b7df1ed-39fc-4484-8f2b-07fbe3e09df1",
        "parentId" : "b9137b00-0195-4364-966c-388daad79d9b",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I thought about this more. And I don't think you need to do anything special for this case. The reason why is that if the type is only derived by the properties the user is about to write, then there is nothing meaningful we could suggest. So I think we should not give a completion list if the parameter has no type and no initializer.\n",
        "createdAt" : "2015-07-16T21:40:55Z",
        "updatedAt" : "2015-07-16T21:40:55Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ca3c14f8a298d5726f43b7887a5bb581472faee5",
    "line" : 81,
    "diffHunk" : "@@ -1,1 +13689,13693 @@                        node.parent.parent.kind === SyntaxKind.ObjectBindingPattern &&\n                        node === (<BindingElement>node.parent).propertyName) {\n                    let typeOfPattern = getTypeAtLocation(node.parent.parent);\n                    let propertyDeclaration = typeOfPattern && getPropertyOfType(typeOfPattern, (<Identifier>node).text);\n"
  },
  {
    "id" : "2684fb9e-ec51-474d-ba92-14bd9ebf00d5",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88097d39-05bc-4690-a547-b8e57fcc1373",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "wrap this line.  it is too long for github.  I recommend the form:\n\n```\nreturn type.flags & TypeFlags.UnionOrIntersection\n    ? getPropertiesOfUnionOrIntersectionType(<UnionOrIntersectionType>type)\n    : getPropertiesOfObjectType(type);\n```\n\nThis also has the benefit of being able to easily see the difference in the branches.\n",
        "createdAt" : "2015-06-25T04:59:22Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "ec727bbc-a58a-4a07-b437-57f429a67514",
        "parentId" : "88097d39-05bc-4690-a547-b8e57fcc1373",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes\n",
        "createdAt" : "2015-06-30T18:56:48Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 190,
    "diffHunk" : "@@ -1,1 +3229,3233 @@        function getPropertiesOfType(type: Type): Symbol[] {\n            type = getApparentType(type);\n            return type.flags & TypeFlags.UnionOrIntersection ? getPropertiesOfUnionOrIntersectionType(<UnionType>type) : getPropertiesOfObjectType(type);\n        }\n"
  },
  {
    "id" : "378a9f4d-82f3-4f27-a8fe-95adcd394539",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "61074909-1572-49a9-89de-4fccc7c5796a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd really prefer this was split into\n\n``` TypeScript\nif (!type1) {\n    return type2;\n}\n\nif (!type2) {\n    return type1;\n}\n\nreturn getIntersectionType([type1, type2]);\n```\n\nBut if you're really set on keeping this as one statement, this might be easier on the eyes:\n\n``` TypeScript\nreturn (!type1 && type2)\n    || (!type2 && type1)\n    || getIntersectionType([type1, type2]);\n```\n",
        "createdAt" : "2015-06-25T04:59:25Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1c7b101a-7d9a-4aed-b9e9-b933989980cf",
        "parentId" : "61074909-1572-49a9-89de-4fccc7c5796a",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I actually find the way @ahejlsberg wrote it clearer than the `&&` style. But I'm also okay with the longhand you suggested.\n",
        "createdAt" : "2015-06-30T18:45:09Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "df089f76-8ff5-46a0-aa85-77d0d56287fc",
        "parentId" : "61074909-1572-49a9-89de-4fccc7c5796a",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I'm going to keep it the way it is, making it longer doesn't really make it any clearer.\n",
        "createdAt" : "2015-06-30T21:42:25Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 99,
    "diffHunk" : "@@ -1,1 +3104,3108 @@\n        function intersectTypes(type1: Type, type2: Type): Type {\n            return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);\n        }\n"
  },
  {
    "id" : "502508ab-b42b-48a8-9e64-a0dec5622123",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe315c16-1ba4-432d-ac5b-54b421cbab7a",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "nit: `property` instead of `prop`\n",
        "createdAt" : "2015-06-26T18:47:05Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +3215,3219 @@        function getPropertiesOfUnionOrIntersectionType(type: UnionOrIntersectionType): Symbol[] {\n            for (let current of type.types) {\n                for (let prop of getPropertiesOfType(current)) {\n                    getPropertyOfUnionOrIntersectionType(type, prop.name);\n                }"
  },
  {
    "id" : "e0895e02-5fc1-47b4-8d5f-21d337449685",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "63705558-9741-4010-84a5-7abc94fc66ec",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "So for intersection type, if the property is private or protected, the property will not be included?\n",
        "createdAt" : "2015-06-26T19:40:29Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "c8ca68d6-6f8c-4553-b5fe-caf59ef2b51d",
        "parentId" : "63705558-9741-4010-84a5-7abc94fc66ec",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Correct, as is the case for union types. When a private or protected property with a particular name occurs in only one constituent type, it is pretty clear that the property should be excluded. It is bit less clear what should happen in cases like the following:\n\n``` typescript\nclass C {\n    private x: { a: string };\n}\n\ninterface I {\n    x: { b: string };\n}\n\nvar obj: C & I;\n```\n\nCurrently `obj` appears to have no property `x`, but you could argue that it should have a property `x` of type `{ private a: string, b: string }` or something like that. \n",
        "createdAt" : "2015-06-27T03:15:42Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "29acbf4a-9fa8-421a-8048-f7f59eda2b21",
        "parentId" : "63705558-9741-4010-84a5-7abc94fc66ec",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think the old structure was easier to read, but doesn't matter much.\n",
        "createdAt" : "2015-06-30T20:11:16Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 212,
    "diffHunk" : "@@ -1,1 +3271,3275 @@                if (type !== unknownType) {\n                    let prop = getPropertyOfType(type, name);\n                    if (prop && !(getDeclarationFlagsFromSymbol(prop) & (NodeFlags.Private | NodeFlags.Protected))) {\n                        if (!props) {\n                            props = [prop];"
  },
  {
    "id" : "859c81ec-bcd5-4aba-a570-e8625b74bbb5",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think you need to ensure that a union type is parenthesized if it is a constituent of an intersection type. Just like how we do for an array element type that is a union or intersection.\n",
        "createdAt" : "2015-06-30T18:41:31Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "329da53a-295f-42fe-9c5d-48cb67362f44",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, we already do that.\n",
        "createdAt" : "2015-06-30T19:45:34Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "9d5b2d23-5447-467d-acfe-65942e4beb85",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Where?\n",
        "createdAt" : "2015-06-30T19:49:04Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b7a0c4c3-7850-4c69-ade4-ce0937c369e5",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Right here. If the delimiter is not comma, we pass the TypeFlags.InElementType flag which will cause parentheses to be added.\n",
        "createdAt" : "2015-06-30T19:51:33Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "76e4043c-927d-4c93-9b00-04efa8490a51",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh right. In that case, can you change the name InElementType to something else? That's what confused me. What this flag is actually trying to say is that the type list is itself a type.\n",
        "createdAt" : "2015-06-30T19:56:04Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "217e94a0-c581-4cec-94b8-4251a28ab7ad",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Maybe IsConstituentOrArrayElement\n",
        "createdAt" : "2015-06-30T20:03:15Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "4fa743a0-4f30-404a-bf24-82455dd39ea0",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Hmm, not sure that really makes it any better. Would prefer to keep it the way it is. All of this logic is due for a revision anyway after we separate out the declaration file generator.\n",
        "createdAt" : "2015-06-30T21:40:13Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "3ed07a96-e9fe-45ec-9207-88f1544a6475",
        "parentId" : "3d20ae58-32c0-4b9e-bd98-58ce675f6d00",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It's just that everywhere else we call it a constituent, and here we call it an element.\n",
        "createdAt" : "2015-06-30T21:47:08Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +1606,1610 @@                            writeSpace(writer);\n                        }\n                        writeType(types[i], delimiter === SyntaxKind.CommaToken ? TypeFormatFlags.None : TypeFormatFlags.InElementType);\n                    }\n                }"
  },
  {
    "id" : "c9913526-17ba-41f9-abef-7b721e0168cf",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd589030-5c17-458c-813d-7b86dfc8d2d2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "resolveUnionTypeMembers has dedicated functions getUnionSignatures and getUnionIndexType. Is there a reason resolveIntersectionTypeMembers has a different shape? I do not understand why this one has a loop, but resolveUnionTypeMembers delegates to other functions to do the loop. Can we make them the same?\n",
        "createdAt" : "2015-06-30T18:53:06Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "12df34bd-e64a-4bdd-ab6e-1e0d34188b87",
        "parentId" : "cd589030-5c17-458c-813d-7b86dfc8d2d2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Our rules for signatures in unions and signatures in intersections are quite different and there really isn't an opportunity for sharing. The logic for index types could potentially be made more similar, but not much would be gained and we already need the loop for signatures.\n",
        "createdAt" : "2015-06-30T19:49:33Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "29f90ef2-462b-4fe5-a273-c1289e4af84a",
        "parentId" : "cd589030-5c17-458c-813d-7b86dfc8d2d2",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah I looked again, and I think you're right.\n",
        "createdAt" : "2015-06-30T19:52:58Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 113,
    "diffHunk" : "@@ -1,1 +3118,3122 @@                constructSignatures = concatenate(constructSignatures, getSignaturesOfType(t, SignatureKind.Construct));\n                stringIndexType = intersectTypes(stringIndexType, getIndexTypeOfType(t, IndexKind.String));\n                numberIndexType = intersectTypes(numberIndexType, getIndexTypeOfType(t, IndexKind.Number));\n            }\n            setObjectTypeMembers(type, emptySymbols, callSignatures, constructSignatures, stringIndexType, numberIndexType);"
  },
  {
    "id" : "4c90e6df-b1f5-47be-a50d-7edc4a803e12",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "acee679a-8ab4-429a-9924-44d928ae52f9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Interesting way to keep the same loop body, but conditionalize whether you loop or just use the first element.\n",
        "createdAt" : "2015-06-30T18:56:30Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +3220,3224 @@                // The properties of a union type are those that are present in all constituent types, so\n                // we only need to check the properties of the first type\n                if (type.flags & TypeFlags.Union) {\n                    break;\n                }"
  },
  {
    "id" : "ad1f3a93-d677-4ba0-88e3-aded9bc9b5e7",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "096ba184-5b09-48df-ae07-22515bd21857",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think this argument applies for union types as well. Maybe we shouldn't do subtype reduction for union types either. Many people try to make recursive union types, and we give an error because a union type depends on its constituents. Can we consider abandoning subtype reduction?\n",
        "createdAt" : "2015-06-30T20:28:21Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "034ac4c8-1c86-4d90-a53a-8579f217c845",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Actually I misunderstood. Recursive union types do work, as long as the type alias reference is not in an area that is reachable when we process the type (for example in an object type). But that only works because we pass true for noSubtypeReduction in getTypeFromUnionTypeNode. In that case, the fact that we want recursive intersection types doesn't preclude us from supporting supertype reduction. It just means that getTypeFromIntersectionTypeNode cannot trigger supertype reduction. But presumably, getApparentType should trigger supertype reduction, no?\n",
        "createdAt" : "2015-06-30T20:55:53Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "f2a643eb-546e-4576-9a6f-062010ef2ac2",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, getApparentType should (and does) trigger subtype reduction. Even though subtype reduction should just be an optimization, it's effects are actually observable in a few cases. For example, expression operators don't apply to `number | number`, but do apply to the reduced type `number`. And call signatures are less restricted when a union type reduces to a single type. So, technically we should spec exactly when we perform subtype reduction.\n",
        "createdAt" : "2015-07-01T03:05:41Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "611f79ce-ca24-4743-be63-12172435a9a6",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, and subtype reduction makes the sorting of union constituents observable too (if you did not sort the constituents, union would not be commutative).\n\nBut I meant why doesn't getApparentType trigger supertype reduction in intersection types? Shouldn't it work like union types?\n",
        "createdAt" : "2015-07-01T17:02:41Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0e946f8e-e41c-40df-ad7e-13f04799aa6f",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We could consider that, but given a type A and a subtype B, the only observable difference between A & B and B would be when B is a primitive type (because expression operators would then come into effect), and use of intersection types with primtives isn't really a scenario. So, it would rarely if ever make a meaningful difference.\n",
        "createdAt" : "2015-07-02T03:04:06Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "0dabe327-f5d3-4681-95c0-f398d278887b",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So why do we do it for union types? Is it to cushion the loss of call/construct signatures?\n\nI was under the impression that subtype reduction is an optimization. If it's an optimization, why is it more important for union types than for intersection types?\n",
        "createdAt" : "2015-07-02T16:46:19Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ccb6e779-1a25-4e94-aa95-1812b26e19eb",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, the primary reason is the observable differences in call/construct signatures. For example, #2610. With intersection types you always get the combined set of signatures so there is no loss of information and supertype reduction wouldn't make an observable difference.\n",
        "createdAt" : "2015-07-03T17:37:26Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "30705a6c-6242-4677-9d85-ae6e28832e3a",
        "parentId" : "096ba184-5b09-48df-ae07-22515bd21857",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Okay, that is a meaningful difference. In my opinion it's kind of a shame that it's necessary, but I guess without solving the real problem of the signatures getting lost, this is a reasonable mitigation.\n",
        "createdAt" : "2015-07-06T18:01:26Z",
        "updatedAt" : "2015-07-06T18:01:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 422,
    "diffHunk" : "@@ -1,1 +4049,4053 @@        // We do not perform supertype reduction on intersection types. Intersection types are created only by the &\n        // type operator and we can't reduce those because we want to support recursive intersection types. For example,\n        // a type alias of the form \"type List<T> = T & { next: List<T> }\" cannot be reduced during its declaration.\n        // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution\n        // for intersections of types with signatures can be deterministic."
  },
  {
    "id" : "1aebf181-a7cb-416e-9612-f9b65ce5124b",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4da10462-d4a0-4e21-a5d4-0121028d74f1",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "getUnionType has\n\n``` ts\n             if (types.length === 0) {\n                 return emptyObjectType;\n             }\n```\n\nI think we should have it here too.\n",
        "createdAt" : "2015-06-30T21:03:22Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "cde8ac2e-873e-406a-8131-1bc7b125d69b",
        "parentId" : "4da10462-d4a0-4e21-a5d4-0121028d74f1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I currently never happens, but I guess it wouldn't hurt.\n",
        "createdAt" : "2015-07-01T01:49:18Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4056,4060 @@                return emptyObjectType;\n            }\n            let typeSet: Type[] = [];\n            addTypesToSet(typeSet, types, TypeFlags.Intersection);\n            if (containsTypeAny(typeSet)) {"
  },
  {
    "id" : "950883b3-a31f-43b4-8b17-b064a5f17a32",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a2b0bb0b-32ec-478f-bd16-8d048946d5fd",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems very important that in all cases, the \"each\" calls come before the \"some\" calls. I'd add brief comment pointing this out.\n",
        "createdAt" : "2015-06-30T23:51:09Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 529,
    "diffHunk" : "@@ -1,1 +4513,4517 @@                        }\n                    }\n                    else {\n                        // It is necessary to try \"each\" checks on both sides because there may be nested \"some\" checks\n                        // on either side that need to be prioritized. For example, A | B = (A | B) & (C | D) or"
  },
  {
    "id" : "beaf1486-0293-450a-9ca7-420b9889c24a",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f23dfc56-4c77-429e-a706-9f3d1289a589",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why is this not `else if` like the \"each\" checks?\n",
        "createdAt" : "2015-06-30T23:54:19Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 543,
    "diffHunk" : "@@ -1,1 +4523,4527 @@                            }\n                        }\n                        if (target.flags & TypeFlags.Union) {\n                            if (result = typeRelatedToSomeType(source, <UnionType>target, reportErrors)) {\n                                return result;"
  },
  {
    "id" : "59463918-5ada-40dd-ad7c-dd466828e768",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "58e647f8-9b94-421c-8df7-161fde97527b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think it is easier to read when the identity case is on top, because it's hard to see what this `else` corresponds to.\n",
        "createdAt" : "2015-06-30T23:59:31Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "2f1a1581-e51e-4c74-a289-1d9012a26476",
        "parentId" : "58e647f8-9b94-421c-8df7-161fde97527b",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Maybe, but I don't really want to change it.\n",
        "createdAt" : "2015-07-01T02:22:14Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 560,
    "diffHunk" : "@@ -1,1 +4531,4535 @@                }\n                else {\n                    if (source.flags & TypeFlags.Union && target.flags & TypeFlags.Union ||\n                        source.flags & TypeFlags.Intersection && target.flags & TypeFlags.Intersection) {\n                        if (result = eachTypeRelatedToSomeType(<UnionOrIntersectionType>source, <UnionOrIntersectionType>target)) {"
  },
  {
    "id" : "991ff70b-7307-46f4-9d31-e3c859efb446",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b458c5cc-fed8-415a-8d33-303a5b15227b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This part is very interesting. Can you put a comment explaining why we only do this for intersections, and only on the source side? I do understand why, it's because we want the intersection to be equivalent to the meet (the aggregation of all the properties), but the union type is not similarly equivalent to the join (the properties the two types have in common). And it's only on the source side because the intent of this step is widen assignability, to allow more things than the union/intersection steps allowed.\n",
        "createdAt" : "2015-07-01T00:14:13Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a984ea29-2cce-4b70-8dad-6b8b0fae670d",
        "parentId" : "b458c5cc-fed8-415a-8d33-303a5b15227b",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Well, since you've explained it very nicely I may just borrow this for a comment. :-)\n",
        "createdAt" : "2015-07-01T02:23:40Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a917eb33-3122-4c9a-8576-c75a225bde90",
        "parentId" : "b458c5cc-fed8-415a-8d33-303a5b15227b",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah sure!\n",
        "createdAt" : "2015-07-01T17:06:00Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4550,4554 @@                // to X. Failing both of those we want to check if the aggregation of A and B's members structurally\n                // relates to X. Thus, we include intersection types on the source side here.\n                if (sourceOrApparentType.flags & (TypeFlags.ObjectType | TypeFlags.Intersection) && target.flags & TypeFlags.ObjectType) {\n                    if (result = objectTypeRelatedTo(sourceOrApparentType, <ObjectType>target, reportStructuralErrors)) {\n                        errorInfo = saveErrorInfo;"
  },
  {
    "id" : "830b2d1e-929a-4daf-b6c3-de3daf0a2e67",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dc4fd7a3-1928-4f20-bbfe-47474418e9d7",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Use a for-of loop\n",
        "createdAt" : "2015-07-01T00:16:12Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "fd020cd9-0fd9-42ff-85ab-be10cdf6e0d5",
        "parentId" : "dc4fd7a3-1928-4f20-bbfe-47474418e9d7",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It is!\n",
        "createdAt" : "2015-07-01T02:35:22Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "5fc73fbe-0785-4a11-8d6a-ed53fd11af11",
        "parentId" : "dc4fd7a3-1928-4f20-bbfe-47474418e9d7",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh I meant in typeRelatedToSomeType, but nvm I didn't see the `i === len - 1`\n",
        "createdAt" : "2015-07-01T17:09:17Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 626,
    "diffHunk" : "@@ -1,1 +4605,4609 @@                let result = Ternary.True;\n                let targetTypes = target.types;\n                for (let targetType of targetTypes) {\n                    let related = isRelatedTo(source, targetType, reportErrors);\n                    if (!related) {"
  },
  {
    "id" : "ad92c2d8-f0a4-4953-9c66-a458391bebd9",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3bb6c500-2fa2-4001-96ee-41021fe867a7",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Use a for-of loop\n",
        "createdAt" : "2015-07-01T00:16:18Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a8ac331a-ef70-4d40-8f68-1e31ebc5aeaa",
        "parentId" : "3bb6c500-2fa2-4001-96ee-41021fe867a7",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, we need a regular for loop so we can compare the current index to `len - 1`.\n",
        "createdAt" : "2015-07-01T02:34:32Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 638,
    "diffHunk" : "@@ -1,1 +4617,4621 @@            function someTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean): Ternary {\n                let sourceTypes = source.types;\n                for (let i = 0, len = sourceTypes.length; i < len; i++) {\n                    let related = isRelatedTo(sourceTypes[i], target, reportErrors && i === len - 1);\n                    if (related) {"
  },
  {
    "id" : "53075c5e-0eea-40b0-aca7-050f74fba262",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ba624a29-66c4-4a8b-9eac-118d8378fdae",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why do they both need to be object types? They can't be union or intersection?\n",
        "createdAt" : "2015-07-01T00:17:55Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d81c63ad-b5c3-44fe-819f-37dc74711002",
        "parentId" : "ba624a29-66c4-4a8b-9eac-118d8378fdae",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We already break down unions and intersections elsewhere. Here we only want to compare identical kinds of types.\n",
        "createdAt" : "2015-07-01T02:36:42Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "59eb4b1a-c01d-48ab-a053-c0c0e5753f6f",
        "parentId" : "ba624a29-66c4-4a8b-9eac-118d8378fdae",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I see. I guess in that sense it's different from subtype and assignability\n",
        "createdAt" : "2015-07-01T17:11:15Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 675,
    "diffHunk" : "@@ -1,1 +4841,4845 @@\n            function propertiesIdenticalTo(source: Type, target: Type): Ternary {\n                if (!(source.flags & TypeFlags.ObjectType && target.flags & TypeFlags.ObjectType)) {\n                    return Ternary.False;\n                }"
  },
  {
    "id" : "a2392cd5-e75d-4a5b-b0fe-1bf45c94f61c",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "69e4efff-75ec-4970-aba4-61166d40265d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Hmm, why did this work before? Is it because union types are flat, and applyToContextualType unwrapped the union types, so all we were left with in lambda was object types? And now unions and intersections can be nested?\n",
        "createdAt" : "2015-07-01T00:22:30Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5d89e59a-51c0-4a0a-8af5-42f79f7a5655",
        "parentId" : "69e4efff-75ec-4970-aba4-61166d40265d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, that's why.\n",
        "createdAt" : "2015-07-01T02:46:15Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 771,
    "diffHunk" : "@@ -1,1 +6458,6462 @@        function getTypeOfPropertyOfContextualType(type: Type, name: string) {\n            return applyToContextualType(type, t => {\n                let prop = t.flags & TypeFlags.StructuredType ? getPropertyOfType(t, name) : undefined;\n                return prop ? getTypeOfSymbol(prop) : undefined;\n            });"
  },
  {
    "id" : "f9b70bda-b143-4306-afef-8b8099a9379b",
    "prId" : 3622,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e34250a3-d58c-4a20-9dfa-cadf5fe38654",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I have been thinking a bit more about this `TypeFlags.Intersection` check, and I think it is too permissive because the intersection could have unions as constituents. Here is an example:\n\n``` ts\ninterface Target {\n    x?: number;\n}\ninterface A1 {\n    a: any;\n    x: string;\n}\ninterface A2 {\n    a: any;\n    x2: string;\n}\ninterface B1 {\n    b: any;\n    x: string;\n}\ninterface B2 {\n    b: any;\n    x2: string;\n}\n\nvar t: Target;\nvar s: (A1 | A2) & (B1 | B2);\nt = s;\n```\n\nThis assignment is supposed to fail, because no matter which side of the intersection you're looking it, there could be a union constituent where x has the wrong type (string instead of number). But because you are recursively diving into the properties of the unions as well as the intersections, you end up losing information about the property x. As a result, we allow the assignment, even though it is bad.\n",
        "createdAt" : "2015-07-02T18:07:46Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "3a0f739e-9403-4696-b737-176b9a2727dc",
        "parentId" : "e34250a3-d58c-4a20-9dfa-cadf5fe38654",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Also, the intersection constituents could be type parameters, primitives, etc. It seems like you only want to do this for the constituents that are object types.\n",
        "createdAt" : "2015-07-02T18:09:15Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e9e0848a-a01f-4083-828a-f856d3450917",
        "parentId" : "e34250a3-d58c-4a20-9dfa-cadf5fe38654",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Actually, type parameters and primitives are fine because we take the apparent type for every constituent when we retrieve properties. Unions are really the issue.\n",
        "createdAt" : "2015-07-02T18:17:34Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ea08e838-2fcd-4627-aa8f-92ba4006411b",
        "parentId" : "e34250a3-d58c-4a20-9dfa-cadf5fe38654",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think the real issue here is that optional properties cannot be checked in the face of unknown extensions. We allow assignment to a target with an optional property when the source doesn't have that property, but we only know that to be true when the source is not subject to further extension (i.e. when source type expresses \"the whole truth\"). For that reason, we do have this same problem with type parameters. For example, X = A & T, where X is a type with an optional property p, A is a type that has no property p, and T is a type parameter. If T is instantiated to a type that has a property p with the wrong type, an inconsistency appears. In fact, the same inconsistency exists just with X = T. It all has to do with the way we check optional properties and I'm not sure we can do much about it.\n",
        "createdAt" : "2015-07-02T18:40:52Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "33aca4b9-f48d-4f10-a3f6-0c71ae6309d7",
        "parentId" : "e34250a3-d58c-4a20-9dfa-cadf5fe38654",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah, maybe you're right. We've always had this problem. It is one of the causes of non-transitivity in the type system also.\n",
        "createdAt" : "2015-07-02T18:46:14Z",
        "updatedAt" : "2015-07-03T18:29:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc1888ec8abec533ef7503e79c4e4c632b17ac90",
    "line" : 581,
    "diffHunk" : "@@ -1,1 +4550,4554 @@                // to X. Failing both of those we want to check if the aggregation of A and B's members structurally\n                // relates to X. Thus, we include intersection types on the source side here.\n                if (sourceOrApparentType.flags & (TypeFlags.ObjectType | TypeFlags.Intersection) && target.flags & TypeFlags.ObjectType) {\n                    if (result = objectTypeRelatedTo(sourceOrApparentType, <ObjectType>target, reportStructuralErrors)) {\n                        errorInfo = saveErrorInfo;"
  },
  {
    "id" : "355d089f-a74b-4c04-8b57-1e29836df7f7",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb7267b3-9312-485e-b878-7113eb3284b0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Fix this indentation\n",
        "createdAt" : "2015-06-20T06:58:23Z",
        "updatedAt" : "2015-07-01T23:15:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +2236,2240 @@                type = getTypeOfPropertyOfType(parentType, name.text) ||\n                isNumericLiteralName(name.text) && getIndexTypeOfType(parentType, IndexKind.Number) ||\n                getIndexTypeOfType(parentType, IndexKind.String);\n                if (!type) {\n                    error(name, Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(parentType), declarationNameToString(name));"
  },
  {
    "id" : "eb67e37e-335e-4d9a-a2a7-e0bcbf279cf2",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b54287dc-56c5-4b9c-90f2-b21ba0fb8ee6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Remove\n",
        "createdAt" : "2015-06-20T07:12:47Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "82ad58e5-817f-4b39-836f-fb1f9bfb365a",
        "parentId" : "b54287dc-56c5-4b9c-90f2-b21ba0fb8ee6",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "After a little thinking, I agree. Changed.\n",
        "createdAt" : "2015-06-22T20:09:47Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6832,6836 @@            return jsxElementType || anyType;\n        }\n\n        /**\n         * Returns true iff the JSX element name would be a valid JS identifier, ignoring restrictions about keywords not being identifiers"
  },
  {
    "id" : "cdfc6bc6-31c6-473d-a3ac-47d0c59225e2",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4fe74143-466d-42cc-8d57-f268dafdfe28",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Remove line\n",
        "createdAt" : "2015-06-20T07:18:36Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d5ab0bb4-de46-4fae-befd-c4c60bd39006",
        "parentId" : "4fe74143-466d-42cc-8d57-f268dafdfe28",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "Changed.\n",
        "createdAt" : "2015-06-22T20:19:31Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6798,6802 @@                return (<Identifier>lhs).text === (<Identifier>rhs).text;\n            }\n\n            return (<QualifiedName>lhs).right.text === (<QualifiedName>rhs).right.text &&\n                tagNamesAreEquivalent((<QualifiedName>lhs).left, (<QualifiedName>rhs).left);"
  },
  {
    "id" : "31d90502-338b-4340-8be8-839bc19c7cbb",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d21867bb-510a-46eb-a58e-46fc0fa6cda8",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Newline above\n",
        "createdAt" : "2015-06-20T07:30:25Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "219fbd26-42ad-45ee-9bf0-9ec049db4804",
        "parentId" : "d21867bb-510a-46eb-a58e-46fc0fa6cda8",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "Changed.\n",
        "createdAt" : "2015-06-22T20:31:44Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12107,12111 @@            }\n\n            if (produceDiagnostics) {\n                checkIndexConstraints(type);\n                checkTypeForDuplicateIndexSignatures(node);"
  },
  {
    "id" : "8d1256bf-5dc6-4c87-9b40-12982efa9bd0",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30dae23a-2c84-40ae-9325-b380d584636c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "These should be left aligned.\n",
        "createdAt" : "2015-06-29T19:47:50Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "400c0161-47fe-43cd-827d-f0f7e3135ec7",
        "parentId" : "30dae23a-2c84-40ae-9325-b380d584636c",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "Changed.\n\nI think it's worth expressing that a linting tool _should_ be able to perform these sorts of checks so we can focus on the more substantial issues. Not a dig against you, just a general frustration :/\n",
        "createdAt" : "2015-06-29T22:21:35Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      },
      {
        "id" : "0a47b6ba-a62a-40f7-a798-1f7e18fa30d4",
        "parentId" : "30dae23a-2c84-40ae-9325-b380d584636c",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "The formatter should do this. If it's not, then maybe we should change the formatter.\n",
        "createdAt" : "2015-06-29T22:24:25Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "12f74d79-0c7a-434e-8290-99ee75567ae1",
        "parentId" : "30dae23a-2c84-40ae-9325-b380d584636c",
        "authorId" : null,
        "body" : "@aozgaa, this repository has `.editorconfig` file at root. If you install editorconfig extension for your editor (available for all editors [including VS](https://visualstudiogallery.msdn.microsoft.com/c8bccfe2-650c-4b42-bc5c-845e21f96328)), it will format the documents accordingly (just `Ctrl,K,D` in VS). Editorconfig extension automatically applies your projects settings to editor scoped to the project only.\n",
        "createdAt" : "2015-06-30T12:25:55Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +9419,9423 @@                let offendingSymbolOperand =\n                    someConstituentTypeHasKind(leftType, TypeFlags.ESSymbol) ? node.left :\n                        someConstituentTypeHasKind(rightType, TypeFlags.ESSymbol) ? node.right :\n                            undefined;\n                if (offendingSymbolOperand) {"
  },
  {
    "id" : "8f8c6434-8a39-4a73-90fe-fb71b446b8ec",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f26e7c75-3787-438c-a912-0d530e2c448b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, I like this approach\n",
        "createdAt" : "2015-06-29T20:27:41Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : 708,
    "diffHunk" : "@@ -1,1 +10335,10339 @@                else {\n                    // Report different errors regarding non-consecutive blocks of declarations depending on whether\n                    // the node in question is abstract.\n                    if (node.flags & NodeFlags.Abstract) {\n                        error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);"
  },
  {
    "id" : "5b5b7927-359c-4141-88b4-042679d47afb",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cb77bd95-822b-46e9-93e6-61424224fc80",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems like you should just be able to pass in derived without `!!`. I feel like Debug.assert should take an any\n",
        "createdAt" : "2015-06-29T21:08:40Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ba7f8c51-06aa-4162-b529-f92570579a06",
        "parentId" : "cb77bd95-822b-46e9-93e6-61424224fc80",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "Separate issue? I think this PR might already be a good example of making too many non-essential changes, harming the readability of the change.\n",
        "createdAt" : "2015-06-29T23:03:07Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12147,12151 @@                let baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);\n\n                Debug.assert(!!derived, \"derived should point to something, even if it is the base class' declaration.\");\n\n                if (derived) {"
  },
  {
    "id" : "cd8d0117-6007-4751-984b-390e95b12de8",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a831a8f-786e-4e23-8f53-5b1d7eace917",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What function are we in?\n",
        "createdAt" : "2015-06-29T21:09:02Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "98663b68-1c53-4058-814c-fa636cbe699c",
        "parentId" : "1a831a8f-786e-4e23-8f53-5b1d7eace917",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "`checkKindsOfPropertyMemberOverrides()` though I think we've resolved the issue offline.\n",
        "createdAt" : "2015-06-29T23:01:13Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12145,12149 @@\n                let derived = getTargetSymbol(getPropertyOfObjectType(type, base.name));\n                let baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);\n\n                Debug.assert(!!derived, \"derived should point to something, even if it is the base class' declaration.\");"
  },
  {
    "id" : "0fd82279-b43d-4657-939b-0529802906bc",
    "prId" : 3579,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f3dcf7c-f4cb-4d49-8c9e-1b22ff252f0b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Shouldn't the static and private checks also be inside `if (node.kind !== SyntaxKind.ClassDeclaration)`?\n",
        "createdAt" : "2015-06-29T21:15:31Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "f4c267ce-0ae3-4444-b22f-eba35db65e04",
        "parentId" : "0f3dcf7c-f4cb-4d49-8c9e-1b22ff252f0b",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "These errors are specific to method declarations today, and consitute duplicate errors in the case of class declarations.\n\nI've moved them inside the block you mentioned.\n",
        "createdAt" : "2015-06-29T22:58:12Z",
        "updatedAt" : "2015-07-01T23:15:02Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "6d0c7c9f6a80f020a8cde9f594855327ee154ce7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +14351,14355 @@                        else if (flags & NodeFlags.Ambient || isInAmbientContext(node.parent)) {\n                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, \"async\");\n                        }\n                        else if (node.kind === SyntaxKind.Parameter) {\n                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"async\");"
  },
  {
    "id" : "4128e765-f3aa-4034-935a-ff4c4fc75999",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "499e9f1b-54fb-4d1c-8858-765cdc909b80",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Use JSDoc format for these.\n",
        "createdAt" : "2015-06-19T21:13:08Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f4547216-711f-43d6-88b0-d6d2a6e03afc",
        "parentId" : "499e9f1b-54fb-4d1c-8858-765cdc909b80",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : ":heavy_check_mark: \n",
        "createdAt" : "2015-06-22T16:14:30Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : 286,
    "diffHunk" : "@@ -1,1 +6866,6870 @@        /// If this is a class-based tag (otherwise returns undefined), returns the symbol of the class\n        /// type or factory function.\n        /// Otherwise, returns unknownSymbol.\n        function getJsxElementTagSymbol(node: JsxOpeningLikeElement): Symbol {\n            let flags: JsxFlags = JsxFlags.UnknownElement;"
  },
  {
    "id" : "f467d4e4-eb3e-46fc-9163-dfe55d847d97",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aee05a9a-8ba6-4221-ab4d-7892eb4713c1",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "So while I don't really have anything against using `else` in such cases, we generally omit them in non-joining branches throughout our codebase. They appear quite a bit in these changes.\n",
        "createdAt" : "2015-06-19T21:20:21Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d6abc8be-14e7-41d4-ada8-277f8e1f4eea",
        "parentId" : "aee05a9a-8ba6-4221-ab4d-7892eb4713c1",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I'll remove them in general but may keep a few where it feels like it impacts readability.\n",
        "createdAt" : "2015-06-22T16:29:51Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +6374,6378 @@                    return undefined;\n                }\n                else {\n                    return getTypeOfPropertyOfType(attrsType, attrib.name.text);\n                }"
  },
  {
    "id" : "01d98be8-cc21-421f-8c29-7b5618a60f93",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "de276e6e-f2dd-41b0-bedf-6f724b5974ef",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Are any of the other ones lazily-loaded? Can you put a comment above like\n\n``` TypeScript\n/**\n * DO NOT USE DIRECTLY.\n *\n * @see getJsxIntrinsicElementsType.\n */\n```\n\nor something like that, depending on if `@see` is a valid tag name.\n",
        "createdAt" : "2015-06-19T21:29:36Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d9f66a31-66ca-42a9-9b1b-28d7941af3ec",
        "parentId" : "de276e6e-f2dd-41b0-bedf-6f724b5974ef",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Maybe we could make a `lazy` primitive in `core` or `utilities`.\n",
        "createdAt" : "2015-06-19T21:30:37Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "304dc43a-17b8-4a5b-9fd4-cb157cb08718",
        "parentId" : "de276e6e-f2dd-41b0-bedf-6f724b5974ef",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Added some comments\n",
        "createdAt" : "2015-06-22T16:38:36Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : null,
    "diffHunk" : "@@ -1,1 +119,123 @@        let jsxElementType: ObjectType;\n        /** Lazily loaded, use getJsxIntrinsicElementType() */\n        let jsxIntrinsicElementsType: ObjectType;\n        let globalIterableType: GenericType;\n        let globalIteratorType: GenericType;"
  },
  {
    "id" : "48274e68-560a-46e8-a02f-0172ae6ac38f",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b1fa7bc4-125d-42a8-9003-aca80c323a08",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "``` TypeScript\n// If there is no 'props' property, you may only have \"data-\" attributes,\n// and in JSX, attribute names starting with \"data-\" are ignored.\n```\n",
        "createdAt" : "2015-06-19T21:38:08Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b3cff65f-857e-4f21-96e8-d12aa4269b2c",
        "parentId" : "b1fa7bc4-125d-42a8-9003-aca80c323a08",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "That's not really correct.\n",
        "createdAt" : "2015-06-22T16:39:22Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6804,6808 @@            // Look up the corresponding property for this attribute\n            if (elementAttributesType === emptyObjectType && isUnhyphenatedJsxName(node.name.text)) {\n                // If there is no 'props' property, you may not have non-\"data-\" attributes\n                error(node.parent, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, getJsxElementPropertiesName());\n            }"
  },
  {
    "id" : "93e48d61-6dd9-40d1-9670-8fd2a9f54d77",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5308afdc-b553-48a4-9389-ad8a293290e7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd make this a ternary and keep the comment around.\n",
        "createdAt" : "2015-06-19T21:39:34Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "284da798-226d-4481-95d0-266de060d6a0",
        "parentId" : "5308afdc-b553-48a4-9389-ad8a293290e7",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Assuming you mean `&&` ?\n",
        "createdAt" : "2015-06-22T16:40:11Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "c8bb46dd-9ff5-4148-be2b-937d72d8db38",
        "parentId" : "5308afdc-b553-48a4-9389-ad8a293290e7",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "No, I mean\n\n``` TypeScript\n// <Elem attr /> is sugar for <Elem attr={true} />\nlet exprType = node.initializer ?\n    checkExpression(node.initializer) :\n    booleanType;\n```\n",
        "createdAt" : "2015-06-22T19:32:41Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "5c33ac52-e34e-4d85-ab99-ab5957ddc145",
        "parentId" : "5308afdc-b553-48a4-9389-ad8a293290e7",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "I don't understand why that's an improvement.\n",
        "createdAt" : "2015-06-22T19:35:27Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "6aead3bf-e103-420d-a110-41ef213e3a33",
        "parentId" : "5308afdc-b553-48a4-9389-ad8a293290e7",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "1. It's more typical with the rest of our codebase, and consistency is important.\n2. You can omit the type annotation.\n3. You declare an uninitialized variable only to immediately initialize it in the following branches. This will sometimes signal that the variable has some complex initialization logic or may be undefined. Just initialize upon declaration.\n",
        "createdAt" : "2015-06-22T23:11:15Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : 238,
    "diffHunk" : "@@ -1,1 +6818,6822 @@\n            let exprType: Type;\n            if (node.initializer) {\n                exprType = checkExpression(node.initializer);\n            }"
  },
  {
    "id" : "2749fdd3-503e-4af2-a5c8-31c62f14b127",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3214ce8-ca28-4b44-b4be-9678321a9bcc",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "`lookupIntrinsicJsxTag`; also make sure these are named consistently with the lookup function in `core.ts` (i.e. \"look-up\" vs \"look-Up\")\n",
        "createdAt" : "2015-06-19T21:57:12Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "5bc6cf02-bda5-493f-a811-323e36607acd",
        "parentId" : "b3214ce8-ca28-4b44-b4be-9678321a9bcc",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "\"lookup\" is a word; I don't want to confuse this with looking \"up\" the stack (as opposed to down).\n",
        "createdAt" : "2015-06-22T19:37:01Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : 299,
    "diffHunk" : "@@ -1,1 +6879,6883 @@            return links.resolvedSymbol;\n\n            function lookupIntrinsicTag(node: JsxOpeningLikeElement): Symbol {\n                let intrinsicElementsType = getJsxIntrinsicElementsType();\n                if (intrinsicElementsType !== unknownType) {"
  },
  {
    "id" : "b015e6e2-2d6a-48b6-9e6b-060b3b85d8fa",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "901325fc-9eaf-492a-96b4-755f14cf546c",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "This one is also lazily loaded.Also, move these below the global blah types\n",
        "createdAt" : "2015-06-22T19:23:45Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "99c08f7e-b8e5-411b-91f0-e380a328e2b7",
        "parentId" : "901325fc-9eaf-492a-96b4-755f14cf546c",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "This isn't lazy. Line 13096 is unconditional\n\n``` ts\njsxElementType = getExportedTypeFromNamespace(\"JSX\", JsxNames.Element);\n```\n",
        "createdAt" : "2015-06-22T19:38:08Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "fe02ddd7-ef58-46a1-9db9-e83c930bdc3d",
        "parentId" : "901325fc-9eaf-492a-96b4-755f14cf546c",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Gotcha, my bad. \n",
        "createdAt" : "2015-06-22T20:11:55Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +117,121 @@        let globalTemplateStringsArrayType: ObjectType;\n        let globalESSymbolType: ObjectType;\n        let jsxElementType: ObjectType;\n        /** Lazily loaded, use getJsxIntrinsicElementType() */\n        let jsxIntrinsicElementsType: ObjectType;"
  },
  {
    "id" : "afeb98d1-0bc4-4b56-906f-6a1abd092601",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abd62600-57de-4eb7-a5a6-d4f8d7f59ee1",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Newline above\n",
        "createdAt" : "2015-06-22T19:27:10Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b4bb481b-acfa-406e-b148-714ae0f2e543",
        "parentId" : "abd62600-57de-4eb7-a5a6-d4f8d7f59ee1",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : ":heavy_check_mark: \n",
        "createdAt" : "2015-06-22T19:39:07Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6745,6749 @@            }\n\n            return (<QualifiedName>lhs).right.text === (<QualifiedName>rhs).right.text &&\n                tagNamesAreEquivalent((<QualifiedName>lhs).left, (<QualifiedName>rhs).left);\n        }"
  },
  {
    "id" : "7f7e8fb8-3b70-48de-964b-732abe0bf9e1",
    "prId" : 3564,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7a54e61-6b26-4698-9227-7fb2088c4ba8",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "single quotes around `attributes`\n",
        "createdAt" : "2015-06-29T15:47:50Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "cb4af397-7776-400b-be29-7e71d77137ec",
        "parentId" : "c7a54e61-6b26-4698-9227-7fb2088c4ba8",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Not sure what you mean here.\n",
        "createdAt" : "2015-06-29T16:04:29Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "1f993770-2cc4-4554-9501-98ab3fcc8aec",
        "parentId" : "c7a54e61-6b26-4698-9227-7fb2088c4ba8",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Sorry, read this too quickly\n",
        "createdAt" : "2015-06-29T16:19:49Z",
        "updatedAt" : "2015-06-29T17:39:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3402f3556c3ceb12be8506116e15d65e5a761928",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6982,6986 @@        ///     non-intrinsic elements' attributes type is 'any'),\n        /// or '' if it has 0 properties (which means every\n        ///     non-instrinsic elements' attributes type is the element instance type)\n        function getJsxElementPropertiesName() {\n            // JSX"
  },
  {
    "id" : "d39c95ae-a979-4419-abb9-30c2667cbe3c",
    "prId" : 3561,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2afcfb0e-26cc-41c6-a3a6-cb0f9ef846d7",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "why not checking timestamp instead, just make sure we check cancellation token if 100 ms passed for instance since last check.\n",
        "createdAt" : "2015-06-18T23:53:00Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a26cd21f99771258f257d183bdfc389e780614c",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +13044,13048 @@            }\n\n            let kind = node.kind;\n            if (cancellationToken) {\n                // Only bother checking on a few construct kinds.  We don't want to be excessivly"
  },
  {
    "id" : "d04a6231-0173-46d5-93ef-2edada6b5308",
    "prId" : 3561,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "Why not pass the cancellation token to createTypeChecker from the program. the program has the cancelation token, then the checker can hold on to it.\n",
        "createdAt" : "2015-06-18T23:55:30Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "460eb693-4405-4251-9803-1e3ab3b42880",
        "parentId" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "A cancellation token is an ephemeral object used during the processing of an operation.  This is the pattern .net uses throughout its APIs.  I don't like thinking about it as a singleton.   Esp as different operations may use different tokens, and each token may or may not be canceled.\n",
        "createdAt" : "2015-06-24T02:45:40Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "40b6d944-aa22-4e4d-9524-6fc13c0a8ee8",
        "parentId" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "but this is the model we have used thus far everywhere else. we do not create new cancellation tokens per operation. we relay on the fact that the JS engine is single threaded. so we have at most one operation at a time. \nWe should not have two ways of doing the same thing.\n",
        "createdAt" : "2015-06-24T18:08:30Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "69989c5d-e17b-4d85-a85d-22e8785edb0f",
        "parentId" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "My understanding was that we used a single point in the shim layer to have the LS-script side be able to communicate with a managed cancellation token.  But i was not under the impression that that meant that on the script side we not be passing the cancellation token along with an operation.  \n\nIMO, it's a lot more complicated to use the 'host' pattern for cancellation.  With that pattern, anything that has access to the host may accidentally check for cancellation, even though they are not safe to cancel.  For example, any random type checking operation might check for this.  But it could end up dying.  This could lead the typechecker in a busted state that could corrupt all further calls into it.\n\nFor example, if we did things this way, then we'd have a problem for nearly all other typechecking operations.  For example, when we did quick info, we'd set have the cancellation token set in the host, then we'd call into the type checker, and it might throw a cancellation exception.  That cancellation exception would bubble out, leaving the type checker in an invalid state.\n\nRight now though we only use cancellation for our expensive operation (i.e. getDiagnostics).  So even though the host has a cancellation token for pretty much every LS operation, the type checker is unaware of it except for the expensive call into it.  And that same expensive call is appropriately guarded for when cancellation may be thrown.\n",
        "createdAt" : "2015-06-25T04:48:03Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "e127adb6-5786-4ab0-bf30-d1227325141d",
        "parentId" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I believe we already have an implementation for cancellation. All i am saying we do not need two ways. i personally like the current model as it does not sprinkle the cancellation token through different interfaces. the argument about inconsistent state of the checker is more of an implementation detail that we should look into solving. i am not convinced that adding an additional way of setting cancellation tokens is the right solution.\n",
        "createdAt" : "2015-06-25T18:12:47Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "458da75e-34b8-453c-93f1-6722264aa9c8",
        "parentId" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I guess i'm not really understanding the complaint.\n\nThe reason the cancellation token works as a singleton elsewhere is because it truly operates as a singleton around all the operations it wraps.  That's not the case for the typechecker.  For some codepaths cancellation should be respected.  Through others it should be ignored.  The easiest (and most natural IMO) way to encode that is to actually pass the cancellation token (or not) through those codepaths.  \n\nSo... i agree that the issue with the checker is \"an implementation detail we should look into solving\".  It's just that the best solution (IMO) was to follow this pattern of cancellation inside of it :)\n",
        "createdAt" : "2015-06-26T04:43:56Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "4c5d4bb7-60c3-466a-a20f-78b2441099c2",
        "parentId" : "969f9639-a993-4abb-9de1-20ed05ec3688",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "When you talk about the host pattern, you mean the one that we use in services? I think those operations are different because they are pure query operations, so they are always safe to interrupt, right? Interrupting the type checker could cause corruption because the checker does caching. This difference seems like it could warrant a different pattern.\n",
        "createdAt" : "2015-06-29T21:43:04Z",
        "updatedAt" : "2015-07-06T22:31:26Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a26cd21f99771258f257d183bdfc389e780614c",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +206,210 @@        return checker;\n\n        function getEmitResolver(sourceFile: SourceFile, cancellationToken: CancellationToken) {\n            // Ensure we have all the type information in place for this file so that all the\n            // emitter questions of this resolver will return the right information."
  },
  {
    "id" : "88cb4a06-0809-45ff-ba6e-5d4c256c91a5",
    "prId" : 3555,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cb239fa-6082-417d-a011-ab6099b189d6",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can you change this to call getSymbolOfNode instead of getSymbolAtLocation?\n",
        "createdAt" : "2015-06-18T20:49:21Z",
        "updatedAt" : "2015-06-18T20:49:21Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "07127876-0af7-4041-bb5c-5f75548da765",
        "parentId" : "0cb239fa-6082-417d-a011-ab6099b189d6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Never mind. My suggestion does not work.\n",
        "createdAt" : "2015-06-18T21:08:08Z",
        "updatedAt" : "2015-06-18T21:08:08Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "84bb38415f2e0f47c8197ac6491abace54c58742",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +5763,5767 @@                if (signature.typePredicate &&\n                    expr.arguments[signature.typePredicate.parameterIndex] &&\n                    getSymbolAtLocation(expr.arguments[signature.typePredicate.parameterIndex]) === symbol) {\n\n                    if (!assumeTrue) {"
  },
  {
    "id" : "916c8c14-8912-4c79-9d5e-7f879b95a91f",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6c5f8d1-f8c3-4dc3-a5f7-a3ab0781bc83",
        "parentId" : null,
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "Can/should this be a JSDoc-style comment?\n",
        "createdAt" : "2015-06-16T20:34:02Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      },
      {
        "id" : "b43d1c74-b055-4243-90ec-5633344a8bbc",
        "parentId" : "f6c5f8d1-f8c3-4dc3-a5f7-a3ab0781bc83",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Agreed.\n",
        "createdAt" : "2015-06-16T20:57:49Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +2624,2628 @@        }\n\n        // The base constructor of a class can resolve to\n        // undefinedType if the class has no extends clause,\n        // unknownType if an error occurred during resolution of the extends expression,"
  },
  {
    "id" : "2a7e6712-4f58-4876-a354-fbd204ceb819",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0efdb7b1-f663-4fee-b02b-bd20938795ac",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Might change if we allow merging of ambient classes.\n",
        "createdAt" : "2015-06-17T06:04:16Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e81ecc2b-d437-4dd1-ba58-77b7cd7bff24",
        "parentId" : "0efdb7b1-f663-4fee-b02b-bd20938795ac",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Possibly. But I'm not sure there's really a need for that feature anymore.\n",
        "createdAt" : "2015-06-17T14:14:23Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +2606,2610 @@\n        function getBaseTypeNodeOfClass(type: InterfaceType): ExpressionWithTypeArguments {\n            return getClassExtendsHeritageClauseElement(<ClassLikeDeclaration>type.symbol.valueDeclaration);\n        }\n"
  },
  {
    "id" : "7dbe5c8a-820e-485b-b93a-4eed93ef44e1",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "832d4319-eb58-44b2-98f1-d22d470934a0",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "We should create a type ClassType.\n",
        "createdAt" : "2015-06-17T06:04:55Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e1c236bd-e59f-44e0-9580-53f5de812152",
        "parentId" : "832d4319-eb58-44b2-98f1-d22d470934a0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes.\n",
        "createdAt" : "2015-06-17T14:16:13Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "18553acc-bd97-4c56-a3b3-980984a47581",
        "parentId" : "832d4319-eb58-44b2-98f1-d22d470934a0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Actually, while I agree a ClassType would be good, I think it is a separate issue from this PR.\n",
        "createdAt" : "2015-06-17T18:27:49Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +2605,2609 @@        }\n\n        function getBaseTypeNodeOfClass(type: InterfaceType): ExpressionWithTypeArguments {\n            return getClassExtendsHeritageClauseElement(<ClassLikeDeclaration>type.symbol.valueDeclaration);\n        }"
  },
  {
    "id" : "f76b2df6-7f50-43d8-855d-e0cdcc8fe661",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b46506e8-71b5-46b8-bfcd-4e97e175e5d7",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This seems unintuitive. Perhaps it is clearer to have a new sentinel that represents the absence of a base constructor. Or even set the resolvedBaseTypes to emptyArray right here.\n",
        "createdAt" : "2015-06-17T06:15:08Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "1950b018-a943-4c82-9354-237ad5f11e0f",
        "parentId" : "b46506e8-71b5-46b8-bfcd-4e97e175e5d7",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think it is fine to do it this way. Another sentinel wouldn't really make a difference IMO and we can't mess with `resolvedBaseTypes` here, it is computed by another function.\n",
        "createdAt" : "2015-06-17T14:18:49Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +2633,2637 @@                let baseTypeNode = getBaseTypeNodeOfClass(type);\n                if (!baseTypeNode) {\n                    return type.resolvedBaseConstructorType = undefinedType;\n                }\n                if (!pushTypeResolution(type)) {"
  },
  {
    "id" : "f7f9374f-a095-4232-b9ed-3929c3cfcede",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47beefd9-9892-42c7-b3fb-dcc1c5d4d7f2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Doesn't this just resolve one level? Why does resolving the members level catch important circularities?\n",
        "createdAt" : "2015-06-17T06:17:23Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "797d357e-9d6b-4a70-8cdd-3cdd0872149f",
        "parentId" : "47beefd9-9892-42c7-b3fb-dcc1c5d4d7f2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It's not really about the members, it's about the fact the resolving the members or a class requires us to resolve the base class of that class. Which may result in a circularity.\n",
        "createdAt" : "2015-06-17T14:24:59Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "280f864f-d0c6-4f0f-b1bd-acd0d387315a",
        "parentId" : "47beefd9-9892-42c7-b3fb-dcc1c5d4d7f2",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Makes sense. I would augment the comment to explain that fact.\n",
        "createdAt" : "2015-06-17T18:13:26Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2642,2646 @@                    // Resolving the members of a class requires us to resolve the base class of that class.\n                    // We force resolution here such that we catch circularities now.\n                    resolveObjectOrUnionTypeMembers(baseConstructorType);\n                }\n                if (!popTypeResolution()) {"
  },
  {
    "id" : "36f854ad-7aeb-4c9f-8ec2-6319e2b9630f",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eaa24396-f4fc-4517-a623-0a6468bef67c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why does it need to be set to the unknown type? What happens if you just set it to the type you got?\n",
        "createdAt" : "2015-06-17T06:19:36Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a6b7032c-68a3-4562-9652-87790b9372bb",
        "parentId" : "eaa24396-f4fc-4517-a623-0a6468bef67c",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Or you could move this entire check to resolveBaseTypesOfClass\n",
        "createdAt" : "2015-06-17T06:25:35Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0193c7d8-fecd-483b-b922-252ccc281b78",
        "parentId" : "eaa24396-f4fc-4517-a623-0a6468bef67c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The unknown type signals that we've already reported an error so we don't get follow-on errors.\n",
        "createdAt" : "2015-06-17T14:36:50Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2650,2654 @@                if (baseConstructorType !== unknownType && baseConstructorType !== nullType && !isConstructorType(baseConstructorType)) {\n                    error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));\n                    return type.resolvedBaseConstructorType = unknownType;\n                }\n                type.resolvedBaseConstructorType = baseConstructorType;"
  },
  {
    "id" : "2e9f2cd6-69f3-4141-8e5d-08b6510591c8",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e315ee63-a9fb-4a70-8d56-ceee37ac27da",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Nice\n",
        "createdAt" : "2015-06-17T06:26:36Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +2684,2688 @@                // class and all return the instance type of the class. There is no need for further checks and we can apply the\n                // type arguments in the same manner as a type reference to get the same error reporting experience.\n                baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseContructorType.symbol);\n            }\n            else {"
  },
  {
    "id" : "a23d8c38-29b6-4101-9358-d670a1ed407d",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b499f77-dfaa-4aa1-857f-ee561a4b5be4",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "constructSignatures\n",
        "createdAt" : "2015-06-17T06:28:30Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +2690,2694 @@                // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere\n                // we check that all instantiated signatures return the same type.\n                let constructors = getInstantiatedConstructorsForTypeArguments(baseContructorType, baseTypeNode.typeArguments);\n                if (!constructors.length) {\n                    error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);"
  },
  {
    "id" : "7ff908a2-b733-4477-8b88-afb0f2bccca6",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "30d85ad8-c3d3-40d7-b34a-46548227177e",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Mention that you will report errors elsewhere for homogeneity of construct signatures.\n",
        "createdAt" : "2015-06-17T06:29:58Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +2695,2699 @@                    return;\n                }\n                baseType = getReturnTypeOfSignature(constructors[0]);\n            }\n            if (baseType === unknownType) {"
  },
  {
    "id" : "d3af0764-b2dd-44ac-aa8c-ab1e50eb1255",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6291c7e-2c8c-46e2-b930-04df84a994c4",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Maybe you should only show this error if there is no base constructor type. That way you can avoid cascading errors here.\n",
        "createdAt" : "2015-06-17T07:07:00Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "7f6cf224-e0b4-4cd8-8d8b-f19c2d145f3c",
        "parentId" : "c6291c7e-2c8c-46e2-b930-04df84a994c4",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, that might be better.\n",
        "createdAt" : "2015-06-17T14:39:15Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5963,5967 @@            let baseClassType = classType && getBaseTypes(classType)[0];\n\n            if (!baseClassType) {\n                if (!classDeclaration || !getClassExtendsHeritageClauseElement(classDeclaration)) {\n                    error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class);"
  },
  {
    "id" : "a15131af-8240-4a1c-914b-a1e13085213a",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "533f9fd5-c520-4ead-8a0c-d1a943e35dde",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This was just computed above on line 10591. Is it possible to reuse it?\n",
        "createdAt" : "2015-06-17T07:11:59Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "90f4c8d0-a0f7-4940-8f50-5b059fe79faf",
        "parentId" : "533f9fd5-c520-4ead-8a0c-d1a943e35dde",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Well, here we're looking at the _instantiated_ constructors. We could potentially cache the uninstantiated constructors, but I don't think it is worth the effort.\n",
        "createdAt" : "2015-06-17T14:41:51Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "f1ce4d41-f37f-48ad-9483-065ad392e695",
        "parentId" : "533f9fd5-c520-4ead-8a0c-d1a943e35dde",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh true, I missed that.\n",
        "createdAt" : "2015-06-17T18:09:12Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +10611,10615 @@                        // references (as opposed to checking the structure of the types) because elsewhere we have already checked\n                        // that the base type is a class or interface type (and not, for example, an anonymous object type).\n                        let constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments);\n                        if (forEach(constructors, sig => getReturnTypeOfSignature(sig) !== baseType)) {\n                            error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);"
  },
  {
    "id" : "2b6cf9d1-d57d-4ffa-9f87-332d2b1e9d48",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77113dde-1cc7-4872-849d-4dcfd5f318fc",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't think types are usually compared by reference equality when checking a type system rule. Probably the correct thing here is to use isTypeIdenticalTo.\n",
        "createdAt" : "2015-06-17T07:14:00Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d8882c6f-459b-42d6-aedc-d3cc10dc2e8d",
        "parentId" : "77113dde-1cc7-4872-849d-4dcfd5f318fc",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "In `resolveBaseTypesOfClass` we validate that the base is a class or interface type (and not, for example, an anonymous object type). Here we want to validate that they all reference the same class or interface type, and that could only be the case if their object identities are equal.\n",
        "createdAt" : "2015-06-17T14:48:08Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4269c67a-e9f1-460f-8d9c-dc5b19852716",
        "parentId" : "77113dde-1cc7-4872-849d-4dcfd5f318fc",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "In that case, seems like you maybe want to check that their symbols are equal. And that their type argument lists are the same. So I see why you checked it like this. Maybe comment that this is a shortcut.\n",
        "createdAt" : "2015-06-17T18:11:06Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +10612,10616 @@                        // that the base type is a class or interface type (and not, for example, an anonymous object type).\n                        let constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments);\n                        if (forEach(constructors, sig => getReturnTypeOfSignature(sig) !== baseType)) {\n                            error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);\n                        }"
  },
  {
    "id" : "116a840b-3103-4cc2-bddf-f727df28b494",
    "prId" : 3516,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "603f4f6b-8082-48e6-9078-d949501af5c2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This line is pretty dense. Can you break it up into multiple statements?\n",
        "createdAt" : "2015-06-17T07:18:26Z",
        "updatedAt" : "2015-06-17T21:18:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5b9a1b5e20696be8c6e27480cd43034f74fbac34",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12014,12018 @@                // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the\n                // extends clause of a class. We handle that case here.\n                return getBaseTypes(<InterfaceType>getDeclaredTypeOfSymbol(getSymbolOfNode(node.parent.parent)))[0];\n            }\n"
  },
  {
    "id" : "4c3797d7-a53a-41a8-8772-49202caa78e3",
    "prId" : 3452,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1698cd98-ae23-4575-a504-00308603a64c",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What is with this brace?\n",
        "createdAt" : "2015-06-09T20:51:55Z",
        "updatedAt" : "2015-06-12T20:58:17Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d4a8fa4e-b804-41a0-9e07-5045cb1ee754",
        "parentId" : "1698cd98-ae23-4575-a504-00308603a64c",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "That is a white space management error\n",
        "createdAt" : "2015-06-09T21:25:21Z",
        "updatedAt" : "2015-06-12T20:58:17Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "aeda84704c672094c71df5afae4b092d5c69f1cb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5219,5223 @@                    depth--;\n                }\n            }\n\n            function inferFromProperties(source: Type, target: Type) {"
  },
  {
    "id" : "0354b81a-92f5-44b6-ab3f-6de0e599469c",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35d211dc-d7e3-4816-ac98-66de0f56f8ab",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think this diff is wrong.\n",
        "createdAt" : "2015-06-05T23:25:10Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3893,3897 @@                case SyntaxKind.TypePredicate:\n                    return booleanType;\n                case SyntaxKind.ExpressionWithTypeArguments:\n                    return getTypeFromTypeReference(<ExpressionWithTypeArguments>node);\n                case SyntaxKind.TypeQuery:"
  },
  {
    "id" : "a5431e0c-1113-4f5e-ad1c-55458409739d",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e017b16-39a7-48ab-b452-b0850b26da8c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This diff is completely incorrect.\n",
        "createdAt" : "2015-06-05T23:27:36Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8983,8987 @@                // Do type argument local checks only if referenced type is successfully resolved\n                let symbol = getNodeLinks(node).resolvedSymbol;\n                let typeParameters = symbol.flags & SymbolFlags.TypeAlias ? getSymbolLinks(symbol).typeParameters : (<TypeReference>type).target.localTypeParameters;\n                let len = node.typeArguments.length;\n                for (let i = 0; i < len; i++) {"
  },
  {
    "id" : "29c83651-8f4c-431b-ae5e-5f453438d716",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6279be6d-d709-4ce4-86ad-f63b234df942",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What happened to our fun optimization?\n",
        "createdAt" : "2015-06-05T23:38:31Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "c01ca9bc-1f9c-4ae5-93c7-1597f5395850",
        "parentId" : "6279be6d-d709-4ce4-86ad-f63b234df942",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It is still there, I just simplified the code. If the declared type has no _local_ type parameters, we simply return the declared type (which may still have _outer_ type parameters).\n",
        "createdAt" : "2015-06-06T15:04:48Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3552,3556 @@                // supplied as type arguments and the type reference only specifies arguments for the local type parameters\n                // of the class or interface.\n                return createTypeReference(<GenericType>type, concatenate((<InterfaceType>type).outerTypeParameters,\n                    map(node.typeArguments, getTypeFromTypeNode)));\n            }"
  },
  {
    "id" : "fb3af4e0-eba5-4463-b621-7e44fb1dae4f",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c35d4003-ad66-4aff-8140-fead00596d9a",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Where do we check that the type parameter reference does not have type arguments?\n",
        "createdAt" : "2015-06-05T23:51:20Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3610,3614 @@                let symbol = typeNameOrExpression && resolveEntityName(typeNameOrExpression, SymbolFlags.Type) || unknownSymbol;\n                let type = symbol === unknownSymbol ? unknownType :\n                    symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) ? getTypeFromClassOrInterfaceReference(node, symbol) :\n                    symbol.flags & SymbolFlags.TypeAlias ? getTypeFromTypeAliasReference(node, symbol) :\n                    getTypeFromNonGenericTypeReference(node, symbol);"
  },
  {
    "id" : "4bc3db10-e692-4f44-9f3d-c96ef876e4a6",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d25c0bb8-32c2-4050-8f87-b899be9bd7e1",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Looks like we may now accidentally allow type arguments to enums, aliases, and type parameters.\n",
        "createdAt" : "2015-06-05T23:54:34Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0da4fab7-70d4-4204-820f-98adfd3f987d",
        "parentId" : "d25c0bb8-32c2-4050-8f87-b899be9bd7e1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "You're right. Will fix. Guess we have no tests for that.\n",
        "createdAt" : "2015-06-06T15:10:48Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "f28f7607-221d-4826-9b60-124e3bb658f3",
        "parentId" : "d25c0bb8-32c2-4050-8f87-b899be9bd7e1",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'm not surprised. It is not an obvious case to test. Can you add tests for this as well?\n",
        "createdAt" : "2015-06-06T22:44:54Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3612,3616 @@                    symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) ? getTypeFromClassOrInterfaceReference(node, symbol) :\n                    symbol.flags & SymbolFlags.TypeAlias ? getTypeFromTypeAliasReference(node, symbol) :\n                    getTypeFromNonGenericTypeReference(node, symbol);\n                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed in when we check the\n                // type reference in checkTypeReferenceOrExpressionWithTypeArguments."
  },
  {
    "id" : "52881a17-4ff8-4b1c-9079-120686c0a0d7",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f59032aa-fe87-4fe5-8416-548bde14312e",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "The resolvedSymbol should already be cached on the node links of `typeNameOrExpression`. I would say just call `resolveEntityName` on that in `checkTypeReferenceOrExpressionWithTypeArguments`. Seems more elegant than special casing this here.\n",
        "createdAt" : "2015-06-06T00:00:55Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "11ea4c43-4c77-40d2-a8b1-9e5229b0fe7d",
        "parentId" : "f59032aa-fe87-4fe5-8416-548bde14312e",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "But I do see why you did it that way.\n",
        "createdAt" : "2015-06-06T00:01:38Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b6adc1ab-c8a4-48c0-9549-13c9939649ce",
        "parentId" : "f59032aa-fe87-4fe5-8416-548bde14312e",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, the resolved symbol isn't cached by `resolveEntityName`, so we'd end up doing the work twice.\n",
        "createdAt" : "2015-06-06T15:12:31Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3615,3619 @@                // Cache both the resolved symbol and the resolved type. The resolved symbol is needed in when we check the\n                // type reference in checkTypeReferenceOrExpressionWithTypeArguments.\n                links.resolvedSymbol = symbol;\n                links.resolvedType = type;\n            }"
  },
  {
    "id" : "087ee0f0-181a-4fa6-997b-c0dcb9136453",
    "prId" : 3397,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c96925d6-f3c1-488f-86bc-6354547e9bd9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems like this error check is being done in 3 places. Can they be consolidated into one check in getTypeFromTypeReference?\n",
        "createdAt" : "2015-06-06T23:02:02Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ef9ebbc6-2371-49d5-a7b3-62f2b7b0f400",
        "parentId" : "c96925d6-f3c1-488f-86bc-6354547e9bd9",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Not easily since we fan out based on symbol kind and only during that processing figure out if the type requires type arguments or not. Best we could do is a helper we call in the 3 places, but it doesn't really seem to be worth it.\n",
        "createdAt" : "2015-06-07T00:24:48Z",
        "updatedAt" : "2015-06-09T13:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "cd595739081d63577460a93442bda73dbb3ad2f9",
    "line" : 178,
    "diffHunk" : "@@ -1,1 +3595,3599 @@            }\n            if (node.typeArguments) {\n                error(node, Diagnostics.Type_0_is_not_generic, symbolToString(symbol));\n                return unknownType;\n            }"
  },
  {
    "id" : "c226b469-cb47-4dde-9755-c7ee3c71b178",
    "prId" : 3351,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e9b21e1-11e8-4754-b918-e74693d7e776",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd move this into `utilities.ts`\n",
        "createdAt" : "2015-06-02T23:21:45Z",
        "updatedAt" : "2015-06-02T23:21:45Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "7ef2cfeaebe48dc6e996f56b4d917591c0c9996a",
    "line" : 19,
    "diffHunk" : "@@ -1,1 +3199,3203 @@        }\n\n        function isOptionalParameter(node: ParameterDeclaration) {\n            return hasQuestionToken(node) || !!node.initializer;\n        }"
  },
  {
    "id" : "f2dd7848-e868-462a-ac6f-2140f61a3d89",
    "prId" : 3333,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e244764f-7eb3-4918-bea0-c2cad809862f",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Same here, you can just check `symbol.flags & SymbolFlags.Class`.\n",
        "createdAt" : "2015-06-03T18:49:13Z",
        "updatedAt" : "2015-07-02T17:34:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "732fdab2-184f-42f3-a61c-59de4b971a1e",
        "parentId" : "e244764f-7eb3-4918-bea0-c2cad809862f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Again, need to check if the class is in an ambient context\n",
        "createdAt" : "2015-06-03T20:25:08Z",
        "updatedAt" : "2015-07-02T17:34:17Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "6de14d2f-b7d6-441b-a30e-447c8983a72d",
        "parentId" : "e244764f-7eb3-4918-bea0-c2cad809862f",
        "authorId" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "body" : "This doesn't work for \n\n``` ts\ninterface I {}\ndeclare class I {}\nmodule I {}\n```\n\nSince the module occupies the value space, the blanket check looking at the symbol will trigger an error, but the merge should be able to go through.\n",
        "createdAt" : "2015-06-03T21:19:37Z",
        "updatedAt" : "2015-07-02T17:34:17Z",
        "lastEditedBy" : "59507247-4932-40ea-95c5-8eabb0b1de63",
        "tags" : [
        ]
      }
    ],
    "commit" : "3af3177fe3bae91761611fa419aedaaf5842080e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12322,12326 @@                        }\n                    }\n                }\n            }\n            forEach(getInterfaceBaseTypeNodes(node), heritageElement => {"
  },
  {
    "id" : "6810fa8a-1a32-49e7-9861-650be8705ac6",
    "prId" : 3316,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56a7b9a4-ce07-4c8c-bd50-c72be058ec93",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't think this is necessary because you only refer to `symbol` once\n",
        "createdAt" : "2015-06-01T18:13:29Z",
        "updatedAt" : "2015-06-03T21:16:42Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "06d8d606-d9f5-4382-bbdc-bf0d92f61e91",
        "parentId" : "56a7b9a4-ce07-4c8c-bd50-c72be058ec93",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Not sure what you mean. It is referenced in a loop that will run at least 10 times (as we known depth >= 10).\n",
        "createdAt" : "2015-06-01T18:16:42Z",
        "updatedAt" : "2015-06-03T21:16:42Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "498e86e6-d31f-4eb8-8f00-afa198ba5bb6",
        "parentId" : "56a7b9a4-ce07-4c8c-bd50-c72be058ec93",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I mean just once lexically. I didn't know the runtime references count individually wrt to local vars.\n",
        "createdAt" : "2015-06-01T18:18:48Z",
        "updatedAt" : "2015-06-03T21:16:42Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "87d43aa6f5cc0bb434bd606defba8588c487b8f3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4428,4432 @@                // We track type references (created by createTypeReference) and instantiated types (created by instantiateType)\n                if (type.flags & (TypeFlags.Reference | TypeFlags.Instantiated) && depth >= 10) {\n                    let symbol = type.symbol;\n                    let count = 0;\n                    for (let i = 0; i < depth; i++) {"
  },
  {
    "id" : "cdd9e19a-b7db-4420-974f-3e6170ace5a1",
    "prId" : 3316,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f901fa31-b25f-4711-a3d5-de00ba46b432",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Please put a comment here saying what Reference and Instantiated each refer to.\n",
        "createdAt" : "2015-06-01T18:34:45Z",
        "updatedAt" : "2015-06-03T21:16:42Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "87d43aa6f5cc0bb434bd606defba8588c487b8f3",
    "line" : 287,
    "diffHunk" : "@@ -1,1 +4432,4436 @@                    for (let i = 0; i < depth; i++) {\n                        let t = stack[i];\n                        if (t.flags & (TypeFlags.Reference | TypeFlags.Instantiated) && t.symbol === symbol) {\n                            count++;\n                            if (count >= 10) return true;"
  },
  {
    "id" : "10eec5f7-3bb8-400b-ae79-18cd15de7b6c",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80f7534d-f0bd-4b35-940f-390a4ec498e5",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "You could just move this check outside the loop.\n\n``` TypeScript\nif (!typeParameters && declarations.length > 0) {\n    typeParameters = [];\n}\n```\n",
        "createdAt" : "2015-05-26T21:04:12Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "88b931c3-619a-432e-a4a5-f967019d5969",
        "parentId" : "80f7534d-f0bd-4b35-940f-390a4ec498e5",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "What's there is more efficient because it creates the single element array in one go vs. first creating an empty array and then pushing.\n",
        "createdAt" : "2015-05-26T21:10:48Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "f98d7cab-644b-4dc4-80bd-c7010173651c",
        "parentId" : "80f7534d-f0bd-4b35-940f-390a4ec498e5",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Based on what this function does, it looks like it should really be written as:\n\n``` ts\nfunction appendTypeParameters(declarations: TypeParameterDeclaration[], typeParameters?: TypeParameters[]) {\n...\n```\n\nThe declarations are the actual input.  The 'typeParameters' array is the output.  We don't generally put output parameters before intput parameters.  Also, as the second parameter is optional (based on the `!typeParameters` check), we should likely mark it as such.\n",
        "createdAt" : "2015-05-26T22:32:50Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "23b70496-a8e7-4d6c-862f-74d88be9328f",
        "parentId" : "80f7534d-f0bd-4b35-940f-390a4ec498e5",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, `typeParameters` is the object being operated on, but its allocation is deferred and never happens if there are no type parameters.\n",
        "createdAt" : "2015-05-26T23:00:00Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "0d4bbcae-94e1-4fbf-9643-c2106bbe5cb4",
        "parentId" : "80f7534d-f0bd-4b35-940f-390a4ec498e5",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "@ahejlsberg It would be best to document that for consumers so that they can quickly eye the function and know this.\n",
        "createdAt" : "2015-05-26T23:21:56Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2522,2526 @@            for (let declaration of declarations) {\n                let tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration));\n                if (!typeParameters) {\n                    typeParameters = [tp];\n                }"
  },
  {
    "id" : "4403e373-b797-4d94-8cc8-cf03b1f0ea14",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2dad178-5f92-4334-8a5a-9b14d8232728",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Space before `{`\n",
        "createdAt" : "2015-05-26T21:05:15Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "0daa5c9a-c05d-4ad1-9722-8bd9408fa8c5",
        "parentId" : "c2dad178-5f92-4334-8a5a-9b14d8232728",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This is the &_(@#$&(_ auto formatting. Are we ever going to fix that bug?\n",
        "createdAt" : "2015-05-26T21:11:32Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "2c0996e9-65ad-4647-a480-1063ad9e11d4",
        "parentId" : "c2dad178-5f92-4334-8a5a-9b14d8232728",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I couldn't find the corresponding issue, so I filed #3269.\n",
        "createdAt" : "2015-05-26T21:17:02Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e961c562-3ce3-445a-ba74-649a9917336f",
        "parentId" : "c2dad178-5f92-4334-8a5a-9b14d8232728",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Which is a duplicate of #2628.\n",
        "createdAt" : "2015-05-26T21:38:28Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2535,2539 @@        // allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set in-place and\n        // returns the same array.\n        function appendOuterTypeParameters(typeParameters: TypeParameter[], node: Node): TypeParameter[]{\n            while (true) {\n                node = node.parent;"
  },
  {
    "id" : "c08ade20-ebd1-4b17-a177-5970075852da",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7069f844-7970-4699-9dd7-805f2e980189",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "\"all declarations of the class\" - I'm a little confused, when can we get multiple declarations of a class?\n",
        "createdAt" : "2015-05-26T21:17:48Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "11f413c0-e974-47db-af6e-aeff74c5841b",
        "parentId" : "7069f844-7970-4699-9dd7-805f2e980189",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Unless you mean all class and interface declarations of a symbol.\n",
        "createdAt" : "2015-05-26T21:19:12Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d72041c9-00c4-4809-acc1-7a48740534a7",
        "parentId" : "7069f844-7970-4699-9dd7-805f2e980189",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We currently only permit multiple declarations of interfaces, but we'll likely allow it for ambient classes as part of the work of changing the core type declarations in lib.d.ts to use class declarations.\n",
        "createdAt" : "2015-05-26T21:21:10Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +2558,2562 @@        }\n\n        // The local type parameters are the combined set of type parameters from all declarations of the class or interface.\n        function getLocalTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] {\n            let result: TypeParameter[];"
  },
  {
    "id" : "2d2530b8-21ac-49c0-b180-3ab0e7a05c71",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "91fe59d4-75ce-4551-9be7-c9a32dd5d6b9",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "can you use two newlines after { after a wrapped conditional.  Right now what happens is that hte next statement is indented exactly as far as the conditional, making it look like it continues the conditional.  Providing the extra newline makes it clear that this is a statement inside the body of the code, and is not part of the if-expression.\n",
        "createdAt" : "2015-05-26T22:34:22Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 122,
    "diffHunk" : "@@ -1,1 +2543,2547 @@                if (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.FunctionDeclaration ||\n                    node.kind === SyntaxKind.FunctionExpression || node.kind === SyntaxKind.MethodDeclaration ||\n                    node.kind === SyntaxKind.ArrowFunction) {\n                    let declarations = (<ClassDeclaration | FunctionLikeDeclaration>node).typeParameters;\n                    if (declarations) {"
  },
  {
    "id" : "ccdd0c72-c61f-41a7-9a9c-a024fad62ff8",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "713a9f25-d028-451c-8ef9-9c791689d736",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "named parameter for the \"undefined\".\n",
        "createdAt" : "2015-05-26T22:49:15Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 134,
    "diffHunk" : "@@ -1,1 +2555,2559 @@        function getOuterTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] {\n            var kind = symbol.flags & SymbolFlags.Class ? SyntaxKind.ClassDeclaration : SyntaxKind.InterfaceDeclaration;\n            return appendOuterTypeParameters(undefined, getDeclarationOfKind(symbol, kind));\n        }\n"
  },
  {
    "id" : "bd227dd5-3723-49a2-a71b-ddbb0a892db6",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f055fefb-faf4-4ebc-b853-627b8160df1c",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Consider: extract common helper for checking that the parent is a module or source file (repeated above as well, as well as in \"shouldWriteTypeOfFunctionSymbol\", \"checkGrammarModifiers\", \"checkGrammarStatementInAmbientContext\", ).\n",
        "createdAt" : "2015-05-26T22:53:01Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 316,
    "diffHunk" : "@@ -1,1 +12510,12514 @@                case SyntaxKind.EnumDeclaration:\n                    if (node.modifiers && (node.modifiers.length > 1 || node.modifiers[0].kind !== SyntaxKind.ConstKeyword) &&\n                        node.parent.kind !== SyntaxKind.ModuleBlock && node.parent.kind !== SyntaxKind.SourceFile) {\n                        return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here);\n                    }"
  },
  {
    "id" : "e0b735c2-09dd-4795-bba0-2520a0658d89",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72791c4f-d2c5-4271-9cbc-bac860c1704b",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Break into multiple checks.  The mix of `&&`s and `||`s make this difficult to read.\n",
        "createdAt" : "2015-05-26T22:53:38Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 315,
    "diffHunk" : "@@ -1,1 +12509,12513 @@                    break;\n                case SyntaxKind.EnumDeclaration:\n                    if (node.modifiers && (node.modifiers.length > 1 || node.modifiers[0].kind !== SyntaxKind.ConstKeyword) &&\n                        node.parent.kind !== SyntaxKind.ModuleBlock && node.parent.kind !== SyntaxKind.SourceFile) {\n                        return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here);"
  },
  {
    "id" : "d6175077-7daa-48cc-b702-3f48adbdad86",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why is this necessary? I thought block scope declarations (like local types) are in the `.locals` of the body, and not of the function itself. Shouldn't that fact make this automatically work out? If that is not true, I think it is a better solution than having this special case.\n\nIf this condition is necessary, then isn't this broken for let and const as well?\n",
        "createdAt" : "2015-05-28T08:24:33Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a17438e9-770a-4ce2-897d-157676bdcb2a",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Top-level block scoped declarations are always in the `locals` of the function itself. We need them to be in the same declaration space as parameters and top-level `var` and `function` declarations in order to properly detect collisions. I thought about having local types in a `locals` attached to the body, but it doesn't work when a symbol is declared both as a value and a type--you can't split one meaning off and put it in a different declaration space.\n",
        "createdAt" : "2015-05-28T13:11:01Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "17d69f3a-078a-44bc-9187-0225b7f51e77",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So a top level `let` in a function can collide with a parameter? If that is the case, can't local types be handled in the same place that we handle block scoped declarations? \n",
        "createdAt" : "2015-05-28T18:21:26Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "94123b80-5753-4a23-9b90-35cae955071b",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, a top-level `let` can collide with a parameter. I don't understand the second question.\n",
        "createdAt" : "2015-05-28T21:07:48Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "812375e2-07a8-4916-bd41-89f92fd14e96",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "My second question has to do with this case\n\n``` ts\nfunction f(x = a) {\n    let a = 0;\n}\n```\n\n`a` is not in scope where it is referenced in the parameter initializer. Yet it is in the locals of `f`. Presumably there is some logic to skip that symbol when we walk up, similar to what you've implemented here. My question is: Where is that logic, and can we combine your added logic with the logic for `let` and `const`?\n",
        "createdAt" : "2015-05-28T23:20:35Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "27657d3d-60a5-4aad-9788-ba19bc1b9b55",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "There is no logic to skip that symbol, but there is a check that x's initializer only reference identifiers declared before x (`checkParameterInitializer` in checker.ts).\n",
        "createdAt" : "2015-05-28T23:26:00Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "6fef264a-ccbf-4329-989d-a69dff3eca43",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh so a top level `let` declaration _is_ in scope in a parameter, it's just not a legal reference. Whereas local types are not even in scope in the parameters or return type. Is there a reason we chose a different behavior from top level block constructs?\n\n``` ts\ninterface Foo { }\nvar x: Foo;\nfunction bar(param: Foo = x) { // x reference is an error, but Foo references the outer interface\n    interface Foo {\n        prop;\n    }\n    var x: Foo;\n}\n```\n",
        "createdAt" : "2015-05-28T23:32:37Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a3743e4e-a050-4bb4-a4e5-21ddddd92c4a",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Initializers are evaluated _inside_ the function in the generated code. We therefore need identifiers in expressions to bind to locals, even if that is subsequently deemed an error. If the locals weren't in scope at all, the following would produce no errors, but it wouldn't actually work:\n\n``` typescript\nvar a = 1;\nfunction f(x = a) {  // We don't want this to bind to the global a\n    let a = 2;\n}\n```\n\nWe don't have any such problem with local types, so we can just take them out of scope.\n",
        "createdAt" : "2015-05-28T23:41:13Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "6086c058-e6aa-4984-8a8c-45f758e67f3f",
        "parentId" : "3402790b-141c-4c34-a26a-f98a1ea3a49d",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh okay. That makes sense, thanks for explaining. It might be worth adding a comment to that effect.\n",
        "createdAt" : "2015-05-28T23:43:05Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +348,352 @@                            !(result.flags & (SymbolFlags.Type & ~SymbolFlags.TypeParameter)) ||\n                            !isFunctionLike(location) ||\n                            lastLocation === (<FunctionLikeDeclaration>location).body) {\n                            break loop;\n                        }"
  },
  {
    "id" : "d2aeebce-550b-4860-8cee-bc0f7862d594",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Probably better to check SymbolFlags.Interface as well\n",
        "createdAt" : "2015-05-28T08:24:55Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a9718aaa-2b01-4c53-9ff7-bbab7b5ec8db",
        "parentId" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No need to: You can't declare classes or interfaces inside interfaces.\n",
        "createdAt" : "2015-05-28T13:13:56Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "471ad10e-66f5-49a5-80e7-462c9ce3d17f",
        "parentId" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I meant checking `symbol.flags & SymbolFlags.Interface`, in case the local type being declared is an interface. I didn't mean inside an interface.\n",
        "createdAt" : "2015-05-28T18:18:13Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b0496d0e-3bdd-491f-98cb-93d643180f72",
        "parentId" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Well, the method is only ever called for a class or interface, so if it isn't a class it must be an interface.\n",
        "createdAt" : "2015-05-28T21:05:52Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "53c703cb-8a00-4782-9961-3d947380a99e",
        "parentId" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Okay\n",
        "createdAt" : "2015-05-28T23:25:44Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "27539c3d-196c-4dca-b8f0-4ca23d23f6aa",
        "parentId" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "use `let` not `var`\n",
        "createdAt" : "2015-05-30T02:14:44Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1d7a64b7-f762-48ab-b5a3-503978895a94",
        "parentId" : "a35443bc-1dee-4d41-82c5-e51454b4b594",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "we'll probably need to come back to this when we do class expressions\n",
        "createdAt" : "2015-05-30T02:15:47Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 133,
    "diffHunk" : "@@ -1,1 +2554,2558 @@        // The outer type parameters are those defined by enclosing generic classes, methods, or functions.\n        function getOuterTypeParametersOfClassOrInterface(symbol: Symbol): TypeParameter[] {\n            var kind = symbol.flags & SymbolFlags.Class ? SyntaxKind.ClassDeclaration : SyntaxKind.InterfaceDeclaration;\n            return appendOuterTypeParameters(undefined, getDeclarationOfKind(symbol, kind));\n        }"
  },
  {
    "id" : "4eb99db6-2132-4aaf-bdd7-90b8b3861571",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why do the outer type parameters have to be supplied as type arguments to the TypeReference? Why can't we just create a type reference that doesn't have any mappings for the outer type parameters? All the mappers for the outer type parameters will just end up mapping things to themselves anyway.\n",
        "createdAt" : "2015-05-28T08:25:01Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0ad5410c-fc87-4850-bb5f-1f42e68c028e",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "That is true only for written type references. Type references created by instantiations will indeed end up having the type parameters mapped to different types. For example:\n\n``` typescript\nfunction f<T>() {\n    class C {\n        x: T;\n    }\n    var c: C;  // Really a C<T>\n    c = new C();\n    return c;\n}\nvar c = f<string>();  // Type of c is C<string>\nvar s = c.x;          // string\n```\n",
        "createdAt" : "2015-05-28T13:25:19Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "dadcce5c-e5f3-454f-ab4d-002825ce24c0",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, but why is it necessary to map them at all for written type references? Why can't we just have them unmapped, and then later in an instantiation, they will get mapped?\n",
        "createdAt" : "2015-05-28T18:16:04Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "18aec0bd-05bb-4271-a4f3-e996f517a612",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We would then need `instantiateType` to instantiate all local type declarations (because they potentially reference outer type parameters) which it isn't prepared to do. Also, if those local type declarations themselves have type parameters, we'd end up with type references where both the target and the type arguments need to be instantiated. These are all \"landmines\" for runaway generic instantiation that we could never detect. Right now, we can only detect runaway instantiations that originate in type references and only by making the outer type parameters be type parameters of the class/interface do we see all of them in one place.\n",
        "createdAt" : "2015-05-28T21:04:00Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "baf89512-adcf-4fef-b92c-645e35c9fd32",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I thought the appending of the outer type parameters to the type parameters of the class happens in getDeclaredTypeOfClassOrInterface. I was asking why type arguments need to be supplied for those outer type parameters. Why can't the type reference have these outer type parameters as type parameters, but with no type arguments for them. I thought that if an instantiation is missing type arguments for its type parameters, the mapper will just return the original type parameter.\n\nI think what I am asking is: Is not passing the outer type parameters as type arguments a suitable optimization?\n",
        "createdAt" : "2015-05-29T00:03:08Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "dc70881c-ba41-4f7b-8be1-998dfe4c6b1e",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Maybe it is easier to discuss this in person.\n",
        "createdAt" : "2015-05-29T00:04:35Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0be603e6-6ef1-4a37-ab30-b3ec5de6ea15",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We assume a 1:1 correspondence between type parameters and type arguments. One list can't be shorter than the other.\n",
        "createdAt" : "2015-05-29T00:08:34Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "37966918-104b-4536-b92b-cf3429a1e7d0",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ah I see. Can you put a comment saying that type parameters and type arguments need to be the same length? I didn't know the compiler required that.\n\nAlso, can you show an example of the new kind of runaway recursion problem you are talking about?\n",
        "createdAt" : "2015-05-29T00:34:17Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0422d395-c1d3-408c-a99e-c5ca7cfc244e",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Here's an example. Enjoy! The infinite expansion is stopped by our isDeeplyNestedGeneric check for type references, but I don't know of a mechanism that could stop what instantiateType would do.\n\n``` typescript\nfunction f<T>() {\n    class C {\n        x = f<C>();\n    }\n    return new C();\n}\nfunction g<T>() {\n    class D {\n        x = g<D>();\n    }\n    return new D();\n}\nvar a = f<string>();\nvar b = g<string>();\na = b;\nb = a;\n```\n",
        "createdAt" : "2015-05-29T00:57:17Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "36c28bb0-68bd-43cd-9cc9-73bb29fbbf33",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh how interesting! I see how the cyclic instantiation happens.\n\nBtw, I came up with another example of this, based on a combination of the example you just gave, and the one from #3237. It looks like this:\n\n``` ts\nfunction foo<T>() {\n    var z = foo();\n    var y: {\n        y2: typeof z\n    };\n    return y;\n}\n\n\nfunction bar<T>() {\n    var z = bar();\n    var y: {\n        y2: typeof z;\n    }\n    return y;\n}\n\nvar a = foo<number>();\nvar b = bar<number>();\na = b;\n```\n\nSeems to stack overflow for me. Does your change fix this?\n\nWhat's interesting here is that T is never referenced in foo or bar. Its mere presence causes us to instantiate infinitely. Although I admit I don't really understand what is going on here.\n\nPerhaps this is more related to #3237, because we don't reuse the mapper between signature instantiations.\n",
        "createdAt" : "2015-05-29T01:54:16Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "4195708f-9f21-4090-8a0a-459a84ff29e0",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, my change doesn't affect this. Looks like the issue is runaway recursion in `instantiateSignature`, similar to what we fixed for `instantiateType` in #3237. We should be able to fix it in the same way, except signatures don't currently have an `id` property. We might have to introduce one.\n",
        "createdAt" : "2015-05-29T03:23:21Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "3961ad45-6f57-4521-a643-b7536b879090",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Hmm. Even if we put in place a cache for already instantiated signatures, I think you can use this as the same kind of infinitely expanding generics device as type references. For example, `var z = foo<T[]>()` in the example above would continually create new signatures. Makes me think we need the same kind of infinite expansion protection in place as we have for type references. That could get rather painful.\n",
        "createdAt" : "2015-05-29T03:33:56Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "20c2454f-26cc-4eee-a2ae-600cabe0e8cf",
        "parentId" : "fa7d236f-7e28-4393-879a-d8eb0f898d06",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I've opened up #3309 for this\n",
        "createdAt" : "2015-05-30T01:15:40Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 232,
    "diffHunk" : "@@ -1,1 +3519,3523 @@                            if (type.flags & (TypeFlags.Class | TypeFlags.Interface) && type.flags & TypeFlags.Reference) {\n                                // In a type reference, the outer type parameters of the referenced class or interface are automatically\n                                // supplied as type arguments and the type reference only specifies arguments for the local type parameters\n                                // of the class or interface.\n                                let localTypeParameters = (<InterfaceType>type).localTypeParameters;"
  },
  {
    "id" : "7188a624-328b-42ae-8ad2-b1d28ee5af10",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81737381-66c7-4c17-b4bd-d54ad661052f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Is this for anonymous class expressions?\n",
        "createdAt" : "2015-05-30T20:16:51Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b35d645c-4bd6-4ad6-b11d-0497b923079c",
        "parentId" : "81737381-66c7-4c17-b4bd-d54ad661052f",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, it's for the anonymous type created for the static side of a class.\n",
        "createdAt" : "2015-05-30T20:56:39Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "7e1b9f0f-a53c-48e6-996a-4cc2160e282d",
        "parentId" : "81737381-66c7-4c17-b4bd-d54ad661052f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ah yes, because previously the static side of a class could never get instantiated.\n",
        "createdAt" : "2015-05-30T21:53:19Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 256,
    "diffHunk" : "@@ -1,1 +4010,4014 @@                }\n                if (type.flags & TypeFlags.Anonymous) {\n                    return type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) ?\n                        instantiateAnonymousType(<ObjectType>type, mapper) : type;\n                }"
  },
  {
    "id" : "cc41875b-eee4-4271-a3fb-ef75a0a4f02f",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3fc248dd-b144-49c1-b678-28f805f39ac0",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can you rename pos and end, or add a comment saying what the pos and end are referring to?\n",
        "createdAt" : "2015-05-30T22:01:36Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1535,1539 @@                }\n\n                function writeSymbolTypeReference(symbol: Symbol, typeArguments: Type[], pos: number, end: number) {\n                    // Unnamed function expressions, arrow functions, and unnamed class expressions have reserved names that\n                    // we don't want to display"
  },
  {
    "id" : "a03e8d8b-2feb-412e-a177-9b6309e8b559",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef40bc97-3ba6-458c-8ef3-2bedeaae88f9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why do you need to check this? What are the cases where you hit a reserved member name that has type parameters, causing you to need to print it?\n",
        "createdAt" : "2015-05-30T22:11:20Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "fb34ec95-e833-408c-a2ef-899742ffd4a6",
        "parentId" : "ef40bc97-3ba6-458c-8ef3-2bedeaae88f9",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "This happens with unnamed generic function expressions, generic arrow functions, and unnamed generic class expressions.\n",
        "createdAt" : "2015-05-30T23:47:49Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "3ff03555-2fc2-4a05-b616-562eb1d0182a",
        "parentId" : "ef40bc97-3ba6-458c-8ef3-2bedeaae88f9",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Okay, can you put it in a comment? Thanks\n",
        "createdAt" : "2015-05-31T00:05:46Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1538,1542 @@                    // Unnamed function expressions, arrow functions, and unnamed class expressions have reserved names that\n                    // we don't want to display\n                    if (!isReservedMemberName(symbol.name)) {\n                        buildSymbolDisplay(symbol, writer, enclosingDeclaration, SymbolFlags.Type);\n                    }"
  },
  {
    "id" : "61f3d824-1369-4397-be58-126a3e176a73",
    "prId" : 3266,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7b60c963-1cfb-4648-9775-f36fc0cf2f63",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think instead of `SymbolFlags.Type` you should pass `symbol.flags`. Though I admit, I don't know what it will do, and I'm really not sure. I'm just thinking in the case where it is a function with type parameters, it is not really a Type.\n",
        "createdAt" : "2015-05-30T22:14:05Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "98bb074e-68b4-4619-9540-7cb694017e33",
        "parentId" : "7b60c963-1cfb-4648-9775-f36fc0cf2f63",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "If anything it should be `SymbolFlags.Type` or `SymbolFlags.Value`, but I'd rather leave it the way it is. It has to do with how aliases are resolved, but I don't think it matters. The sooner we can clean up that cryptic stuff the better.\n",
        "createdAt" : "2015-05-31T00:02:26Z",
        "updatedAt" : "2015-05-31T00:11:47Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6f734d6edef5b168be800e25018a5d95d2abb949",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1539,1543 @@                    // we don't want to display\n                    if (!isReservedMemberName(symbol.name)) {\n                        buildSymbolDisplay(symbol, writer, enclosingDeclaration, SymbolFlags.Type);\n                    }\n                    if (pos < end) {"
  },
  {
    "id" : "e5ba974a-b186-4a9e-abfe-5e9709c97dd2",
    "prId" : 3262,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df9731d0-4c0e-4c3d-adef-ba5ae53b7141",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "`return -1`, right?\n",
        "createdAt" : "2015-06-08T20:14:59Z",
        "updatedAt" : "2015-06-08T23:54:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "efb701387e52ba2730fc2750f4e386d89b8e3234",
    "line" : 298,
    "diffHunk" : "@@ -1,1 +8618,8622 @@                    }\n                }\n            }\n            return -1;\n        }"
  },
  {
    "id" : "404c38a7-325f-44c8-83cd-7c9e7322d657",
    "prId" : 3249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aab575c8-930e-43a8-b7d6-169ed4a27b27",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Do we actually do this anywhere else? I think @RyanCavanaugh has had some objections in using `void` in a union type.\n",
        "createdAt" : "2015-05-22T05:49:20Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c7f36170-6a90-4305-bc4f-e527ca3e8955",
        "parentId" : "aab575c8-930e-43a8-b7d6-169ed4a27b27",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "This is consistent with the current definition for MethodDecorator in core.d.ts\n",
        "createdAt" : "2015-05-27T19:11:53Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "071ef34e49a181ac4ce35000ce9f706381df11bb",
    "line" : 752,
    "diffHunk" : "@@ -1,1 +9822,9826 @@                    let methodType = getTypeOfNode(node.parent);\n                    let descriptorType = createTypedPropertyDescriptorType(methodType);\n                    expectedReturnType = getUnionType([descriptorType, voidType]);\n                    break;\n            }"
  },
  {
    "id" : "860094de-15b0-4006-b6af-5583e0eca753",
    "prId" : 3249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "99aa68c2-e046-4357-ad53-1ed876eaf17a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Let's add\n\n``` TypeScript\n//\n// For a decorator, no argument should be susceptible to contextual typing\n// because decorators are applied to *declarations*, not expressions.\n```\n",
        "createdAt" : "2015-05-22T05:58:01Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "071ef34e49a181ac4ce35000ce9f706381df11bb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7588,7592 @@            // For a decorator, no arguments are susceptible to contextual typing due to the fact \n            // decorators are applied to a declaration by the emitter, and not to an expression.\n            let excludeArgument: boolean[];\n            if (!isDecorator) {\n                // We do not need to call `getEffectiveArgumentCount` here as it only"
  },
  {
    "id" : "e846464e-3034-46da-8114-51a17d9e5ed6",
    "prId" : 3249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2d3903ff-3150-4752-8254-16e409ac9b44",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "How will this work? You are saying that even in the case of decorators or tagged template expressions, you are going to check the expression given by the effective call arguments. But I don't think that is correct. You will get `decorator.expression` for all of these, which is not the argument you are trying to infer from. I think the `else` behavior was correct.\n",
        "createdAt" : "2015-05-24T05:01:29Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "071ef34e49a181ac4ce35000ce9f706381df11bb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7154,7158 @@                    // If the effective argument type is 'undefined', there is no synthetic type \n                    // for the argument. In that case, we should check the argument.\n                    if (argType === undefined) {\n                        // For context sensitive arguments we pass the identityMapper, which is a signal to treat all\n                        // context sensitive function expressions as wildcards"
  },
  {
    "id" : "c357d19c-4a2f-46f1-9292-09dbe44a5b65",
    "prId" : 3249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "16d332ed-7798-42e8-a558-8b122573b153",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What's the difference between error and reportError?\n",
        "createdAt" : "2015-05-24T05:06:51Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "bb1b753c-e95c-45da-80c0-8c5d7160ed60",
        "parentId" : "16d332ed-7798-42e8-a558-8b122573b153",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "`reportError` wraps the chained diagnostic for the decorator, see line 7229 in the modified source below. It is used in a few places, so I wrapped the logic in a function to remove redundancy.\n",
        "createdAt" : "2015-05-26T21:27:28Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "071ef34e49a181ac4ce35000ce9f706381df11bb",
    "line" : 549,
    "diffHunk" : "@@ -1,1 +7568,7572 @@            reorderCandidates(signatures, candidates);\n            if (!candidates.length) {\n                reportError(Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);\n                return resolveErrorCall(node);\n            }"
  },
  {
    "id" : "16c58ac4-adb1-4403-b3fc-eeda307dc85b",
    "prId" : 3249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f8b945af-833f-476c-bd6c-676ca243abdb",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't think you are using candidatesOutArray, are you?\n",
        "createdAt" : "2015-05-24T05:11:13Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ff6eedae-1af7-46db-825a-b60c772bf68b",
        "parentId" : "f8b945af-833f-476c-bd6c-676ca243abdb",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "It's passed from getResolvedSignature, to which I added Decorator for the sake of consistency.\n",
        "createdAt" : "2015-05-26T22:05:01Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "071ef34e49a181ac4ce35000ce9f706381df11bb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7944,7948 @@          * Resolves a decorator as if it were a call expression.\n          */\n        function resolveDecorator(node: Decorator, candidatesOutArray: Signature[]): Signature {\n            let funcType = checkExpression(node.expression);\n            let apparentType = getApparentType(funcType);"
  },
  {
    "id" : "9bba3bb2-2caf-4a86-830c-4052b935a080",
    "prId" : 3249,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d35f24c6-72bf-4398-9897-1333cee4d97f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "A lot of this code feels not really specific to decorators? Is there a way to reuse more of the code from resolveCallExpression and such?\n",
        "createdAt" : "2015-05-24T05:16:13Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d0f9f793-d595-459b-8e03-cf811659befc",
        "parentId" : "d35f24c6-72bf-4398-9897-1333cee4d97f",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Generally I'm using the same approach that resolveTaggedTemplateExpression uses, which avoids some of the work that resolveCallExpression does.\n",
        "createdAt" : "2015-05-26T21:29:15Z",
        "updatedAt" : "2015-06-23T22:26:50Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "071ef34e49a181ac4ce35000ce9f706381df11bb",
    "line" : 672,
    "diffHunk" : "@@ -1,1 +7952,7956 @@            \n            let callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);\n            if (funcType === anyType || (!callSignatures.length && !(funcType.flags & TypeFlags.Union) && isTypeAssignableTo(funcType, globalFunctionType))) {\n                return resolveUntypedCall(node);\n            }"
  },
  {
    "id" : "5177b66e-1e9b-4667-8fb9-d673c4d1eb73",
    "prId" : 3160,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c577630f-04d1-4865-a20d-6d3915d97b16",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "this code needs documentation.\n",
        "createdAt" : "2015-05-14T00:57:20Z",
        "updatedAt" : "2015-05-14T20:21:17Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "583e7b7b-285f-4fdc-b0cb-011de9259953",
        "parentId" : "c577630f-04d1-4865-a20d-6d3915d97b16",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Added a comment at https://github.com/Microsoft/TypeScript/commit/26f73d4dc89191fdc317f9e359a5035761413495\n",
        "createdAt" : "2015-05-14T20:21:59Z",
        "updatedAt" : "2015-05-14T20:22:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "26f73d4dc89191fdc317f9e359a5035761413495",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +2415,2419 @@            let links = getSymbolLinks(symbol);\n            if (!links.type) {\n                let targetSymbol = resolveAlias(symbol);\n\n                // It only makes sense to get the type of a value symbol. If the result of resolving"
  },
  {
    "id" : "7ae22499-4b8c-4a66-999b-7b9fe362efe6",
    "prId" : 3157,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ee7d3f9a-3258-442c-b3f3-0cec808e5e61",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "1. No error when we hit the circularity?  Or is that handled elsewhere?  If handled elsewhere, can you comment in the code where.\n2.  It seems like you're setting the reduced type to the type itself.  That seems... odd.  What's the intuition for why that's the appropriate type.\n",
        "createdAt" : "2015-05-14T00:05:32Z",
        "updatedAt" : "2015-05-15T17:24:33Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "ffb3bbfd-98ab-47d7-a4cf-c11a33549ec3",
        "parentId" : "ee7d3f9a-3258-442c-b3f3-0cec808e5e61",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Subtype reduction is basically an optimization we do to avoid excessively large union types, which take longer to process and look strange in quick info and error messages. Semantically there is no difference between the reduced type and the type itself. So, when we detect a circularity we simply say that the reduced type is the type itself.\n",
        "createdAt" : "2015-05-14T00:15:50Z",
        "updatedAt" : "2015-05-15T17:24:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "6e2a5ac8-850b-4487-a293-ad368aecd6eb",
        "parentId" : "ee7d3f9a-3258-442c-b3f3-0cec808e5e61",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "That makes sense.  We should definitely state this in the code itself with a comment of some sort.  It's not at all self-evident, and it's definitely important for the code to make this clear that this is expected and desirable behavior.\n",
        "createdAt" : "2015-05-14T00:19:49Z",
        "updatedAt" : "2015-05-15T17:24:33Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "194680f179497ea40208006f887cfbbe8e77391e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3643,3647 @@            }\n            else if (type.reducedType === circularType) {\n                type.reducedType = type;\n            }\n            return type.reducedType;"
  },
  {
    "id" : "87c5bffd-5a4b-4c95-b0b7-c01293ba849c",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7543027f-4296-4b67-8c05-d066232e65d7",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I guess this can just be a conditional operator\n",
        "createdAt" : "2015-05-13T21:53:51Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8626,8630 @@            if (func.body.kind !== SyntaxKind.Block) {\n                type = checkExpressionCached(<Expression>func.body, contextualMapper); \n                if (isAsync) {\n                    // From within an async function you can return either a non-promise value or a promise. Any \n                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so the "
  },
  {
    "id" : "34081923-69b1-44ca-8bb6-0d64d5b2c351",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72710b31-21ba-4f6d-8d6b-ad2a10b2bca9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yay, it looks just like getIteratedType!\n",
        "createdAt" : "2015-05-13T21:54:43Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : 373,
    "diffHunk" : "@@ -1,1 +10468,10472 @@          * @remarks The \"promised type\" of a type is the type of the \"value\" parameter of the \"onfulfilled\" callback.\n          */\n        function getPromisedType(promise: Type): Type {\n            //\n            //  { // promise"
  },
  {
    "id" : "eacacbfc-a06a-4d42-84e0-e80cc82fbc38",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5e4a4c1e-9728-41a0-bcce-220ed1346722",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "functions with \"create\" prefix always return a type. the ones with \"get\" can return undefined though. consider renaming this function.\n",
        "createdAt" : "2015-06-16T23:04:29Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +8604,8608 @@        }\n        \n        function createPromiseType(promisedType: Type): Type {\n            // creates a `Promise<T>` type where `T` is the promisedType argument\n            let globalPromiseType = getGlobalPromiseType();"
  },
  {
    "id" : "9a27e8dc-8564-4a62-b78c-632975f11305",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9fd84e59-fa4c-4497-9e55-2709db9da512",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "does not seem to be used. if so please remove it.\n",
        "createdAt" : "2015-06-16T23:46:49Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +108,112 @@        let globalESSymbolConstructorSymbol: Symbol;\n        \n        let getGlobalPromiseConstructorSymbol: () => Symbol;\n\n        let globalObjectType: ObjectType;"
  },
  {
    "id" : "96983052-99f1-433c-b875-cf5f6e9d3d45",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "94314bc9-2f1f-475e-a024-c705a19b1f19",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we have already reported the error. so i would not bother here re reporting.\n",
        "createdAt" : "2015-06-16T23:52:47Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +10633,10637 @@          */\n        function checkAsyncFunctionReturnType(node: FunctionLikeDeclaration): Type {\n            let globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType();\n            if (globalPromiseConstructorLikeType === emptyObjectType) {\n                // If we couldn't resolve the global PromiseConstructorLike type we cannot verify"
  },
  {
    "id" : "cc8b08e7-3ef5-4090-abc9-4df586dd1320",
    "prId" : 3078,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "401608a2-264c-46d4-94c7-3f3c89e69b3e",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "can we add a test for verifying that unwrapping union types behaves as expected:\n\n``` ts\nfunction foo(): MyPromise<number> | MyPromise<string>{\n    return undefined;\n}\n\nasync function bar(): MyPromise<number|string> {\n    return await foo();\n}\n```\n",
        "createdAt" : "2015-06-17T00:10:02Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "945c5883-f8d1-403e-ad21-50b8b1f9457c",
        "parentId" : "401608a2-264c-46d4-94c7-3f3c89e69b3e",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Is it even possible to unwrap a union type?\n",
        "createdAt" : "2015-06-17T00:23:18Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "43d70521-b513-4018-bab6-1b733684bb8f",
        "parentId" : "401608a2-264c-46d4-94c7-3f3c89e69b3e",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "For `await`, yes it should be.\n\nI will probably need to tinker with getAwaitedType a bit to work better with unions. What should happen is that I will need to get the awaited type for each constituent type in a union, and return the union of those types.\n\nConsider this example:\n\n``` ts\nfunction f(b: boolean): number | Promise<string> {\n  if (b) { \n    return 1;\n  }\n  else {\n    return Promise.resolve(\"text\");\n  }\n}\n\nasync function g(b: boolean) {\n  let x = await f(b); // x should have type `number | string`;\n}\n```\n",
        "createdAt" : "2015-06-17T23:47:04Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "51b3503e-3f90-432d-9149-7eefe55c389e",
        "parentId" : "401608a2-264c-46d4-94c7-3f3c89e69b3e",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes it would require explicit union logic, and would not fall out given the union logic we have today.\n",
        "createdAt" : "2015-06-18T00:12:09Z",
        "updatedAt" : "2015-07-01T16:27:56Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4b4a96b9dce97d02f9bcf5db3ff49e3045f3d23b",
    "line" : 431,
    "diffHunk" : "@@ -1,1 +10526,10530 @@          * Promise-like type; otherwise, it is the type of the expression. This is used to reflect\n          * The runtime behavior of the `await` keyword.\n          */\n        function getAwaitedType(type: Type) {\n            return checkAwaitedType(type, /*location*/ undefined, /*message*/ undefined);"
  },
  {
    "id" : "d1616659-4b91-411d-88f5-63af7fba5aef",
    "prId" : 3064,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ced22125-f5fb-4a9c-abc3-85b153e552e5",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Put an extra newline here so it looks separate from the prior two conditions\n",
        "createdAt" : "2015-05-07T18:20:29Z",
        "updatedAt" : "2015-05-07T18:27:53Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "69f94cde8e415d19be4835db4394d8e8ede87419",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5406,5410 @@                    }\n\n                    if (constructSignatures && constructSignatures.length) {\n                        targetType = getUnionType(map(constructSignatures, signature => getReturnTypeOfSignature(getErasedSignature(signature))));\n                    }"
  },
  {
    "id" : "42f06486-054e-481d-ace5-7ca5bfd0952f",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "07aff594-729e-40e0-a071-8d9404152945",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "So off the bat, I actually don't know what this is used for and what exactly it is. Can you leave a nice comment giving a \"visual\" analogue and some intuition behind it?\n",
        "createdAt" : "2015-05-14T20:25:01Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "53630d16-487d-41ad-8df7-3f362a726947",
        "parentId" : "07aff594-729e-40e0-a071-8d9404152945",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think you could just use `emptyObjectType` and add an `instantiations` property to it.\n",
        "createdAt" : "2015-05-14T22:46:33Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "ffb2479c-f148-43d4-94c4-509c9d0a654f",
        "parentId" : "07aff594-729e-40e0-a071-8d9404152945",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Okay, I can do that. I will still have to cast it though, in order to use it as a generic type.\n",
        "createdAt" : "2015-05-14T22:48:24Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "288f1a05-7328-4f05-b380-16038852a881",
        "parentId" : "07aff594-729e-40e0-a071-8d9404152945",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd actually prefer you kept the `emptyObjectType` separate.\n",
        "createdAt" : "2015-05-15T20:35:26Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "c30f7c0d-a522-4055-b232-e8430faefd9c",
        "parentId" : "07aff594-729e-40e0-a071-8d9404152945",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'm gonna have a separate variable, but I'll just assign it the same object.\n",
        "createdAt" : "2015-05-17T00:40:07Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "171b3852375d6d1f6cbb49c01e4e870bf77ac7b7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +92,96 @@\n        let emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n        let emptyGenericType = <GenericType><ObjectType>createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n        emptyGenericType.instantiations = {};\n"
  },
  {
    "id" : "9af6da78-e9a1-45ec-bf0d-e88edfbb1bff",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "56fc045e-f61a-4e52-a54e-2a59db53857f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Let's actually leave a comment because I'm still reading this wrong every time I look at it. Can you make the first parameter `globalType` and document that you're expecting it to take one type parameter?\n",
        "createdAt" : "2015-05-14T21:03:59Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "171b3852375d6d1f6cbb49c01e4e870bf77ac7b7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3515,3519 @@         * Instantiates a global type that is generic with some element type, and returns that instantiation.\n         */\n        function createTypeFromGenericGlobalType(genericGlobalType: GenericType, elementType: Type): Type {\n            return <ObjectType>genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, [elementType]) : emptyObjectType;\n        }"
  },
  {
    "id" : "50cb9f68-15d5-4aff-b8f4-f3475a3f9703",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c2e51b45-c933-4680-862a-b0f6b43679a8",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Add a newline above\n",
        "createdAt" : "2015-05-14T21:09:01Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "171b3852375d6d1f6cbb49c01e4e870bf77ac7b7",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5827,5831 @@            }\n\n            // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature\n            // and that call signature is non-generic, return statements are contextually typed by the return type of the signature\n            let signature = getContextualSignatureForFunctionLikeDeclaration(<FunctionExpression>functionDecl);"
  },
  {
    "id" : "9c11d124-e966-4621-8e6e-b32b4c928a07",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8a693442-a729-49c8-a769-070cffb86af6",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Are contextual types for object literal methods somehow connected to generators?\n",
        "createdAt" : "2015-05-14T22:53:33Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a95fdf51-3e44-4191-aa96-f93e5192a904",
        "parentId" : "8a693442-a729-49c8-a769-070cffb86af6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Not inherently. But I noticed the check was missing here, so I added it. Interestingly, this was not caught by any existing tests, but some of my generator tests did catch it.\n",
        "createdAt" : "2015-05-14T23:28:44Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "17e6554f-c335-4ae0-8b43-a2f90732bd32",
        "parentId" : "8a693442-a729-49c8-a769-070cffb86af6",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can you add existing tests for it that don't relate to generators then?\n",
        "createdAt" : "2015-05-15T20:37:14Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "aa7edd81-0bea-4cf1-8ce6-40b8927c08cd",
        "parentId" : "8a693442-a729-49c8-a769-070cffb86af6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Sure, I'll add my favorite kind of contextual typing test, one that causes fixing of a type parameter.\n",
        "createdAt" : "2015-05-17T00:41:22Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "7978c2c7-e19e-430c-96cf-3a3d7464c97f",
        "parentId" : "8a693442-a729-49c8-a769-070cffb86af6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Done\n",
        "createdAt" : "2015-05-20T22:36:53Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "171b3852375d6d1f6cbb49c01e4e870bf77ac7b7",
    "line" : 173,
    "diffHunk" : "@@ -1,1 +6046,6050 @@            // Only function expressions, arrow functions, and object literal methods are contextually typed.\n            return isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node)\n                ? getContextualSignature(<FunctionExpression>node)\n                : undefined;\n        }"
  },
  {
    "id" : "05a6725d-d905-499e-a6ac-0ea07528689f",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Why the explicit check for void?\n",
        "createdAt" : "2015-05-14T23:15:59Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "e8a14d67-de72-4d6b-aaf9-223188fe8f61",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It gives a better error message than just relying on assignability.\n",
        "createdAt" : "2015-05-14T23:18:59Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b2e5de7d-28b2-4869-b645-bfbf4689281d",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I don't think people are likely to write an explicit `void` type annotation on a generator. Much more likely would be a primitive type like `string` or `number` or whatever the generator yields, but we aren't doing anything special for those.\n",
        "createdAt" : "2015-05-14T23:30:39Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "b8585b3f-a83d-40e0-8cab-9b9feac87c83",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "True, but the default error message would make more sense for those primitives. For void, it wouldn't make sense because you are not declaring a return type, you're declaring the absence of a return. So to say it's not assignable to void sounds weird.\n",
        "createdAt" : "2015-05-14T23:33:25Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ea5af21c-535c-4fee-97d7-21d1767d5886",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "But the actual error message you see here would be something about `void` (or `string` or `number` or whatever) missing a `next` method, right? If we're fine reporting that for `string` and `number` then why not `void`. Or maybe I'm misunderstanding what the experience is in the error case.\n",
        "createdAt" : "2015-05-14T23:43:41Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "c96e8d97-2c3e-47cb-b657-635a6135499d",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It is about IterableIterator not being assignable to void.\n",
        "createdAt" : "2015-05-14T23:46:24Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8c5e3ddc-55f8-46b3-81f6-272f52a7c471",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "If you feel strongly I can remove this check, I just thought it would make the experience nicer.\n",
        "createdAt" : "2015-05-14T23:46:46Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "3df5255a-482d-4f4e-b0a0-bd9680df69cb",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think a common mistake is going to be annotating with the actual element type (instead of `IterableIterator<T>`). But when compiling this:\n\n``` typescript\nfunction *foo(): number {\n    yield 5;\n}\n```\n\nI get the error `Type 'IterableIterator<any>' is not assignable to type 'number'`. That seems like an odd experience. I would have expected something more along the lines of `'number' is not a proper iterator type`.\n",
        "createdAt" : "2015-05-15T00:04:05Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "8546c439-6f23-491b-9d97-dd361018dc27",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Well, you are allowed to write something that is an _iterator_ or an _iterable_ or both, or neither actually. You are allowed to write `{}`. You are just not allowed to write something like number because it has extra things that IterableIterator doesn't have.\n",
        "createdAt" : "2015-05-15T00:10:55Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "66e4e86a-c133-4606-b5dc-4ad132ca5a62",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Wait, why is the error `Type 'IterableIterator<any>' is not assignable to type 'number'`?\n\nTo clarify, I think it should be `'IterableIterator<number>'`.\n",
        "createdAt" : "2015-05-15T20:38:54Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "36330bb1-eb77-4ea1-a907-aea8c2a4ca36",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Discussed offline - @JsonFreeman suggested we can try using @ahejlsberg's suggested message as the head message for assignability.\n",
        "createdAt" : "2015-05-15T20:46:48Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "bb146e5e-7cb6-4b23-adf6-8e08f7889688",
        "parentId" : "aea631de-c58e-4152-a6f9-a8f6a3207479",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I will try to fix this later.\n",
        "createdAt" : "2015-05-20T22:55:54Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "171b3852375d6d1f6cbb49c01e4e870bf77ac7b7",
    "line" : 368,
    "diffHunk" : "@@ -1,1 +8405,8409 @@                        let returnType = getTypeFromTypeNode(node.type);\n                        if (returnType === voidType) {\n                            error(node.type, Diagnostics.A_generator_cannot_have_a_void_type_annotation);\n                        }\n                        else {"
  },
  {
    "id" : "8209a34d-656f-4a46-96e8-34acb0f36260",
    "prId" : 3031,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ccc782b8-c915-46f1-8ffe-c0434b11ecdf",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'm a little confused when to use `nodeIsPresent(node.body)` and checking for the presence of the field `node.body`.\n",
        "createdAt" : "2015-05-14T23:32:22Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "dd2925c6-cce6-45b1-8e94-4d83c72ab546",
        "parentId" : "ccc782b8-c915-46f1-8ffe-c0434b11ecdf",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It's the same except that nodeIsPresent also handles bodies of width 0. I guess in some error cases the parser may parse a body of width 0 if it is missing. But you're right, I was wondering the same thing too. If I didn't see the call above to nodeIsMissing, I would not have thought to call nodeIsPresent\n",
        "createdAt" : "2015-05-15T06:56:22Z",
        "updatedAt" : "2015-05-30T00:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "171b3852375d6d1f6cbb49c01e4e870bf77ac7b7",
    "line" : 402,
    "diffHunk" : "@@ -1,1 +9199,9203 @@                }\n\n                if (node.asteriskToken && nodeIsPresent(node.body)) {\n                    // A generator with a body and no type annotation can still cause errors. It can error if the\n                    // yielded values have no common supertype, or it can give an implicit any error if it has no"
  },
  {
    "id" : "9ef1480c-da36-4d7e-9672-7c5b8ed4ad28",
    "prId" : 2991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "981af7b7-e12c-4a70-8814-a97dc29dfdd8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why doesn't this one have to change to the new model?\n",
        "createdAt" : "2015-05-04T18:23:27Z",
        "updatedAt" : "2015-05-05T14:31:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "02b58b0c-3558-42b7-bf34-f8a1a1950077",
        "parentId" : "981af7b7-e12c-4a70-8814-a97dc29dfdd8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It is already guarded by the ContextChecked flag and will never be re-entered.\n",
        "createdAt" : "2015-05-04T19:44:55Z",
        "updatedAt" : "2015-05-05T14:31:52Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "eeb23ad96ec85385de335f13f40fc8f678f10da9",
    "line" : 262,
    "diffHunk" : "@@ -1,1 +7376,7380 @@                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);\n                        }\n                        if (!node.type && !signature.resolvedReturnType) {\n                            let returnType = getReturnTypeFromBody(node, contextualMapper);\n                            if (!signature.resolvedReturnType) {"
  },
  {
    "id" : "59f2f479-0081-4240-a2fc-3b9536df4b2a",
    "prId" : 2991,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83b3c0c1-37e3-433b-a359-5e7ce30de9ee",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I realize the target object only matters for identity of the result. But I'd rather have one type that gets pushed onto the stack. I noticed below, the things that get pushed can be of type Symbol, SymbolLinks or Signature. I would really prefer to converge on one type if possible, just to keep things organized.\n",
        "createdAt" : "2015-05-04T18:26:59Z",
        "updatedAt" : "2015-05-05T14:31:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8fd76b77-943e-41d5-807f-3b54f177a1a8",
        "parentId" : "83b3c0c1-37e3-433b-a359-5e7ce30de9ee",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Also, it seems very easy to pass in the same object from two different callers by mistake, even when tracking different properties. I wish we could pass a stronger proxy for the property, rather than passing a different owner object in a way that is unrelated to which property we want to track.\n",
        "createdAt" : "2015-05-04T18:55:05Z",
        "updatedAt" : "2015-05-05T14:31:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "eeb23ad96ec85385de335f13f40fc8f678f10da9",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2024,2028 @@        // SymbolLinks.type, SymbolLinks instances are used to track resolution of SymbolLinks.declaredType, and\n        // Signature instances are used to track resolution of Signature.resolvedReturnType.\n        function pushTypeResolution(target: Object): boolean {\n            let i = 0;\n            let count = resolutionTargets.length;"
  },
  {
    "id" : "d075b7d0-9344-4e40-a24e-1f5ee3e14d89",
    "prId" : 2969,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fd30e9c6-eb87-4fa9-996d-a0c4dce8f5d6",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'm not a huge fan of this name. I've talked it over with @mhegazy and @DanielRosenwasser, and it's probably better to keep this line as it was, instead of factoring it out.\n",
        "createdAt" : "2015-05-05T20:44:00Z",
        "updatedAt" : "2015-05-06T12:18:43Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "776f390786f1dc71236b4c124084a20da225d0ae",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +5365,5369 @@                        // If the current type is a union type, remove all constituents that aren't subtypes of the target.\n                        if (type.flags & TypeFlags.Union) {\n                            return getUnionTypeOfSubtypeConstituents(<UnionType>type, targetType);\n                        }\n                    }"
  },
  {
    "id" : "dc5c8d70-0b99-40c0-ad1f-c46b826995d4",
    "prId" : 2813,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "961e83bc-57b0-4126-aae1-134207f8a12a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "this can now be getTypeFromTypeNode to make things cleaner if you want.\n",
        "createdAt" : "2015-04-17T21:01:04Z",
        "updatedAt" : "2015-04-17T21:31:06Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9d8c67ab6f3aeef67a90ea80837cc74eb968f3f",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +2475,2479 @@            let baseTypeNode = getClassExtendsHeritageClauseElement(declaration);\n            if (baseTypeNode) {\n                let baseType = getTypeFromHeritageClauseElement(baseTypeNode);\n                if (baseType !== unknownType) {\n                    if (getTargetType(baseType).flags & TypeFlags.Class) {"
  },
  {
    "id" : "0711d468-5033-405b-8b23-5fe431a13c2a",
    "prId" : 2813,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "458a86e1-20f9-4906-8939-46f8db1c13ce",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "consider getTypeFromTypeNode.\n",
        "createdAt" : "2015-04-17T21:02:28Z",
        "updatedAt" : "2015-04-17T21:31:06Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "c9d8c67ab6f3aeef67a90ea80837cc74eb968f3f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2497,2501 @@                if (declaration.kind === SyntaxKind.InterfaceDeclaration && getInterfaceBaseTypeNodes(<InterfaceDeclaration>declaration)) {\n                    for (let node of getInterfaceBaseTypeNodes(<InterfaceDeclaration>declaration)) {\n                        let baseType = getTypeFromHeritageClauseElement(node);\n\n                        if (baseType !== unknownType) {"
  },
  {
    "id" : "876424ad-007f-4f54-a7f7-f0adb17d60dc",
    "prId" : 2805,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a380595-0fb6-4f56-816d-3f856b7a2e9f",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Would `hasExternalModuleSymbol` help you out at all?\n\nI notice we do this `name.kind === SyntaxKind.StringLiteral` thing a lot. Can we abstract this to a helper function?\n",
        "createdAt" : "2015-04-16T23:49:48Z",
        "updatedAt" : "2015-04-17T17:16:59Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e73827ff-2766-4646-abc3-1ee15b19f9d8",
        "parentId" : "5a380595-0fb6-4f56-816d-3f856b7a2e9f",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "We should. will get that in a different commit.\n",
        "createdAt" : "2015-04-17T00:02:50Z",
        "updatedAt" : "2015-04-17T17:16:59Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "3298327ad0890839881f79be8e6c775ce0b95206",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +351,355 @@                        }\n                        else if (location.kind === SyntaxKind.SourceFile ||\n                            (location.kind === SyntaxKind.ModuleDeclaration && (<ModuleDeclaration>location).name.kind === SyntaxKind.StringLiteral)) {\n                            result = getSymbol(getSymbolOfNode(location).exports, \"default\", meaning & SymbolFlags.ModuleMember);\n                            let localSymbol = getLocalSymbolForExportDefault(result);"
  },
  {
    "id" : "22113696-7512-44ff-8a02-d59fef8516d9",
    "prId" : 2756,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d8dd79d0-91aa-49fc-8a97-5d646b23b7f6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "What were we getting before? `unknownType`?\n",
        "createdAt" : "2015-04-14T02:45:22Z",
        "updatedAt" : "2015-04-14T02:45:22Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "aeca0669-14e7-4be8-be21-3852dc35fb13",
        "parentId" : "d8dd79d0-91aa-49fc-8a97-5d646b23b7f6",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "undefined. causing a crash later on.\n",
        "createdAt" : "2015-04-14T02:53:35Z",
        "updatedAt" : "2015-04-14T02:53:35Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "fe75002450440b5b091fbd4991d5e11410eb08ab",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +9415,9419 @@                let indexType = getIndexTypeOfType(inputType, IndexKind.Number);\n                if (indexType) {\n                    return indexType;\n                }\n            }"
  },
  {
    "id" : "0ba1611c-0de5-4b2b-8e9c-123648910d86",
    "prId" : 2750,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "20c55aa9-7864-44ab-af01-5c5ca0f8f053",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I don't think this is correct when the containers are internal modules that get merged.\n\n``` ts\nmodule container {\n    export class clodule { }\n}\nmodule container {\n    export module clodule { ; }\n}\n```\n\nThese don't have the same block scope container do they? Yet you want to elide the var declaration when you emit the module portion.\n",
        "createdAt" : "2015-04-14T18:14:23Z",
        "updatedAt" : "2015-04-15T06:23:07Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "2133021e-b393-4f0b-8ef1-b74273fdea7e",
        "parentId" : "20c55aa9-7864-44ab-af01-5c5ca0f8f053",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "This should be correct, as the class and module have differing block scopes. I do not want to elide the `var` when I emit the module in your example, otherwise the emit would be:\n\n``` js\nvar container;\n(function (container) {\n  class clodule { }\n  container.clodule = clodule;\n})(container || (container = {});\n\nvar container;\n(function (container) {\n  (function (clodule) {\n    ;\n  })(clodule = container.clodule || (container.clodule = {})); // error: 'clodule' is not defined\n})(container || container = {});\n```\n\nWe need to emit the `var` here, to ensure a local variable for `clodule` is in scope:\n\n``` js\nvar container;\n(function (container) {\n  class clodule { }\n  container.clodule = clodule;\n})(container || (container = {});\n\nvar container;\n(function (container) {\n  var clodule; // will not collide with the lexical declaration above.\n  (function (clodule) {\n    ;\n  })(clodule = container.clodule || (container.clodule = {})); \n})(container || container = {});\n```\n",
        "createdAt" : "2015-04-15T01:18:51Z",
        "updatedAt" : "2015-04-15T06:23:07Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      },
      {
        "id" : "79f8f4b3-fcf7-4253-8bb2-bd3f5ed5336b",
        "parentId" : "20c55aa9-7864-44ab-af01-5c5ca0f8f053",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh I see what you mean. I forgot we emit a local for an exported module.\n",
        "createdAt" : "2015-04-15T18:01:32Z",
        "updatedAt" : "2015-04-15T18:01:32Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eb0a3abab71f933b8bfb50ca9e94505926b305e",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +10400,10404 @@        }\n\n        function inSameLexicalScope(node1: Node, node2: Node) {\n            let container1 = getEnclosingBlockScopeContainer(node1);\n            let container2 = getEnclosingBlockScopeContainer(node2);"
  },
  {
    "id" : "cc188d2e-62e0-4b6a-9e25-38b902500114",
    "prId" : 2750,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9afc0e01-b911-44ba-9d76-1b992a438a39",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I wonder if you could just get away with checking the parent\n",
        "createdAt" : "2015-04-15T18:02:05Z",
        "updatedAt" : "2015-04-15T18:02:05Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3eb0a3abab71f933b8bfb50ca9e94505926b305e",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +10402,10406 @@        function inSameLexicalScope(node1: Node, node2: Node) {\n            let container1 = getEnclosingBlockScopeContainer(node1);\n            let container2 = getEnclosingBlockScopeContainer(node2);\n            if (isGlobalSourceFile(container1)) {\n                return isGlobalSourceFile(container2);"
  },
  {
    "id" : "14a4e5b1-b5cf-4992-b447-133f9fdea7cd",
    "prId" : 2729,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3872a60d-53fd-433d-9368-e3464413bb5a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Split each branch onto its own line:\n\n``` TypeScript\nreturn type.flags & TypeFlags.Union ?\n    getPropertiesOfUnionType(<UnionType>type) :\n    getPropertiesOfObjectType(type);\n```\n",
        "createdAt" : "2015-04-12T18:21:52Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b7224273-73a6-49c4-8241-eb0ff29b619e",
        "parentId" : "3872a60d-53fd-433d-9368-e3464413bb5a",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "or, preferably:\n\n``` ts\nreturn type.flags & TypeFlags.Union\n    ? getPropertiesOfUnionType(<UnionType>type)\n    : getPropertiesOfObjectType(type);\n```\n",
        "createdAt" : "2015-04-12T19:17:43Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b2f426a0-c305-4962-89b7-a4a8c572249e",
        "parentId" : "3872a60d-53fd-433d-9368-e3464413bb5a",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : ":+1: to @CyrusNajmabadi's suggestion\n",
        "createdAt" : "2015-04-12T19:18:53Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "27a2e1c9-5047-4303-b716-34e40f1a3ccf",
        "parentId" : "3872a60d-53fd-433d-9368-e3464413bb5a",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Fits just fine on one line, I'd prefer to keep it that way.\n",
        "createdAt" : "2015-04-12T21:26:25Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "b3effdfd-fdfd-4d5d-85f1-401ca75a29db",
        "parentId" : "3872a60d-53fd-433d-9368-e3464413bb5a",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "The problem with long single lines is github:\n\n![image](https://cloud.githubusercontent.com/assets/4564579/7123448/f156d1e2-e1d6-11e4-958a-acbf718489bd.png)\n\nIt's actually harder to read because github is optimized for 80 columns.\n",
        "createdAt" : "2015-04-13T19:17:16Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a2846ef72e7d9d14945609a3009315e1f9cee20",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +2906,2910 @@        function getPropertiesOfType(type: Type): Symbol[] {\n            type = getApparentType(type);\n            return type.flags & TypeFlags.Union ? getPropertiesOfUnionType(<UnionType>type) : getPropertiesOfObjectType(type);\n        }\n"
  },
  {
    "id" : "3edecf8e-3bfb-4356-a4bd-f74edde723ee",
    "prId" : 2729,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c86458f5-9ad1-4de4-8cdd-0f6a4aac8640",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "When is `noSubtypeReduction` `true`? Can we document that?\n",
        "createdAt" : "2015-04-12T18:27:18Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "5858ed79-0fd8-497d-b1fc-1d37ff6376c2",
        "parentId" : "c86458f5-9ad1-4de4-8cdd-0f6a4aac8640",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Could we accomplish this in a simpler manner by just having getUnionType always do subtype reduction?  Would that then ensure that all later parts of the checker see the union as consistently reduced?\n",
        "createdAt" : "2015-04-12T19:19:41Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "85a28992-884e-46ae-b4ce-63cb7ec48087",
        "parentId" : "c86458f5-9ad1-4de4-8cdd-0f6a4aac8640",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The `noSubtypeReduction` flag is there because it isn't possible to always do subtype reduction. The flag is true when creating a union type from a type node and when instantiating a union type. In both of those cases subtype reduction has to be deferred to properly support recursive union types.\n",
        "createdAt" : "2015-04-12T21:37:54Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a2846ef72e7d9d14945609a3009315e1f9cee20",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +3611,3615 @@                type = unionTypes[id] = <UnionType>createObjectType(TypeFlags.Union | getWideningFlagsOfTypes(sortedTypes));\n                type.types = sortedTypes;\n                type.reducedType = noSubtypeReduction ? undefined : type;\n            }\n            return type;"
  },
  {
    "id" : "7c06daae-9d14-41c6-a722-60eb17fc44f0",
    "prId" : 2729,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d2b36041-e570-4740-8f42-1512b4fe5f6c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Is it at all significant that this case moved to the end of the function? To my reading, it is not.\n",
        "createdAt" : "2015-04-14T18:31:58Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "4944f76d-7874-4ffc-a3eb-1057234fa0d2",
        "parentId" : "d2b36041-e570-4740-8f42-1512b4fe5f6c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, it is not significant, but I like handling the union case after the object case (as it is less common).\n",
        "createdAt" : "2015-04-14T21:07:18Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a2846ef72e7d9d14945609a3009315e1f9cee20",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +3005,3009 @@                return getPropertyOfObjectType(globalObjectType, name);\n            }\n            if (type.flags & TypeFlags.Union) {\n                return getPropertyOfUnionType(<UnionType>type, name);\n            }"
  },
  {
    "id" : "ac3d1031-21a8-464e-adb2-f2120e7fd0f7",
    "prId" : 2729,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "764e6958-2cbd-41e8-9c90-6bda209112bc",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why don't we need to call resolveObjectOrUnionTypeMembers for unions as well?\n",
        "createdAt" : "2015-04-14T18:34:33Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "19cc4b05-8bb6-44db-b61d-3723c60c8547",
        "parentId" : "764e6958-2cbd-41e8-9c90-6bda209112bc",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We resolve all properties of object types in one go because it is cheap to do so, but we resolve union type properties one by one on demand because it involves a lot more work.\n",
        "createdAt" : "2015-04-14T21:09:54Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "13c13321-fdbd-4c05-97ac-9f8dc5737ad2",
        "parentId" : "764e6958-2cbd-41e8-9c90-6bda209112bc",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Sounds reasonable. I think this is worth noting in a comment.\n",
        "createdAt" : "2015-04-14T21:18:29Z",
        "updatedAt" : "2015-04-14T21:51:36Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a2846ef72e7d9d14945609a3009315e1f9cee20",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +2990,2994 @@            type = getApparentType(type);\n            if (type.flags & TypeFlags.ObjectType) {\n                let resolved = resolveObjectOrUnionTypeMembers(type);\n                if (hasProperty(resolved.members, name)) {\n                    let symbol = resolved.members[name];"
  },
  {
    "id" : "fc255d52-2c86-4f65-95d8-01611f478cf0",
    "prId" : 2684,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "21fd60a0-f0b2-4779-9fc6-bac4dff37201",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "This won't work for modules.  For example, if you have:\n\n``` ts\n\"use strict\";\nmodule public.whatever {\n}\n```\n\n(make sure to add a test for this).\n",
        "createdAt" : "2015-04-09T06:55:53Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "51d4b71e-3db2-494d-9a1d-b6b011d29676",
        "parentId" : "21fd60a0-f0b2-4779-9fc6-bac4dff37201",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "This also won't work for a variable with a binding pattern.  For example:\n\n``` ts\n\"use strict\";\nvar { public, private };\n```\n",
        "createdAt" : "2015-04-09T06:56:48Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "63a2359d1a59995b2615f3c90f03d9411389b506",
    "line" : 160,
    "diffHunk" : "@@ -1,1 +11952,11956 @@\n        function checkGrammarDeclarationNameInStrictMode(node: Declaration): boolean {\n            let name = node.name;\n            if (name && name.kind === SyntaxKind.Identifier && isReservedwordInStrictMode(<Identifier>name)) {\n                let nameText = declarationNameToString(name);"
  },
  {
    "id" : "8e4231d5-f0f2-493b-a19f-64ea635b540b",
    "prId" : 2684,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eb355470-a752-4c5a-bece-62865fa06458",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Good catch remembering to check this.  Is there a test for this as well?\n",
        "createdAt" : "2015-04-10T00:01:17Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "5b46dcd9-a18b-42a9-b7a1-be07f9d989dd",
        "parentId" : "eb355470-a752-4c5a-bece-62865fa06458",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Yep\n",
        "createdAt" : "2015-04-10T00:11:08Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "63a2359d1a59995b2615f3c90f03d9411389b506",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +8061,8065 @@\n        function checkTypeParameter(node: TypeParameterDeclaration) {\n            checkGrammarDeclarationNameInStrictMode(node);\n\n            // Grammar Checking"
  },
  {
    "id" : "83e51acd-89a5-4047-8311-dd1470e02a70",
    "prId" : 2684,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5b43b3ff-291f-4197-8636-a3742859e4d8",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Youwant the opposite.   You want to error on _public_, and not on 'private' or 'package'.\n",
        "createdAt" : "2015-04-11T00:13:56Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "63a2359d1a59995b2615f3c90f03d9411389b506",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11996,12000 @@            //      foo (x: B.private.bar)      // error at private\n            //      foo (x: public.private.package)  // error at public, private, and package\n            else if (typeName.kind === SyntaxKind.QualifiedName) {\n                // Walk from right to left and report a possible error at each Identifier in QualifiedName\n                // Example:"
  },
  {
    "id" : "e265f901-5edc-42f1-9a58-c49a23e12742",
    "prId" : 2684,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef866dbf-a74c-4bec-a697-25ad5a089e43",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Instead, call: checkGrammarTypeReferenceInStrictMode((<QualifiedName>typeName).left)\n",
        "createdAt" : "2015-04-11T00:14:18Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "abed732c-d5c3-4cc6-8c7d-839a27d0f214",
        "parentId" : "ef866dbf-a74c-4bec-a697-25ad5a089e43",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "For TypeReference, according to TypeScript spec each dot component in QualifiedName is a Identifier not IdentifierName, so we want to check each identifier in QualifiedName\n",
        "createdAt" : "2015-04-11T02:01:50Z",
        "updatedAt" : "2015-04-12T04:03:14Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "63a2359d1a59995b2615f3c90f03d9411389b506",
    "line" : null,
    "diffHunk" : "@@ -1,1 +12000,12004 @@                // Example:\n                //      x1: public.private.package  // error at public and private\n                checkGrammarTypeNameInStrictMode((<QualifiedName>typeName).right);\n                checkGrammarTypeReferenceInStrictMode((<QualifiedName>typeName).left);\n            }"
  },
  {
    "id" : "c8d78b64-33a0-4d51-b69f-2c240a77494b",
    "prId" : 2642,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "35bb2fae-794d-48cd-898c-d414b1c84656",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Do the check on the initial symbol; none of the others should ever be `undefined`, should they?\n",
        "createdAt" : "2015-04-06T22:12:43Z",
        "updatedAt" : "2015-04-06T22:12:58Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "a9692efc-c6f7-41d8-850c-e7903fa7f0eb",
        "parentId" : "35bb2fae-794d-48cd-898c-d414b1c84656",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "we later on call `visit(resolveExternalModuleName(node, (<ExportDeclaration>node).moduleSpecifier));` and that can be undefined if the module is empty. see my second test case.\n",
        "createdAt" : "2015-04-06T22:37:01Z",
        "updatedAt" : "2015-04-06T22:37:01Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "3ca76ca53bcafff8284d81eb80bcf174cf6f2919",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +930,934 @@            // module 'a' can 'export * from \"b\"' and 'b' can 'export * from \"a\"' without error.\n            function visit(symbol: Symbol) {\n                if (symbol && symbol.flags & SymbolFlags.HasExports && !contains(visitedSymbols, symbol)) {\n                    visitedSymbols.push(symbol);\n                    if (symbol !== moduleSymbol) {"
  },
  {
    "id" : "c3adf5d8-2862-402a-b3cb-3d7fee0930e6",
    "prId" : 2589,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e9419c5f-627a-4d95-908f-198d83900b92",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "can you add a comment on why we are doing this.\n",
        "createdAt" : "2015-04-02T21:03:37Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bab2339a34ce2673f78ccd43b23b19201f84295",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8739,8743 @@        }\n\n        /** Checks a type reference node as an expression. */\n        function checkTypeNodeAsExpression(node: TypeNode | LiteralExpression) {\n            // When we are emitting type metadata for decorators, we need to try to check the type"
  },
  {
    "id" : "4f55ba68-e832-498c-a8d9-8d8c999cfbfa",
    "prId" : 2589,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9790882a-fafe-4e4a-9c6a-edaf9dc6896a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Are we locked into this in the future.  Will changing these constitute 'breaking changes'?  \n",
        "createdAt" : "2015-04-02T22:43:29Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "623db4ee-62d2-49f3-9dc9-b259c49a867d",
        "parentId" : "9790882a-fafe-4e4a-9c6a-edaf9dc6896a",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "There may be breaking changes in the near future, however this is currently an experimental feature.\n",
        "createdAt" : "2015-04-02T22:57:11Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bab2339a34ce2673f78ccd43b23b19201f84295",
    "line" : 169,
    "diffHunk" : "@@ -1,1 +11551,11555 @@            // serialization of a TypeReferenceNode uses the following rules:\n            //\n            // * The serialized type of a TypeReference that is `void` is \"void 0\".\n            // * The serialized type of a TypeReference that is a `boolean` is \"Boolean\".\n            // * The serialized type of a TypeReference that is an enum or `number` is \"Number\"."
  },
  {
    "id" : "cf5e8e62-54ca-440d-82cb-a57aeef40dbd",
    "prId" : 2589,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "138a4412-2e36-4a2c-9aec-355b56d3dfb6",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Why 'void 0' out of curiosity?\n",
        "createdAt" : "2015-04-02T22:43:45Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "ac098edb-73ab-4f73-adb5-7809c46fbc08",
        "parentId" : "138a4412-2e36-4a2c-9aec-355b56d3dfb6",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "That's part of the serialization rules that @mhegazy and I worked out. Currently, every serialized type points to some constructor function, except for `void`, which has no related constructor function. We emit `void` types as `undefined`, though we use `void 0` here to emit `undefined`, just as we do elsewhere within the compiler.\n",
        "createdAt" : "2015-04-02T22:58:48Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bab2339a34ce2673f78ccd43b23b19201f84295",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +11562,11566 @@            let type = getTypeFromTypeReference(node);\n            if (type.flags & TypeFlags.Void) {\n                return \"void 0\";\n            }\n            else if (type.flags & TypeFlags.Boolean) {"
  },
  {
    "id" : "4df0cdb7-0877-4cc1-a938-e19538174c86",
    "prId" : 2589,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9b92e579-f955-4530-af9b-dfdc2c86103a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Possibly assert here that somethign was missed.  That way if we add a new type kind in the future we know we have to update this.\n",
        "createdAt" : "2015-04-02T22:45:01Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bab2339a34ce2673f78ccd43b23b19201f84295",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11634,11638 @@                    default:\n                        Debug.fail(\"Cannot serialize unexpected type node.\");\n                        break;\n                }\n            }"
  },
  {
    "id" : "f29d4f28-5ede-46a2-b601-393d247114f6",
    "prId" : 2589,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6827205-5871-4920-90ae-c8599e1e16da",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Is this appropriate if you're doing ES6 emit?\n",
        "createdAt" : "2015-04-02T22:45:32Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "6575c264-9595-4924-aef8-8316944e766f",
        "parentId" : "c6827205-5871-4920-90ae-c8599e1e16da",
        "authorId" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "body" : "Generally, the serialized type of a declaration is the function constructor that would satisfy an `instanceof` check (except for primitive types, as they are serialized as their boxed constructor type).\n\n``` JavaScript\nclass C { }\nC instanceof Function; // true\n```\n",
        "createdAt" : "2015-04-02T23:04:48Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "1eec7f68-de25-4f88-827c-00769c75a2d7",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bab2339a34ce2673f78ccd43b23b19201f84295",
    "line" : 272,
    "diffHunk" : "@@ -1,1 +11654,11658 @@            // For rules on serializing type annotations, see `serializeTypeNode`.\n            switch (node.kind) {\n                case SyntaxKind.ClassDeclaration:       return \"Function\";\n                case SyntaxKind.PropertyDeclaration:    return serializeTypeNode((<PropertyDeclaration>node).type, getGeneratedNameForNode);\n                case SyntaxKind.Parameter:              return serializeTypeNode((<ParameterDeclaration>node).type, getGeneratedNameForNode);"
  },
  {
    "id" : "dd59877e-57bb-4950-a562-985bf41d4914",
    "prId" : 2589,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7baca77d-1961-47af-a336-cce618052b42",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "So we're doing this stuff syntactically only?  Is that ok?  Should we consider using the type information isntead?\n",
        "createdAt" : "2015-04-02T22:47:15Z",
        "updatedAt" : "2015-04-06T18:13:54Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bab2339a34ce2673f78ccd43b23b19201f84295",
    "line" : 309,
    "diffHunk" : "@@ -1,1 +11691,11695 @@                            if (parameters[i].dotDotDotToken) {\n                                var parameterType = parameters[i].type;\n                                if (parameterType.kind === SyntaxKind.ArrayType) {\n                                    parameterType = (<ArrayTypeNode>parameterType).elementType;\n                                }"
  },
  {
    "id" : "bf20fdb1-9aa1-447d-810c-3463848cea35",
    "prId" : 2567,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "001de42a-f4e1-46be-94cb-1f11980b0fa9",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I really do not like this name. why do we need it here? why can not we just have getTypeOfNode?\n",
        "createdAt" : "2015-04-01T17:13:03Z",
        "updatedAt" : "2015-04-01T17:13:03Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc38c2956e0a5cd8b3e27c934bf204e3658b7d1",
    "line" : 97,
    "diffHunk" : "@@ -1,1 +2107,2111 @@            // Use type from type annotation if one is present\n            if (declaration.type) {\n                return getTypeFromTypeNodeOrHeritageClauseElement(declaration.type);\n            }\n            if (declaration.kind === SyntaxKind.Parameter) {"
  },
  {
    "id" : "51f377ed-38cb-468b-a42d-1991e9d50e90",
    "prId" : 2550,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c01badda-a9e0-45de-b5d9-6289994f72f6",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i think we can just make this the default behavior. the only cases we would be breaking are error cases, that in the past we elided modules imports, and now we will be writing them. is that correct?\n",
        "createdAt" : "2015-03-30T20:30:18Z",
        "updatedAt" : "2015-03-31T20:55:15Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "0fed4493-44ac-49fd-a1cc-ee4e5ddb432a",
        "parentId" : "c01badda-a9e0-45de-b5d9-6289994f72f6",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "done\n",
        "createdAt" : "2015-03-30T22:20:12Z",
        "updatedAt" : "2015-03-31T20:55:15Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "28c4b160-08c8-4d8f-bbdc-b525af287505",
        "parentId" : "c01badda-a9e0-45de-b5d9-6289994f72f6",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "actually I've re-checked - this might lead to cascading errors so I'll keep relaxed behavior specific to `separateCompilation` mode\n",
        "createdAt" : "2015-03-31T02:43:30Z",
        "updatedAt" : "2015-03-31T20:55:15Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bdcaa3d43db6a44bed574f93de3d422bb47bf04",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +716,720 @@            if (target) {\n                let markAlias =\n                    (target === unknownSymbol && compilerOptions.separateCompilation) ||\n                    (target !== unknownSymbol && (target.flags & SymbolFlags.Value) && !isConstEnumOrConstEnumOnlyModule(target));\n"
  },
  {
    "id" : "86b2f626-380e-4b79-afaf-b1240846f3ef",
    "prId" : 2498,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b975b05a-e144-4090-a596-6bae4064c846",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "That's an odd requirement given that the grammar only says this:\n\n```\nRestParameter:\n    ...   Identifier   TypeAnnotation_opt\n```\n\nI don't see why, at grammar check time, we'd care if the parameter was an array type or not.\n",
        "createdAt" : "2015-03-26T01:42:21Z",
        "updatedAt" : "2015-04-08T23:42:04Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "34d93dbf-768f-44ee-b385-8413f9ce5eec",
        "parentId" : "b975b05a-e144-4090-a596-6bae4064c846",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It's the type system, not the grammar checker. I will fix the comment\n",
        "createdAt" : "2015-03-26T01:48:17Z",
        "updatedAt" : "2015-04-08T23:42:04Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "846c2252970b9f59d9c1ea8af53549f001ebd751",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2207,2211 @@                    // an iterable. However, there is a requirement in our type system that all rest\n                    // parameters be array types. To satisfy this, we have an exception to the rule that\n                    // says the type of an array binding pattern with a rest element is an array type\n                    // if it is *itself* in a rest parameter. It will still be compatible with a spreaded\n                    // iterable argument, but within the function it will be an array."
  },
  {
    "id" : "19104316-0a09-4c95-9f60-48854012d079",
    "prId" : 2476,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fe369fa-5421-4436-9c65-5f514de85829",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "This is already an inner function so it should be able to refer to the node from the outer function. Why you have to pass it in as function argument?\n",
        "createdAt" : "2015-03-24T18:59:40Z",
        "updatedAt" : "2015-03-24T18:59:40Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "3c381f3c-5a19-41b4-8c11-f5bf73970491",
        "parentId" : "5fe369fa-5421-4436-9c65-5f514de85829",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "it is both the question of style (use explicit inputs\\outputs for function) and potential optimization opportunities (in theory nested function that does not any captured data can be lifted to a higher scope)\n",
        "createdAt" : "2015-03-24T19:58:57Z",
        "updatedAt" : "2015-03-24T19:58:57Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "3a8df4106de50ea7c929f53629836e02d59a4bc9",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +7254,7258 @@            }\n\n            function isImportedNameFromExternalModule(n: Node): boolean {\n                switch (n.kind) {\n                    case SyntaxKind.ElementAccessExpression:"
  },
  {
    "id" : "e9996b20-04f7-4680-ab8e-7a0d243a9802",
    "prId" : 2471,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "520b3bbf-e5ab-4670-af0d-7421161268d1",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "maybe `, generateName: NameGenerator`  along with `type NameGenerator = (node: Node) => string;` ?\n\nI find it pretty tough to read these sigs with function types in it.  But it's up to you.\n",
        "createdAt" : "2015-03-24T18:32:30Z",
        "updatedAt" : "2015-03-24T19:28:20Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f0cbcd6782899685b13a7ae1e70ac3d3c16d7809",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +10970,10974 @@        }\n\n        function getExportNameSubstitution(symbol: Symbol, location: Node, getGeneratedNameForNode: (Node: Node) => string): string {\n            if (isExternalModuleSymbol(symbol.parent)) {\n                var symbolName = unescapeIdentifier(symbol.name);"
  },
  {
    "id" : "6a393fa1-6479-4075-bb2e-10b370acde7e",
    "prId" : 2460,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53d748e7-68f5-4ea2-b71e-165e3a2afce6",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Why aren't these included?\n",
        "createdAt" : "2015-03-23T04:56:56Z",
        "updatedAt" : "2015-03-25T16:47:45Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "8c31d99f-b19e-4833-a845-77d376ae04c0",
        "parentId" : "53d748e7-68f5-4ea2-b71e-165e3a2afce6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We don't want the reserved member names (such as '__export') to show up in statement completion lists.\n",
        "createdAt" : "2015-03-23T05:03:01Z",
        "updatedAt" : "2015-03-25T16:47:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a05f1e8d8595237f7d877021849b1de302c5f2d1",
    "line" : 306,
    "diffHunk" : "@@ -1,1 +2995,2999 @@            let result: Symbol[] = [];\n            for (let id in symbols) {\n                if (!isReservedMemberName(id)) {\n                    result.push(symbols[id]);\n                }"
  },
  {
    "id" : "f1db0c58-2874-4d2a-bb52-497aff911fe7",
    "prId" : 2356,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9de2b7da-561d-4210-814d-ec5c5329c606",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "This seems odd. No inferences were made, but inference succeeded?  Can you provide some some explnatories comments on this?  Thanks!\n",
        "createdAt" : "2015-03-15T22:10:00Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "19dbeb8d-6e76-4c14-b1da-16e368076752",
        "parentId" : "9de2b7da-561d-4210-814d-ec5c5329c606",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Sure, but this is just a rule of the language. If there were no inferences, inference still succeeds. I don't love it. But @DanielRosenwasser has a PR where he issues an error for this case under a compiler flag.\n",
        "createdAt" : "2015-03-16T02:51:48Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "0930ee77-ae2c-4b08-adae-9e0a05fa98b6",
        "parentId" : "9de2b7da-561d-4210-814d-ec5c5329c606",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "It's not yet a PR; I'd like to make it a PR if we could solve some of the original concerns in #360.\n\nTo clarify, when inference for a type argument fails, the process falls back to using `{}` as a type argument. :+1: for explaining what a failure scenario would be in contrast to no inferences being found.\n",
        "createdAt" : "2015-03-16T04:25:35Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "6149d777-faa9-4cdd-ac69-1b7520f3b288",
        "parentId" : "9de2b7da-561d-4210-814d-ec5c5329c606",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ok, I'll add a comment.\n",
        "createdAt" : "2015-03-16T17:23:49Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3879d0ae9add9b0e7bac23e88f47cda21efc068b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4762,4766 @@                    // candidates with no common supertype.\n                    inferredType = emptyObjectType;\n                    inferenceSucceeded = true;\n                }\n"
  },
  {
    "id" : "ee1047ab-a3b0-4599-a7bd-146543f44247",
    "prId" : 2356,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "48b775a5-ac8e-4605-9a42-b267140c5955",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Great comment, thanks.\n",
        "createdAt" : "2015-03-15T22:10:59Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3879d0ae9add9b0e7bac23e88f47cda21efc068b",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +4765,4769 @@                }\n\n                // Only do the constraint check if inference succeeded (to prevent cascading errors)\n                if (inferenceSucceeded) {\n                    let constraint = getConstraintOfTypeParameter(context.typeParameters[index]);"
  },
  {
    "id" : "b256beb4-5463-4a2a-9c7b-e06030895137",
    "prId" : 2356,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42935df0-c2ac-493f-918f-99ef847289c6",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Is this actually an optimization?  Or is this necessary to get correct results?   I thought it was the latter.\n",
        "createdAt" : "2015-03-15T22:17:17Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "4ad9e5b2-2756-4654-8d42-1a6b9bfb5815",
        "parentId" : "42935df0-c2ac-493f-918f-99ef847289c6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It's not an optimization that we reset it. It's an optimization that we skip resetting it if the type parameter was already fixed. It would be just as correct to reset all of them. But then we'd be repeating the same work for the type parameters that were fixed. Namely the work done by getInferredType.\n",
        "createdAt" : "2015-03-16T02:56:42Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "06147545-bc40-43a8-a482-817e0bbae4d8",
        "parentId" : "42935df0-c2ac-493f-918f-99ef847289c6",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Good to explain in the code.\n",
        "createdAt" : "2015-03-16T19:19:00Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "7178a3bb-df61-47b4-8c8f-96d145ee328d",
        "parentId" : "42935df0-c2ac-493f-918f-99ef847289c6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ok, I'm basically adding my comment from above as a comment in the code\n",
        "createdAt" : "2015-03-16T21:08:43Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3879d0ae9add9b0e7bac23e88f47cda21efc068b",
    "line" : 137,
    "diffHunk" : "@@ -1,1 +6378,6382 @@            // Clear out all the inference results from the last time inferTypeArguments was called on this context\n            for (let i = 0; i < typeParameters.length; i++) {\n                // As an optimization, we don't have to clear (and later recompute) inferred types\n                // for type parameters that have already been fixed on the previous call to inferTypeArguments.\n                // It would be just as correct to reset all of them. But then we'd be repeating the same work"
  },
  {
    "id" : "89e80640-4311-4be8-84ee-18aaa8fad477",
    "prId" : 2356,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1678f983-beb3-4d45-b03a-9c76973199c0",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "downfallType? Is this supposed to be like a fallbackType? If so, rename it. downfallType sounds like it describes revolutions, lost wars, etc.\n",
        "createdAt" : "2015-03-16T19:36:08Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "95791155-040b-4ca7-8587-a8a770f27331",
        "parentId" : "1678f983-beb3-4d45-b03a-9c76973199c0",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It _is_ supposed to be downfallType. It _is_ supposed to sound like it describes revolutions and lost wars, but in particular tragic heroes.\n\nThe downfallType is the type that caused a particular candidate to not be the common supertype. So if it weren't for this one downfallType, the type in question could have been the common supertype.\n\nNote that downfallType is the first type that is not a subtype of type. It's not necessarily the only one.\n",
        "createdAt" : "2015-03-16T21:48:44Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8bfea541-78e1-4e67-bb2c-f971ceb47ba2",
        "parentId" : "1678f983-beb3-4d45-b03a-9c76973199c0",
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Can we add this explanation in the code  \n\n```\nThe downfallType is the type that caused a particular candidate to not be the common supertype. So if it weren't for this one downfallType, the type in question could have been the common supertype.\n```\n",
        "createdAt" : "2015-03-17T01:19:50Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "3879d0ae9add9b0e7bac23e88f47cda21efc068b",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +4392,4396 @@                }\n\n                Debug.assert(!!downfallType, \"If there is no common supertype, each type should have a downfallType\");\n\n                if (score > bestSupertypeScore) {"
  },
  {
    "id" : "f75841e1-df31-40f4-a4cc-c00dcafa8a34",
    "prId" : 2356,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d55b892a-1cad-4bde-9e08-558d91acab53",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "There's no documentation for `inferiority`.\n",
        "createdAt" : "2015-03-16T19:53:01Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "69924125-416f-4edb-854d-1d18b4e95847",
        "parentId" : "d55b892a-1cad-4bde-9e08-558d91acab53",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Also, the documentation for `primary` and `secondary` are a bit lacking; elaborate on the distinctions and _why_ we make these distinctions.\n",
        "createdAt" : "2015-03-16T19:55:10Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "d79689be-6add-4beb-a9ea-b828c3fe1a1c",
        "parentId" : "d55b892a-1cad-4bde-9e08-558d91acab53",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "``` ts\n// Any inferences that are made to a type parameter in a union type are inferior\n// to inferences made to a flat (non-union) type. This is because if we infer to\n// T | string[], we really don't know if we should be inferring to T or not (because\n// the correct constituent on the target side could be string[]). Therefore, we put\n// such inferior inferences into a secondary bucket, and only use them if the primary\n// bucket is empty.\n```\n",
        "createdAt" : "2015-03-16T21:29:11Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "308bca30-454f-4391-b0c2-31fb5d402a65",
        "parentId" : "d55b892a-1cad-4bde-9e08-558d91acab53",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : ":clap:\n",
        "createdAt" : "2015-03-17T03:09:24Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3879d0ae9add9b0e7bac23e88f47cda21efc068b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4634,4638 @@                                // such inferior inferences into a secondary bucket, and only use them if the primary\n                                // bucket is empty.\n                                let candidates = inferiority ?\n                                    inferences.secondary || (inferences.secondary = []) :\n                                    inferences.primary || (inferences.primary = []);"
  },
  {
    "id" : "532ec7c9-6915-46da-a792-c3327904c890",
    "prId" : 2356,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "53b3fefd-4d4e-4300-b81f-a1b4e94bb398",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Should this have `failedTypeParameterIndex` as a property? It is optional though I find it will be easier to read through\n",
        "createdAt" : "2015-03-17T02:19:31Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "4556f393-ae6d-4969-ac15-f2a5baf660d6",
        "parentId" : "53b3fefd-4d4e-4300-b81f-a1b4e94bb398",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think I'm going to leave it out. The reason it's optional is because it is always initially undefined, and undefined means that there have been no failures (yet).\n",
        "createdAt" : "2015-03-17T04:47:16Z",
        "updatedAt" : "2015-03-17T17:45:52Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "3879d0ae9add9b0e7bac23e88f47cda21efc068b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4582,4586 @@                inferUnionTypes,\n                inferences,\n                inferredTypes: new Array(typeParameters.length),\n            };\n        }"
  },
  {
    "id" : "c3fc88a3-c752-4b15-b330-a001ead9fced",
    "prId" : 2339,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9598ca7a-fc26-430e-8778-73b87f72d88b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This cast to Identifier does not look safe anymore, now that we allow expressions.\n",
        "createdAt" : "2015-03-13T19:38:22Z",
        "updatedAt" : "2015-03-16T21:42:59Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "cfec19ec-c268-4ba3-8b26-c973d9798a36",
        "parentId" : "9598ca7a-fc26-430e-8778-73b87f72d88b",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "We treat identifier specially, as it means to export all meanings of the identifier, where as an exporting an expression, only exports the value. the binder handles these differently, if it is an identifier it will bind the symbol for the default export. so we know if we only have an identifier here.\n",
        "createdAt" : "2015-03-15T21:30:19Z",
        "updatedAt" : "2015-03-16T21:42:59Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "2842a696-8d5f-46d2-9fbf-e899a0ca8586",
        "parentId" : "9598ca7a-fc26-430e-8778-73b87f72d88b",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I understand what you are saying about the binder. But I don't understand how it implies that over here, you can assume node.expression is an Identifier.\n",
        "createdAt" : "2015-03-16T01:27:46Z",
        "updatedAt" : "2015-03-16T21:42:59Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5edff3e6-f94c-4b27-b648-13f27897b092",
        "parentId" : "9598ca7a-fc26-430e-8778-73b87f72d88b",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Does this method only get called when it's an identifier? If so, I'd add an assert.\n",
        "createdAt" : "2015-03-16T01:28:48Z",
        "updatedAt" : "2015-03-16T21:42:59Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "696b68898727d49ea9f1e0aeef8577d29be0a532",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +568,572 @@\n        function getTargetOfExportAssignment(node: ExportAssignment): Symbol {\n            return node.expression && resolveEntityName(<Identifier>node.expression, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace);\n        }\n"
  },
  {
    "id" : "6e0aa682-2012-403d-9c39-5e5f6ca313a0",
    "prId" : 2339,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3b1d1cd-69ec-4f23-919d-d69531548bf8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Or checkExpressionCached could be resilient to an undefined argument. But I don't have a strong preference either way.\n",
        "createdAt" : "2015-03-13T19:39:09Z",
        "updatedAt" : "2015-03-16T21:42:59Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "696b68898727d49ea9f1e0aeef8577d29be0a532",
    "line" : null,
    "diffHunk" : "@@ -1,1 +626,630 @@                if (node.kind === SyntaxKind.ExportAssignment && (<ExportAssignment>node).expression) {\n                    // export default <symbol>\n                    checkExpressionCached((<ExportAssignment>node).expression);\n                }\n                else if (node.kind === SyntaxKind.ExportSpecifier) {"
  },
  {
    "id" : "ade61dfc-7a0f-4ab3-a58d-d11dcddb5dfd",
    "prId" : 2339,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e341923-bf11-450b-bb61-f150fbafece5",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I find it really bizarre that export assignments are handled in getTypeOfVariableOrParameterOrProperty, as an export assignment is neither a variable, nor a parameter, nor a property.\n",
        "createdAt" : "2015-03-13T19:41:13Z",
        "updatedAt" : "2015-03-16T21:42:59Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "696b68898727d49ea9f1e0aeef8577d29be0a532",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +2073,2077 @@                }\n                // Handle export default expressions\n                if (declaration.kind === SyntaxKind.ExportAssignment) {\n                    var exportAssignment = <ExportAssignment>declaration;\n                    if (exportAssignment.expression) {"
  },
  {
    "id" : "7349bd26-a2b2-40d9-8f9f-d3a97c5a8cc6",
    "prId" : 2335,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0f11485-a7fb-4837-8e2c-4dd37f9ae97a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Is this documented with Jonathan as a breaking change?  (it seems like a very big one, erroring on an entire feature if you move to ES6).\n",
        "createdAt" : "2015-03-13T11:31:18Z",
        "updatedAt" : "2015-03-17T20:09:24Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "c2b474bf-4543-47d6-b0b6-35937d1abf8b",
        "parentId" : "d0f11485-a7fb-4837-8e2c-4dd37f9ae97a",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "yes. that is the current design. we will have a blog post about moving to the new module syntax.\n",
        "createdAt" : "2015-03-13T17:19:21Z",
        "updatedAt" : "2015-03-17T20:09:24Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "a06ce61684e286d641c237b4688f7fb908dc675d",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +10102,10106 @@                    if (languageVersion >= ScriptTarget.ES6) {\n                        // Import equals declaration is deprecated in es6 or above\n                        grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_6_or_higher_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_or_import_d_from_mod_instead);\n                    }\n                }"
  },
  {
    "id" : "77c32ea1-fbae-407e-80b5-278db577b2b0",
    "prId" : 2335,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5c1cf98-37d3-4ebf-b716-40fa1cbc0877",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "can you add a comment why we don't prefix export name with 'exports.' when  emitting for ES6+?\n",
        "createdAt" : "2015-03-17T19:43:13Z",
        "updatedAt" : "2015-03-17T20:09:24Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "78b63f63-8999-40f1-bd17-761c9a5a43b7",
        "parentId" : "d5c1cf98-37d3-4ebf-b716-40fa1cbc0877",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "done.\n",
        "createdAt" : "2015-03-17T20:05:26Z",
        "updatedAt" : "2015-03-17T20:09:24Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "a06ce61684e286d641c237b4688f7fb908dc675d",
    "line" : null,
    "diffHunk" : "@@ -1,1 +11026,11030 @@                // no need to qualify it.\n                if (languageVersion >= ScriptTarget.ES6) {\n                    return symbolName;\n                }\n                else {"
  },
  {
    "id" : "ef34cff8-ea8e-4673-bba7-b4456c18a0f2",
    "prId" : 2308,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3dd94122-8d9c-49e7-bf0d-a1d55c8ae369",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Could you add, at the top of this function, the types of types you want this fnction to be able to handle, and what final type will be returned?\n\nNote: this function never seems to return 'undefined'.  But i thought you used || earlier to default to hte 'any' type of you got 'undefined' back from this.\n",
        "createdAt" : "2015-03-12T16:11:35Z",
        "updatedAt" : "2015-03-12T21:57:15Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "0a5eae2b-d70f-4cde-9a94-cebd79358f8b",
        "parentId" : "3dd94122-8d9c-49e7-bf0d-a1d55c8ae369",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah I will add a summary of what the result should be, as well as some examples.\n",
        "createdAt" : "2015-03-12T20:10:08Z",
        "updatedAt" : "2015-03-12T21:57:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "6691408147bb6e773fed3ef116c3fd30ee6c64e4",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +9089,9093 @@            var arrayElementType = getIndexTypeOfType(arrayType, IndexKind.Number) || unknownType;\n            if (hasStringConstituent) {\n                // This is just an optimization for the case where arrayOrStringType is string | string[]\n                if (arrayElementType.flags & TypeFlags.StringLike) {\n                    return stringType;"
  },
  {
    "id" : "fb85ac47-206c-4f39-8a1f-0c46b0ee84ef",
    "prId" : 2238,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a3ddaeb5-fb56-498f-93bf-0b400fded85a",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This bad message can now only happen if the user removes the indexer from Array, and then writes code like the following:\n\n``` ts\nvar a = [];\nvar [b, c] = a;\n```\n",
        "createdAt" : "2015-03-06T23:07:04Z",
        "updatedAt" : "2015-03-10T19:59:21Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d06729b188efd7fa2fa91b1cd04bb3dad33ee49",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1850,1854 @@                        }\n                        else {\n                            error(declaration, Diagnostics.Type_0_has_no_property_1, typeToString(parentType), propName);\n                        }\n                        return unknownType;"
  },
  {
    "id" : "8f8910b4-d56c-42ae-ab92-3788843f1421",
    "prId" : 2238,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e699791-bae6-4a3e-a655-c58747b8d889",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why not use isTupleLikeType?\n",
        "createdAt" : "2015-03-10T17:25:10Z",
        "updatedAt" : "2015-03-10T19:59:21Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "51935190-bde4-4572-8605-0fb361889e07",
        "parentId" : "9e699791-bae6-4a3e-a655-c58747b8d889",
        "authorId" : "487cc21a-b6fe-4fbf-acc6-e48e89cff671",
        "body" : "doesn't always have `elementTypes`, which makes it hard to determine its tuple \"length\"\n",
        "createdAt" : "2015-03-10T17:26:15Z",
        "updatedAt" : "2015-03-10T19:59:21Z",
        "lastEditedBy" : "487cc21a-b6fe-4fbf-acc6-e48e89cff671",
        "tags" : [
        ]
      },
      {
        "id" : "aa1a8ff6-675b-4484-8752-6d3cbacd022d",
        "parentId" : "9e699791-bae6-4a3e-a655-c58747b8d889",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ok, please put a comment explaining that in general, one should use isTupleLikeType for type system checks, but when someone depends on the existence of .elementTypes, call isTupleType. It has different semantics from isTupleLikeType because it has to be literally written as a tuple, and not as an object with a '0' property.\n",
        "createdAt" : "2015-03-10T17:32:40Z",
        "updatedAt" : "2015-03-10T19:59:21Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0d06729b188efd7fa2fa91b1cd04bb3dad33ee49",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4343,4347 @@         * Prefer using isTupleLikeType() unless the use of `elementTypes` is required.\n         */\n        function isTupleType(type: Type) : boolean {\n            return (type.flags & TypeFlags.Tuple) && !!(<TupleType>type).elementTypes;\n        }"
  },
  {
    "id" : "998b139f-83ef-4e28-8603-8a468c0922e1",
    "prId" : 2235,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a9ccdc9d-a06b-43fd-824e-f93a70bf59f5",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can this be a binding pattern?\n",
        "createdAt" : "2015-03-06T22:30:08Z",
        "updatedAt" : "2015-03-06T22:30:08Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "bae4bc5e-6d3f-4fa5-b967-de35cd706b4d",
        "parentId" : "a9ccdc9d-a06b-43fd-824e-f93a70bf59f5",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Sorry, I didn't see the previous condition that checks it's an identifier\n",
        "createdAt" : "2015-03-06T22:32:16Z",
        "updatedAt" : "2015-03-06T22:32:21Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "2edb5c88d841750e774769f3cbbc7b126de8aeeb",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +9159,9163 @@                    }\n                    else {\n                        var identifierName = (<Identifier>catchClause.variableDeclaration.name).text;\n                        var locals = catchClause.block.locals;\n                        if (locals && hasProperty(locals, identifierName)) {"
  },
  {
    "id" : "3224fde5-d1b8-446c-92ce-da44660d0639",
    "prId" : 2235,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "129db338-56c3-4b03-be51-d1060d92ec85",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Doesn't look like this handles nested cases:\n\n``` ts\ntry { }\ncatch (e) {\n    if (true) {\n       let e;\n    }\n}\n```\n",
        "createdAt" : "2015-03-06T22:34:16Z",
        "updatedAt" : "2015-03-06T22:34:16Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "97b5a6fb-5f29-42d2-80b8-8e05158b2815",
        "parentId" : "129db338-56c3-4b03-be51-d1060d92ec85",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Look for the call to checkVarDeclaredNamesNotShadowed inside checkVariableLikeDeclaration. I would make another function that does what you are checking here, and call from the same spot in checkVariableLikeDeclaration.\n",
        "createdAt" : "2015-03-06T22:41:28Z",
        "updatedAt" : "2015-03-06T22:41:28Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5bccd9df-b932-4ecf-8e51-d28d17bdaef2",
        "parentId" : "129db338-56c3-4b03-be51-d1060d92ec85",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "i do not think this is meant to fail.. the spec says \"LexicallyDeclaredNames\" of the catch block. this is not lexically declared in the catch block.\n",
        "createdAt" : "2015-03-06T22:44:40Z",
        "updatedAt" : "2015-03-06T22:44:40Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "68292d96-f16e-49cf-92cf-81bd24165a7d",
        "parentId" : "129db338-56c3-4b03-be51-d1060d92ec85",
        "authorId" : "653c1a3f-9d47-48c5-8f19-f894f1744d89",
        "body" : "Firefox Nightly doesn't error in that case. So not sure if we should?\nEdit: mhegazy answers seems more appropriate. Thanks!\n",
        "createdAt" : "2015-03-06T22:45:44Z",
        "updatedAt" : "2015-03-06T22:46:15Z",
        "lastEditedBy" : "653c1a3f-9d47-48c5-8f19-f894f1744d89",
        "tags" : [
        ]
      },
      {
        "id" : "4aa706ba-a16b-44ed-a48c-b81e63710f53",
        "parentId" : "129db338-56c3-4b03-be51-d1060d92ec85",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh yeah, you are (both) right.\n",
        "createdAt" : "2015-03-06T22:54:42Z",
        "updatedAt" : "2015-03-06T22:54:42Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "2edb5c88d841750e774769f3cbbc7b126de8aeeb",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +9164,9168 @@                            var localSymbol = locals[identifierName]\n                            if (localSymbol && (localSymbol.flags & SymbolFlags.BlockScopedVariable) !== 0) {\n                                grammarErrorOnNode(localSymbol.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, identifierName);\n                            }\n                        }"
  },
  {
    "id" : "875036be-3871-43b1-ad77-59136c119c68",
    "prId" : 2205,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "91cca5fc-c164-4321-bcde-0c60ae47bf35",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Maybe call this createNodeDiagnostic\n",
        "createdAt" : "2015-03-05T02:26:43Z",
        "updatedAt" : "2015-03-05T02:38:01Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "d367c96df6ea716d8e4f3b1a8485d99da3a7abd3",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +11837,11841 @@            var sourceFile = getSourceFileOfNode(node);\n            if (!hasParseDiagnostics(sourceFile)) {\n                diagnostics.add(createDiagnosticForNode(node, message, arg0, arg1, arg2));\n                return true;\n            }"
  },
  {
    "id" : "d1fc26cb-3221-445c-9281-85272c2d8309",
    "prId" : 2164,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "44735808-b438-4999-81a7-32f050e0e782",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "what is the purpose of this check?\n",
        "createdAt" : "2015-02-27T08:41:19Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "edffbd54-9b21-46e2-9906-84052b0003b7",
        "parentId" : "44735808-b438-4999-81a7-32f050e0e782",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This function is essentially generating a semantic access chain of the following form (given the type `iterable`):\n\n``` ts\niterable[Symbol.iterator]().next().value\n```\n\nAt every level in this access chain, you could encounter an `anyType` or `unknownType`. So let's say `iterable[Symbol.iterator]()` returns `anyType`. Then when we try to access `next`, we will get undefined, because `anyType` does not have properties. Now consider what would happen if we did not do the `any` check. We would proceed, and `iteratorNextFunction` would be undefined. Then `iteratorNextFunctionSignatures` would be the emptyArray. And then we would incorrectly report an error that you don't have a next method.\n",
        "createdAt" : "2015-02-27T19:02:30Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0227d12b90582ec0c6c7389d0a6170813b494d3",
    "line" : 415,
    "diffHunk" : "@@ -1,1 +8981,8985 @@\n                var iterator = getUnionType(map(iteratorFunctionSignatures, getReturnTypeOfSignature));\n                if (allConstituentTypesHaveKind(iterator, TypeFlags.Any)) {\n                    return undefined;\n                }"
  },
  {
    "id" : "e31fe66f-de65-4173-91cd-bdf2d987532f",
    "prId" : 2164,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67ce789e-6fd8-45cb-943d-a55ad2a2f945",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'm split between aesthetics and convention here.\n",
        "createdAt" : "2015-03-01T19:41:38Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f4cc1641-717e-4844-a063-277edc6dba14",
        "parentId" : "67ce789e-6fd8-45cb-943d-a55ad2a2f945",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Reverting (none of this should have changed).\n",
        "createdAt" : "2015-03-01T23:19:05Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "fccd9286-8748-48ac-87f7-56195b0379b1",
        "parentId" : "67ce789e-6fd8-45cb-943d-a55ad2a2f945",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I mean I'm keeping it, sorry. I like the new way better.\n",
        "createdAt" : "2015-03-01T23:19:55Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0227d12b90582ec0c6c7389d0a6170813b494d3",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +8379,8383 @@                checkGrammarDisallowedModifiersInBlockOrObjectLiteralExpression(node) ||\n                checkGrammarFunctionName(node.name) ||\n                checkGrammarForGenerator(node);\n\n                checkCollisionWithCapturedSuperVariable(node, node.name);"
  },
  {
    "id" : "8c0ae959-e7eb-42e4-b6a4-ac1881182d2c",
    "prId" : 2164,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a946c51d-7975-410c-bd9f-c23d5b98046e",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Why not `varType` and `exprType`?\n",
        "createdAt" : "2015-03-01T19:57:27Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "567d5d7e-e913-45e7-8973-a2d31a3884c5",
        "parentId" : "a946c51d-7975-410c-bd9f-c23d5b98046e",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Because the thing on the left can also be an expression.\n",
        "createdAt" : "2015-03-01T23:29:45Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0227d12b90582ec0c6c7389d0a6170813b494d3",
    "line" : 304,
    "diffHunk" : "@@ -1,1 +8873,8877 @@                //   and Expr must be an expression of type Any, an object type, or a type parameter type.\n                var varExpr = <Expression>node.initializer;\n                var leftType = checkExpression(varExpr);\n                if (varExpr.kind === SyntaxKind.ArrayLiteralExpression || varExpr.kind === SyntaxKind.ObjectLiteralExpression) {\n                    error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);"
  },
  {
    "id" : "1da1a474-16c0-4384-bb8e-87b069b6ff82",
    "prId" : 2164,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6afeeb8f-77ac-4318-b74e-5d1b7aedafba",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Is it valid to have anything other than 1 initializer?\n",
        "createdAt" : "2015-03-01T20:03:07Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "3ab7b883-aae1-407b-9186-a287dda6d8a5",
        "parentId" : "6afeeb8f-77ac-4318-b74e-5d1b7aedafba",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "No, but the grammar check does not cause us to return early from `checkForOfStatement` and `checkForInStatement`. Do you think we should just bail out, and only get here if we had no grammar errors?\n",
        "createdAt" : "2015-03-01T23:33:10Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "74c530e1-9ea6-4d1c-be00-87b49d8800b8",
        "parentId" : "6afeeb8f-77ac-4318-b74e-5d1b7aedafba",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd have to see the sort of examples that it would bail out on to make a judgement on it, but consider just leaving a comment saying that something else will check the initializer count.\n",
        "createdAt" : "2015-03-02T00:20:52Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "75ab131d-7c6d-4c89-a8d9-49508eae0b43",
        "parentId" : "6afeeb8f-77ac-4318-b74e-5d1b7aedafba",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I can leave a comment.\n",
        "createdAt" : "2015-03-02T00:23:05Z",
        "updatedAt" : "2015-03-02T23:28:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "e0227d12b90582ec0c6c7389d0a6170813b494d3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8899,8903 @@            var variableDeclarationList = <VariableDeclarationList>iterationStatement.initializer;\n            // checkGrammarForInOrForOfStatement will check that there is exactly one declaration.\n            if (variableDeclarationList.declarations.length >= 1) {\n                var decl = variableDeclarationList.declarations[0];\n                checkVariableDeclaration(decl);"
  },
  {
    "id" : "33c079f3-922b-4d30-9041-1d55f50c4e9b",
    "prId" : 2162,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76941d22-431e-4831-9647-e02a9f6bb9a4",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Add test\n",
        "createdAt" : "2015-02-27T01:38:11Z",
        "updatedAt" : "2015-02-27T01:42:53Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "57e54bf0-8cf6-4fc8-8121-22250dfddc67",
        "parentId" : "76941d22-431e-4831-9647-e02a9f6bb9a4",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Done.\n",
        "createdAt" : "2015-02-27T01:44:14Z",
        "updatedAt" : "2015-02-27T01:44:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b7f49725d7b51bebdbb5acccc3caefc3fc7ce9d",
    "line" : 42,
    "diffHunk" : "@@ -1,1 +8922,8926 @@                // Grammar checking\n                if (catchClause.variableDeclaration) {\n                    if (catchClause.variableDeclaration.name.kind !== SyntaxKind.Identifier) {\n                        grammarErrorOnFirstToken(catchClause.variableDeclaration.name, Diagnostics.Catch_clause_variable_name_must_be_an_identifier);\n                    }"
  },
  {
    "id" : "74f73731-df5c-416b-a1d7-d34eb4fcd6a2",
    "prId" : 2121,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4d2efb0-a386-483c-8a80-ebbb61eb52e9",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "please break this up.  :)\n",
        "createdAt" : "2015-02-24T00:48:12Z",
        "updatedAt" : "2015-02-24T22:38:12Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "eefbae66134cff051abce09cd8dac432bbd15f48",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +10280,10284 @@                    // External module name in an import declaration\n                    var moduleName: Expression;\n                    if ((isExternalModuleImportEqualsDeclaration(node.parent.parent) &&\n                        getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||\n                        ((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) &&"
  },
  {
    "id" : "f9416dbf-142b-426f-bfe7-948ff50bc6eb",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b819958e-662e-4706-97ec-92221d4093df",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can we rename this?\n",
        "createdAt" : "2015-02-13T18:55:28Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "941728de074a93488d8d7d6bebd3725d5276f205",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +8199,8203 @@        }\n\n        function checkVarDeclaredNamesNotShadowed(node: VariableDeclaration | BindingElement) {\n            // - ScriptBody : StatementList\n            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList "
  },
  {
    "id" : "c16b1b81-d125-49df-97ee-64723187cd17",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "55d6ba36-6f23-412f-9592-e94ccfed1b0f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "How can a block scoped declaration have a function scoped symbol?\n",
        "createdAt" : "2015-02-13T18:56:14Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "8776631e-9146-4739-86e1-3d8e4553e62f",
        "parentId" : "55d6ba36-6f23-412f-9592-e94ccfed1b0f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "oh sorry didn't see the === 0\n",
        "createdAt" : "2015-02-13T20:12:47Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b2b98a5c-a895-4848-8317-83b61f96b1fd",
        "parentId" : "55d6ba36-6f23-412f-9592-e94ccfed1b0f",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So when would this not be true?\n",
        "createdAt" : "2015-02-13T20:14:30Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "941728de074a93488d8d7d6bebd3725d5276f205",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +8226,8230 @@            if (node.initializer && (getCombinedNodeFlags(node) & NodeFlags.BlockScoped) === 0) {\n                var symbol = getSymbolOfNode(node);\n                if (symbol.flags & SymbolFlags.FunctionScopedVariable) {\n                    var localDeclarationSymbol = resolveName(node, (<Identifier>node.name).text, SymbolFlags.Variable, /*nodeNotFoundErrorMessage*/ undefined, /*nameArg*/ undefined);\n                    if (localDeclarationSymbol &&"
  },
  {
    "id" : "bed01ebd-dbdb-4d39-9420-dd7a85912a46",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "070beff5-ab69-4262-b1fb-038bdbe5cbed",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Add a code example where the relevant declarations are labelled with 'localDeclarationSymbol' and 'symbol'\n",
        "createdAt" : "2015-02-13T20:12:02Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "941728de074a93488d8d7d6bebd3725d5276f205",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +8230,8234 @@                    if (localDeclarationSymbol &&\n                        localDeclarationSymbol !== symbol &&\n                        localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable) {\n                        if (getDeclarationFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped) {\n"
  },
  {
    "id" : "a65c826b-73b7-4a79-9d40-e99625adce84",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5fe2473a-a8c1-4c11-972c-1e83aed48a65",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "When would this not be true? You already checked the symbol flags\n",
        "createdAt" : "2015-02-13T20:14:08Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "941728de074a93488d8d7d6bebd3725d5276f205",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +8231,8235 @@                        localDeclarationSymbol !== symbol &&\n                        localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable) {\n                        if (getDeclarationFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped) {\n\n                            var varDeclList = getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKind.VariableDeclarationList);"
  },
  {
    "id" : "cd9e7cf5-dc30-4224-804e-01a2ef010cb3",
    "prId" : 2027,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "600e43ec-90df-492d-a301-3fbed0b6ae96",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What else could it be? We already checked that PropertyDeclaration and PropertySignature are false\n",
        "createdAt" : "2015-02-13T20:19:55Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ad4cbd8e-df7c-4e46-be12-51d529be9452",
        "parentId" : "600e43ec-90df-492d-a301-3fbed0b6ae96",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "i.e. EnumMember or Parameter\n",
        "createdAt" : "2015-02-13T20:50:57Z",
        "updatedAt" : "2015-02-13T21:15:22Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "3e858175-217a-458d-8554-63152d2e9f3a",
        "parentId" : "600e43ec-90df-492d-a301-3fbed0b6ae96",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Please note that\n",
        "createdAt" : "2015-02-13T21:44:46Z",
        "updatedAt" : "2015-02-13T21:44:46Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "acd5ad00-4956-47e1-aafd-4ce4dd959582",
        "parentId" : "600e43ec-90df-492d-a301-3fbed0b6ae96",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Oh, but what if the binding element is in the parameter? Then you want to skip it, right?\n",
        "createdAt" : "2015-02-13T21:45:15Z",
        "updatedAt" : "2015-02-13T21:45:36Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "941728de074a93488d8d7d6bebd3725d5276f205",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +8350,8354 @@                // We know we don't have a binding pattern or computed name here\n                checkExportsOnMergedDeclarations(node);\n                if (node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement) {\n                    checkVarDeclaredNamesNotShadowed(<VariableDeclaration | BindingElement>node);\n                }"
  },
  {
    "id" : "11753500-136f-4b22-aebf-22cf0727a6d3",
    "prId" : 2025,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "607d6747-0c38-478b-bf59-fb190128c5c4",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I'd prefer you just compared to `0`.\n",
        "createdAt" : "2015-02-16T22:17:25Z",
        "updatedAt" : "2015-02-16T22:17:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b88efa1b80fea9d49e5385a33ccfb894c60e72d3",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +1586,1590 @@                    case SyntaxKind.VariableDeclaration:\n                        if (isBindingPattern(node.name) &&\n                            !(<BindingPattern>node.name).elements.length) {\n                            // If the binding pattern is empty, this variable declaration is not visible\n                            return false;"
  },
  {
    "id" : "1c9993ac-eff1-47d3-8d78-e877e06012bf",
    "prId" : 1983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4e93a5cd-a69f-404f-a572-bbde95761e21",
        "parentId" : null,
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Should this not report error if this external module has exportAssignmentSymbol ?\n",
        "createdAt" : "2015-02-11T02:53:54Z",
        "updatedAt" : "2015-02-23T19:27:45Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "7717ac8b-4385-4fce-b9cd-801d9a3fd792",
        "parentId" : "4e93a5cd-a69f-404f-a572-bbde95761e21",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I don't think so. The core constraint is that an ES5/ES3 external module can't have both regular exports and a default export. That's really the only thing we need to enforce, and indeed you get an error in a module that tries to have both. Basically, an ES5/ES3 module either (a) has a namespace with zero or more members and no default export or (b) has an empty namespace and a default export, or otherwise you'll get an error.\n\nOn the import side, there is no reason to treat ES5/ES3 modules specially. Errors just follow from the constrained shape of the module itself. Specifically, you'll get an error if you attempt to import the default object from a module that doesn't have one, and you'll be importing from an empty namespace in a module that does have a default object.\n",
        "createdAt" : "2015-02-11T06:28:22Z",
        "updatedAt" : "2015-02-23T19:27:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "889a9235-636b-43a5-ade7-b4b291800ac7",
        "parentId" : "4e93a5cd-a69f-404f-a572-bbde95761e21",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "That makes sense, although I think importing a module with an empty namespace using a namespace import is likely not what the user intended. If they just wanted to execute the module, they would have done `import \"mod\";`.\n\nThe error that you get for using the default import with a non-default-exported module is early. It's on the import. However, the error for importing an empty namespace with a namespace import is downstream. I could envision a user not being able to access a particular property on their import alias, and then wasting time looking inside the external module to figure out what happened.\n",
        "createdAt" : "2015-02-11T18:35:34Z",
        "updatedAt" : "2015-02-23T19:27:45Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "27529f1d38584189b98e57a526d3854216ab5c45",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +494,498 @@\n        function getTargetOfNamespaceImport(node: NamespaceImport): Symbol {\n            return resolveExternalModuleName(node, (<ImportDeclaration>node.parent.parent).moduleSpecifier);\n        }\n"
  },
  {
    "id" : "d8daebf2-d6c4-462e-ba0b-1dea659bb39f",
    "prId" : 1983,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d3d67c6e-9924-49af-87b0-fb5ebb1af6a0",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "`identifiers` can be incomplete after incremental parsing so 'compile on save' will be broken. that is why we use a separate table `nameTable` in part of `SourceFile` that belongs to services layer. We can pull [initializeNameTable](https://github.com/Microsoft/TypeScript/blob/master/src/services/services.ts#L3951) function that builds nameTable on demand down to the base compiler.\n",
        "createdAt" : "2015-02-16T07:08:13Z",
        "updatedAt" : "2015-02-23T19:27:45Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "50f44ef4-bbc9-4c5b-a35b-8f8a8e616ea3",
        "parentId" : "d3d67c6e-9924-49af-87b0-fb5ebb1af6a0",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, we should do that.\n",
        "createdAt" : "2015-02-16T16:45:07Z",
        "updatedAt" : "2015-02-23T19:27:45Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "27529f1d38584189b98e57a526d3854216ab5c45",
    "line" : 741,
    "diffHunk" : "@@ -1,1 +10454,10458 @@\n            function isExistingName(name: string) {\n                return hasProperty(globals, name) ||  hasProperty(sourceFile.identifiers, name) || hasProperty(generatedNames, name);\n            }\n"
  },
  {
    "id" : "c540673f-4a7f-489d-ac19-37e3d75d8b52",
    "prId" : 1978,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4b9648bd-2e0b-4df0-b546-12c641d77a05",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "We should really consider making an issue to track this; on the other hand, I'm the only one who has suggested this so far.\n\nWe really shouldn't be putting Symbol in `lib.d.ts`. Instead, we should just make the `lib.es6.d.ts` definitions usable from pre-ES6 mode.\n",
        "createdAt" : "2015-02-17T00:26:24Z",
        "updatedAt" : "2015-02-18T01:02:30Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "47404bccf08092d0cb087cb85e9c202bc7b79c89",
    "line" : 544,
    "diffHunk" : "@@ -1,1 +10461,10465 @@                // Consider putting Symbol interface in lib.d.ts. On the plus side, putting it in lib.d.ts would make it\n                // extensible for Polyfilling Symbols. But putting it into lib.d.ts could also break users that have\n                // a global Symbol already, particularly if it is a class.\n                globalESSymbolType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n                globalESSymbolConstructorSymbol = undefined;"
  },
  {
    "id" : "5aed35d6-f43d-4aab-a56a-416c4b80da91",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ce57c3f-7ce7-4a44-957e-4db996ace0e3",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I'm assuming nothing actually changed in this function, correct?\n",
        "createdAt" : "2015-02-06T09:27:22Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5821a97a-e329-4a82-bcb9-fc281cc20cbb",
        "parentId" : "3ce57c3f-7ce7-4a44-957e-4db996ace0e3",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Correct, I just changed it to top-level, added parameters, and gave it a more indicative name.\n",
        "createdAt" : "2015-02-06T14:23:22Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +5827,5831 @@        // var b: B;\n        // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]\n        function reorderCandidates(signatures: Signature[], result: Signature[]): void {\n            var lastParent: Node;\n            var lastSymbol: Symbol;"
  },
  {
    "id" : "bada49da-b863-4163-9a6f-e99f28adca32",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7844f61d-c9cf-46ca-bfaa-3f9b2569b71d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Declare argType outside\n",
        "createdAt" : "2015-02-06T09:32:16Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 149,
    "diffHunk" : "@@ -1,1 +5990,5994 @@                    var paramType = getTypeAtPosition(signature, arg.kind === SyntaxKind.SpreadElementExpression ? -1 : i);\n                    if (i === 0 && args[i].parent.kind === SyntaxKind.TaggedTemplateExpression) {\n                        var argType = globalTemplateStringsArrayType;\n                    }\n                    else {"
  },
  {
    "id" : "33fb66f6-002b-420d-a4cc-d1d8bfa8f60a",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "74755923-591f-42ba-8c18-41e80b466151",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why -1?\n",
        "createdAt" : "2015-02-06T09:33:02Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "1431e4b4-ae4f-483b-b224-5917a0f8f211",
        "parentId" : "74755923-591f-42ba-8c18-41e80b466151",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I use that as an indicator to return the rest parameter type of the signature (as an array type as opposed to as the element type of the array).\n",
        "createdAt" : "2015-02-06T14:25:10Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "1bc7b63b-d90e-4b92-a3c1-62b2807385db",
        "parentId" : "74755923-591f-42ba-8c18-41e80b466151",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah I definitely prefer separating getTypeAtPosition into 2 functions, like you said you had earlier.\n",
        "createdAt" : "2015-02-06T18:49:23Z",
        "updatedAt" : "2015-02-06T18:49:23Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 147,
    "diffHunk" : "@@ -1,1 +5988,5992 @@                var arg = args[i];\n                if (arg.kind !== SyntaxKind.OmittedExpression) {\n                    var paramType = getTypeAtPosition(signature, arg.kind === SyntaxKind.SpreadElementExpression ? -1 : i);\n                    if (i === 0 && args[i].parent.kind === SyntaxKind.TaggedTemplateExpression) {\n                        var argType = globalTemplateStringsArrayType;"
  },
  {
    "id" : "4bbe6bd0-7df9-470c-b4eb-9ae8fc9a395f",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "abffd013-6029-4b44-b1b5-dfac85f13759",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "True\n",
        "createdAt" : "2015-02-06T09:34:09Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5184af84-9df4-471c-82ac-04e304bc0c69",
        "parentId" : "abffd013-6029-4b44-b1b5-dfac85f13759",
        "authorId" : "048f9565-3011-4a30-9ada-ef1768a829db",
        "body" : "Typo: \"exlusion\"\n",
        "createdAt" : "2015-02-24T05:37:26Z",
        "updatedAt" : "2015-02-24T05:37:26Z",
        "lastEditedBy" : "048f9565-3011-4a30-9ada-ef1768a829db",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 174,
    "diffHunk" : "@@ -1,1 +6007,6011 @@            if (excludeArgument) {\n                for (var i = 0; i < args.length; i++) {\n                    // No need to check for omitted args and template expressions, their exlusion value is always undefined\n                    if (excludeArgument[i] === false) {\n                        var arg = args[i];"
  },
  {
    "id" : "88cfb4fb-c40a-4898-8e29-7282fba8269d",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a0d4a83-c3d4-4e2b-a9b1-e5f30cb9962b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Again, I don't understand the -1.\n",
        "createdAt" : "2015-02-06T09:34:47Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +6010,6014 @@                    if (excludeArgument[i] === false) {\n                        var arg = args[i];\n                        var paramType = getTypeAtPosition(signature, arg.kind === SyntaxKind.SpreadElementExpression ? -1 : i);\n                        inferTypes(context, checkExpressionWithContextualType(arg, paramType, inferenceMapper), paramType);\n                    }"
  },
  {
    "id" : "83001da3-7f6e-496f-8eb2-6049e44716db",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1f635420-27a2-46db-a0ee-affc2cb3a8f8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This is kind of a mouthful\n",
        "createdAt" : "2015-02-06T09:38:52Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "c1b59a90-4abf-424b-be2c-07b28a6eb307",
        "parentId" : "1f635420-27a2-46db-a0ee-affc2cb3a8f8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Honestly, I find it a lot easier to understand than the 25 lines of imperative code it replaces.\n",
        "createdAt" : "2015-02-06T14:28:14Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 224,
    "diffHunk" : "@@ -1,1 +6059,6063 @@                    var argType = i === 0 && node.kind === SyntaxKind.TaggedTemplateExpression ? globalTemplateStringsArrayType :\n                        arg.kind === SyntaxKind.StringLiteral && !reportErrors ? getStringLiteralType(<LiteralExpression>arg) :\n                        checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);\n                    // Use argument expression as error location when reporting errors\n                    if (!checkTypeRelatedTo(argType, paramType, relation, reportErrors ? arg : undefined,"
  },
  {
    "id" : "ff13ae87-6f90-4f65-b4e9-3859c5e38097",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c3eec0db-986d-4bca-ba63-d5f94a0ba77c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would far prefer to have two separate functions, one for spread, and one for normal arguments. I noticed above that you use the conditional operator to switch the pos value you pass in, so instead you can just switch the function that you call, and pass the pos as is.\n",
        "createdAt" : "2015-02-06T09:41:11Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "c0023380-21c7-43da-bf64-d9e257578eb0",
        "parentId" : "c3eec0db-986d-4bca-ba63-d5f94a0ba77c",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I had it that way, but this actually seemed better (and shorter). Anyway, I can change it back.\n",
        "createdAt" : "2015-02-06T14:29:31Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 325,
    "diffHunk" : "@@ -1,1 +6530,6534 @@        }\n\n        function getTypeAtPosition(signature: Signature, pos: number): Type {\n            if (pos >= 0) {\n                return signature.hasRestParameter ?"
  },
  {
    "id" : "b6106b44-7448-4454-a4e9-d4591d45dacb",
    "prId" : 1931,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a9bc2e2-e7a7-4647-aee6-8b642508bfd9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I think that if the spread argument is not in the rest range, we should return anyArrayType, just like the case where there is no rest param.\n",
        "createdAt" : "2015-02-06T09:44:04Z",
        "updatedAt" : "2015-02-06T15:39:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "9859f0ca-6c96-4fb3-a587-02790d34391c",
        "parentId" : "3a9bc2e2-e7a7-4647-aee6-8b642508bfd9",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I don't understand what you mean.\n",
        "createdAt" : "2015-02-06T14:32:27Z",
        "updatedAt" : "2015-02-06T15:39:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "38e6c1fb-82e5-4b4c-844e-fdf277341479",
        "parentId" : "3a9bc2e2-e7a7-4647-aee6-8b642508bfd9",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Like in the following case:\n\n``` ts\nfunction foo(x: string, y: string, ...rest: number[]) {}\nfoo(...[\"hi\", \"bye\"]);\n```\n\nThis is an error, but getTypeOfSymbol returns `number[]`. But I think it should return `any[]`, just like it does if the rest param were not there.\n",
        "createdAt" : "2015-02-06T18:55:54Z",
        "updatedAt" : "2015-02-06T18:55:54Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "86a476e3-79e7-441b-828a-a8adff12d86f",
        "parentId" : "3a9bc2e2-e7a7-4647-aee6-8b642508bfd9",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Or it could return a union of all the param types starting from the current index in the param list, all the way to the end, but I think that's not necessary, since it is an error case.\n",
        "createdAt" : "2015-02-06T18:56:53Z",
        "updatedAt" : "2015-02-06T18:57:00Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "0819ca897cf2dc61f8e60f51870e192ae28c764b",
    "line" : 334,
    "diffHunk" : "@@ -1,1 +6537,6541 @@            }\n            return signature.hasRestParameter ?\n                getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]) :\n                anyArrayType;\n        }"
  },
  {
    "id" : "ac901af5-6c35-42ff-a4bf-8fa5cca9c651",
    "prId" : 1861,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "77a4dd27-cf2e-4484-86d7-61dccf84ab95",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "~~Technically, you may not use the inference mapper at if all your arguments are sensitive to contextual typing. This was already the case though. I doubt it's a worthwhile optimization, but I'm just thinking out loud (in writing).~~\n",
        "createdAt" : "2015-01-30T08:24:54Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "4a27c7c5-7ba5-46aa-b21e-f7c0a6c4be19",
        "parentId" : "77a4dd27-cf2e-4484-86d7-61dccf84ab95",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "No, you will always use it on the second pass at least\n",
        "createdAt" : "2015-01-30T08:59:12Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a534bf7d-9c3a-45b3-aeab-2fff5670401e",
        "parentId" : "77a4dd27-cf2e-4484-86d7-61dccf84ab95",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "My mistake, I see that now\n",
        "createdAt" : "2015-01-30T09:13:54Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "34ed45df8e21de17c061ac01933c7d34058480b5",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +5889,5893 @@            var typeParameters = signature.typeParameters;\n            var context = createInferenceContext(typeParameters, /*inferUnionTypes*/ false);\n            var inferenceMapper = createInferenceMapper(context);\n\n            // We perform two passes over the arguments. In the first pass we infer from all arguments, but use"
  },
  {
    "id" : "f8e8030c-1553-45cc-b9cb-06c24274b442",
    "prId" : 1861,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "26f8b762-5aa6-416f-8139-dd3fab1e7ff7",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Ouch! Sorry about that.\n",
        "createdAt" : "2015-01-30T08:26:07Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e1e4ebe5-a026-4218-99e5-35787008cf40",
        "parentId" : "26f8b762-5aa6-416f-8139-dd3fab1e7ff7",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Can we get a test that would trigger this not working in the old code?\n",
        "createdAt" : "2015-01-30T08:28:40Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "86b63277-5ef9-4de6-b46f-a2c32c9a895b",
        "parentId" : "26f8b762-5aa6-416f-8139-dd3fab1e7ff7",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Good catch\n",
        "createdAt" : "2015-01-30T08:43:16Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "1ad9dee3-c6ca-4483-91c5-352e14b7f89f",
        "parentId" : "26f8b762-5aa6-416f-8139-dd3fab1e7ff7",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "contextualTypingWithFixedTypeParameters1.ts already tests it. The error message about a 'foo' property missing on type 'T' reveals the problem.\n",
        "createdAt" : "2015-01-30T17:21:46Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "cf721dc4-1541-4c48-82a3-b61b4d9f08ab",
        "parentId" : "26f8b762-5aa6-416f-8139-dd3fab1e7ff7",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would still rather have a test that is explicitly designed to test this.\n",
        "createdAt" : "2015-01-30T18:53:59Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "34ed45df8e21de17c061ac01933c7d34058480b5",
    "line" : 82,
    "diffHunk" : "@@ -1,1 +7291,7295 @@                    return checkTypeAssertion(<TypeAssertion>node);\n                case SyntaxKind.ParenthesizedExpression:\n                    return checkExpression((<ParenthesizedExpression>node).expression, contextualMapper);\n                case SyntaxKind.FunctionExpression:\n                case SyntaxKind.ArrowFunction:"
  },
  {
    "id" : "9814aaab-b568-4983-b134-26e56b92d104",
    "prId" : 1861,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "00a1b438-e8c2-4ffe-b274-12a88dfff5b1",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So the order is essentially still the same. We first do all the arguments (instead of just the ones that were never excluded). Then we come back and do the ones that were once excluded but no longer are.\n\nI'm noticing two things:\n1. For the arguments that do contain context sensitive expressions, we will end up visiting (inferring from) most of the argument twice. The only parts that will be new the second time are the context sensitive expressions. I guess it is not worth the complexity of trying to fish out just the context sensitive expressions for this second visit. After all, many arguments of this sort are likely to be lambdas, which only consist of a context sensitive expression.\n2. We will visit each argument at most twice. So while this does improve things over what we had before, we will not be able to handle something like:\n\n``` ts\ninterface Computed<T, U> {\n    read(): T;\n    write(value: T): U;\n    rewrite(value: U);\n}\n\nfunction foo<T, U>(x: Computed<T, U>) { }\n\nvar s: string;\n\nfoo({\n    read: () => s,\n    write: value => s = value,\n    rewrite: value => s = value\n});\n```\n\nFor this to work, you'd have to visit the argument 3 times. I would be very surprised if this kind of thing ever comes up though.\n",
        "createdAt" : "2015-01-30T08:40:53Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "6c21b462-2b9c-4622-8458-7a9233224868",
        "parentId" : "00a1b438-e8c2-4ffe-b274-12a88dfff5b1",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Yes, your observations are correct.\n",
        "createdAt" : "2015-01-30T17:26:29Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "34ed45df8e21de17c061ac01933c7d34058480b5",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +5919,5923 @@                    if (excludeArgument[i] === false) {\n                        var parameterType = getTypeAtPosition(signature, i);\n                        inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, inferenceMapper), parameterType);\n                    }\n                }"
  },
  {
    "id" : "0cf8bbdf-ca66-4294-8605-98593dcbba35",
    "prId" : 1861,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "603719d6-4c55-4de0-b539-a4d6e583e96d",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I assume you're keeping the `contextualMapper === identityMapper` as a quick short-circuiting operation.\n",
        "createdAt" : "2015-01-30T08:42:12Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "fe36bd0c-7a49-4105-abbf-dfa95bba8955",
        "parentId" : "603719d6-4c55-4de0-b539-a4d6e583e96d",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "How was this not an issue before? Were we only passing identityMapper when the node was context sensitive?\n",
        "createdAt" : "2015-01-30T08:42:41Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "931d0fb8-7e23-4308-81ba-c6081b7c3023",
        "parentId" : "603719d6-4c55-4de0-b539-a4d6e583e96d",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Previously we would never pass identityMapper during inferential typing and it was fine to just treat _all_ function expressions in the argument as wildcards. We now want a \"hybrid\" type constructed where only context sensitive function expessions are blanked out, such that we can infer from it in the first pass.\n",
        "createdAt" : "2015-01-30T17:39:20Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "db4e1029-c5c1-4c4a-9117-c57d8d8fda85",
        "parentId" : "603719d6-4c55-4de0-b539-a4d6e583e96d",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I see. In other words, we only passed the identity mapper during the argument assignability check. And because that is a boolean check whose only side effects apply to context sensitive functions, it was impossible to observe the fact that context insensitive functions  were being skipped.\n",
        "createdAt" : "2015-01-30T19:01:20Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "34ed45df8e21de17c061ac01933c7d34058480b5",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +6617,6621 @@\n            // The identityMapper object is used to indicate that function expressions are wildcards\n            if (contextualMapper === identityMapper && isContextSensitive(node)) {\n                return anyFunctionType;\n            }"
  },
  {
    "id" : "11e75297-0781-4bee-b82b-0b68f911a8c2",
    "prId" : 1861,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "713f3f62-0a08-41b1-ab58-772b7baca1d6",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Add a simple comment above this and a newline below the body.\n",
        "createdAt" : "2015-01-30T08:47:15Z",
        "updatedAt" : "2015-02-02T18:26:39Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "34ed45df8e21de17c061ac01933c7d34058480b5",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +4321,4325 @@                if (source === anyFunctionType) {\n                    return;\n                }\n                if (target.flags & TypeFlags.TypeParameter) {\n                    // If target is a type parameter, make an inference"
  },
  {
    "id" : "0f9f5547-9fc8-45d8-8e88-288e09b24b5c",
    "prId" : 1816,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b2e3c44-b9b4-4844-bc6e-ec8e5de53381",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This is fine, but one alternative you might consider is for resolveCall to take a parameter for the type arguments, and have the caller determine what to pass. So whichever caller handles super calls would get the type arguments from the base type reference. But I admit it's a bit weird to pass the entire CallLikeExpression, with the the type arguments alongside it. It's like having meat and potatoes, with a side of potatoes.\n",
        "createdAt" : "2015-01-27T06:07:43Z",
        "updatedAt" : "2015-01-27T22:57:43Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "5fa44456-b6f0-4d96-9e37-71bd7bff46ca",
        "parentId" : "8b2e3c44-b9b4-4844-bc6e-ec8e5de53381",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Exactly! It's like if you gave me corn alongside corn-off-the-cob - it's kind of odd to give both.\n",
        "createdAt" : "2015-01-27T06:43:28Z",
        "updatedAt" : "2015-01-27T22:57:43Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "4cd27dba-d1c7-42c4-af18-d69a71de97fc",
        "parentId" : "8b2e3c44-b9b4-4844-bc6e-ec8e5de53381",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "We can do this without passing the type arguments. But I think we'll leave it for another PR.\n",
        "createdAt" : "2015-01-27T23:00:27Z",
        "updatedAt" : "2015-01-27T23:00:27Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0ffa722e23a14f281debebd8d0612dfc66909ddd",
    "line" : 34,
    "diffHunk" : "@@ -1,1 +6007,6011 @@\n            if (!isTaggedTemplate) {\n                typeArguments = getEffectiveTypeArguments(<CallExpression>node);\n\n                // We already perform checking on the type arguments on the class declaration itself."
  },
  {
    "id" : "33c594e5-5721-4263-ae10-12e5db3cd0e5",
    "prId" : 1795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "27f9715a-8dc1-4c79-8aa4-42d043b1e15e",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It is clear what this does, but please put a comment explaining when it should be called. It would seem very easy to forget to call it.\n",
        "createdAt" : "2015-01-26T19:42:19Z",
        "updatedAt" : "2015-01-27T14:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3da7cc8ce6c999990bdd54d8e60bfd65b1a3d2",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2830,2834 @@        // It is only necessary to do so if a constituent type might be the undefined type, the null type, or the type\n        // of an object literal (since those types have widening related information we need to track).\n        function getWideningFlagsOfTypes(types: Type[]): TypeFlags {\n            var result: TypeFlags = 0;\n            for (var i = 0; i < types.length; i++) {"
  },
  {
    "id" : "54346837-474d-4a0a-82ec-b14e9823779d",
    "prId" : 1795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "673e4d51-f348-496c-8a64-4571ffb9a809",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Seems like this should be `&&`. I'm not sure how this was ever working.\n",
        "createdAt" : "2015-01-26T19:44:54Z",
        "updatedAt" : "2015-01-27T14:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "34b4ab2f-5b39-4548-b9eb-18f87557a188",
        "parentId" : "673e4d51-f348-496c-8a64-4571ffb9a809",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No, it's correct. It says \"if the target property is not optional (i.e. if it is a required property) _or_ if we require optional properties to be present in the source\".\n",
        "createdAt" : "2015-01-26T20:03:00Z",
        "updatedAt" : "2015-01-27T14:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3da7cc8ce6c999990bdd54d8e60bfd65b1a3d2",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +3725,3729 @@                    if (sourceProp !== targetProp) {\n                        if (!sourceProp) {\n                            if (!(targetProp.flags & SymbolFlags.Optional) || requireOptionalProperties) {\n                                if (reportErrors) {\n                                    reportError(Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));"
  },
  {
    "id" : "8f92ffeb-6a8b-4cc6-a600-d90a24c2674c",
    "prId" : 1795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fdea7cf7-2d29-4f5d-9467-850ffb437612",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What is the actual change here? It seems the check `propType !== widenedType` is the only new thing, but that's just an optimization, right? Or am I missing something\n",
        "createdAt" : "2015-01-26T19:47:18Z",
        "updatedAt" : "2015-01-27T14:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e4e589db-05c3-402b-a52b-89c6d6c17e4c",
        "parentId" : "fdea7cf7-2d29-4f5d-9467-850ffb437612",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Right, the new thing is the added optimization.\n",
        "createdAt" : "2015-01-26T20:03:46Z",
        "updatedAt" : "2015-01-27T14:32:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3da7cc8ce6c999990bdd54d8e60bfd65b1a3d2",
    "line" : 94,
    "diffHunk" : "@@ -1,1 +4139,4143 @@                    p = symbol;\n                }\n                members[p.name] = p;\n            });\n            var stringIndexType = getIndexTypeOfType(type, IndexKind.String);"
  },
  {
    "id" : "c2501fdd-3040-448f-8eb3-4ac4051797bf",
    "prId" : 1795,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1cf7a4f-1c59-48ee-9644-d9f77f85a495",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, this is important\n",
        "createdAt" : "2015-01-26T19:50:10Z",
        "updatedAt" : "2015-01-27T14:32:35Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "5c3da7cc8ce6c999990bdd54d8e60bfd65b1a3d2",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +5525,5529 @@                    }\n                    var result = propTypes.length ? getUnionType(propTypes) : undefinedType;\n                    typeFlags |= result.flags;\n                    return result;\n                }"
  },
  {
    "id" : "b6e92358-4212-4d43-8b11-ff3e062221b5",
    "prId" : 1752,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "68da9d5a-414e-41a9-8ebd-1d74caad3c42",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Can you give an example of when this would happen?\n",
        "createdAt" : "2015-01-22T14:36:31Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "6b19c8e0-10bc-47e7-aaf6-85575ca0b33e",
        "parentId" : "68da9d5a-414e-41a9-8ebd-1d74caad3c42",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yes, a good example is tests\\cases\\conformance\\es6\\computedProperties\\computedPropertyNames32.ts:\n\n``` ts\nfunction foo<T>() { return '' }\nclass C<T> {\n    [foo<T>()]() { }\n}\n```\n\nI will add this snippet in a comment in the code as well.\n",
        "createdAt" : "2015-01-22T22:35:41Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd29ca83893c54e300b56f7a5460f604c1591aa8",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +352,356 @@                            // A reference to this grandparent's type parameters would be an error\n                            if (result = getSymbol(getSymbolOfNode(grandparent).members, name, meaning & SymbolFlags.Type)) {\n                                error(errorLocation, Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);\n                                return undefined;\n                            }"
  },
  {
    "id" : "797e5d8e-ebac-4036-8596-a619fbd0e176",
    "prId" : 1752,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "54b8ec83-555b-45c5-b620-b58d41c49bee",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Are you sure `valueDeclaration` is always defined here?\n",
        "createdAt" : "2015-01-22T14:51:07Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "585415db-0bb9-4c44-b200-9fbbe4fbcd75",
        "parentId" : "54b8ec83-555b-45c5-b620-b58d41c49bee",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I believe every property symbol has a valueDeclaration, but I can try to refactor it so that I don't have to make that assumption.\n",
        "createdAt" : "2015-01-22T22:45:18Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ba69ba18-cb18-4fa1-93f2-5185d1ff8977",
        "parentId" : "54b8ec83-555b-45c5-b620-b58d41c49bee",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Some synthetic property symbols don't have declarations (e.g. the property members of a tuple), just wanted to make sure that doesn't apply here.\n",
        "createdAt" : "2015-01-22T23:19:18Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "19eade20-acbf-44d9-8a71-a86d2d07a9da",
        "parentId" : "54b8ec83-555b-45c5-b620-b58d41c49bee",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I verified in the binder that all property symbols should have a valueDeclaration. I admit this feels fragile, but I can't think of a better way to access the declaration, other than valueDeclaration. It is no more fragile than assuming a declaration will have a symbol, because both links are wired at the same time in addDeclarationToSymbol.\n",
        "createdAt" : "2015-01-22T23:23:11Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "c99d58e7-3aa8-490a-b142-39aec2bf4544",
        "parentId" : "54b8ec83-555b-45c5-b620-b58d41c49bee",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Are those all typed as TransientSymbol? I can do a sweep of those.\n",
        "createdAt" : "2015-01-22T23:27:47Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "183b5287-90fa-4f79-a06b-67599db35f23",
        "parentId" : "54b8ec83-555b-45c5-b620-b58d41c49bee",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Ok, I looked for all calls to createSymbol in the checker. The only one that could apply for interfaces, classes, or object type literals (the three things that checkIndexConstraints is called on) is the call in cloneSymbol. And that function copies the valueDeclaration from the original symbol.\n",
        "createdAt" : "2015-01-23T01:17:34Z",
        "updatedAt" : "2015-01-24T02:50:04Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "bd29ca83893c54e300b56f7a5460f604c1591aa8",
    "line" : 451,
    "diffHunk" : "@@ -1,1 +8558,8562 @@\n                // index is numeric and property name is not valid numeric literal\n                if (indexKind === IndexKind.Number && !isNumericName(prop.valueDeclaration.name)) {\n                    return;\n                }"
  },
  {
    "id" : "094df474-8cf5-429c-875c-63b4da6e93c0",
    "prId" : 1673,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ecd7224a-75fb-4eb8-96d2-614f97311923",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "How can node.kind be Parameter if node is a SignatureDeclaration?\n",
        "createdAt" : "2015-01-15T00:22:06Z",
        "updatedAt" : "2015-01-15T00:22:06Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "f9a2bdca-517a-45fa-a940-184309b8fef8",
        "parentId" : "ecd7224a-75fb-4eb8-96d2-614f97311923",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "To clarify, it's not, GitHub diffs break after 10K lines.\n",
        "createdAt" : "2015-01-15T00:32:32Z",
        "updatedAt" : "2015-01-15T00:32:32Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "e19ebc6d3ea63a33beb70a59c698ba2a152c3d73",
    "line" : 35,
    "diffHunk" : "@@ -1,1 +10173,10177 @@                return grammarErrorOnNode(lastDeclare, Diagnostics.A_declare_modifier_cannot_be_used_with_an_interface_declaration, \"declare\");\n            }\n            else if (node.kind === SyntaxKind.Parameter && (flags & NodeFlags.AccessibilityModifier) && isBindingPattern((<ParameterDeclaration>node).name)) {\n                return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_a_binding_pattern);\n            }"
  },
  {
    "id" : "ba507fb7-80a1-4fa8-a829-4abfbebfe0d4",
    "prId" : 1575,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5f89817f-476e-4f84-a727-599a78425796",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "i would write this as:\n\n``` typescript\nif (sourceType === targetType) {\n    sourceType = typeToString(...);\n    targetType = typeToString(...);\n}\n\nreportError(headMessage, sourceType, targetType)\n```\n",
        "createdAt" : "2015-01-03T03:36:12Z",
        "updatedAt" : "2015-01-24T16:50:17Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc9f45468238e086d2d2fc5a6986ff7c30b9841",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +3513,3517 @@                    headMessage = headMessage || Diagnostics.Type_0_is_not_assignable_to_type_1;\n                    var sourceType = typeToString(source);\n                    var targetType = typeToString(target);\n                    if (sourceType === targetType) {\n                        sourceType = typeToString(source, /*enclosingDeclaration*/ undefined, TypeFormatFlags.UseFullyQualifiedType);"
  },
  {
    "id" : "0e1ea395-03e2-450b-b0db-bca9b3d2d5c7",
    "prId" : 1575,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8c418aa9-b02f-4765-a55c-b9a84e699865",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "This is subtle - leave a comment saying that in these cases, the specified symbol flags need to be reinterpreted as type flags.\n",
        "createdAt" : "2015-01-23T20:14:02Z",
        "updatedAt" : "2015-01-24T16:50:17Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc9f45468238e086d2d2fc5a6986ff7c30b9841",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1125,1129 @@                    else if (type.flags & (TypeFlags.Class | TypeFlags.Interface | TypeFlags.Enum | TypeFlags.TypeParameter)) {\n                        // The specified symbol flags need to be reinterpreted as type flags\n                        buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, SymbolFlags.Type, SymbolFormatFlags.None, flags);\n                    }\n                    else if (type.flags & TypeFlags.Tuple) {"
  },
  {
    "id" : "c527f52a-69a9-4bfc-8b0c-07254f2e7225",
    "prId" : 1575,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1c6a7a36-c628-475e-b492-76a7297e919c",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Same comment as for `TypeFlags.Class | TypeFlags.Interface | TypeFlags.Enum | TypeFlags.TypeParameter`\n",
        "createdAt" : "2015-01-23T20:21:03Z",
        "updatedAt" : "2015-01-24T16:50:17Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "afc9f45468238e086d2d2fc5a6986ff7c30b9841",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1207,1211 @@                        if (typeAlias) {\n                            // The specified symbol flags need to be reinterpreted as type flags\n                            buildSymbolDisplay(typeAlias, writer, enclosingDeclaration, SymbolFlags.Type, SymbolFormatFlags.None, flags);\n                        }\n                        else {"
  },
  {
    "id" : "f3f4caab-1f08-4fa8-ae2e-189ff3d1c62d",
    "prId" : 1515,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5d1d8aa6-9aa6-48ab-88c1-b6ad85988faa",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Could you add test case for when you don't reference the import.\n",
        "createdAt" : "2014-12-17T22:22:46Z",
        "updatedAt" : "2014-12-17T22:36:17Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "29dfa3d6c035d784b0fab8da7b89065e806f0a39",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +9189,9193 @@                    if (symbolWithRelevantName.flags & SymbolFlags.Import) {\n                        var importDeclarationWithRelevantName = <ImportDeclaration>getDeclarationOfKind(symbolWithRelevantName, SyntaxKind.ImportDeclaration);\n                        if (isReferencedImportDeclaration(importDeclarationWithRelevantName)) {\n                            return false;\n                        }"
  },
  {
    "id" : "c5400a3f-1c0a-44cd-b83a-b098d1c54d5a",
    "prId" : 1463,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2e948045-46f3-4c7b-a04f-b80227ef1144",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Does this ever return `-1`?\n",
        "createdAt" : "2014-12-12T21:50:46Z",
        "updatedAt" : "2014-12-17T19:50:22Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "58e73595-b9b6-4f57-80ce-c26d306af1ee",
        "parentId" : "2e948045-46f3-4c7b-a04f-b80227ef1144",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "No. We generally assume that it is safe to get the index of a child element in a parent collection without checking for -1 (as that should never be the case).\n",
        "createdAt" : "2014-12-12T22:44:44Z",
        "updatedAt" : "2014-12-17T19:50:22Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a667959b1fcc0f22c3695fb71e9abf7da31e948b",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +1684,1688 @@                if (!declaration.dotDotDotToken) {\n                    // Use specific property type when parent is a tuple or numeric index type when parent is an array\n                    var propName = \"\" + indexOf(pattern.elements, declaration);\n                    var type = isTupleLikeType(parentType) ? getTypeOfPropertyOfType(parentType, propName) : getIndexTypeOfType(parentType, IndexKind.Number);\n                    if (!type) {"
  },
  {
    "id" : "45738cd7-34bb-4e13-b963-56a1583da227",
    "prId" : 1463,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76720270-7b6d-4f94-a475-c17621313c75",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "could you explain this bit.  If there is a dotDotDot token, then we push the 'any' type into the elment types.  Then we get the union type that includes that any types?  Why is that desirable here?  Thanks!\n",
        "createdAt" : "2014-12-15T08:37:03Z",
        "updatedAt" : "2014-12-17T19:50:22Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "f527a9c6-bacb-4918-afbd-28cf3a725708",
        "parentId" : "76720270-7b6d-4f94-a475-c17621313c75",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "The comment on `getTypeFromBindingPattern` just below explains the `any`. It says:\n\n> Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself and without regard to its context (i.e. without regard any type annotation or initializer associated with the declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any] and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of the parameter.\n\nUnless an element has an initializer, we treat it as having type `any` when determining the implied type. And, since omitted and rest elements never have initializers, they are always regarded as having type `any`.\n",
        "createdAt" : "2014-12-15T14:40:11Z",
        "updatedAt" : "2014-12-17T19:50:22Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "a667959b1fcc0f22c3695fb71e9abf7da31e948b",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +1775,1779 @@                }\n            });\n            return !elementTypes.length ? anyArrayType : hasSpreadElement ? createArrayType(getUnionType(elementTypes)) : createTupleType(elementTypes);\n        }\n"
  },
  {
    "id" : "6c8b1b13-cfb8-4479-8077-2d338da03485",
    "prId" : 1463,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "25fb3851-ebc3-4dc7-b0bf-2a2cb7198d23",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Could you add some comments to this code explaining what it is doing?  I have no intuition as to what it is trying to do, or why it is desirable behavior.  Thanks!\n",
        "createdAt" : "2014-12-15T08:38:27Z",
        "updatedAt" : "2014-12-17T19:50:22Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "a667959b1fcc0f22c3695fb71e9abf7da31e948b",
    "line" : 125,
    "diffHunk" : "@@ -1,1 +5349,5353 @@            var elementTypes: Type[] = [];\n            forEach(elements, e => {\n                var type = checkExpression(e, contextualMapper);\n                if (e.kind === SyntaxKind.SpreadElementExpression) {\n                    elementTypes.push(getIndexTypeOfType(type, IndexKind.Number) || anyType);"
  },
  {
    "id" : "1b8a1a81-f97d-491f-b9d2-85dc0865ad97",
    "prId" : 1434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12b1b385-83a8-44c3-ac57-e6075c84cee6",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Why the extra level of indirection (and extra nodes for every variable declaration)?\n",
        "createdAt" : "2014-12-16T21:49:55Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "c4c70e8f-bfc9-4214-9165-9bd5ab6fab3a",
        "parentId" : "12b1b385-83a8-44c3-ac57-e6075c84cee6",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "See above comment.  The existing model for parsing inappropriately pushed outer flags to nested children.  This broke the invariant that nodes are only affected by changes below them, and affected the ability for us to be able to incrementally reuse nodes safely.\n\nNote: while this adds a small amount of memory to compilation, the incremental gain produces vastly less garbage for the LS scenario.  this is quite important as garbage leads to GCs which lead to pauses, which pushes the latency for typing above our high water mark.\n",
        "createdAt" : "2014-12-17T00:48:29Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a08c54f429e486d774b92c4af6858820fb9c55f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +8121,8125 @@            checkGrammarDisallowedModifiersInBlockOrObjectLiteralExpression(node) || checkGrammarModifiers(node) || checkGrammarVariableDeclarationList(node.declarationList) || checkGrammarForDisallowedLetOrConstStatement(node);\n\n            forEach(node.declarationList.declarations, checkSourceElement);\n        }\n"
  },
  {
    "id" : "7469e1f5-eb60-4d83-80c7-7556feb5db37",
    "prId" : 1434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "585d4cf8-c35d-48e2-9f28-87ffb9b10e56",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Previous scheme had less code and fewer allocated objects.\n",
        "createdAt" : "2014-12-16T21:51:03Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a08c54f429e486d774b92c4af6858820fb9c55f",
    "line" : 319,
    "diffHunk" : "@@ -1,1 +8189,8193 @@                    checkExpression(<Expression>node.initializer)\n                }\n            }\n\n            if (node.condition) checkExpression(node.condition);"
  },
  {
    "id" : "52a5eaee-8d54-4391-bd87-008f20188d12",
    "prId" : 1434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "feffa1af-abb2-43a7-b642-8cdb15dac6be",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "That's an awful lot of indirections and allocated nodes for something as common as a variable declaration.\n",
        "createdAt" : "2014-12-16T21:54:16Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a08c54f429e486d774b92c4af6858820fb9c55f",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1630,1634 @@            // Parent chain: \n            // VaribleDeclaration -> VariableDeclarationList -> VariableStatement -> 'Declaration Container'\n            return node.kind === SyntaxKind.VariableDeclaration ? node.parent.parent.parent : node.parent;\n        }\n"
  },
  {
    "id" : "4cd8d997-a81f-47a8-99b3-af4923bf9e56",
    "prId" : 1434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0820142-4e34-45dd-a930-0566a7f5c142",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "When should `nodeIsMissing` be used?\n",
        "createdAt" : "2014-12-16T21:54:45Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "3abb3954-037e-4b62-add3-aaf9ec9fc59d",
        "parentId" : "d0820142-4e34-45dd-a930-0566a7f5c142",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "When you want to know if the user provide actual code for the node in their source file or not. \n\nIn the case where the node is optional, it will show up as missing (because it's not there as the user didn't write it).  And in the case where it is required, it will show up as missing (even htough it is not necessarily 'undefined' due to the parser strictly trying to parse it out.\n\nThis helps address cases where we were just checking for the presence or absence of a node. This wasn't working properly for the acse where the user didn't have any code for the node, so we parsed out a missing one.  We'd see the node was not undefined, and hten we'd go report things.\n\nFor example, if you had some function that required a body, but didn't provide one, we'd then end up reporting both the missing body, _and_ a message that you needed a return statement or throw in the body.  THe latter is pointless.  if the body is missing, don't report errors that only make sense if the body is there.\n\nI will add comments to this effect on the function.\n",
        "createdAt" : "2014-12-17T00:53:28Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a08c54f429e486d774b92c4af6858820fb9c55f",
    "line" : 88,
    "diffHunk" : "@@ -1,1 +2638,2642 @@                    }\n\n                    if (!returnType && nodeIsMissing((<FunctionLikeDeclaration>declaration).body)) {\n                        returnType = anyType;\n                    }"
  },
  {
    "id" : "7d2ff0a0-f87e-4b44-8e5c-9c0e4c057ce8",
    "prId" : 1434,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b62ca03-dc1c-4032-b367-97c6bf3d86d6",
        "parentId" : null,
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I see a lot of changes like this, but the node being tested is optional so the existing code is already correct, not to mention shorter and less confusing because use of the function implies that the node is _not_ optional but rather a required node that is missing.\n\nWe already have an established practice for encoding missing optional nodes: undefined. And we have an established practice for checking for undefined: Simply test the value. We're not going to change that.\n",
        "createdAt" : "2014-12-17T01:25:23Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "050e7e4b-67f0-437c-9e3b-a3c316911be4",
        "parentId" : "2b62ca03-dc1c-4032-b367-97c6bf3d86d6",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Note: nodeIsMissing is more correct here.  There may be cases where we have a body (i.e. it is _defined_), but it is still _missing_.  In that case, we don't want to proceed and perform further checks that will just be noisy.\n\nA very good example of this are the errors for the body of things that _do_ require bodies, that they must have a return statemnet or throw statement.  The node is _required_.  So it will _not_ be undefined.  But checking just for 'undefined' will mean that we go forward and report the issue about return/throw being missing.  \n\nThis unifies the concept of a missing _required_ node, and a missing _optional_ node.  Something that 'undefined/defined' did not encode previously.\n",
        "createdAt" : "2014-12-17T01:51:48Z",
        "updatedAt" : "2014-12-17T21:22:17Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6a08c54f429e486d774b92c4af6858820fb9c55f",
    "line" : 152,
    "diffHunk" : "@@ -1,1 +7304,7308 @@\n            // exit early in the case of signature - super checks are not relevant to them\n            if (nodeIsMissing(node.body)) {\n                return;\n            }"
  },
  {
    "id" : "8e27488b-2346-4ecc-ae2e-d2b1aed2742e",
    "prId" : 1433,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "70a382c3-0b5a-4b00-9876-ed56400d93b5",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What about unknownType?\n",
        "createdAt" : "2014-12-10T19:56:14Z",
        "updatedAt" : "2014-12-10T22:25:18Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "ec429251-2a25-48b8-9283-a95f290acff7",
        "parentId" : "70a382c3-0b5a-4b00-9876-ed56400d93b5",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "TypeFlags.Any includes the unknown type.\n",
        "createdAt" : "2014-12-10T20:44:46Z",
        "updatedAt" : "2014-12-10T22:25:18Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a8a67a0b-7c95-4409-befa-9f525bb0a798",
        "parentId" : "70a382c3-0b5a-4b00-9876-ed56400d93b5",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Can we rename it to .AnyOrUnknown then?\n",
        "createdAt" : "2014-12-10T21:18:42Z",
        "updatedAt" : "2014-12-10T22:25:18Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "9f1f89f8-e150-4aac-b174-99e220325c9b",
        "parentId" : "70a382c3-0b5a-4b00-9876-ed56400d93b5",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I'm going to leave it unchanged for now.\n",
        "createdAt" : "2014-12-10T22:25:53Z",
        "updatedAt" : "2014-12-10T22:25:53Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2876ba6a6cb1c133235b25e8a9d6f7417ba07a6e",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +6614,6618 @@            }\n            // NOTE: do not raise error if right is unknown as related error was already reported\n            if (!(rightType.flags & TypeFlags.Any || isTypeSubtypeOf(rightType, globalFunctionType))) {\n                error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);\n            }"
  },
  {
    "id" : "d5db1318-bbd7-448c-81fb-f1e8da57a2e8",
    "prId" : 1433,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e8da0993-b94e-4e6f-ac61-c8702117da44",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Again, what about unknown?\n",
        "createdAt" : "2014-12-10T19:56:55Z",
        "updatedAt" : "2014-12-10T22:25:18Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "2876ba6a6cb1c133235b25e8a9d6f7417ba07a6e",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +7976,7980 @@            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved\n            // in this case error about missing name is already reported - do not report extra one\n            if (!(exprType.flags & TypeFlags.Any || isStructuredType(exprType))) {\n                error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);\n            }"
  },
  {
    "id" : "41e12f20-9fdc-43eb-9ce8-c8ffd989dc0c",
    "prId" : 1423,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eede9cbf-2b3f-4a6f-942e-06063bcba1c4",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "i think these comments can jus tbe removed in cases like this.  your call.\n",
        "createdAt" : "2014-12-17T03:14:00Z",
        "updatedAt" : "2014-12-17T03:59:37Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "99a189936f2c7449bb6ad2c52190f18f59bdc3de",
    "line" : 171,
    "diffHunk" : "@@ -1,1 +6958,6962 @@\n        function checkObjectLiteralMethod(node: MethodDeclaration, contextualMapper?: TypeMapper): Type {\n            // Grammar checking\n            checkGrammarMethod(node);\n"
  },
  {
    "id" : "1c845b93-083c-41c9-95fe-9077629a45d3",
    "prId" : 1423,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "32f1d014-ff68-46ed-bc5b-f7a62792b413",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "only do this if the first grammar check returned false.\n",
        "createdAt" : "2014-12-17T03:19:48Z",
        "updatedAt" : "2014-12-17T03:59:37Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "99a189936f2c7449bb6ad2c52190f18f59bdc3de",
    "line" : null,
    "diffHunk" : "@@ -1,1 +9008,9012 @@            // Grammar checking\n            if (!checkGrammarModifiers(node) && (node.flags & NodeFlags.Modifier)) {\n                grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers);\n            }\n"
  },
  {
    "id" : "a2c55c6f-dfd8-48ae-8e7e-3488238ba303",
    "prId" : 1388,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a54dbee-6b11-4f1b-b952-9dfa9c3bcb29",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "would not the fallback always be \"x\"\n",
        "createdAt" : "2014-12-06T15:19:11Z",
        "updatedAt" : "2014-12-06T15:19:11Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9bda982569bf709867c066e7417bc8891556910",
    "line" : 9,
    "diffHunk" : "@@ -1,1 +1313,1317 @@                        // declaration might not be found if indexer was added from the contextual type.\n                        // in this case use fallback name\n                        return fallbackName;\n                    }\n                    Debug.assert(declaration.parameters.length !== 0);"
  },
  {
    "id" : "f0c662ec-63dc-44cd-a0f7-10202531ac0a",
    "prId" : 1362,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65f1cd1d-a1f5-499a-b453-76ae51948a7e",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "why getNarrowedType here, but not above?\n",
        "createdAt" : "2014-12-03T23:00:17Z",
        "updatedAt" : "2014-12-04T20:56:02Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "acdc497a-2f88-4bc9-a84b-5761b7fa0d60",
        "parentId" : "65f1cd1d-a1f5-499a-b453-76ae51948a7e",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "I will add inline comment too.. but this is because getTypeOfNode by default does narrowing and gets it correctly. But if you just gettype of symbol it wouldn't be narrowed. It needs node at which you are trying to get type of symbol so that it can decide if it can decide when and how to narrow the type.\n\neg. consider this:\nfunction foo(a: string | number) {\nif (typeof a === \"string\") {\na/**/\n}\n}\n\nThe symbol of a is a parameter symbol. and if you can getTypeOfSymbol then it would be string | number because there is no node information specified\n\nBut if you tell I want type of a at the /**/ location it can decide to narrow it to \"string\"\n",
        "createdAt" : "2014-12-04T20:17:57Z",
        "updatedAt" : "2014-12-04T20:56:02Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "c3c44dc3c81ee12ddf9ede71f94a4b731feb8a45",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4423,4427 @@            // By using getNarrowedTypeOfSymbol would return string since it would be able to narrow\n            // it by typeguard in the if true condition\n            return getNarrowedTypeOfSymbol(symbol, node);\n        }\n"
  },
  {
    "id" : "9eb7d54a-064e-4ecd-8d31-e31b339c2eb9",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a84e6851-71d6-45a5-a463-91b27ec66f9e",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "a lot of comments here as to what's goign on would be helpful.\n",
        "createdAt" : "2014-12-03T03:32:10Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1694,1698 @@            var parentType = getTypeForVariableLikeDeclaration(<VariableLikeDeclaration>pattern.parent);\n            // If parent has the unknown (error) type, then so does this binding element\n            if (parentType === unknownType) {\n                return unknownType;\n            }"
  },
  {
    "id" : "5d4d6463-60b6-4b9c-800f-b9b52735b751",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fc4c4a0c-e90d-44f1-87dc-303db8d70f46",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "this pattern of getting the name off a binding element seems to repeat in several places.  Extracting a helper function for this would be nice.\n",
        "createdAt" : "2014-12-03T03:39:44Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 280,
    "diffHunk" : "@@ -1,1 +1802,1806 @@            forEach(pattern.elements, e => {\n                var flags = SymbolFlags.Property | SymbolFlags.Transient | (e.initializer ? SymbolFlags.Optional : 0);\n                var name = e.propertyName || <Identifier>e.name;\n                var symbol = <TransientSymbol>createSymbol(flags, name.text);\n                symbol.type = getTypeFromBindingElement(e);"
  },
  {
    "id" : "6a4158e8-3c7b-4dea-b65d-86efd023b676",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0d33903a-e5c9-49e8-ae88-a0c38b5617a9",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Hrmm.  Is this what we want in all cases?  i.e. if i have a `interface Foo { \"0\" }`, then that's also a tuple type?\n",
        "createdAt" : "2014-12-03T03:41:08Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "4db71989-2e0e-4cf4-bdc1-fc7585b79472",
        "parentId" : "0d33903a-e5c9-49e8-ae88-a0c38b5617a9",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I will rename the function to `isTupleLikeType`. It used only in contextual situations to determine if something is tuple-like.\n",
        "createdAt" : "2014-12-05T01:14:00Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4125,4129 @@\n        function isTupleLikeType(type: Type): boolean {\n            return !!getPropertyOfType(type, \"0\");\n        }\n"
  },
  {
    "id" : "058fc57f-f34f-415a-8f5c-2417def1f8ea",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3a1a54be-2388-40ed-9626-4e3e89833315",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "nice.  Looks like a very nice optimization.\n",
        "createdAt" : "2014-12-03T03:41:26Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 550,
    "diffHunk" : "@@ -1,1 +4148,4152 @@\n        function getWidenedType(type: Type): Type {\n            if (type.flags & TypeFlags.Unwidened) {\n                if (type.flags & (TypeFlags.Undefined | TypeFlags.Null)) {\n                    return anyType;"
  },
  {
    "id" : "af1b28e3-4008-4481-af7d-fcd52cdb093b",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "03dfd004-1c04-4a32-81d7-f276654bcebf",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Having very complex conditionals like this forces all readers to internalize all the possible complex AST shapes, and try to determine if they're validly represented here.  Consider extract out helper functions with clear comments that explain the different variations that can happen here, and why these checks are correct and exhaustive.\n",
        "createdAt" : "2014-12-03T03:44:58Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4525,4529 @@\n            function isAssignedInVariableDeclaration(node: VariableLikeDeclaration) {\n                if (!isBindingPattern(node.name) && getSymbolOfNode(node) === symbol && hasInitializer(node)) {\n                    return true;\n                }"
  },
  {
    "id" : "c6a02469-491e-4066-b610-cd222d98bd03",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b6bc8133-1297-41b8-89a3-0d5a95ea9bae",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "the latter two cases are not what i expected to see here.  Please comment the types of code that cause us to hit them.\n",
        "createdAt" : "2014-12-03T03:46:04Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "8e7c5e18-e7fa-4b27-9335-091938975109",
        "parentId" : "b6bc8133-1297-41b8-89a3-0d5a95ea9bae",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Also, consider renaming to something like 'isImplicitOrExplicitBindingTarget' or maybe 'isExplicitOrBindingPatternAssignment'.\n",
        "createdAt" : "2014-12-03T10:15:44Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 830,
    "diffHunk" : "@@ -1,1 +5306,5310 @@                return true;\n            }\n            if (parent.kind === SyntaxKind.PropertyAssignment) {\n                return isAssignmentTarget(parent.parent);\n            }"
  },
  {
    "id" : "0bd68474-93a0-4b69-8bb4-8e87a4f94cc5",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8bf88b24-65e4-41ec-a16d-42010af5e73f",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "possible alternative name:getOrComputeResolvedTypeOfExpression\n",
        "createdAt" : "2014-12-03T03:47:57Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 1134,
    "diffHunk" : "@@ -1,1 +6885,6889 @@        }\n\n        function checkExpressionCached(node: Expression, contextualMapper?: TypeMapper): Type {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {"
  },
  {
    "id" : "aa875524-f1b2-497e-ad37-90b303c00e3a",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1aaf4a56-fa60-439d-83ef-efb35f88b74a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "could we instead just call checkSourceElement(node.name)   and add a switch case for the two binding patterns?\n",
        "createdAt" : "2014-12-03T03:49:41Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7864,7868 @@            // For a binding pattern, check contained binding elements\n            if (isBindingPattern(node.name)) {\n                forEach((<BindingPattern>node.name).elements, checkSourceElement);\n            }\n            // For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body"
  },
  {
    "id" : "a27e8e56-4c99-4040-b734-9178304dc313",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9e48588c-96d7-4d77-bf65-ebc4f3e85e06",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "is it ok that we don't do these checks if we have a parameter with a binding pattern?\n",
        "createdAt" : "2014-12-03T10:16:46Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "4d3f0151-3038-46bf-bb08-a9f5338e5cc2",
        "parentId" : "9e48588c-96d7-4d77-bf65-ebc4f3e85e06",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We _will_ perform the checks, just not for the parent node of a binding pattern declaration. When `checkVariableDeclaration` is called on a node with a binding pattern name it will do a `checkSourceElement` for each child binding element, which in turn gets us back to `checkParameter` for the child nodes.\n",
        "createdAt" : "2014-12-04T19:25:26Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7028,7032 @@        function checkParameter(node: ParameterDeclaration) {\n            checkVariableLikeDeclaration(node);\n            var func = getContainingFunction(node);\n            if (node.flags & (NodeFlags.Public | NodeFlags.Private | NodeFlags.Protected)) {\n                func = getContainingFunction(node);"
  },
  {
    "id" : "19008162-3b9c-4774-80c3-382785788de7",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "153b2c6f-fdc3-45f0-83eb-7df6b27e6806",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Very nice that we do this checking/reporting in the typechecker.\n",
        "createdAt" : "2014-12-03T10:48:34Z",
        "updatedAt" : "2014-12-09T19:29:09Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 1038,
    "diffHunk" : "@@ -1,1 +6653,6657 @@                }\n                else {\n                    error(p, Diagnostics.Property_assignment_expected);\n                }\n            }"
  },
  {
    "id" : "7369644c-ab1d-4c19-a4cf-05f534dd86ad",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Shouldn't the type be any if the parent type was any?\n",
        "createdAt" : "2014-12-09T21:37:54Z",
        "updatedAt" : "2014-12-09T21:37:54Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "08a221ee-6436-4a0b-8312-69495c7e5bd2",
        "parentId" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It is if there is not an initializer. If you're suggesting it should be `any` regardless of the initializer, then no. Consider:\n\n``` typescript\nvar a: any;\nvar [x, y = 1] = a;\n```\n\nHere, `a` provides no clue as to the intended type of `x` and `y`, so we infer from the type of the initializer. This contrasts with:\n\n``` typescript\nvar a: any;\nvar [x, y = 1] = [a, a];\n```\n\nHere, the type of `a` is the intended type for `y`, and the initializer is required to be assignment compatible with that type.\n",
        "createdAt" : "2014-12-09T22:00:15Z",
        "updatedAt" : "2014-12-09T22:00:15Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "25fd0104-ad85-4374-8478-e6bcf44aaa27",
        "parentId" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Do we do that for contextual typing? An analogous example (courtesy of @CyrusNajmabadi):\n\n``` ts\nvar v: (a: any) => void = (a = 1) { a.blah };\n```\n\nShould `a` in the body be of type any or number? Applying the reasoning you stated from destructuring, it seems like in this example it should be number, not any.\n",
        "createdAt" : "2014-12-09T22:11:37Z",
        "updatedAt" : "2014-12-09T22:11:37Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "b8b9b5a0-f9c9-4860-b133-5beb06f69b89",
        "parentId" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "For a parameter the order of precedence is this:\n- Explicit type annotation.\n- Contextual parameter type.\n- Initializer type.\n\nFor a binding element it is this:\n- Deconstructed type (i.e. the type of the corresponding property or array element in the deconstructed value).\n- Type of local default value (initializer) if type of deconstructed value is unknown or any.\n\nSo, you can't really apply the reasoning of one to the other. They're different kinds of constructs.\n",
        "createdAt" : "2014-12-10T01:33:03Z",
        "updatedAt" : "2014-12-10T01:33:03Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "29150ba2-9521-45d0-a39a-f7cd045f2dd0",
        "parentId" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I understand that the way you described is how things are working, but it doesn't seem self explanatory why that is the case. Why are they different constructs?\n",
        "createdAt" : "2014-12-10T01:35:56Z",
        "updatedAt" : "2014-12-10T01:35:56Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "a2f408c4-b076-449c-9b08-a4b161a2a1b8",
        "parentId" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I assume you agree with the already existing rules for parameters, so I won't try to elaborate on those.\n\nFor a destructuring element, the high order bit is the type of the value being deconstructed. Indeed, the initializer isn't even evaluated when a deconstructed value is available. So, this establishes the intuition that the binding element type should primarily come from the corresponding property or element in the deconstructed type. Then, in cases where the type of the deconstructed value isn't known or is any, it makes sense to take a clue from the initializer. That's the next best source of information.\n",
        "createdAt" : "2014-12-10T01:51:35Z",
        "updatedAt" : "2014-12-10T01:51:35Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "996c9310-8d1d-4052-b8c8-f143087f5c57",
        "parentId" : "664702b3-eb9e-4bb4-9221-74dbe576dc14",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "That makes a lot of sense, but why is that not the case for parameters? I don't necessarily agree with the rules for parameters. I buy your argument about the destructuring and would like to apply it to parameters\n",
        "createdAt" : "2014-12-10T02:10:41Z",
        "updatedAt" : "2014-12-10T02:10:41Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 162,
    "diffHunk" : "@@ -1,1 +1700,1704 @@            // infer from the initializer of the binding element if one is present. Otherwise, go with the\n            // undefined or any type of the parent.\n            if (!parentType || parentType === anyType) {\n                if (declaration.initializer) {\n                    return checkExpressionCached(declaration.initializer);"
  },
  {
    "id" : "6afe9b7c-40aa-44f0-99eb-12179dfe9f79",
    "prId" : 1346,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3ba8c6f3-3379-4936-b244-975db17ca330",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "What is the difference between getTypeForBindingElement and getTypeFromBindingElement?\n",
        "createdAt" : "2014-12-09T21:38:19Z",
        "updatedAt" : "2014-12-09T21:38:19Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "20f2a9c5-fc99-42ed-b754-16735aabe506",
        "parentId" : "3ba8c6f3-3379-4936-b244-975db17ca330",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It's pretty much what the names say (and there are a number of comments in the code). Consider:\n\n``` typescript\nvar [x, y = 1] = [10, undefined];\n```\n\nHere, `getTypeForBindingElement` returns number and undefined for `x` and `y` respectively, and `getTypeFromBindingElement` returns any and number for `x` and `y` respectively.\n",
        "createdAt" : "2014-12-09T22:11:20Z",
        "updatedAt" : "2014-12-09T22:11:34Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "a505f5e1-afa6-44aa-9176-1d8d602d2c68",
        "parentId" : "3ba8c6f3-3379-4936-b244-975db17ca330",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Maybe we should call them getTypeFromBindingElementParent and getTypeFromBindingElementInitializer\n",
        "createdAt" : "2014-12-09T23:48:32Z",
        "updatedAt" : "2014-12-09T23:48:32Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "26a78ff2-16c1-44d4-bd0c-a9f981933399",
        "parentId" : "3ba8c6f3-3379-4936-b244-975db17ca330",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Not crazy about those. Regarding getTypeFromBindingElementParent, we're not actually getting the type from the element's parent, we're getting it from the corresponding property or element in the type of the value being destructured. Regarding getTypeFromBindingElementInitializer, the type comes from the initializer or, lacking one, if the element is itself a binding pattern, from the shape of that pattern and recursively from it's elements.\n",
        "createdAt" : "2014-12-10T02:09:25Z",
        "updatedAt" : "2014-12-10T02:09:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "98280189-846e-4894-968e-6c4875e415d5",
        "parentId" : "3ba8c6f3-3379-4936-b244-975db17ca330",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Maybe those names aren't very accurate, but I think we need two names where the distinction is encoded in more than a preposition.\n",
        "createdAt" : "2014-12-10T02:13:34Z",
        "updatedAt" : "2014-12-10T02:13:34Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc35b3ae0e663e59b8305433da17508b868f140",
    "line" : 152,
    "diffHunk" : "@@ -1,1 +1690,1694 @@\n        // Return the inferred type for a binding element\n        function getTypeForBindingElement(declaration: BindingElement): Type {\n            var pattern = <BindingPattern>declaration.parent;\n            var parentType = getTypeForVariableLikeDeclaration(<VariableLikeDeclaration>pattern.parent);"
  },
  {
    "id" : "d1679530-7c46-4f12-a8ae-f1ac1c3b09a6",
    "prId" : 1308,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2a7a2e19-56f8-4a8e-b85e-a1fa5c4788b5",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Might not be a declaration after an iteration in the loop, maybe rename.\n",
        "createdAt" : "2014-12-01T06:33:57Z",
        "updatedAt" : "2014-12-01T06:34:06Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "1c2799ff-6f88-4e78-b795-60048334f9d3",
        "parentId" : "2a7a2e19-56f8-4a8e-b85e-a1fa5c4788b5",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Will do.\n",
        "createdAt" : "2014-12-01T06:36:55Z",
        "updatedAt" : "2014-12-01T06:36:55Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebe8711a21ef7ecca2b877b5fe121b52edcd512e",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +1576,1580 @@\n                        // Container of resolvedExportSymbol is visible\n                        return forEach(resolvedExportSymbol.declarations, (declaration: Node) => {\n                            while (declaration) {\n                                if (declaration === node) {"
  },
  {
    "id" : "ce31ccb5-f384-4c22-a696-865d6b2f51fc",
    "prId" : 1308,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8ce4efff-0db8-4eff-8ff6-ffa7630dd1ae",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Put this on one line.\n",
        "createdAt" : "2014-12-01T06:46:09Z",
        "updatedAt" : "2014-12-01T06:46:09Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "66bf0c6e-10a9-4375-b725-f6ed3c007f57",
        "parentId" : "8ce4efff-0db8-4eff-8ff6-ffa7630dd1ae",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "okey dokey.\n",
        "createdAt" : "2014-12-01T06:49:00Z",
        "updatedAt" : "2014-12-01T06:49:00Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebe8711a21ef7ecca2b877b5fe121b52edcd512e",
    "line" : 180,
    "diffHunk" : "@@ -1,1 +4429,4433 @@                var right = <LiteralExpression>expr.right;\n                if (left.expression.kind !== SyntaxKind.Identifier ||\n                    getResolvedSymbol(<Identifier>left.expression) !== symbol) {\n\n                    return type;"
  },
  {
    "id" : "40020fb4-f69b-4f58-b34e-30ff9daf1296",
    "prId" : 1275,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "12c37238-7d8f-40e5-b50a-c69795263f77",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "why do you need to !! a boolean?\n",
        "createdAt" : "2014-11-26T03:06:13Z",
        "updatedAt" : "2014-11-27T01:14:16Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "bc61565b-59da-421a-b878-d1931a47fcd9",
        "parentId" : "12c37238-7d8f-40e5-b50a-c69795263f77",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "It's an optional property; towards the bottom, we have an assertion that `callIsIncomplete` is actually set.\n",
        "createdAt" : "2014-11-26T03:40:48Z",
        "updatedAt" : "2014-11-27T01:14:16Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae384470a4ba370e068a356cd65e4195e99d296f",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +5303,5307 @@                    var lastSpan = lastOrUndefined(templateExpression.templateSpans);\n                    Debug.assert(lastSpan !== undefined); // we should always have at least one span.\n                    callIsIncomplete = lastSpan.literal.kind === SyntaxKind.Missing || !!lastSpan.literal.isUnterminated;\n                }\n                else {"
  },
  {
    "id" : "a244dcd3-7f36-4137-b004-715fd4914357",
    "prId" : 1272,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3330d723-89cc-46af-9665-1c7d9e754c19",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Make sure to it work for functionExpression\n",
        "createdAt" : "2014-11-26T01:54:37Z",
        "updatedAt" : "2014-11-27T04:15:45Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      }
    ],
    "commit" : "ddebd028288b90c392ef5661a8f18af4f716f77e",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +7211,7215 @@\n        function checkFunctionDeclaration(node: FunctionDeclaration): void {\n            checkFunctionLikeDeclaration(node);\n            if (fullTypeCheck) {\n                checkCollisionWithCapturedSuperVariable(node, node.name);"
  },
  {
    "id" : "bd2d99b0-2f77-4502-a06f-401f125e7a7c",
    "prId" : 1127,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a5bc8483-38a3-4af0-89f8-da3d6af18b08",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "assert here what type of member decl you think this is.\n",
        "createdAt" : "2014-11-11T21:00:28Z",
        "updatedAt" : "2014-11-17T19:35:15Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "59e87251-fec5-4bba-adc4-31157cb5e179",
        "parentId" : "a5bc8483-38a3-4af0-89f8-da3d6af18b08",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "+1\n",
        "createdAt" : "2014-11-12T06:13:59Z",
        "updatedAt" : "2014-11-17T19:35:15Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "1b66ee6f3a7bad2a5ed13f17b1375c29c8439f30",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5017,5021 @@                        else {\n                            Debug.assert(memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment);\n                            type = checkExpression(memberDecl.name, contextualMapper);\n                        }\n                        var prop = <TransientSymbol>createSymbol(SymbolFlags.Property | SymbolFlags.Transient | member.flags, member.name);"
  },
  {
    "id" : "9d4ead8d-f9a5-458b-a9e3-00d038a2087b",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d5c6e108-062b-4676-861a-c0a082dd156e",
        "parentId" : null,
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Should support >>> as well probably\n",
        "createdAt" : "2014-10-27T00:02:26Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "2df9fe02-1c8b-4b78-b2c7-ede166594772",
        "parentId" : "d5c6e108-062b-4676-861a-c0a082dd156e",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "done\n",
        "createdAt" : "2014-10-27T02:18:16Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "c8e53d49-5e54-4da7-92d9-ef8802b63b88",
        "parentId" : "d5c6e108-062b-4676-861a-c0a082dd156e",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Why not include *, /, %, and ^ as well? Seems hard to define a principle that would exclude them.\n",
        "createdAt" : "2014-10-27T13:59:39Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "4fda0aba-486c-44ed-adb7-3c274f1f107a",
        "parentId" : "d5c6e108-062b-4676-861a-c0a082dd156e",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : ":+1: to Anders' suggestion. Might be arguable as to what you want to do when the RHS for `/` and `%` are `0` though.\n",
        "createdAt" : "2014-10-27T17:26:27Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7824,7828 @@                                case SyntaxKind.BarToken: return left | right;\n                                case SyntaxKind.AmpersandToken: return left & right;\n                                case SyntaxKind.GreaterThanGreaterThanToken: return left >> right;\n                                case SyntaxKind.GreaterThanGreaterThanGreaterThanToken: return left >>> right;\n                                case SyntaxKind.LessThanLessThanToken: return left << right;"
  },
  {
    "id" : "74cbdb8b-6331-4c6e-81a4-962f887a9607",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3c527cc8-7b6d-434a-a50b-abc33835a2cb",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "these are new capabilities not previously in the compiler.  do we intend to put these behind a flag?\n",
        "createdAt" : "2014-10-27T00:44:56Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "76085f7d-7063-4cfa-aad1-5cbda275ce4b",
        "parentId" : "3c527cc8-7b6d-434a-a50b-abc33835a2cb",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "not really, we used to handle UnaryExpression with '+' and '-' as operators. I'll cover '~' by the flag\n",
        "createdAt" : "2014-10-27T02:17:34Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7803,7807 @@                            }\n                            switch ((<UnaryExpression>e).operator) {\n                                case SyntaxKind.PlusToken: return value;\n                                case SyntaxKind.MinusToken: return -value;\n                                case SyntaxKind.TildeToken: return enumIsConst ? ~value : undefined;"
  },
  {
    "id" : "65d8666c-3945-4019-b47c-f24ea0e5749d",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "361ef919-a67a-466a-b08b-b4bae12e8a3e",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "note: the spec (at one point) specified that this was a signed-integer.  If so, then there can be no space between the `-` and the value.  Also, things like `- - 10` are not allowed.\n",
        "createdAt" : "2014-10-27T00:46:06Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7804,7808 @@                            switch ((<UnaryExpression>e).operator) {\n                                case SyntaxKind.PlusToken: return value;\n                                case SyntaxKind.MinusToken: return -value;\n                                case SyntaxKind.TildeToken: return enumIsConst ? ~value : undefined;\n                            }"
  },
  {
    "id" : "a48bac77-a927-4887-b759-b15407be690c",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "87b1f841-400f-40ef-8f3a-193f70d69115",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "we probably want to handle IndexedAccess as well.  That way we can deal with enums with string/numeric names.\n",
        "createdAt" : "2014-10-27T00:49:26Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7841,7845 @@                        case SyntaxKind.Identifier:\n                        case SyntaxKind.IndexedAccess:\n                        case SyntaxKind.PropertyAccess:\n                            if (!enumIsConst) {\n                                return undefined;"
  },
  {
    "id" : "43a98e57-64bb-425c-8e85-34f948e8a8be",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "06943cad-c478-48c7-8c63-9066a60536ba",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Will this work ok in the LS (where we might helicopter in to an arbitrary enum member)?\n",
        "createdAt" : "2014-10-27T00:51:48Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "4830442a-384a-4107-b9b9-135c16322df2",
        "parentId" : "06943cad-c478-48c7-8c63-9066a60536ba",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "I believe that this value was never used by language service. In fact we do not compute them when checker is not in fulltypecheck mode. \n",
        "createdAt" : "2014-10-27T02:33:58Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7891,7895 @@                                return undefined;\n                            }\n                            return <number>getNodeLinks(propertyDecl).enumMemberValue;\n                    }\n                }"
  },
  {
    "id" : "f259f0eb-26ab-49e8-8f92-4fa395ad6a05",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83d744b4-6480-485f-bb51-dc52e7e6d7dc",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Seems like all you're getting from introducing a helper function is a nicer name - it's a little unnecessary, but I don't mind it all that much.\n",
        "createdAt" : "2014-10-27T05:45:55Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7795,7799 @@                return evalConstant(initializer);\n\n                function evalConstant(e: Node): number {\n                    switch (e.kind) {\n                        case SyntaxKind.PrefixOperator:"
  },
  {
    "id" : "7390f2ce-d68e-427b-9e08-cbed6161abe6",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "83fcc7b8-e85b-456e-9f7c-5fa7b5383bd5",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Mention that it also has to be there.\n",
        "createdAt" : "2014-10-30T01:19:55Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : 203,
    "diffHunk" : "@@ -1,1 +7760,7764 @@                        if (autoValue === undefined) {\n                            if (enumIsConst) {\n                                error(initializer, Diagnostics.In_const_enum_declarations_member_initializer_must_be_constant_expression);\n                            }\n                            else if (!ambient) {"
  },
  {
    "id" : "372f598c-2020-430a-be42-2814a2f58995",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6e0ff47f-87da-4b95-aa7a-66ac03333ab2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So it will autonumber if there is no initializer, it is ambient and not a const.\n",
        "createdAt" : "2014-10-30T01:22:10Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7780,7784 @@\n                    }\n                    else if (ambient && !enumIsConst) {\n                        autoValue = undefined;\n                    }"
  },
  {
    "id" : "f4e34e4b-4649-42db-ba73-ddbfd6388912",
    "prId" : 970,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "80bb8f1f-b68c-43d1-9ac4-a944d91d4ab9",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Please rename the function to \"isTopLevelValueImportWithEntityName\"\n",
        "createdAt" : "2014-10-30T01:29:06Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "dc095cdd-0a28-4114-82cc-c7614566368c",
        "parentId" : "80bb8f1f-b68c-43d1-9ac4-a944d91d4ab9",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "done\n",
        "createdAt" : "2014-10-30T06:33:07Z",
        "updatedAt" : "2014-11-03T19:14:58Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "4d354c02864caf7f5dc4fde1b31c722c90b18637",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +8768,8772 @@                // parent is not source file or it is not reference to internal module\n                return false;\n            }\n            var symbol = getSymbolOfNode(node);\n            return isImportResolvedToValue(getSymbolOfNode(node));"
  },
  {
    "id" : "5569881d-929e-446a-bfe3-cec7752731d4",
    "prId" : 960,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "aa058b31-2642-4958-892f-c2ef60e7e2de",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Explain why this is correct.  I believe it's because we rewrite this to string addition, and string addition allows the other side to be of any type.  So we don't need to check for things like void types, etc.  But it would be good to comment this bit.\n",
        "createdAt" : "2014-10-25T00:44:33Z",
        "updatedAt" : "2014-10-31T21:54:20Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3e8978fb60973242390a4b3e5c481194c1cce335",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6183,6187 @@            // A place where we actually *are* concerned with the expressions' types are\n            // in tagged templates.\n            forEach((<TemplateExpression>node).templateSpans, templateSpan => {\n                checkExpression(templateSpan.expression);\n            });"
  },
  {
    "id" : "4c22d359-f4d5-4644-8819-994e03c8868f",
    "prId" : 859,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3f5fded1-e68c-435e-bb57-d4126876e926",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Assert that that's the case.\n",
        "createdAt" : "2014-10-08T20:51:38Z",
        "updatedAt" : "2014-10-08T22:45:02Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "eb3106d2b75a56c8ce2eba22f4fddb49b50adea5",
    "line" : null,
    "diffHunk" : "@@ -1,1 +7254,7258 @@                    Debug.assert(node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName, \"'node' was expected to be a qualified name or identifier in 'isTypeNode'.\");\n\n                    var parent = node.parent;\n                    if (parent.kind === SyntaxKind.TypeQuery) {\n                        return false;"
  },
  {
    "id" : "41713211-634d-433a-abdb-07803d7223d3",
    "prId" : 824,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c4b1e0d7-e9d8-41e0-8930-7a3e6ce66554",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "comments on what sort of sturcture you're building up here would be very helpful.  right now this line is hard to understand.  You're mapping over all the signature lists, and for each over those, you're extracting out the i'ith signature? \n",
        "createdAt" : "2014-10-05T04:40:58Z",
        "updatedAt" : "2014-10-13T23:16:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f5cd4145d5e2e02672018c267dbfc00ee1d2ebcb",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2092,2096 @@                // Clear resolved return type we possibly got from cloneSignature\n                s.resolvedReturnType = undefined;\n                s.unionSignatures = map(signatureLists, signatures => signatures[i]);\n            }\n            return result;"
  },
  {
    "id" : "ccaaf990-e1bc-4322-a3c3-97c95466133a",
    "prId" : 823,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3bb6013d-ad96-498e-acfa-22d080df748b",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "it's not clear to me how || is an effective alternative to  |=\n",
        "createdAt" : "2014-10-04T07:28:07Z",
        "updatedAt" : "2014-10-04T18:25:38Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "6577be07-0ef7-4770-8021-72fb9a09cb22",
        "parentId" : "3bb6013d-ad96-498e-acfa-22d080df748b",
        "authorId" : "fe87caf4-bdcc-4926-8b6e-d7fd2b533094",
        "body" : "It's really not but if we are using the same error message then we have to follow the same form of providing a suggestion. If they are trying to use a bitwise assignment operator with 2 booleans we could do something more intelligent and say \"Consider using 'x = x || y'\" but that would require a separate error message and error code for all of the bitwise assignment operators. If that makes more sense to do I can definitely change it to that though. \n",
        "createdAt" : "2014-10-04T16:48:33Z",
        "updatedAt" : "2014-10-04T18:25:38Z",
        "lastEditedBy" : "fe87caf4-bdcc-4926-8b6e-d7fd2b533094",
        "tags" : [
        ]
      }
    ],
    "commit" : "739885381771db522d6af162f7703cc93970e0bd",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5106,5110 @@                switch (operator) {\n                    case SyntaxKind.BarToken:\n                    case SyntaxKind.BarEqualsToken:\n                        return SyntaxKind.BarBarToken;\n                    case SyntaxKind.CaretToken:"
  },
  {
    "id" : "3d8e2241-7e09-445c-ba70-ca374cf03cb2",
    "prId" : 763,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "15bb1e00-6c70-423d-b001-ccb79aa45303",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "is propertyName redundant with teh PropertyAccess node?  Can you not just do node.right.text?\n",
        "createdAt" : "2014-09-26T23:26:58Z",
        "updatedAt" : "2014-09-26T23:26:58Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "4227e58b82a9666cb8afbe681ea39be88115534d",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +4241,4245 @@        }\n\n        function isValidPropertyAccess(node: PropertyAccess, propertyName: string): boolean {\n            var type = checkExpression(node.left);\n            if (type !== unknownType && type !== anyType) {"
  },
  {
    "id" : "1bc08be5-7a10-4ba1-84fd-fc7c9888430b",
    "prId" : 737,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d73997f6-3cd9-4749-8906-30dfce2ea575",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Can you rename this function to `isAnyOrObjectTypeOrTypeParameter`? I think it would be more readable that way.\n",
        "createdAt" : "2014-09-24T17:54:28Z",
        "updatedAt" : "2014-09-24T17:54:28Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "d52a93d58db3a14cb03e69b00fad40212723c5e1",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4937,4941 @@            // The result is always of the Boolean primitive type.\n            // NOTE: do not raise error if leftType is unknown as related error was already reported\n            if (leftType !== unknownType && !isTypeAnyTypeObjectTypeOrTypeParameter(leftType)) {\n                error(node.left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);\n            }"
  },
  {
    "id" : "0a0a865c-0481-4294-b315-f973cb9350b6",
    "prId" : 737,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "67adfd92-19c1-48a5-aec0-dd1d38838d18",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "i don't mind this.  But it does seem ike a very 1-off solution.  It seems like preventing cascading in teh event of 'unknownType' is something we'd want to do in a lot more places.\n",
        "createdAt" : "2014-09-24T18:06:27Z",
        "updatedAt" : "2014-09-24T18:06:27Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "3d145d6e-edfa-426d-9dc4-4a8c21ed0f64",
        "parentId" : "67adfd92-19c1-48a5-aec0-dd1d38838d18",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "We already use this approach almost everywhere in checker.\n",
        "createdAt" : "2014-09-24T18:09:15Z",
        "updatedAt" : "2014-09-24T18:09:15Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      }
    ],
    "commit" : "d52a93d58db3a14cb03e69b00fad40212723c5e1",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +4937,4941 @@            // The result is always of the Boolean primitive type.\n            // NOTE: do not raise error if leftType is unknown as related error was already reported\n            if (leftType !== unknownType && !isTypeAnyTypeObjectTypeOrTypeParameter(leftType)) {\n                error(node.left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);\n            }"
  },
  {
    "id" : "5807c44b-4636-4002-ba2a-4623d3bc3130",
    "prId" : 708,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5a7475e6-ac66-490c-bb4b-c7289bb84e7d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Just return if you don't have a symbol\n",
        "createdAt" : "2014-09-23T01:02:57Z",
        "updatedAt" : "2014-09-23T22:41:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "d6fc3fc2daaf9cd91fcc69f79d626d421ec0b84f",
    "line" : 200,
    "diffHunk" : "@@ -1,1 +1061,1065 @@            var needsDot = false;\n            function walkSymbol(symbol: Symbol, meaning: SymbolFlags): void {\n                if (symbol) {\n                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning);\n"
  },
  {
    "id" : "817283cc-68d8-4587-ab8c-9f4ced8eff90",
    "prId" : 708,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b61e9c80-6a17-4ada-8491-5d6fa0082c3a",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Clean this up please. \n",
        "createdAt" : "2014-09-23T01:08:11Z",
        "updatedAt" : "2014-09-23T22:41:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "d6fc3fc2daaf9cd91fcc69f79d626d421ec0b84f",
    "line" : 285,
    "diffHunk" : "@@ -1,1 +1122,1126 @@            releaseStringWriter(writer);\n\n            var maxLength = compilerOptions.noErrorTruncation || flags & TypeFormatFlags.NoTruncation ? undefined : 100;\n            if (maxLength && result.length >= maxLength) {\n                result = result.substr(0, maxLength - \"...\".length) + \"...\";"
  },
  {
    "id" : "a3934fbd-10b9-46f5-a328-5a4bf33e6371",
    "prId" : 688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "98887f41-3c5d-411b-9c41-5548fc9a365f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "trailing comma\n",
        "createdAt" : "2014-09-17T18:26:03Z",
        "updatedAt" : "2014-09-19T21:01:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5b0777ad51fa6e7de362fad5e10db95a5ab91a3",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +2710,2714 @@        function isPropertyIdenticalToRecursive(sourceProp: Symbol, targetProp: Symbol, reportErrors: boolean, relate: (source: Type, target: Type, reportErrors: boolean) => boolean): boolean {\n            // Two members are considered identical when\n            // - they are public properties with identical names, optionality, and types,\n            // - they are private or protected properties originating in the same declaration and having identical types\n            if (sourceProp === targetProp) {"
  },
  {
    "id" : "01b42737-7af4-48f7-bb2b-14828265ea91",
    "prId" : 688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "96c5d6d1-b327-4e0f-b81f-c2aea45b0f1c",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Yeah this is definitely a better place to check targetProp\n",
        "createdAt" : "2014-09-17T18:33:24Z",
        "updatedAt" : "2014-09-19T21:01:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5b0777ad51fa6e7de362fad5e10db95a5ab91a3",
    "line" : 73,
    "diffHunk" : "@@ -1,1 +2928,2932 @@                    var sourceProp = sourceProperties[i];\n                    var targetProp = getPropertyOfType(target, sourceProp.name);\n                    if (!targetProp || !isPropertyIdenticalToRecursive(sourceProp, targetProp, reportErrors, isRelatedTo)) {\n                        return false;\n                    }"
  },
  {
    "id" : "3cb78ef1-08bb-41c7-8b24-7ef54506b51c",
    "prId" : 688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce6ade09-e9a5-45d2-94bc-5d295f6dd8e8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It seems a little odd that we would have to check this case here. Should we really be calling into this function if it is a super access?\n",
        "createdAt" : "2014-09-17T18:59:05Z",
        "updatedAt" : "2014-09-19T21:01:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "af27450b-d36a-4069-acc9-89cca51aba6f",
        "parentId" : "ce6ade09-e9a5-45d2-94bc-5d295f6dd8e8",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "We still need the other checks in a `super` property access and I don't really want to duplicate them. But yeah, it is a bit messy to have that here.\n",
        "createdAt" : "2014-09-17T22:30:35Z",
        "updatedAt" : "2014-09-19T21:01:30Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5b0777ad51fa6e7de362fad5e10db95a5ab91a3",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4033,4037 @@            // Property is known to be protected at this point\n            // All protected properties of a supertype are accessible in a super access\n            if (node.left.kind === SyntaxKind.SuperKeyword) {\n                return;\n            }"
  },
  {
    "id" : "ae44732e-50ce-4ab0-8b95-642363160b74",
    "prId" : 688,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5944581c-b577-46ab-98ed-5259e0575c7b",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I would prefer just checking `node.left.kind === SyntaxKind.SuperKeyword`. Then in a nested if statement, you can check for SyntaxKind.Method. That way, super is left out of the whole isClassPropertyAccessible function.\n",
        "createdAt" : "2014-09-17T19:24:22Z",
        "updatedAt" : "2014-09-19T21:01:30Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "b5b0777ad51fa6e7de362fad5e10db95a5ab91a3",
    "line" : 246,
    "diffHunk" : "@@ -1,1 +4076,4080 @@                    //   where this references the constructor function object of a derived class, \n                    //   a super property access is permitted and must specify a public static member function of the base class.\n                    if (node.left.kind === SyntaxKind.SuperKeyword && getDeclarationKindFromSymbol(prop) !== SyntaxKind.Method) {\n                        error(node.right, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);\n                    }"
  },
  {
    "id" : "cf506c2a-3b8a-4e47-998c-18bb6494726b",
    "prId" : 677,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "eece281d-83a0-4f44-95bc-56ccebb0d544",
        "parentId" : null,
        "authorId" : "26699569-4335-45b0-a775-bfd0a044730b",
        "body" : "Why do we need to check accessibility for the getNavigateToItems ?\n",
        "createdAt" : "2014-09-16T18:50:59Z",
        "updatedAt" : "2014-09-16T23:57:07Z",
        "lastEditedBy" : "26699569-4335-45b0-a775-bfd0a044730b",
        "tags" : [
        ]
      },
      {
        "id" : "61322e51-270e-4f71-86cd-f709b866234a",
        "parentId" : "eece281d-83a0-4f44-95bc-56ccebb0d544",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "no. we show local variables and local functions anyways, so private vs. public is not an issue. think of this more as a semantic search.\n",
        "createdAt" : "2014-09-16T20:14:57Z",
        "updatedAt" : "2014-09-16T23:57:07Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "50a4926eaf8f26960b6f3d8ddcc00c42c637b307",
    "line" : 6,
    "diffHunk" : "@@ -1,1 +5212,5216 @@                var otherAccessor = <AccessorDeclaration>getDeclarationOfKind(node.symbol, otherKind);\n                if (otherAccessor) {\n                    if (((node.flags & NodeFlags.AccessibilityModifier) !== (otherAccessor.flags & NodeFlags.AccessibilityModifier))) {\n                        error(node.name, Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);\n                    }"
  },
  {
    "id" : "cf20edd2-7ff0-41bc-b05a-005fdbc654cf",
    "prId" : 676,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0679f510-c76a-43d2-957f-9f8340688cd5",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Could you potentially just use `getAncestor` to implement this function?\n",
        "createdAt" : "2014-09-15T21:40:37Z",
        "updatedAt" : "2014-09-18T00:31:05Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "b9bca300-7da1-4f6b-9a28-b9e30795465d",
        "parentId" : "0679f510-c76a-43d2-957f-9f8340688cd5",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "no, cause the condition is a valid location, and you can be deep inside the condition, so I can not just say condition. I could off course use offsets to know, but this seemed like a cleaner approach.\n",
        "createdAt" : "2014-09-16T20:18:16Z",
        "updatedAt" : "2014-09-18T00:31:05Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "9e00693163e7198f694161be62c92a7dd94b479e",
    "line" : 78,
    "diffHunk" : "@@ -1,1 +6698,6702 @@            }\n\n            return false;\n        }\n"
  },
  {
    "id" : "dd6e0c5b-4986-4f9a-a9f1-9aa1ec1ac899",
    "prId" : 649,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9cac7a39-07d8-42a3-8bc3-c9b82804960f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Actually can you just add a comment saying that if we are resolving an object literal, we should never get here.\n",
        "createdAt" : "2014-09-10T20:05:59Z",
        "updatedAt" : "2014-09-10T20:14:38Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9ae6cec17f03761cd9cff477cdb66e67185533c",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1357,1361 @@                var type = checkAndMarkExpression(declaration.initializer);\n                // Widening of property assignments is handled by checkObjectLiteral, exclude them here\n                if (declaration.kind !== SyntaxKind.PropertyAssignment) {\n                    var unwidenedType = type;\n                    type = getWidenedType(type);"
  },
  {
    "id" : "aef1f483-3672-4730-afe9-10738a6278e7",
    "prId" : 602,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e87db027-85c1-4a34-81ac-05f1fee1ba9a",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Don't we still need to propagate `supressNoImplicitAnyErrors`?\n",
        "createdAt" : "2014-09-07T07:14:18Z",
        "updatedAt" : "2014-09-08T19:08:22Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "fd8d0f59-e4fe-4e31-8cbc-dc525e7bcd62",
        "parentId" : "e87db027-85c1-4a34-81ac-05f1fee1ba9a",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Not if we just closed over it (see my comment from earlier about nesting the subroutines inside getWidenedType).\n",
        "createdAt" : "2014-09-08T17:18:40Z",
        "updatedAt" : "2014-09-08T19:08:22Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f21fb59a2f45a392ef879f33afed21f27b68c89",
    "line" : 77,
    "diffHunk" : "@@ -1,1 +3165,3169 @@                    forEach(properties, p => {\n                        var propType = getTypeOfSymbol(p);\n                        var widenedType = getWidenedType(propType);\n                        if (propType !== widenedType) {\n                            propTypeWasWidened = true;"
  },
  {
    "id" : "01527182-f3a5-4d3f-a8c3-d9de07951884",
    "prId" : 602,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0a25d7a9-d9d6-4c29-818c-a23fec51f1b9",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "\"suppress\" not \"supress\"\n",
        "createdAt" : "2014-09-07T07:14:38Z",
        "updatedAt" : "2014-09-08T19:08:22Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "4f21fb59a2f45a392ef879f33afed21f27b68c89",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +3146,3150 @@\n        /* If we are widening on a literal, then we may need to the 'node' parameter for reporting purposes */\n        function getWidenedType(type: Type, supressNoImplicitAnyErrors?: boolean): Type {\n            if (type.flags & (TypeFlags.Undefined | TypeFlags.Null)) {\n                return anyType;"
  },
  {
    "id" : "f5698aca-6b63-42e1-a1aa-6c0b74d5d93d",
    "prId" : 569,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "dca27604-3a7e-4a9d-b8e1-368fedc9d93a",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "typo: shouldn't\n",
        "createdAt" : "2014-09-04T15:44:18Z",
        "updatedAt" : "2014-09-04T20:04:24Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "7b45cdf9b3022933f034d3b6aeeb22a32f9a2b4e",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +5699,5703 @@            }\n\n            // Uninstantiated modules shouldnt do this check\n            if (node.kind === SyntaxKind.ModuleDeclaration && !isInstantiated(node)) {\n                return;"
  },
  {
    "id" : "6e9ad7af-6868-43ae-9573-bc26054a639a",
    "prId" : 554,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0aa583e7-bd2c-4fe2-a44a-52f48919f648",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "either reomve the symbol. or remove the declaration of name.\n",
        "createdAt" : "2014-08-27T19:15:37Z",
        "updatedAt" : "2014-08-29T00:31:03Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "e21f726f-934b-47e5-a6a5-a13ebe6f270d",
        "parentId" : "0aa583e7-bd2c-4fe2-a44a-52f48919f648",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "why do you need symbol.name here?\n",
        "createdAt" : "2014-08-28T14:46:21Z",
        "updatedAt" : "2014-08-29T00:31:03Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "ad85ddd5-eb34-433b-be18-82ef0bd89cbf",
        "parentId" : "0aa583e7-bd2c-4fe2-a44a-52f48919f648",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "So we can tell the user which type we are complaining about.\n",
        "createdAt" : "2014-08-28T17:20:40Z",
        "updatedAt" : "2014-08-29T00:31:03Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "d25825e6-756a-4175-8be2-ba3c8f86578d",
        "parentId" : "0aa583e7-bd2c-4fe2-a44a-52f48919f648",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Done\n",
        "createdAt" : "2014-08-28T18:41:34Z",
        "updatedAt" : "2014-08-29T00:31:03Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae59368836b36c417d4eafe4bff3a3c395a7cbe8",
    "line" : null,
    "diffHunk" : "@@ -1,1 +2238,2242 @@            var type = getDeclaredTypeOfSymbol(symbol);\n            if (!(type.flags & TypeFlags.ObjectType)) {\n                error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbol.name);\n                return emptyObjectType;\n            }"
  },
  {
    "id" : "6dbe923d-908c-4331-876e-ae4e32fed75f",
    "prId" : 554,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "753f8b23-2467-4aba-b9af-827475b6e3c0",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "since we are adding this check here, i would remove the check for isInRightSideOfImportOrExportAssignment from getSymbolInfo\n",
        "createdAt" : "2014-08-27T19:19:58Z",
        "updatedAt" : "2014-08-29T00:31:03Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "54990b0b-bdb2-4d22-9347-01b1b3e9679f",
        "parentId" : "753f8b23-2467-4aba-b9af-827475b6e3c0",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "It is not used in getSymbolInfo... No change is necessary here.\n",
        "createdAt" : "2014-08-28T18:45:55Z",
        "updatedAt" : "2014-08-29T00:31:03Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "ae59368836b36c417d4eafe4bff3a3c395a7cbe8",
    "line" : 69,
    "diffHunk" : "@@ -1,1 +6816,6820 @@                return getSymbolOfPartOfRightHandSideOfImport(entityName);\n            }\n\n            if (isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\n                entityName = entityName.parent;"
  },
  {
    "id" : "202776aa-1f28-4d8b-8dc2-9e39232b08e4",
    "prId" : 550,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89b05a21-011c-46c9-9122-ded59f7e6dc2",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Move this down to where you use it\n",
        "createdAt" : "2014-08-27T17:40:35Z",
        "updatedAt" : "2014-09-03T17:56:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "2ad53785-522d-4f36-8be1-18dd7e8a09c2",
        "parentId" : "89b05a21-011c-46c9-9122-ded59f7e6dc2",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "It's used in both if statements below.\n",
        "createdAt" : "2014-08-27T20:55:41Z",
        "updatedAt" : "2014-09-03T17:56:50Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "be08411a6cdc479e420aa4bd56b3888706e85e30",
    "line" : null,
    "diffHunk" : "@@ -1,1 +1821,1825 @@                }\n                if (symbol.flags & SymbolFlags.Class) {\n                    var classType = getDeclaredTypeOfClass(symbol);\n                    constructSignatures = getSignaturesOfSymbol(symbol.members[\"__constructor\"]);\n                    if (!constructSignatures.length) {"
  },
  {
    "id" : "1f338df5-02ce-4291-8ed0-c8defd05f134",
    "prId" : 550,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "88d28ead-f72c-4613-87d2-1ee3df6c6607",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "stringIndexType looks like it might be undefined at this point, if you took the else path above. I would do stringIndexType || undefined just to make the intent clear.\n",
        "createdAt" : "2014-08-27T17:47:46Z",
        "updatedAt" : "2014-09-03T17:56:50Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "cdd3bfc4-9add-4b46-b495-a5409804402d",
        "parentId" : "88d28ead-f72c-4613-87d2-1ee3df6c6607",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Added (superfluous) assignment of undefined to make it clearer.\n",
        "createdAt" : "2014-08-27T20:57:21Z",
        "updatedAt" : "2014-09-03T17:56:50Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "be08411a6cdc479e420aa4bd56b3888706e85e30",
    "line" : 54,
    "diffHunk" : "@@ -1,1 +1834,1838 @@                var numberIndexType: Type = (symbol.flags & SymbolFlags.Enum) ? stringType : undefined;\n            }\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\n        }\n"
  },
  {
    "id" : "31c0962b-e2e4-4f91-b31f-fef0430aac2c",
    "prId" : 473,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ce940565-62ae-4f11-8fc9-c772ae8b9ede",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Might be worth commenting why it is transient\n",
        "createdAt" : "2014-08-19T18:50:25Z",
        "updatedAt" : "2014-08-29T22:59:29Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "dc0560ae596815838a67606a57b40d4f78a5de76",
    "line" : 61,
    "diffHunk" : "@@ -1,1 +3825,3829 @@                        if (member.valueDeclaration) prop.valueDeclaration = member.valueDeclaration;\n                        prop.type = type;\n                        prop.target = member;\n                        member = prop;\n                    }"
  },
  {
    "id" : "2b1b625c-0000-4080-b8ef-62b84f1b0fec",
    "prId" : 464,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3040995-6dd9-47a9-91fa-a6b454f25515",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Add comment \n",
        "createdAt" : "2014-08-18T22:00:46Z",
        "updatedAt" : "2014-08-19T02:59:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "f949c5014ac57f2eee089720dc91466795c88ee0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6700,6704 @@                case SyntaxKind.StringLiteral:\n                    // Specialized signatures can have string literals as their parameters' type names\n                    return node.parent.kind === SyntaxKind.Parameter;\n                // Identifiers and qualified names may be type nodes, depending on their context. Climb\n                // above them to find the lowest container"
  },
  {
    "id" : "423baa82-7584-4594-b3c2-2b307ee20af7",
    "prId" : 464,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "371912a3-1f31-4925-860a-f5257ea5e608",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Get rid of this block\n",
        "createdAt" : "2014-08-18T22:14:38Z",
        "updatedAt" : "2014-08-19T02:59:15Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "f949c5014ac57f2eee089720dc91466795c88ee0",
    "line" : 388,
    "diffHunk" : "@@ -1,1 +6917,6921 @@            if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {\n                expr = expr.parent;\n            }\n            return checkExpression(expr);\n        }"
  },
  {
    "id" : "97b9bee3-22d1-4685-a568-cb7acf52ab6e",
    "prId" : 464,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f01b5290-f5be-4dc0-bffd-be7e533aa3c0",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "I find the names of these kinds very confusing.  Why do we have 'VariableDeclaration' but not 'ParameterDeclaration'.  Why have 'Parameter' but not 'Variable'.  If these are all declarations, it seems ike that should be in their name.  Or, if we don't want that in some cases, we should be consistent.  And then have .Class, .Interface, etc.\n",
        "createdAt" : "2014-08-18T22:28:38Z",
        "updatedAt" : "2014-08-19T02:59:15Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f949c5014ac57f2eee089720dc91466795c88ee0",
    "line" : 102,
    "diffHunk" : "@@ -1,1 +6590,6594 @@                case SyntaxKind.TypeParameter:\n                case SyntaxKind.Parameter:\n                case SyntaxKind.VariableDeclaration:\n                case SyntaxKind.Property:\n                case SyntaxKind.PropertyAssignment:"
  },
  {
    "id" : "16a3ab7f-0953-4406-be3b-bca9db8eab7d",
    "prId" : 464,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8b655e6a-c026-482b-bc1e-97cd132d5a2a",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "maybe just walk to the parent, and run the above code.\n",
        "createdAt" : "2014-08-18T22:36:07Z",
        "updatedAt" : "2014-08-19T02:59:15Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "f949c5014ac57f2eee089720dc91466795c88ee0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +6877,6881 @@            }\n\n            if (isTypeDeclarationName(node)) {\n                var symbol = getSymbolInfo(node);\n                return getDeclaredTypeOfSymbol(symbol);"
  },
  {
    "id" : "7bf06f8b-0995-4a09-804f-7f6c4b6c2666",
    "prId" : 450,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cc96450f-0d3d-4593-b869-3a1e033c9b35",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "should we instead just augment checkTypeAssignableTo to check the fullTypeCheck flag?\n",
        "createdAt" : "2014-08-13T23:04:22Z",
        "updatedAt" : "2014-08-15T19:07:05Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "a271b94b9d4c64568fc691838e8a740c4940891a",
    "line" : 36,
    "diffHunk" : "@@ -1,1 +4072,4076 @@                var constraint = getConstraintOfTypeParameter(typeParameters[i]);\n                if (constraint && fullTypeCheck) {\n                    checkTypeAssignableTo(typeArgument, constraint, typeArgNode, Diagnostics.Type_0_does_not_satisfy_the_constraint_1_Colon, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);\n                }\n                result.push(typeArgument);"
  },
  {
    "id" : "de6e9fad-5bd8-432a-957a-eed045d18992",
    "prId" : 428,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4dab0366-c7ec-4494-b3ca-24b256f7be38",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "consider adding a createTransientSymbol helper so you can avoid the 'or' and the redundant cast.\n",
        "createdAt" : "2014-08-11T20:00:48Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "89d85dde-1275-4bc8-afc9-885318ba3b65",
        "parentId" : "4dab0366-c7ec-4494-b3ca-24b256f7be38",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Only used in a few places, don't think it is worth it to create a helper.\n",
        "createdAt" : "2014-08-11T21:43:53Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "8d9de8d2-7948-4888-85a8-1bbc10c7f443",
        "parentId" : "4dab0366-c7ec-4494-b3ca-24b256f7be38",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Currently we have three places where we do this (and this will bring us to four).  Once we're repeating ourselves that many times, it seems desirable to start using a helper :)\n\ncreateSymbol itself is only used 9 times (so only 6 times without making something transient).  It seems like nearly half the times we create a symbol, it's a transient symbol.  This seems worthwhile to me :)\n",
        "createdAt" : "2014-08-12T05:35:54Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "cb3de58e-bcec-4a8c-b9f0-5a4926e565cd",
        "parentId" : "4dab0366-c7ec-4494-b3ca-24b256f7be38",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I agree. As well as a comment about when to create a transient symbol vs a nontransient symbol.\n",
        "createdAt" : "2014-08-12T17:44:33Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4cddc39033834a291cb241d55a0270098aaa452",
    "line" : 84,
    "diffHunk" : "@@ -1,1 +1849,1853 @@            var members: SymbolTable = {};\n            for (var i = 0; i < memberTypes.length; i++) {\n                var symbol = <TransientSymbol>createSymbol(SymbolFlags.Property | SymbolFlags.Transient, \"\" + i);\n                symbol.type = memberTypes[i];\n                members[i] = symbol;"
  },
  {
    "id" : "646c1a6f-0b1a-4263-9f11-2075c74ba815",
    "prId" : 428,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef84b0a1-7007-4a7e-b3aa-e03297816631",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "this is getting more confusing. can you extract out a method that breaks out the checks, to make it more understandable what it is doing.\n",
        "createdAt" : "2014-08-11T20:03:49Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "4ec38543-8df9-466c-b4e6-6d5a482ecf11",
        "parentId" : "ef84b0a1-7007-4a7e-b3aa-e03297816631",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "There's a comment on the next line that explains what the test is doing.\n",
        "createdAt" : "2014-08-11T20:54:03Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "80341c6e-99c6-4a4d-b7d4-c1e73da8ea85",
        "parentId" : "ef84b0a1-7007-4a7e-b3aa-e03297816631",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "The comment is really just an English transliteration of the Boolean check.  it doesn't really convey what's actually happening.  i.e. a comment for \"source.flags & TypeFlags.ObjectType && (target.flags & TypeFlags.Reference\"   saying \"if the source is an object and the target is a reference\" doesn't really explain things.\n\nWhat I meant was more have English prose explaining why these are the right set of checks.  For example, why is is right that 'inferFromTypes' cares about tuples.  And why is right that inferFromTypes does _not_ care about the other sorts of types not checked here.\n\nIn other words, say someone has to come along and try to determine if this code is correct or not.  Having the English prose explaining why it is precisely supposed to be this way is enormously helpful.\n",
        "createdAt" : "2014-08-12T05:38:54Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4cddc39033834a291cb241d55a0270098aaa452",
    "line" : 179,
    "diffHunk" : "@@ -1,1 +3387,3391 @@                    }\n                }\n                else if (source.flags & TypeFlags.ObjectType && (target.flags & (TypeFlags.Reference | TypeFlags.Tuple) ||\n                    (target.flags & TypeFlags.Anonymous) && target.symbol && target.symbol.flags & (SymbolFlags.Method | SymbolFlags.TypeLiteral))) {\n                    // If source is an object type, and target is a type reference, a tuple type, the type of a method, or a type literal, infer from members"
  },
  {
    "id" : "67487157-9632-497e-a51c-21e7be0995c4",
    "prId" : 428,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b7166f5e-dfc8-479c-b941-9fd4e45d9409",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "not sure what this is doing in the context of tuples.  Can you clarify why this is necessary.\n",
        "createdAt" : "2014-08-11T20:05:56Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "a1e2d9f4-4889-4eeb-8b4c-660be71ad2e5",
        "parentId" : "b7166f5e-dfc8-479c-b941-9fd4e45d9409",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "If the contextual type is a tuple type we want to return the tuple element type at the same index as the expression node.\n",
        "createdAt" : "2014-08-11T21:04:43Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "b9ccebf1-fe6a-4e93-b2bf-bbab6e1e317d",
        "parentId" : "b7166f5e-dfc8-479c-b941-9fd4e45d9409",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Sorry, I meant \"clarify in the source code.\"   These comments in the code review are not something people see when working with the code.  \n",
        "createdAt" : "2014-08-12T05:39:27Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4cddc39033834a291cb241d55a0270098aaa452",
    "line" : 236,
    "diffHunk" : "@@ -1,1 +3828,3832 @@        // the type of the property with the numeric name N in T, if one exists. Otherwise, it is the type of the numeric\n        // index signature in T, if one exists.\n        function getContextualTypeForElementExpression(node: Expression): Type {\n            var arrayLiteral = <ArrayLiteral>node.parent;\n            var type = getContextualType(arrayLiteral);"
  },
  {
    "id" : "7f46139f-74b8-4864-9a66-861da6c849be",
    "prId" : 428,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "76476050-a1ca-493c-a339-c46a5ad267a6",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "the former way seemed better.  It was explicit that only the special .Prototype member was considered to be a property, and anything else went to the decl.  Now, the new code is assuming anything without a valueDecl is a property.  It's not clear why that invariant would be true.\n",
        "createdAt" : "2014-08-11T20:07:41Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b84c35f5-f0d4-4f77-aa2d-c9b187324215",
        "parentId" : "76476050-a1ca-493c-a339-c46a5ad267a6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Some symbols have no declarations associated with them and we need a default policy for those. This establishes that policy. Also, note that the function is simply a helper for `checkPropertyAccess` and not referenced anywhere else.\n",
        "createdAt" : "2014-08-11T21:42:22Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      },
      {
        "id" : "54e1ee4e-ce42-46a2-a021-1157ce332d54",
        "parentId" : "76476050-a1ca-493c-a339-c46a5ad267a6",
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "\"This establishes that policy\"\n\nWhen establishing policy we should be documenting it (at least with some sort of comment).  For example, in the comment for 'valueDeclaration' on Symbol we should be documenting: \"if a symbol does not have a valueDeclaration, it is assumed to be a property.  Example of this are the synthesized '.prototype' property as well as synthesized tuple index properties.\"\n",
        "createdAt" : "2014-08-12T05:41:14Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "6521bbad-d6be-45ec-978e-68a93c188b5b",
        "parentId" : "76476050-a1ca-493c-a339-c46a5ad267a6",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Definitely agree with Cyrus here\n",
        "createdAt" : "2014-08-12T17:45:54Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "22d76a62-1148-416c-a225-633e877e2f7d",
        "parentId" : "76476050-a1ca-493c-a339-c46a5ad267a6",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Ok, will add a comment.\n",
        "createdAt" : "2014-08-13T00:34:50Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4cddc39033834a291cb241d55a0270098aaa452",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3991,3995 @@        // '.prototype' property as well as synthesized tuple index properties.\n        function getDeclarationKindFromSymbol(s: Symbol) {\n            return s.valueDeclaration ? s.valueDeclaration.kind : SyntaxKind.Property;\n        }\n"
  },
  {
    "id" : "21ab8c7e-3ea2-4a64-9ed6-6d36e25cba72",
    "prId" : 428,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ed4b3a0-9344-4cd5-87ff-2b86670ae839",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Good ol' Œ∑-reduction.\n",
        "createdAt" : "2014-08-13T01:31:35Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "a75ccc81-9c1c-4e5a-9a5a-ab2699a7b235",
        "parentId" : "4ed4b3a0-9344-4cd5-87ff-2b86670ae839",
        "authorId" : "d028362c-70f3-4a60-b6bc-f80ee67fc04b",
        "body" : "someone ate my tea\n",
        "createdAt" : "2014-08-13T09:08:57Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "d028362c-70f3-4a60-b6bc-f80ee67fc04b",
        "tags" : [
        ]
      },
      {
        "id" : "3a7a8887-6a47-49a3-ad2d-6747987eb606",
        "parentId" : "4ed4b3a0-9344-4cd5-87ff-2b86670ae839",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Someone eta my tea\n",
        "createdAt" : "2014-08-13T18:43:34Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "aa9234a5-eacf-4c92-af1c-80473d5f3bc1",
        "parentId" : "4ed4b3a0-9344-4cd5-87ff-2b86670ae839",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : ":+1:\n",
        "createdAt" : "2014-08-13T18:48:53Z",
        "updatedAt" : "2014-09-15T18:08:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b4cddc39033834a291cb241d55a0270098aaa452",
    "line" : 116,
    "diffHunk" : "@@ -1,1 +2275,2279 @@                            var typeParameters = (<InterfaceType>type).typeParameters;\n                            if (node.typeArguments && node.typeArguments.length === typeParameters.length) {\n                                type = createTypeReference(<GenericType>type, map(node.typeArguments, getTypeFromTypeNode));\n                            }\n                            else {"
  },
  {
    "id" : "b636992a-2931-488f-8ead-d8827f6f8ba4",
    "prId" : 410,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "can you not return undefined here.   boolean methods should return true/false, not true/false/undefined.\n",
        "createdAt" : "2014-08-10T04:44:40Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "23bf7e85-bbdd-4a93-86af-d921d1f4d263",
        "parentId" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "this isnot returning false.. isSymbolUsedInExportAssignment will return true/undefined\n",
        "createdAt" : "2014-08-11T17:35:21Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "54077db0-aa68-43d5-b1f1-f56caee98b36",
        "parentId" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "why not just true/false?\n",
        "createdAt" : "2014-08-11T18:21:47Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "eb0c52d5-3c47-4284-b8fa-60e4cd5c372f",
        "parentId" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "we don't want to be returning false specifically  instead use undefined.\n",
        "createdAt" : "2014-08-11T21:18:23Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "6b3cd279-0725-4559-a184-e123ead02606",
        "parentId" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "yes, I understand, but why? what is the value in not just having return false as the last statement of the function? the truthiness of the result still holds, it is more of a style issue.. \n",
        "createdAt" : "2014-08-13T04:31:35Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "d5fcb8eb-a898-4055-b6ca-f26e38b17745",
        "parentId" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "aren't we following rule of not returning false but using undefined (with no return statement instead) as false value?\n",
        "createdAt" : "2014-08-13T20:16:44Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "82c12554-a254-48b8-ba88-6c45f1af9c0e",
        "parentId" : "777b7e7c-ceb2-427c-b3d9-1850f780a9ec",
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I do not think we reached a conclusion on this. Once we have unreachable code detection enabled we will not be able to follow that model. lets talk about it though.\n",
        "createdAt" : "2014-08-13T21:04:25Z",
        "updatedAt" : "2014-08-14T01:04:18Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      }
    ],
    "commit" : "54f5f15796d8b064e0bd31787c1a9a41c1ef4d21",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +1075,1079 @@                        return isSymbolUsedInExportAssignment(resolveImport(symbolOfNode));\n                    }\n                }\n\n                // Check if the symbol is used in export assignment"
  },
  {
    "id" : "ecf40da4-e379-48ea-ab68-860317a34750",
    "prId" : 330,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "72aec90b-9edc-4025-bbbd-8067a2b80097",
        "parentId" : null,
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "Is picking immediate parent is always correct option or we need to bubble up to the interesting node?\n",
        "createdAt" : "2014-08-02T22:26:48Z",
        "updatedAt" : "2014-08-04T18:41:13Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "a5f10fa1-dd3d-43c3-8d8a-6fb70ddf0087",
        "parentId" : "72aec90b-9edc-4025-bbbd-8067a2b80097",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "Picking the immediate parent is intentional because we're dispatching on the immediately containing context of the given expression node. The function we dispatch to may crawl further up the parent chain, but that depends on the particular context.\n",
        "createdAt" : "2014-08-03T22:33:25Z",
        "updatedAt" : "2014-08-04T18:41:13Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "2b26e3797642c396a1e70c787dd3ffe2b0e2cc06",
    "line" : 346,
    "diffHunk" : "@@ -1,1 +3519,3523 @@                return node.contextualType;\n            }\n            var parent = node.parent;\n            switch (parent.kind) {\n                case SyntaxKind.VariableDeclaration:"
  },
  {
    "id" : "39667f73-c0c7-41d3-8662-66d282a25ce3",
    "prId" : 317,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "028b9a38-781c-4415-ad73-a81ec52443ac",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Doesn't make a difference, but my preference is\n\n``` TypeScript\nif (c === node) {\n    seen = true;\n}\n```\n\nFeel free to keep it the same.\n",
        "createdAt" : "2014-07-30T23:51:26Z",
        "updatedAt" : "2014-07-31T18:06:49Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "a62b47eace853463a8dc7ee73d1851a978675ff2",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +4885,4889 @@                    }\n                    else {\n                        seen = c === node;\n                    }\n                });"
  },
  {
    "id" : "52293785-9b94-483b-b580-5dacfe2d72d1",
    "prId" : 256,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "774b2c1d-98b1-4224-9931-164ded6b6ec5",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Don't you still need to do this for setters?\n",
        "createdAt" : "2014-07-29T08:05:47Z",
        "updatedAt" : "2014-07-29T08:05:47Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "194f2fd1-718e-4c68-ba8d-f9655277a0f6",
        "parentId" : "774b2c1d-98b1-4224-9931-164ded6b6ec5",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Setters don't need to have their bodies checked - they don't return anything.\n",
        "createdAt" : "2014-07-29T18:27:42Z",
        "updatedAt" : "2014-07-29T18:31:29Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "fc80c300a0fa01d6eec76766cb8c67d3e8d45fe2",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +4949,4953 @@\n            checkSourceElement(node.body);\n            if (node.type && !isAccessor(node.kind)) {\n                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));\n            }"
  },
  {
    "id" : "353cdb00-857d-4004-8401-8d9be282a078",
    "prId" : 197,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b375c258-6cac-4e9c-9966-248600144707",
        "parentId" : null,
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Add a comment to explain what is going on here. From what I can understand\n\n``` TypeScript\n// Get the appropriate declaration for the local symbol\n// (e.g. if we are checking a function, get the function declaration).\n// If this is not the root of the export, then we have no reason to check.\n```\n\ncould work.\n",
        "createdAt" : "2014-07-24T19:11:51Z",
        "updatedAt" : "2014-07-25T18:15:25Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "42df260eb5f57e1662ae0217e01aee531e7d2bd6",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4942,4946 @@\n            // run the check only for the first declaration in the list\n            if (getDeclarationOfKind(symbol, node.kind) !== node) {\n                return;\n            }"
  },
  {
    "id" : "f1164e26-e2c6-432d-8a21-8ccd3496d3ad",
    "prId" : 176,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5dda1ccf-cc3e-4e0f-b944-4780c3ffc802",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "This seems wrong.  The _statement_ of the 'with' block should not be checked, but the _expression_ of the with block should still be checked.  Yes?\n",
        "createdAt" : "2014-07-22T06:22:54Z",
        "updatedAt" : "2014-07-23T18:54:06Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "7168dd4b-14d4-4e65-aa66-129b8350366b",
        "parentId" : "5dda1ccf-cc3e-4e0f-b944-4780c3ffc802",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "I am open to discussing checking the expression, but as @RyanCavanaugh says, skipping it is consistent with the old compiler.\n",
        "createdAt" : "2014-07-22T16:59:28Z",
        "updatedAt" : "2014-07-23T18:54:06Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "29284cb1b94f84c1853a3ee91070cb930047be23",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5285,5289 @@        function checkWithStatement(node: WithStatement) {\n            checkExpression(node.expression);\n            error(node.expression, Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);\n        }\n"
  },
  {
    "id" : "69a73e82-7a4f-4969-ba7a-54e687ee9943",
    "prId" : 176,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "917c4bcb-5685-43dc-aabf-8b6f38a0a223",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "small tweak.  can you just underline the 'while' token (i think you can get it with the scanner).  it seems weird to underling the expression since you're complaining about the 'while' block.  \n",
        "createdAt" : "2014-07-23T19:12:15Z",
        "updatedAt" : "2014-07-23T19:12:15Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "b4a91424-e9db-47c2-8fa2-6e49892d568a",
        "parentId" : "917c4bcb-5685-43dc-aabf-8b6f38a0a223",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Agreed. Should be the `with` keyword.\n",
        "createdAt" : "2014-07-23T19:22:59Z",
        "updatedAt" : "2014-07-23T19:23:07Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "29284cb1b94f84c1853a3ee91070cb930047be23",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +5285,5289 @@        function checkWithStatement(node: WithStatement) {\n            checkExpression(node.expression);\n            error(node.expression, Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);\n        }\n"
  },
  {
    "id" : "c494638c-a07a-4f8a-9bba-964f7151139e",
    "prId" : 175,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df96670c-9b29-43c3-a2a7-46de681cac0f",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Why do you have to instantiate the source, but not the target? Please put a comment\n",
        "createdAt" : "2014-07-21T23:57:58Z",
        "updatedAt" : "2014-07-22T17:54:46Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85df9e9faa807f8481c88d4babb77e1e7d9ed72",
    "line" : null,
    "diffHunk" : "@@ -1,1 +3677,3681 @@            forEachMatchingParameterType(contextualSignature, signature, (source, target) => {\n                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type\n                inferTypes(context, instantiateType(source, contextualMapper), target);\n            });\n            return getSignatureInstantiation(signature, getInferredTypes(context));"
  },
  {
    "id" : "16699e0f-6e80-47e2-a9c2-a87acf6d9b9e",
    "prId" : 175,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "95180479-391c-42d4-9d68-4137d30e2d7d",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "You should probably use this in all the places where we do something for each parameter (as I recall, there are a lot)\n",
        "createdAt" : "2014-07-22T00:01:55Z",
        "updatedAt" : "2014-07-22T17:54:46Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "d85df9e9faa807f8481c88d4babb77e1e7d9ed72",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +2979,2983 @@        }\n\n        function forEachMatchingParameterType(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {\n            var sourceMax = source.parameters.length;\n            var targetMax = target.parameters.length;"
  },
  {
    "id" : "0273ce54-2a98-4865-872a-a21816c1c1a3",
    "prId" : 161,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2b088a74-3339-43e1-8691-d8aa55764df3",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "I have added a lookup method for Map, it would be more consistent.\n",
        "createdAt" : "2014-08-05T16:35:57Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "c8d663bb-6303-4fd8-b425-9b9247d724b7",
        "parentId" : "2b088a74-3339-43e1-8691-d8aa55764df3",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "i will update that when I resolve merge conflicts.\n",
        "createdAt" : "2014-08-05T18:09:02Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e31aa9e12ae98fe5cbfffdd4aaee85bf0b67197b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +646,650 @@\n                // If symbol is directly available by its name in the symbol table\n                if (hasProperty(symbols, symbol.name) && isAccessible(symbols[symbol.name])) {\n                    return symbol;\n                }"
  },
  {
    "id" : "5dbdd2fb-2f32-4fb5-9883-5a955ea065a0",
    "prId" : 161,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ff1c41a8-8e84-44cb-b604-ac0b6942994c",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "question: what if we were looking for a static method on a class, the parent is not a module in this case.. how would that wok?\n",
        "createdAt" : "2014-08-05T16:39:30Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "61b5f914-ca25-4f22-a578-c67c74bcb62e",
        "parentId" : "ff1c41a8-8e84-44cb-b604-ac0b6942994c",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "i still have todo on that,  i will add a todo comment here specifically.\n",
        "createdAt" : "2014-08-05T18:35:29Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e31aa9e12ae98fe5cbfffdd4aaee85bf0b67197b",
    "line" : null,
    "diffHunk" : "@@ -1,1 +726,730 @@                    // But it cant, hence the accessible is going to be undefined, but that doesnt mean m.c is accessible\n                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification\n                    meaningToLook = SymbolFlags.Namespace;\n                    symbol = symbol.parent;\n                }"
  },
  {
    "id" : "ce5c20ff-d6f7-402d-b81c-770971f92524",
    "prId" : 161,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0a0629b-748d-4503-9031-c28662c3a6db",
        "parentId" : null,
        "authorId" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "body" : "question: If we could not find a symbol at this location, should we just break? what is the point of examining the parent if this link in the chain is not accessible?\n",
        "createdAt" : "2014-08-05T16:41:11Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "7a428a65-3bd3-41f2-b899-b42dc7177963",
        "tags" : [
        ]
      },
      {
        "id" : "a5ed2ca4-8e74-4f80-823e-b28871dccf8c",
        "parentId" : "d0a0629b-748d-4503-9031-c28662c3a6db",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "module m {\n    export class c {\n    }\n}\n\nvar x: typeof m.c\n\nIn this example when we look if the symbol constructor function m.c is accessible, we will start with the symbol for c. Since c is not directly in the scope - the answer here that is accessible symbol is going to be undefined. But that doesn't mean m.c is not accessible. It is accessible if the parent m is accessible.\n",
        "createdAt" : "2014-08-06T18:18:49Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      },
      {
        "id" : "3b031e59-e324-4c5c-85b9-ca3022b5d0a3",
        "parentId" : "d0a0629b-748d-4503-9031-c28662c3a6db",
        "authorId" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "body" : "Note I added the detailed comment\n",
        "createdAt" : "2014-08-06T18:22:11Z",
        "updatedAt" : "2014-08-06T18:26:46Z",
        "lastEditedBy" : "cb16561c-58c1-4f0a-a738-613be01155c9",
        "tags" : [
        ]
      }
    ],
    "commit" : "e31aa9e12ae98fe5cbfffdd4aaee85bf0b67197b",
    "line" : 29,
    "diffHunk" : "@@ -1,1 +701,705 @@                    // Symbol is accessible if it by itself is accessible\n                    var accessibleSymbol = getAccessibleSymbol(symbol, enclosingDeclaration, meaningToLook);\n                    if (accessibleSymbol) {\n                        if (forEach(accessibleSymbol.declarations, declaration => !isDeclarationVisible(declaration))) {\n                            return {"
  },
  {
    "id" : "8bd8275d-6e52-487d-b723-a73d85bdce33",
    "prId" : 147,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Did we used to support a getter with a single throw statement?\n",
        "createdAt" : "2014-07-19T00:41:07Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e20a7660-2112-474a-adbe-87fd7241eac8",
        "parentId" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Yes; however, we erroneously permitted the following in both the old compiler and the new one prior to this commit.\n\n``` TypeScript\nclass C {\n    get foo() {\n        return;\n    }\n}\n```\n",
        "createdAt" : "2014-07-19T00:47:57Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "e33dd6bd-85c3-44c6-bedd-f6165e799782",
        "parentId" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "Can you add an explanation why this is error? Per TypeScript spec (and ECMA 262) return statement that lacks expression returns the value `undefined`\n",
        "createdAt" : "2014-07-19T05:28:33Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "13fc3666-7f15-4e86-895d-0e3e65d40927",
        "parentId" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "authorId" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "body" : "Yes, This is crazy world of JavaScript. Also restricting this is a potential breaking change. I'd say that these issues should be traced by some sort of linter tool\n",
        "createdAt" : "2014-07-19T05:39:39Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "ebe500ea-e2a7-4d57-a65b-c50e7640b049",
        "tags" : [
        ]
      },
      {
        "id" : "46952917-ad93-43aa-a17f-ffa804f2ef06",
        "parentId" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Well yes, but doesn't the following also implicitly return `undefined`?\n\n``` TypeScript\nclass C {\n    get foo() {\n    }\n}\n```\n\nAdditionally, the following should be permissible by the same reasoning, meaning that the entire check should be removed.\n\n``` TypeScript\nfunction f(): string {\n    return;\n}\n```\n\nI think that the rules for the check should be the same between get accessors and functions with type annotations. If not, we may need to open this up to discussion, because then maybe we don't need the check.\n\nEdit: Sorry @vladima, didn't see your last response, and I decided to remove my answer and think the matter over a bit more before posting this.\n",
        "createdAt" : "2014-07-19T08:37:11Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      },
      {
        "id" : "f08b9c73-474f-4ec0-9bfa-c0af0ef43b69",
        "parentId" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "authorId" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "body" : "Adding 'Breaking Change' label to the original issue then\n",
        "createdAt" : "2014-07-20T04:49:48Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "8ef7dcc8-4842-40e3-9f9a-182aa5f9b120",
        "tags" : [
        ]
      },
      {
        "id" : "03a4bd25-871c-42da-a69f-39df6889db15",
        "parentId" : "f72c27c5-b9d4-4b43-810b-29eeab61dee7",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "I have opened up #162 to prevent this issue from blocking the fix.\n\nI'll simply amend this pull request so that it does not cause a breaking change.\n",
        "createdAt" : "2014-07-20T17:30:53Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f4e887155777a65dfd039c814b3de4f8db01e78",
    "line" : null,
    "diffHunk" : "@@ -1,1 +4655,4659 @@            if (node.kind === SyntaxKind.GetAccessor) {\n                if (!isInAmbientContext(node) && node.body && !(bodyContainsAReturnStatement(<Block>node.body) || bodyContainsSingleThrowStatement(<Block>node.body))) {\n                    error(node.name, Diagnostics.A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement);\n                }\n            }"
  },
  {
    "id" : "b50b8c41-2bbd-47f0-b69c-4d21fece2c75",
    "prId" : 147,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ef6e3d7a-dea3-48cb-9fb4-d25677cf65b8",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Personally I would rather enumerate the cases where we don't go in. But that's just me\n",
        "createdAt" : "2014-07-19T00:44:02Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "221893c1-9304-4d59-aeb9-33f280f621d4",
        "parentId" : "ef6e3d7a-dea3-48cb-9fb4-d25677cf65b8",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Yeah, I've gone back and forth. It's kind of a matter of whitelisting vs blacklisting, so I went with whitelisting because it was feasible.\n",
        "createdAt" : "2014-07-19T00:50:14Z",
        "updatedAt" : "2014-07-21T23:55:33Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f4e887155777a65dfd039c814b3de4f8db01e78",
    "line" : 38,
    "diffHunk" : "@@ -1,1 +3974,3978 @@                    case SyntaxKind.ReturnStatement:\n                        return visitor(node);\n                    case SyntaxKind.Block:\n                    case SyntaxKind.FunctionBlock:\n                    case SyntaxKind.IfStatement:"
  },
  {
    "id" : "289cdab5-60a6-4394-90dd-5b994c520a32",
    "prId" : 147,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "bc6bc4e0-44d0-4fff-943a-3a28f2ef6556",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "no parens around (returnStatement)\n",
        "createdAt" : "2014-07-22T23:58:14Z",
        "updatedAt" : "2014-07-22T23:58:14Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      },
      {
        "id" : "0a033d82-d094-4298-9da1-9385a0934da1",
        "parentId" : "bc6bc4e0-44d0-4fff-943a-3a28f2ef6556",
        "authorId" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "body" : "Fixed in 0e10fc76b8142a3fa1e7caf33d1ac9b25714ed80.\n",
        "createdAt" : "2014-07-23T00:08:44Z",
        "updatedAt" : "2014-07-23T00:08:44Z",
        "lastEditedBy" : "cbc74313-e7e9-4313-b106-3e17fde5473d",
        "tags" : [
        ]
      }
    ],
    "commit" : "0f4e887155777a65dfd039c814b3de4f8db01e78",
    "line" : 56,
    "diffHunk" : "@@ -1,1 +3999,4003 @@            var aggregatedTypes: Type[] = [];\n\n            forEachReturnStatement(body, (returnStatement) => {\n                var expr = returnStatement.expression;\n                if (expr) {"
  },
  {
    "id" : "32984d0d-e599-4725-a19c-93c27bd72550",
    "prId" : 33,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "743b07c8-2f7f-47fb-a472-255307a42938",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Please break this up to make it easier to read.\n",
        "createdAt" : "2014-07-16T22:01:15Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "e37e4038-0b67-49fa-a5b8-2730a8e357d3",
        "parentId" : "743b07c8-2f7f-47fb-a472-255307a42938",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I think it's fine and the name of the function says what it does.\n",
        "createdAt" : "2014-07-16T22:59:55Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b112b1a468af6ae9a6a2ddc1950493217cd64a0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5561,5565 @@            for (var i = 0; i < declarations.length; i++) {\n                var declaration = declarations[i];\n                if ((declaration.kind === SyntaxKind.ClassDeclaration || (declaration.kind === SyntaxKind.FunctionDeclaration && (<FunctionDeclaration>declaration).body)) && !isInAmbientContext(declaration)) {\n                    return declaration;\n                }"
  },
  {
    "id" : "90ad338b-f532-4e6a-be5b-832e8287bb04",
    "prId" : 33,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "535ad726-4904-4362-a065-1f83fd41db61",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This is beautifully concise!\n",
        "createdAt" : "2014-07-16T22:05:01Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "c5da43a7-60e8-4c03-8aee-43d70f7fcb87",
        "parentId" : "535ad726-4904-4362-a065-1f83fd41db61",
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "This actually differs from the old compiler, which errored on the class/function instead of the module. This corresponds to 2 notions:\n1. Error on the second thing if there is some sort of collision\n2. It would lead to fewer errors because you would get at most one error per symbol, rather than an error on each nonambient module declaration that precedes the function/class\n",
        "createdAt" : "2014-07-16T22:10:10Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      },
      {
        "id" : "64a7969a-bc27-4884-add8-87feb2d63d46",
        "parentId" : "535ad726-4904-4362-a065-1f83fd41db61",
        "authorId" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "body" : "I prefer erroring on the module(s) because they are the thing that is \"merged in\". The class or function declaration establishes that we're dealing with a function object and that can't be \"merged in\" later. Don't think multiple errors are a problem, in reality there will only be one of each.\n",
        "createdAt" : "2014-07-16T23:03:09Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "bdee90d3-fa06-43ed-8bf1-d381c3d69e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b112b1a468af6ae9a6a2ddc1950493217cd64a0",
    "line" : null,
    "diffHunk" : "@@ -1,1 +5581,5585 @@                    }\n                }\n            }\n            if (node.name.kind === SyntaxKind.StringLiteral) {\n                if (!isGlobalSourceFile(node.parent)) {"
  },
  {
    "id" : "d5f7e811-7eb9-47ab-bda0-1f45455f76b6",
    "prId" : 33,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ec2c765-3930-465b-846e-9cf25ccd9d22",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "Can you wrap these lines.  THey don't show up in Github's CR tool.\n",
        "createdAt" : "2014-07-16T23:25:52Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b112b1a468af6ae9a6a2ddc1950493217cd64a0",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +5561,5565 @@            for (var i = 0; i < declarations.length; i++) {\n                var declaration = declarations[i];\n                if ((declaration.kind === SyntaxKind.ClassDeclaration || (declaration.kind === SyntaxKind.FunctionDeclaration && (<FunctionDeclaration>declaration).body)) && !isInAmbientContext(declaration)) {\n                    return declaration;\n                }"
  },
  {
    "id" : "89587bfa-84b6-4ef2-9e4b-64b92d74bba5",
    "prId" : 33,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ffc630f1-9646-47b7-bb27-bb5bf186640e",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "good name. but can you make it getFirstNonAmbientNonSignatureClassOrFunctionDeclaration\n",
        "createdAt" : "2014-07-16T23:26:52Z",
        "updatedAt" : "2014-07-16T23:32:02Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6b112b1a468af6ae9a6a2ddc1950493217cd64a0",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +5557,5561 @@        }\n\n        function getFirstNonAmbientClassOrFunctionDeclaration(symbol: Symbol): Declaration {\n            var declarations = symbol.declarations;\n            for (var i = 0; i < declarations.length; i++) {"
  },
  {
    "id" : "e4c3c380-6495-41d7-a376-4b9913a5fda8",
    "prId" : 30,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ac79ca6b-68ed-4eeb-98ce-6cda7f03d820",
        "parentId" : null,
        "authorId" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "body" : "Assert that you won't get here\n",
        "createdAt" : "2014-07-16T20:14:58Z",
        "updatedAt" : "2014-07-16T21:51:02Z",
        "lastEditedBy" : "1b34783f-ccca-4b94-9373-cb3f0e0d8028",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bb219a3ddc51a4d1c2f3260ccfc157cc7cce51e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +936,940 @@                        return (node.flags & NodeFlags.ExternalModule) ? node : undefined;\n                    }\n                }\n                Debug.fail(\"getContainingModule cant reach here\");\n            }"
  },
  {
    "id" : "55cf3e81-1e05-46df-94fd-50d4713429c0",
    "prId" : 30,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ad5fc8e-b511-456d-a954-c98f4c56fbd6",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "should enclosingDeclaration be optional?  When is it ok not to pass it in?\n\nWhy is 'meaning' optional.  When is it ok to not pass it in.  When would/shoudl people pass it in?\n",
        "createdAt" : "2014-07-16T20:43:41Z",
        "updatedAt" : "2014-07-16T21:51:02Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bb219a3ddc51a4d1c2f3260ccfc157cc7cce51e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +688,692 @@        // Enclosing declaration is optional when we dont want to get qualified name in the enclosing declaration scope\n        // Meaning needs to be specified if the enclosing declaration is given\n        function symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags) {\n            function getSymbolName(symbol: Symbol) {\n                if (symbol.declarations && symbol.declarations.length > 0) {"
  },
  {
    "id" : "42ffad89-8765-4e75-8924-fb3d9dbd20e7",
    "prId" : 30,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5c75fed7-e646-4409-a7bb-0e1e4a28a930",
        "parentId" : null,
        "authorId" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "body" : "what does this conditional mean.  I have no intuition why you're needing to check all these cases, or if there are cases being missed.\n",
        "createdAt" : "2014-07-16T20:45:04Z",
        "updatedAt" : "2014-07-16T21:51:02Z",
        "lastEditedBy" : "d46620b3-5a79-45a1-96fd-76f5c2ababd1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1bb219a3ddc51a4d1c2f3260ccfc157cc7cce51e",
    "line" : null,
    "diffHunk" : "@@ -1,1 +702,706 @@            if (enclosingDeclaration &&\n                // Properties/methods/Signatures/Constructors/TypeParameters do not need qualification\n                !(symbol.flags & SymbolFlags.PropertyOrAccessor & SymbolFlags.Signature & SymbolFlags.Constructor & SymbolFlags.Method & SymbolFlags.TypeParameter)) {\n                var symbolName: string;\n                while (symbol) { "
  }
]
[
  {
    "id" : "e167b72b-5a4e-4634-864f-d3bd5b0da922",
    "prId" : 640,
    "prUrl" : "https://github.com/sbt/zinc/pull/640#pullrequestreview-215226299",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0cb2c9dc-10f6-453a-99be-a621ff31f95e",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "This is a hack ðŸ˜›I presume you're doing it because in macOS temporary files get a public symlink to a private symlink and here you are getting the dealiased paths for the generated class files. Can we instead dealias `classfile`?",
        "createdAt" : "2019-03-13T09:05:43Z",
        "updatedAt" : "2019-03-15T20:01:08Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "9a89837a-c3e0-48b9-9b86-b4f5f1875a18",
        "parentId" : "0cb2c9dc-10f6-453a-99be-a621ff31f95e",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "ok.\r\n",
        "createdAt" : "2019-03-15T03:43:19Z",
        "updatedAt" : "2019-03-15T20:01:08Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "9e5ccc41-b063-444e-8a8f-4fa9be34c0df",
        "parentId" : "0cb2c9dc-10f6-453a-99be-a621ff31f95e",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "https://github.com/sbt/zinc/pull/640/commits/23485a8fa5ebc208805727c1121f9126874022dd\r\n\r\n```scala\r\n  def dealiasSymlinks(xs: HashSet[File]): HashSet[String] =\r\n    xs map { x =>\r\n      x.getCanonicalPath\r\n    }\r\n```\r\n\r\n",
        "createdAt" : "2019-03-15T20:04:11Z",
        "updatedAt" : "2019-03-15T20:04:11Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0353db8f04c82e18fa3e5c6c80eb816e817a412",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +67,71 @@    val classfile = new File(out, \"good.class\")\n    assert(classfile.exists)\n    assert(\n      dealiasSymlinks(classfileManager.generatedClasses) ==\n        (if (forked) HashSet() else dealiasSymlinks(HashSet(classfile))))"
  },
  {
    "id" : "f5aba87a-3f96-4f9c-a910-0f9d2a3db180",
    "prId" : 280,
    "prUrl" : "https://github.com/sbt/zinc/pull/280#pullrequestreview-32403290",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "I don't understand this, can you elaborate?",
        "createdAt" : "2017-04-04T21:46:06Z",
        "updatedAt" : "2017-04-05T17:49:42Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "4606c2d2-5570-447b-9944-06ddf4171fbe",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "b5f4eacc-de6f-4e3b-a1b8-02e88a89d94b",
        "body" : "Removing laziness from the fields of `ClassLike` has the side effect to randomize the order of the result from `compileWithPrimitive()` method (which returns a `Seq` containing a `class` and an `object`).\r\nSorting the result ensure we have an order consistent with the expected result of the test.",
        "createdAt" : "2017-04-04T22:20:31Z",
        "updatedAt" : "2017-04-05T17:49:42Z",
        "lastEditedBy" : "b5f4eacc-de6f-4e3b-a1b8-02e88a89d94b",
        "tags" : [
        ]
      },
      {
        "id" : "3de1c27d-5119-48a4-9f23-3284bfc613b0",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "> Removing laziness from the fields of ClassLike has the side effect to randomize the order of the result \r\n\r\nDoes the result become non-deterministic with this change? If so would that affect change detection in computing (transitive) incremental compilation? iirc, Zinc first compiles whatever that it first detected as source change, and then it subsequently uses API difference to figure out if it needs to do more work.",
        "createdAt" : "2017-04-05T00:14:49Z",
        "updatedAt" : "2017-04-05T17:49:42Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "19d4e92b-9a22-40c1-ad24-a9cdf113856f",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "> Removing laziness from the fields of ClassLike has the side effect to randomize the order of the result from compileWithPrimitive() method (which returns a Seq containing a class and an object).\r\n  \r\nCan you diagnose why? This is strange.\r\n  \r\n> Sorting the result ensure we have an order consistent with the expected result of the test.\r\n  \r\nIn my opinion, we should not sort here just for testing purposes. Our core logic does not require it, it has no effect on Zinc changes analysis and it's not a contract of our API. Can we solve it in the tests side?",
        "createdAt" : "2017-04-05T09:29:09Z",
        "updatedAt" : "2017-04-05T17:49:42Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "fd6521cd-2fff-4099-8702-0491fcb78877",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "dd00f985-62e6-4807-b6a5-77e061400587",
        "body" : "AFAIK order should not matter in computing APIs and hashes (I am almost sure that we have a tests for that). Maybe we need to call `toSet` in checks later on?",
        "createdAt" : "2017-04-05T11:41:44Z",
        "updatedAt" : "2017-04-05T17:49:42Z",
        "lastEditedBy" : "dd00f985-62e6-4807-b6a5-77e061400587",
        "tags" : [
        ]
      },
      {
        "id" : "95450112-26a3-4a4a-97cf-32b804398e3f",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "b5f4eacc-de6f-4e3b-a1b8-02e88a89d94b",
        "body" : "`ClassToAPI` uses a `Set` to keep track of the APIs, then returns its result converted into a `Seq`.\r\nContraband generate the `hashCode()` method in a different way, depending on the class having lazy fields or not. Since all the lazy fields have been removed, it computes the hash by combining the hash of all the fields together instead of just calling `super.hashCode()` (See [JavaCodeGen.scala](https://github.com/sbt/contraband/blob/master/library/src/main/scala/sbt/contraband/JavaCodeGen.scala#L332-L345)). This should explain why we now have a random order.\r\n\r\nSince we zip the `leftAPI` and `rightAPI` together, sorting the result seems to be the apropriate way to ensure we call `SameAPI` with the correct pairs.",
        "createdAt" : "2017-04-05T17:38:12Z",
        "updatedAt" : "2017-04-05T17:49:42Z",
        "lastEditedBy" : "b5f4eacc-de6f-4e3b-a1b8-02e88a89d94b",
        "tags" : [
        ]
      },
      {
        "id" : "eda29176-801b-4f30-8668-8a63489239cb",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "@zehkae Thanks for the explanation!\r\n  \r\nSo I have two questions:\r\n  \r\n1. Could this issue be fixed in Contraband?\r\n2. When you mention `leftAPI` and `rightAPI`, do you mean that their order alter the behaviour of the API change detection algorithm?\r\n  \r\nTo me, this change seems to be necessary only for the testing suite. I'm slightly reluctant of sorting this only for testing purposes because order should not be a factor that we should take into account if it really doesn't alter semantics :smile:.",
        "createdAt" : "2017-04-07T09:42:01Z",
        "updatedAt" : "2017-04-07T09:42:23Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "f28ec577-511a-4a7a-a518-3fd8bc3faa56",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "b5f4eacc-de6f-4e3b-a1b8-02e88a89d94b",
        "body" : "  1. There is no issue with Contraband. Changing how `hashCode()` is generated based on the laziness of the fields is intended and prevents infinite recursion (see the test added in 436828c).\r\n  2. The compilation done by `compileWithPrimitive()` can produce a *class* and an *object*, but their order is not defined since they're in a `Set`. So `leftApi` will contain a *class* and an *object* from a first compilation and `rightApi` will contain a *class* and an *object* from a second compilation. Since we want to compare the *class* of `leftApi` with the *class* of `rightApi` (same for the *object*) we need to form the correct pairs for the comparison and not compare a *class* with an *object*. Sorting ensure we have the same order in `leftApi` and in `rightApi`. There may be other ways to ensure we get the correct pairs, the sort could be done elsewhere, but sorting there seemed to be a simple fix for the problem. Finally the sort is done only in the tests, it shouldn't be needed elsewhere.\r\n\r\nSorry for the late response. Even though the PR has been merged, I hope these answers help you understand the necessity of the sort in those tests.",
        "createdAt" : "2017-04-12T15:02:36Z",
        "updatedAt" : "2017-04-12T15:02:36Z",
        "lastEditedBy" : "b5f4eacc-de6f-4e3b-a1b8-02e88a89d94b",
        "tags" : [
        ]
      },
      {
        "id" : "36901288-99f6-44e4-8c0e-3600fdc613a8",
        "parentId" : "2978bb12-536e-44c3-af32-2fb58e5106e6",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Yes, they do. Thanks.",
        "createdAt" : "2017-04-12T15:06:18Z",
        "updatedAt" : "2017-04-12T15:06:18Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      }
    ],
    "commit" : "436828c4fc9222349a3df4b71a7f64260465c084",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +96,100 @@        result shouldBe true\n        val clazzz = new URLClassLoader(Array(out.toURI.toURL)).loadClass(\"hasstaticfinal\")\n        ClassToAPI(Seq(clazzz)).sortBy(_.definitionType.hashCode)\n      }\n"
  }
]
[
  {
    "id" : "ec067983-5428-4f2a-975c-e69cdfbeb2ba",
    "prId" : 351,
    "prUrl" : "https://github.com/sbt/zinc/pull/351#pullrequestreview-50064289",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "parentId" : null,
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "`private[inc]` is no guarantee - as you see `Stamp.fromString` invokes it without doing any validation:\r\n\r\n```scala\r\nscala> sbt.internal.inc.Stamp.fromString(\"hash(gobbledygook)\")\r\nres0: xsbti.compile.analysis.Stamp = hash(gobbledygook)\r\n```",
        "createdAt" : "2017-07-14T10:46:16Z",
        "updatedAt" : "2017-07-14T10:46:21Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "ffdbd62f-4dd2-482c-9df4-5c028bbeeedc",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Yeah, I know. But it's the best we can do. There's no way to define it `private` and instantiate it in the same file.",
        "createdAt" : "2017-07-14T11:11:45Z",
        "updatedAt" : "2017-07-14T11:11:45Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "bf106101-3d56-488a-b65f-1846cf649c52",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "Sure there is, define it `private[this]` and constructed it from Hash's companion object, after validating the input.",
        "createdAt" : "2017-07-14T13:17:57Z",
        "updatedAt" : "2017-07-14T13:17:57Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "3ad9fdf8-8944-46b3-af76-0d516f873f25",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "No, I don't think that's possible. `Hash` is instantiated from two different objects: `Stamp` and `Stamper`, and wrapping them into Hash's companion object is not a valid solution.",
        "createdAt" : "2017-07-14T13:26:22Z",
        "updatedAt" : "2017-07-14T13:26:22Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "9d12c2ff-3d8d-4851-842a-412e513e4c22",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "Wrapping them? You define a safe method in Hash's companion object that does the validation and then call that method from Stamp and Stamper.",
        "createdAt" : "2017-07-14T13:31:49Z",
        "updatedAt" : "2017-07-14T13:31:49Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "2fb4d6ec-0d12-4bed-bf29-ff2a8284d9da",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "The validation is in the types. `Stamp` needs to pass in a string (which is the deserialized format). Adding a method in Hash's companion object does not solve anything: instead of exposing the constructor with string you will expose a method that has the same signature. People can still call that from anywhere in Zinc. ",
        "createdAt" : "2017-07-14T13:35:40Z",
        "updatedAt" : "2017-07-14T13:35:40Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "adab6ebb-4637-49ad-bf5b-52f8bf66817a",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "What does \"The validation is in the types\" mean? I'd just like it be impossible to create illegal Hash objects. Currently it's trivial.",
        "createdAt" : "2017-07-14T13:43:15Z",
        "updatedAt" : "2017-07-14T13:43:15Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "bbbac74e-f9e9-4001-9266-84c2cdeed301",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "This looks like a minor detail we can come back later, so I am going to merge this PR as is.\r\n",
        "createdAt" : "2017-07-14T13:43:20Z",
        "updatedAt" : "2017-07-14T13:43:21Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "f521b3e8-fe13-4b37-9731-b1208e35ef4d",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "> What does \"The validation is in the types\" mean? I'd just like it be impossible to create illegal Hash objects. Currently it's trivial.\r\n  \r\nWhat I mean is that it's not possible to prevent the creation of illegal hash objects because `Stamp` needs access to a constructor that takes a string. Whether that is provided by a constructor or a method in the companion object produces the same result: it has to be accessible from `Stamp`, which disqualifies it from being defined as `private[this]`. The only way this can be supported is by wrapping all the definitions inside an object or a package, and then fixing all the imports. Too big of a change to do it here. I'm happy to do open a ticket to do it.\r\n  \r\nAll in all, with the current organisation of the code, `private[this]` cannot be used and that's why we use `private[inc]`, which at least gives us something.",
        "createdAt" : "2017-07-14T13:49:02Z",
        "updatedAt" : "2017-07-14T13:49:02Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "dbe26b63-ede8-4db1-8b9e-1813909516a8",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "Sure you can prevent the creation. You can pass back an `Option[Hash]`, or an `Either[String, Hash]`, or you can stick to what zinc was doing previous which is throw an exception. Either way you prevent the creation of an illegal hash object.",
        "createdAt" : "2017-07-14T13:52:00Z",
        "updatedAt" : "2017-07-14T13:52:00Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "a6b13dd0-f879-431f-8405-4c9d6d934b3c",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Either of those alternatives have a runtime performance penalty (returning `Option` and `Either` require validation), which goes against the goal of the commit that introduced this change.\r\n  \r\nIMO, the best to solve this issue is to put all those stamp utils in its own package, and then do `private[stamps]`.",
        "createdAt" : "2017-07-14T13:55:06Z",
        "updatedAt" : "2017-07-14T13:55:06Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "4fe4841b-b6e1-4ddc-8ced-b10ac08de8f0",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "`fromString` is already doing regex pattern matching. If you want to tighten it you should change `final val Pattern = \"\"\"hash\\((\\w+)\\)\"\"\".r` in object Hash to accept hex only.",
        "createdAt" : "2017-07-14T14:24:26Z",
        "updatedAt" : "2017-07-14T14:24:26Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "d37b22e2-8edc-4600-b0fc-c469fca75597",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "Good idea, validation is being done there. I'll fix it with that.",
        "createdAt" : "2017-07-14T14:30:36Z",
        "updatedAt" : "2017-07-14T14:30:36Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "5927c1cd-3f00-431a-9bf4-8b356513fcb5",
        "parentId" : "7913790e-8f2f-418f-91c7-1449ee136d89",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Yeah, good idea. I'll replace it with `\"\"\"hash\\(([0-9a-fA-F]+)\\).r\"\"\"`.",
        "createdAt" : "2017-07-14T14:41:03Z",
        "updatedAt" : "2017-07-14T14:41:03Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      }
    ],
    "commit" : "690b7a4336756812e8ed53470ee660c64f4f7880",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +60,64 @@\n/** Define the hash of the file contents. It's a typical stamp for compilation sources. */\nfinal class Hash private[inc] (val hexHash: String) extends StampBase {\n  // Assumes `hexHash` is a hexadecimal value.\n  override def writeStamp: String = s\"hash($hexHash)\""
  }
]
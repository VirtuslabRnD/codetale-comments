[
  {
    "id" : "3b5be17f-c200-458f-bbef-e5bbedc7b602",
    "prId" : 639,
    "prUrl" : "https://github.com/sbt/zinc/pull/639#pullrequestreview-214935551",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f9286a8e-c547-4437-afb9-1b0a1ee3fa90",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "We use mostly these names to be able to find the class file counterpart of a symbol. Could we add some tests that check the names of generated class files (by scalac) match what we derive from the analysis symbols? This should be JDK-independent.",
        "createdAt" : "2019-03-13T08:58:11Z",
        "updatedAt" : "2019-03-13T08:58:45Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "9589769d-dbe0-435c-a088-8f4c5d1dcbc0",
        "parentId" : "f9286a8e-c547-4437-afb9-1b0a1ee3fa90",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "As far as I can tell ClassToAPI is invoked only by `AnalyzingJavaCompiler`, so the scalac encoding of class names I don't think matters much to the accuracy of ClassToAPI. In that sense the whole ClassCanonicalNameSpec is not very relevant imo since it's exercising `Class[_]` -> canonical name capability based on Scala-generated classes, and not Java. WDYT?",
        "createdAt" : "2019-03-15T03:25:17Z",
        "updatedAt" : "2019-03-15T03:25:17Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "f782ae7d-a745-4363-aea0-be51cfbf9ee5",
        "parentId" : "f9286a8e-c547-4437-afb9-1b0a1ee3fa90",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "I think you make a good point, it's not necessary to do that, so we can just merge this PR and rebase the other one based on it. üëç ",
        "createdAt" : "2019-03-15T09:30:48Z",
        "updatedAt" : "2019-03-15T09:30:48Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      }
    ],
    "commit" : "ebac8aabb05a669cdceba996c876e614980fc084",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +29,33 @@\n      // c.getCanonicalName is JDK implementation specific\n      // assert(getNativeCanonicalName(c) === nativeCanonicalClassName)\n    }\n  }"
  },
  {
    "id" : "5542bc57-c555-4dbb-bbf4-4bd2d756ce74",
    "prId" : 380,
    "prUrl" : "https://github.com/sbt/zinc/pull/380#pullrequestreview-52859500",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1a910d7b-e88a-42fd-af42-3a71853ffcf6",
        "parentId" : null,
        "authorId" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "body" : "@jvican Do these canonical class names look right to you?\r\n\r\nLooking at the pattern across all the nestings, the ones that have a malformed class name look wrong to me.\r\n\r\nBasically I expect them all to be either \"x.y.z$\" or \"x.y.z\".\r\n\r\nWDYT?",
        "createdAt" : "2017-07-27T22:26:11Z",
        "updatedAt" : "2017-07-29T18:21:50Z",
        "lastEditedBy" : "b1c80b04-b64d-48bd-95ec-f1ce9c0f0774",
        "tags" : [
        ]
      },
      {
        "id" : "8d8db201-65b5-43d6-9d69-79e4ddac50d2",
        "parentId" : "1a910d7b-e88a-42fd-af42-3a71853ffcf6",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "I've answered this in #381.",
        "createdAt" : "2017-07-28T07:18:05Z",
        "updatedAt" : "2017-07-29T18:21:50Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      }
    ],
    "commit" : "2c7f2eb943440474a074332af138087d82cc30d8",
    "line" : 90,
    "diffHunk" : "@@ -1,1 +88,92 @@  object COC extends Expected(\"x.y$$z\", nativeClassNameIsMalformed = true)\n  object CCO extends Expected(\"x.y.z$\")\n  object CCC extends Expected(\"x.y.z\")\n\n  class Expected("
  }
]
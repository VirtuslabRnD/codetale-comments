[
  {
    "id" : "0338b910-f801-45af-b6c2-638d6e552853",
    "prId" : 37,
    "prUrl" : null,
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9a330c4d-ce9a-4886-8943-380eb79c2065",
        "parentId" : null,
        "authorId" : "fce79507-a821-4ed3-ae85-b5acf756c201",
        "body" : "Two `extra`s are considered equivalent if they have the same mapping for all keys that do not start with `info.`?\nSo the two following `extra`s are equivalent?\n\n``` scala\nval e1 = Array((\"info.foo\", \"foo\"))\nval e2 = Array((\"info.foo\", \"bar\"), (\"info.baz\", \"hello\"))\n```\n\nWhy?\n",
        "createdAt" : "2015-12-22T09:06:12Z",
        "updatedAt" : "2015-12-22T09:06:12Z",
        "lastEditedBy" : "fce79507-a821-4ed3-ae85-b5acf756c201",
        "tags" : [
        ]
      },
      {
        "id" : "c1faa422-09e1-482a-b65b-86ccee97df21",
        "parentId" : "9a330c4d-ce9a-4886-8943-380eb79c2065",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "When the metadata is not equivalent we will invalidate the previous compilation result, but there might be a situation where we would like to track some information without invalidating the previous.\n",
        "createdAt" : "2015-12-22T09:08:53Z",
        "updatedAt" : "2015-12-22T09:08:53Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      }
    ],
    "commit" : "3aa0da9a056f5b3a346ac40443b68bd4936e261c",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +34,38 @@      ((a.toList filter { x => !(x.get1 startsWith \"info.\") }) sameElements\n        (b.toList filter { x => !(x.get1 startsWith \"info.\") }))\n  }\n  implicit val equivFile: Equiv[File] = new Equiv[File] {\n    def equiv(a: File, b: File) = a.getAbsoluteFile == b.getAbsoluteFile"
  }
]
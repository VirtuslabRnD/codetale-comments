[
  {
    "id" : "d7c7688f-3dee-442b-ba77-9abe6b57332e",
    "prId" : 651,
    "prUrl" : "https://github.com/sbt/zinc/pull/651#pullrequestreview-224549471",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d6fb537-71d7-4c24-9674-822da02d11f3",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Why is `acme` and `ModuleSerializationProxy` an exception for Scala 2.13?",
        "createdAt" : "2019-04-09T10:25:34Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "3687b9e6-6528-4e4f-a041-39cf29e7fe6f",
        "parentId" : "4d6fb537-71d7-4c24-9674-822da02d11f3",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "acme was missing from the list of extracted names, and ModuleSerializationProxy showed up as an extracted name. We can open issue for these.",
        "createdAt" : "2019-04-09T17:26:50Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb4a53f6aaa55de39d6460219c62629ac5699e65",
    "line" : 28,
    "diffHunk" : "@@ -1,1 +36,40 @@    \"?0\",\n    \"package\",\n    \"acme\",\n    \"ModuleSerializationProxy\",\n    \"scala;runtime;ModuleSerializationProxy;init;\","
  },
  {
    "id" : "90a36e8a-05b7-4d67-88c2-47ad4c9ab66f",
    "prId" : 651,
    "prUrl" : "https://github.com/sbt/zinc/pull/651#pullrequestreview-224553088",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b502b04b-8f42-4811-9598-85c747b6ff0c",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Can we compile to 2.13.0-RC1 while not disabling all of these checks? The look material to making incremental compilation work correctly in 2.13.x.",
        "createdAt" : "2019-04-09T10:26:13Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "98c5234a-44c7-489e-bc1c-662c3d7dda95",
        "parentId" : "b502b04b-8f42-4811-9598-85c747b6ff0c",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "> The look material to making incremental compilation work correctly in 2.13.x.\r\n\r\nI agree it does look like a problem, and I am trying to surface that by running these tests against 2.13.0-RC1.\r\nThe status quo is that the tests are running against 2.13.0-M2 or M5 and people are using the bridge source anyways to run RC1.",
        "createdAt" : "2019-04-09T17:30:56Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "67de0135-45dd-4775-a2de-262a56c7321d",
        "parentId" : "b502b04b-8f42-4811-9598-85c747b6ff0c",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Can we look into it? I don't feel comfortable merging this PR with all these tests disabled for all compiler bridge versions and without a deep understanding of why these failures happen.",
        "createdAt" : "2019-04-09T17:34:06Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb4a53f6aaa55de39d6460219c62629ac5699e65",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +63,67 @@    // val expectedNamesForTuplerInstances = Set(\"E\", \"Tuple4\", \"e\", \"case7\", \"Tuple15\", \"s\", \"case19\", \"T7\", \"x\", \"TuplerInstances\", \"matchEnd19\", \"T20\", \"Tuple11\", \"HNil\", \"matchEnd6\", \"p16\", \"$anon\", \"T19\", \"p20\", \"T2\", \"p10\", \"case22\", \"p19\", \"n\", \"Tuple12\", \"case11\", \"Tuple22\", \"p12\", \"matchEnd7\", \"N\", \"p4\", \"T13\", \"case26\", \"Tuple19\", \"p7\", \"p5\", \"j\", \"Out\", \"T\", \"p23\", \"case15\", \"matchEnd20\", \"t\", \"p21\", \"matchEnd15\", \"J\", \"head\", \"case13\", \"u\", \"matchEnd18\", \"U\", \"Tupler\", \"f\", \"T8\", \"T16\", \"F\", \"Tuple3\", \"case8\", \"case18\", \"case24\", \"Boolean\", \"matchEnd21\", \"A\", \"matchEnd26\", \"a\", \"Tuple14\", \"T1\", \"::\", \"Nothing\", \"p18\", \"case20\", \"m\", \"matchEnd10\", \"M\", \"matchEnd25\", \"tail\", \"Tuple2\", \"matchEnd5\", \"p15\", \"matchEnd23\", \"I\", \"i\", \"matchEnd14\", \"AnyRef\", \"Tuple8\", \"matchEnd8\", \"case25\", \"T12\", \"p3\", \"case14\", \"case23\", \"T5\", \"matchEnd22\", \"T17\", \"v\", \"p22\", \"Tuple18\", \"G\", \"Tuple13\", \"matchEnd12\", \"scala;MatchError;init;\", \"acme;TuplerInstances;$anon;init;\", \"java;lang;Object;init;\", \"V\", \"q\", \"p11\", \"Q\", \"case12\", \"L\", \"b\", \"apply\", \"Object\", \"g\", \"B\", \"l\", \"==\", \"Out0\", \"Tuple1\", \"matchEnd9\", \"P\", \"p2\", \"T15\", \"Aux\", \"matchEnd24\", \"p\", \"scala\", \"matchEnd11\", \"Tuple20\", \"HList\", \"case17\", \"T9\", \"p14\", \"Tuple7\", \"matchEnd17\", \"T4\", \"case28\", \"T22\", \"p17\", \"C\", \"Tuple6\", \"MatchError\", \"T11\", \"x1\", \"H\", \"case16\", \"matchEnd13\", \"c\", \"Tuple9\", \"h\", \"T6\", \"T18\", \"r\", \"K\", \"Tuple17\", \"p9\", \"R\", \"ne\", \"T14\", \"case21\", \"k\", \"case10\", \"Tuple21\", \"O\", \"case9\", \"Tuple10\", \"Any\", \"T10\", \"case27\", \"Tuple5\", \"D\", \"p13\", \"o\", \"p6\", \"p8\", \"matchEnd16\", \"S\", \"T21\", \"Tuple16\", \"d\", \"T3\")\n    val expectedNamesForRefinement = Set(\"Out0\")\n    // val `expectedNamesFor::` = Set(\"x\", \"T2\", \"ScalaRunTime\", \"Iterator\", \"T\", \"head\", \"asInstanceOf\", \"Boolean\", \"A\", \"$\" + \"isInstanceOf\", \"T1\", \"||\", \"acme;::;init;\", \"::\", \"Nothing\", \"x$1\", \"any2stringadd\", \"acme\", \"typedProductIterator\", \"tail\", \"Tuple2\", \"AnyRef\", \"isInstanceOf\", \"Int\", \"java;lang;Object;init;\", \"_hashCode\", \"apply\", \"Object\", \"x$0\", \"==\", \"Some\", \"IndexOutOfBoundsException\", \"java;lang;IndexOutOfBoundsException;init;\", \"T0\", \"Predef\", \"scala\", \"matchEnd4\", \"HList\", \"None\", \"x1\", \"toString\", \"H\", \"+\", \"&&\", \"Serializable\", \"Product\", \"case6\", \"::$1\", \"eq\", \"Any\", \"runtime\", \"String\")\n    val expectedNamesForDepFn1 = Set(\"DepFn1\", \"Out\", \"T\", \"AnyRef\", \"Object\", \"scala\")\n    // val expectedNamesForHNil = Set(\"x\", \"HNil\", \"ScalaRunTime\", \"Iterator\", \"Boolean\", \"A\", \"T\", \"$\" + \"isInstanceOf\", \"::\", \"Nothing\", \"x$1\", \"acme\", \"typedProductIterator\", \"Int\", \"java;lang;Object;init;\", \"apply\", \"Object\", \"IndexOutOfBoundsException\", \"java;lang;IndexOutOfBoundsException;init;\", \"scala\", \"HList\", \"toString\", \"H\", \"Serializable\", \"h\", \"Product\", \"Any\", \"runtime\", \"matchEnd3\", \"String\", \"T0\")"
  },
  {
    "id" : "822a9248-6085-4272-8207-2502f01df679",
    "prId" : 651,
    "prUrl" : "https://github.com/sbt/zinc/pull/651#pullrequestreview-224841295",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7bc0343-571b-4562-b720-80d5da011566",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Not tracking this name in Scala 2.13 will give incremental compiler errors when initializers are involved",
        "createdAt" : "2019-04-10T08:58:43Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb4a53f6aaa55de39d6460219c62629ac5699e65",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +38,42 @@    \"acme\",\n    \"ModuleSerializationProxy\",\n    \"scala;runtime;ModuleSerializationProxy;init;\",\n    \"Class\",\n    \"Sealed\""
  },
  {
    "id" : "041ad720-2dda-4996-b2d4-9a4d4c3fb11f",
    "prId" : 651,
    "prUrl" : "https://github.com/sbt/zinc/pull/651#pullrequestreview-224877842",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "675aa241-83a4-425f-b928-a9bc17c9c451",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "This is most likely the reason why we don't track incrementality for sealed class hierarchies anymore in Scala 2.13. Not as severe correctness-wise as the other error, but still worth fixing...",
        "createdAt" : "2019-04-10T08:59:47Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "30bfdf50-aefa-4879-b149-f5bf9fab528f",
        "parentId" : "675aa241-83a4-425f-b928-a9bc17c9c451",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "The capitalized Class and Sealed are new named that started to show up in 2.13, but didn't exist before.\r\nWe probably should filter it out so it doesn't lead to overcompilation.",
        "createdAt" : "2019-04-10T10:11:33Z",
        "updatedAt" : "2019-04-18T21:31:38Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      }
    ],
    "commit" : "bb4a53f6aaa55de39d6460219c62629ac5699e65",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +40,44 @@    \"scala;runtime;ModuleSerializationProxy;init;\",\n    \"Class\",\n    \"Sealed\"\n  )\n  def diffAndSort(xs: Set[String]): List[String] = (xs -- scalaDiff).toList.sorted"
  }
]
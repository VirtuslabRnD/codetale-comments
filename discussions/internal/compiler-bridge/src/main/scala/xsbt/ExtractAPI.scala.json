[
  {
    "id" : "cd7e4b40-db6d-48a0-a690-14b6cd3a7e82",
    "prId" : 969,
    "prUrl" : "https://github.com/sbt/zinc/pull/969#pullrequestreview-619254857",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7ce224d-8720-4837-81d6-16bd5637d2ba",
        "parentId" : null,
        "authorId" : "6f938ccf-9240-4d03-badc-3b4107983b16",
        "body" : "Hash it! Or at least that's what I do: https://github.com/lampepfl/dotty/blob/d4f1c261f808b185f91bb3e6f3efebd25c39646f/compiler/src/dotty/tools/dotc/sbt/ExtractAPI.scala#L619-L695 :)",
        "createdAt" : "2021-03-23T23:35:33Z",
        "updatedAt" : "2021-03-23T23:40:38Z",
        "lastEditedBy" : "6f938ccf-9240-4d03-badc-3b4107983b16",
        "tags" : [
        ]
      },
      {
        "id" : "99da387f-81a6-4d6b-9f4b-6319305cee1d",
        "parentId" : "c7ce224d-8720-4837-81d6-16bd5637d2ba",
        "authorId" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "body" : "Nice. It would be preferable for the compiler directly hash much more than it already does, but as you point out the test discovery feature would still need to find annotated members.",
        "createdAt" : "2021-03-24T02:24:41Z",
        "updatedAt" : "2021-03-24T02:24:41Z",
        "lastEditedBy" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "tags" : [
        ]
      }
    ],
    "commit" : "4bbbd5d67a0d4fcce17ff3e68d501a13ab32f7d2",
    "line" : 51,
    "diffHunk" : "@@ -1,1 +255,259 @@                  xsbti.api.AnnotationArgument\n                    .of(\"\", ReusableTreePrinter.mkString(a.args, \"(\", \",\", \")\"))\n                ) // what else to do with a Tree?\n              else\n                a.assocs"
  },
  {
    "id" : "e0830ac0-df87-4f6f-9ea0-d2b1d5afdcd2",
    "prId" : 492,
    "prUrl" : "https://github.com/sbt/zinc/pull/492#pullrequestreview-100325409",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "567ea571-8768-46c1-987f-19ecbdffae63",
        "parentId" : null,
        "authorId" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "body" : "This change needs the most careful review. We should probably build a version that has the old and new implementations in place that asserts they agree.",
        "createdAt" : "2018-02-22T07:55:16Z",
        "updatedAt" : "2018-03-01T05:46:17Z",
        "lastEditedBy" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "tags" : [
        ]
      },
      {
        "id" : "10fe16dc-6529-4ee8-844f-ba9d6f4e5f9c",
        "parentId" : "567ea571-8768-46c1-987f-19ecbdffae63",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Looks correct under the assumption that the compiler does not synthesize setters if there are no getters. We have a biggish community build in bloop (https://github.com/scalacenter/bloop/tree/master/build-integrations), I can try out the optimized Zinc version when this PR is ready and we assert that we don't break incremental compilation for existing projects. Unfortunately, these tests will need to be manual since there's no automated infrastructure for it aside from the scripted tests we have.",
        "createdAt" : "2018-02-22T10:20:51Z",
        "updatedAt" : "2018-03-01T05:46:17Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "15b79d0c-c45a-4469-b3ea-37f3d2effd38",
        "parentId" : "567ea571-8768-46c1-987f-19ecbdffae63",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "Is it possible to write out common cases as tests in https://github.com/sbt/zinc/blob/1.1.x/internal/compiler-bridge-test/src/test/scala/xsbt/ExtractAPISpecification.scala?",
        "createdAt" : "2018-03-01T06:11:30Z",
        "updatedAt" : "2018-03-01T06:11:31Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a9441843a8d00bf62bebb10245a2ce526f03c60",
    "line" : 119,
    "diffHunk" : "@@ -1,1 +237,241 @@      //  a) they are recorded as normal source methods anyway\n      //  b) there is no way to distinguish them from user-defined methods\n      if (b.hasGetter) {\n        val annotations = collection.mutable.LinkedHashSet[xsbti.api.Annotation]()\n        def add(sym: Symbol) = {"
  },
  {
    "id" : "6f1693cd-2398-4592-9eee-f704367b7c17",
    "prId" : 492,
    "prUrl" : "https://github.com/sbt/zinc/pull/492#pullrequestreview-98472748",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5ca11ac8-2e1f-4920-baf2-55cc511c6ac7",
        "parentId" : null,
        "authorId" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "body" : "The motivation for using Java maps was to avoid the cost of generalized equality and hashing. Usually I'd reach for an `AnyRefMap`, but AFAICT this code needs to cross compile to Scala 2.10, so it was easier to just use a Java Map.",
        "createdAt" : "2018-02-22T07:56:43Z",
        "updatedAt" : "2018-03-01T05:46:17Z",
        "lastEditedBy" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a9441843a8d00bf62bebb10245a2ce526f03c60",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +68,72 @@  private[this] val typeCache = new java.util.HashMap[(Symbol, Type), xsbti.api.Type]()\n  // these caches are necessary for correctness\n  private[this] val structureCache = new java.util.HashMap[Symbol, xsbti.api.Structure]()\n  private[this] val classLikeCache =\n    new java.util.HashMap[(Symbol, Symbol), xsbti.api.ClassLikeDef]()"
  },
  {
    "id" : "8a7d57b3-91de-4bf4-9b7a-de9f92974f57",
    "prId" : 492,
    "prUrl" : "https://github.com/sbt/zinc/pull/492#pullrequestreview-100626973",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cf1b6dab-3629-48e0-b468-7b5a945b71ba",
        "parentId" : null,
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "Is time-travelling with Scalac's API generally inefficient or impedes inlining? I see that you're inlining the body manually here.",
        "createdAt" : "2018-02-22T10:24:09Z",
        "updatedAt" : "2018-03-01T05:46:17Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "4f981e5d-24ab-4fcf-9b38-8e39024a09bc",
        "parentId" : "cf1b6dab-3629-48e0-b468-7b5a945b71ba",
        "authorId" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "body" : "Does the on-the-fly compilation of the compiler interface enable the\r\noptimiser? If not, hand inlining here is helpful.",
        "createdAt" : "2018-03-01T05:30:45Z",
        "updatedAt" : "2018-03-01T05:46:17Z",
        "lastEditedBy" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "tags" : [
        ]
      },
      {
        "id" : "c5fff4e8-33d1-4392-81a9-94d86597bf47",
        "parentId" : "cf1b6dab-3629-48e0-b468-7b5a945b71ba",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "https://github.com/sbt/zinc/blob/v1.1.1/internal/zinc-compile-core/src/main/scala/sbt/internal/inc/AnalyzingCompiler.scala#L350:\r\n\r\n```scala\r\n          compiler(sourceFiles, classpath, outputDirectory, \"-nowarn\" :: Nil)\r\n```\r\n\r\nIt seems like we just pass in `\"-nowarn\"`.\r\n",
        "createdAt" : "2018-03-01T05:53:51Z",
        "updatedAt" : "2018-03-01T05:53:51Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "3dad3399-48bc-4b08-80a0-5f8985348f19",
        "parentId" : "cf1b6dab-3629-48e0-b468-7b5a945b71ba",
        "authorId" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "body" : "It would be interesting to add the optimiser flags in here and benchmark the bridge, WDYT?",
        "createdAt" : "2018-03-01T09:45:05Z",
        "updatedAt" : "2018-03-01T09:45:15Z",
        "lastEditedBy" : "ee674eea-a8c8-4bb7-aef2-04e7f846d57d",
        "tags" : [
        ]
      },
      {
        "id" : "acd23233-7e0d-4ff1-8e43-ba4b47a1483e",
        "parentId" : "cf1b6dab-3629-48e0-b468-7b5a945b71ba",
        "authorId" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "body" : "I think it makes sense, especially if we can observe some effect. Is there a safe flag that would work for all Scala versions, or do we have to optimize the list of optimize flag per Scala versions?",
        "createdAt" : "2018-03-01T19:29:16Z",
        "updatedAt" : "2018-03-01T19:29:16Z",
        "lastEditedBy" : "25a8667a-469c-4af9-ae50-c45d69e5c60d",
        "tags" : [
        ]
      },
      {
        "id" : "3572ff35-7c7e-4cbf-a5b2-e7274ccdd3a7",
        "parentId" : "cf1b6dab-3629-48e0-b468-7b5a945b71ba",
        "authorId" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "body" : "The compiler options and bugs are version dependent. I would be inclined to leave it off, at least by default. Exposing these options as config might be useful for experimentation.",
        "createdAt" : "2018-03-01T23:03:01Z",
        "updatedAt" : "2018-03-01T23:03:01Z",
        "lastEditedBy" : "c7d4bff9-85e5-49d0-85e4-79743bd27861",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a9441843a8d00bf62bebb10245a2ce526f03c60",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +230,234 @@  private def annotations(in: Symbol, s: Symbol): Array[xsbti.api.Annotation] = {\n    val saved = phase\n    phase = currentRun.typerPhase\n    try {\n      val base = if (s.hasFlag(Flags.ACCESSOR)) s.accessed else NoSymbol"
  }
]
[
  {
    "id" : "ed20d5aa-9d93-456b-8a6f-c62323924155",
    "prId" : 4727,
    "prUrl" : "https://github.com/RocketChat/Rocket.Chat/pull/4727#pullrequestreview-5758626",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ae424838-801b-4ed4-aeec-60584ef624a2",
        "parentId" : null,
        "authorId" : "63d23e28-e025-4b10-afb9-98765a45a3c3",
        "body" : "@rodrigok - This makes me super nervous.  This is kind of ambiguous and assumes every server has an ip address which is somewhat true.  When you think about the number of people that run meteor in docker in something like kubernetes, it would mean judging this statement on port, not physical ip.  you are also locking at INSTANCE_IP vs 'localhost'.  That is a bad check since localhost is actually 127.0.0.1 as an IP, but that is not always true as well.\n",
        "createdAt" : "2016-10-25T21:34:23Z",
        "updatedAt" : "2016-10-25T21:44:48Z",
        "lastEditedBy" : "63d23e28-e025-4b10-afb9-98765a45a3c3",
        "tags" : [
        ]
      },
      {
        "id" : "e8a75a9e-fbae-4b64-a4d8-50819d1c2632",
        "parentId" : "ae424838-801b-4ed4-aeec-60584ef624a2",
        "authorId" : "6b2de464-07b6-478f-bdd0-b8707d59c1c1",
        "body" : "@leefaus That is the old behavior, and it already exists, but now we have the StreamCast project, one instance running only to receive connections from RC instances and broadcast messages.\n",
        "createdAt" : "2016-10-25T22:00:48Z",
        "updatedAt" : "2016-10-25T22:00:48Z",
        "lastEditedBy" : "6b2de464-07b6-478f-bdd0-b8707d59c1c1",
        "tags" : [
        ]
      },
      {
        "id" : "83119d3d-22a7-41ed-9ee5-34dbf288a57b",
        "parentId" : "ae424838-801b-4ed4-aeec-60584ef624a2",
        "authorId" : "12a7c8fe-552e-47fc-8088-d69d0d19367f",
        "body" : "What happens when that server goes down?  Do you still have a single point of failure?\n",
        "createdAt" : "2016-10-25T22:06:26Z",
        "updatedAt" : "2016-10-25T22:06:27Z",
        "lastEditedBy" : "12a7c8fe-552e-47fc-8088-d69d0d19367f",
        "tags" : [
        ]
      },
      {
        "id" : "31946e71-7796-485b-bf73-71647c875c08",
        "parentId" : "ae424838-801b-4ed4-aeec-60584ef624a2",
        "authorId" : "6b2de464-07b6-478f-bdd0-b8707d59c1c1",
        "body" : "@continuouslee Yes, but that will not stop RC, you will need to refresh the page to see new messages.\n",
        "createdAt" : "2016-10-25T22:24:08Z",
        "updatedAt" : "2016-10-25T22:24:08Z",
        "lastEditedBy" : "6b2de464-07b6-478f-bdd0-b8707d59c1c1",
        "tags" : [
        ]
      },
      {
        "id" : "1a769ea1-ef40-47ba-8fed-27b41fd61501",
        "parentId" : "ae424838-801b-4ed4-aeec-60584ef624a2",
        "authorId" : "12a7c8fe-552e-47fc-8088-d69d0d19367f",
        "body" : "Have you tested that assumption?  If there is a single write node and that write node goes down, who else is able to write?  Is there an election done between nodes to make sure there is always one write node?  I feel like we are re-inventing the wheel here.  There are lots of products, open source projects that have already solved this problem.  Why not plug something like RabbitMQ or Redis into the mix.\n",
        "createdAt" : "2016-10-25T22:39:53Z",
        "updatedAt" : "2016-10-25T22:39:53Z",
        "lastEditedBy" : "12a7c8fe-552e-47fc-8088-d69d0d19367f",
        "tags" : [
        ]
      }
    ],
    "commit" : "4a46097e29fdd677de0c3f5bd546a1d2af08a7cc",
    "line" : 103,
    "diffHunk" : "@@ -1,1 +121,125 @@@connections = {}\n@startStreamBroadcast = () ->\n\tprocess.env.INSTANCE_IP ?= 'localhost'\n\n\tlogger.info 'startStreamBroadcast'"
  }
]
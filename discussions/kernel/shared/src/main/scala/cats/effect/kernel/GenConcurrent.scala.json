[
  {
    "id" : "8d224c36-d222-4729-a1b7-91f1da9034e0",
    "prId" : 1829,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1829#pullrequestreview-622773348",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "245f3195-7ead-427f-be18-97918b28f2a4",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "So much faster-er and lighter-weight-er-er.",
        "createdAt" : "2021-03-28T19:01:46Z",
        "updatedAt" : "2021-03-28T22:46:51Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "3931d86bcecf000100431bb9cae034eff0ac0a9d",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +123,127 @@        case Left(oc) => Left((oc, fibB))\n        case Right(oc) => Right((fibA, oc))\n      }\n    }\n  }"
  },
  {
    "id" : "4cf8e19f-46ff-42f9-a26d-48ed52ff2bb7",
    "prId" : 1552,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1552#pullrequestreview-559320505",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d0eb37ce-5cf7-4fad-a3b5-9490e8d4ae9d",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "Is this still true ? If we're caching the `Outcome`, when the first fetch is cancelled, it would just write in `Canceled`",
        "createdAt" : "2020-12-28T21:11:47Z",
        "updatedAt" : "2021-01-06T15:30:45Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "94a42004-893d-4874-b6ee-9be1233a1580",
        "parentId" : "d0eb37ce-5cf7-4fad-a3b5-9490e8d4ae9d",
        "authorId" : "3f1176f1-791a-4566-8749-308589834168",
        "body" : "My intent was to distinguish between the outcome of `fa` being `Canceled` and all the fetches being canceled. Where the former would cache `Canceled` and the latter would re-evaluate `fa` on the next fetch. However, given the interleaving you described above, this isn't always possible (without additional state).",
        "createdAt" : "2020-12-28T22:19:56Z",
        "updatedAt" : "2021-01-06T15:30:45Z",
        "lastEditedBy" : "3f1176f1-791a-4566-8749-308589834168",
        "tags" : [
        ]
      }
    ],
    "commit" : "000758b0b5e1ae12161845dc472bf148459ca237",
    "line" : 11,
    "diffHunk" : "@@ -1,1 +39,43 @@   * `fa` will only be evaluated once.\n   *\n   * If all `get`s are canceled prior to `fa` completing, it will be canceled\n   * and evaluated again the next time `get` is sequenced.\n   */"
  },
  {
    "id" : "a6a1d6fe-7acf-4968-9c1b-598c75270f56",
    "prId" : 1458,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1458#pullrequestreview-540383952",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7f21e2a0-1e2a-4de1-81d1-c4721a83bdb7",
        "parentId" : null,
        "authorId" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "body" : "The order in which tasks start is predetermined (effectively) before any of the tasks execute, as dictated by the order in which they claim a spot in the underlying queue, correct? ",
        "createdAt" : "2020-11-28T04:55:24Z",
        "updatedAt" : "2020-11-28T04:55:24Z",
        "lastEditedBy" : "3b5d55eb-40d5-4d14-a8a4-3ed1601b5bff",
        "tags" : [
        ]
      },
      {
        "id" : "34cbb0a8-12ad-4310-ac44-80e19b23a949",
        "parentId" : "7f21e2a0-1e2a-4de1-81d1-c4721a83bdb7",
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "Inside the semaphore, yeah",
        "createdAt" : "2020-11-28T15:58:22Z",
        "updatedAt" : "2020-11-28T15:58:23Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "7117092d67189f3cb03ed2cc195dbdc7bd0dbc0e",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +93,97 @@   * Note that the semantics of this operation aim to maximise\n   * fairness: when a spot to execute becomes available, every task\n   * has a chance to claim it, and not only the next `n` tasks in `ta`\n   */\n  def parTraverseN[T[_]: Traverse, A, B](n: Int)(ta: T[A])(f: A => F[B]): F[T[B]] = {"
  },
  {
    "id" : "b428b997-8325-4b87-8880-2810c490b341",
    "prId" : 1204,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/1204#pullrequestreview-491213259",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c40a0bd0-500a-41ca-8ac3-45937fab0226",
        "parentId" : null,
        "authorId" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "body" : "Things are so much easier now that we can do this :)",
        "createdAt" : "2020-09-18T07:26:13Z",
        "updatedAt" : "2020-09-19T05:45:56Z",
        "lastEditedBy" : "a5a514ff-cd89-45cb-bcc8-796f0fa2a445",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a8532c6ddc8fcf5e96d80d649ee6f0e5d6d30ac",
    "line" : 55,
    "diffHunk" : "@@ -1,1 +69,73 @@              case Start() => {\n                val start = fetch.start.flatMap(fiber => stop.complete(fiber.cancel))\n                Running(1, value, stop) -> start *> poll(value.get).onCancel(removeSubscriber)\n              }\n              case Running(subs, value, stop) =>"
  }
]
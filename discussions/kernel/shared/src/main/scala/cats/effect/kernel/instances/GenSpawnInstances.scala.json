[
  {
    "id" : "e27e090d-69e7-43a2-b0f8-a4c654bef50a",
    "prId" : 2159,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/2159#pullrequestreview-719384206",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "041a9dd3-349a-4d3c-9324-b044d00a0b61",
        "parentId" : null,
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "Is this type annotation `[A]` (and later `[Z]`) really necessary?",
        "createdAt" : "2021-07-30T18:49:17Z",
        "updatedAt" : "2021-07-30T18:56:38Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      },
      {
        "id" : "2bff7047-7176-48b9-9fef-1c13422fa71b",
        "parentId" : "041a9dd3-349a-4d3c-9324-b044d00a0b61",
        "authorId" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "body" : "It is necessary.",
        "createdAt" : "2021-07-30T19:00:26Z",
        "updatedAt" : "2021-07-30T19:00:26Z",
        "lastEditedBy" : "566d094c-978a-46cc-94f5-bc87e03c9fd3",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b19b6ba3e5f1136a760f32383496cc6b19559a9",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +61,65 @@              a <- F\n                .onCancel(poll(fiberA.join), F.both(fiberA.cancel, fiberB.cancel).void)\n                .flatMap[A] {\n                  case Outcome.Succeeded(fa) => fa\n                  case Outcome.Errored(e) => fiberB.cancel *> F.raiseError(e)"
  },
  {
    "id" : "b558e4ba-0220-4bec-a177-8af6ccbc62e0",
    "prId" : 2159,
    "prUrl" : "https://github.com/typelevel/cats-effect/pull/2159#pullrequestreview-719537939",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "42804816-b3b5-4a4d-ac4c-5e87dbc730e7",
        "parentId" : null,
        "authorId" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "body" : "this code is exactly the same as below, except for the `Eval` wrapping, no?\r\n\r\nWhy not have one private method that returns `Now[ParallelF[F, Z]]` and in the map2 case pass `fa, Now(fb)`? I think the extra now wrap unwrap is likely trivial.",
        "createdAt" : "2021-07-30T23:24:57Z",
        "updatedAt" : "2021-07-30T23:24:58Z",
        "lastEditedBy" : "b93e2985-c394-41e6-a036-b46320cfbf21",
        "tags" : [
        ]
      },
      {
        "id" : "053a49e8-ee8c-424a-b8d8-9ad77c0438a7",
        "parentId" : "42804816-b3b5-4a4d-ac4c-5e87dbc730e7",
        "authorId" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "body" : "> I think the extra now wrap unwrap is likely trivial.\r\n\r\nThe unwrap is pretty trivial but the allocation isâ€¦ less so. Particularly since you pay that penalty on a per-item basis.",
        "createdAt" : "2021-07-31T02:42:25Z",
        "updatedAt" : "2021-07-31T02:42:25Z",
        "lastEditedBy" : "5b44dcf3-8819-42b0-9a49-4cdbf5a8a305",
        "tags" : [
        ]
      }
    ],
    "commit" : "8b19b6ba3e5f1136a760f32383496cc6b19559a9",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +51,55 @@      final override def pure[A](a: A): ParallelF[F, A] = ParallelF(F.pure(a))\n\n      final override def map2[A, B, Z](fa: ParallelF[F, A], fb: ParallelF[F, B])(\n          f: (A, B) => Z): ParallelF[F, Z] =\n        ParallelF("
  }
]
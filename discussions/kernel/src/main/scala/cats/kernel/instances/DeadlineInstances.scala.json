[
  {
    "id" : "842817e7-c944-4888-a1a9-d747e1bcdb05",
    "prId" : 3937,
    "prUrl" : "https://github.com/typelevel/cats/pull/3937#pullrequestreview-708964960",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "parentId" : null,
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "I think a BoundedSemilattice may also make sense here (on max?) or maybe it is unclear so we should let users make their own.",
        "createdAt" : "2021-07-15T17:02:12Z",
        "updatedAt" : "2021-07-15T17:02:12Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "9a44abc3-c42c-418c-9180-51f96272e3a9",
        "parentId" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "authorId" : "26257fb5-fa93-454c-abec-1d576d02f22e",
        "body" : "It definitely is unclear to me how to implement that. So I'd appreciate either an approval or some help.",
        "createdAt" : "2021-07-15T17:32:56Z",
        "updatedAt" : "2021-07-15T17:32:56Z",
        "lastEditedBy" : "26257fb5-fa93-454c-abec-1d576d02f22e",
        "tags" : [
        ]
      },
      {
        "id" : "e3419efa-d13e-47db-b1b7-0a2414768dd0",
        "parentId" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "The `BoundedSemilattice` is a `Monoid`, so you'd need to define `empty` and `combine`.  You also inherit these typeclasses, and therefore laws:\r\n\r\n* a `CommutativeSemigroup`: `combine(x, y) === combine(y, x)`\r\n* a `Band`: `combine(x, x) == x`\r\n\r\nIf you combine two deadlines, would you want the result to be the earlier deadline (`min`) or the later (`max`)?  I can imagine both, so I'm a bit skeptical of the instance.\r\n\r\nAnd what should `empty` be?  `Deadline.now` is tempting, but changes on each call.  I suppose we'd use `minBound` if we combined with `max`, and `maxBound` if we combined with `min`.  Or we could escape this question by being a `Semilattice` instead of a `BoundedSemilattice`.\r\n\r\nI think if someone can make a persuasive case for min or max being the canonical instance, we could handle this in a separate PR.",
        "createdAt" : "2021-07-16T03:33:46Z",
        "updatedAt" : "2021-07-16T03:37:55Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      },
      {
        "id" : "a1e15b96-bc51-431d-aae5-cecb61728b4c",
        "parentId" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "empty would be either the minimum or maximum value depending on which BoundedSemilattice you pick. `now` would not be lawful.",
        "createdAt" : "2021-07-16T04:52:00Z",
        "updatedAt" : "2021-07-16T04:52:00Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "781c578a-5521-4e32-a2a0-7c684a8eb897",
        "parentId" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "authorId" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "body" : "Note: we already have a constructor function for picking a max or min semilattice if you give the corresponding empty value. I agree it isn't clear if you want min or max here.\n\nProbably some applications would want one and others the other.",
        "createdAt" : "2021-07-16T04:53:30Z",
        "updatedAt" : "2021-07-16T04:53:30Z",
        "lastEditedBy" : "64725de8-1e61-4b2f-a436-5cc06313d237",
        "tags" : [
        ]
      },
      {
        "id" : "169ca0fe-813f-49e6-8706-2a2dd268c7f4",
        "parentId" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "authorId" : "26257fb5-fa93-454c-abec-1d576d02f22e",
        "body" : "If it is dependent on the application, I would refrain from implementing it here and merging this PR.\r\nLater one could implement the `Semilattice` in a follow-up PR anyways.",
        "createdAt" : "2021-07-16T06:52:45Z",
        "updatedAt" : "2021-07-16T06:52:45Z",
        "lastEditedBy" : "26257fb5-fa93-454c-abec-1d576d02f22e",
        "tags" : [
        ]
      },
      {
        "id" : "3831358d-114b-4a70-a7d0-59dc7c4eb4d0",
        "parentId" : "73616231-6e96-4c9a-ba69-36fb21970a97",
        "authorId" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "body" : "I'm pretty well convinced the `empty` follows from `combine` and any eventual instance should be monoidal.  But there's no obvious canonical instance, and no reason to block this waiting for one.  Let's get a second approval and get this shipped.",
        "createdAt" : "2021-07-17T19:34:36Z",
        "updatedAt" : "2021-07-17T19:34:36Z",
        "lastEditedBy" : "2ed5d687-cc94-4d72-ba74-717be38944e9",
        "tags" : [
        ]
      }
    ],
    "commit" : "6edd687d1163e4b57e1e7688a492538eae3b8486",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +15,19 @@}\n\nclass DeadlineOrder extends Order[Deadline] with Hash[Deadline] with DeadlineBounded { self =>\n\n  def hash(x: Deadline): Int = x.hashCode()"
  }
]
[
  {
    "id" : "9183986d-2f61-449f-9f26-160738984def",
    "prId" : 377,
    "prUrl" : "https://github.com/resilience4j/resilience4j/pull/377#pullrequestreview-233478196",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d7fc0ea6-e9f8-4e5b-a19e-0827593972ac",
        "parentId" : null,
        "authorId" : "dbb24844-d7bc-47b7-a5ba-c189ef4c9f95",
        "body" : "may I ask why ConcurrentReferenceHashMap ? FYI it is not 100% thread safe as i remember !",
        "createdAt" : "2019-05-02T16:02:30Z",
        "updatedAt" : "2019-05-03T13:34:31Z",
        "lastEditedBy" : "dbb24844-d7bc-47b7-a5ba-c189ef4c9f95",
        "tags" : [
        ]
      },
      {
        "id" : "5a68eb34-50cf-447c-a07d-180ae33ffae0",
        "parentId" : "d7fc0ea6-e9f8-4e5b-a19e-0827593972ac",
        "authorId" : "8a74cba0-cafa-4278-a23b-e54648ece3ed",
        "body" : "I found `ConcurrentReferenceHashMap` is used as a cache in [org.springframework.util.ReflectionUtils](\r\nhttps://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/ReflectionUtils.java). And I thought cached values could be removed if there is no memory space, so I chose `SoftReference`. Since there is no such warning in the document, I didn't know `ConcurrentReferenceHashMap ` is not 100% thread-safe. But should it be a thread-safe guaranteed? Recovery methods are not changing in run-time.\r\n",
        "createdAt" : "2019-05-03T13:47:28Z",
        "updatedAt" : "2019-05-03T13:47:28Z",
        "lastEditedBy" : "8a74cba0-cafa-4278-a23b-e54648ece3ed",
        "tags" : [
        ]
      }
    ],
    "commit" : "5622a6c39654b548b4b7753b97e5b73323ed386b",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +41,45 @@ */\npublic class RecoveryMethod {\n    private static final Map<MethodMeta, Map<Class<?>, Method>> RECOVERY_METHODS_CACHE = new ConcurrentReferenceHashMap<>();\n    private final Map<Class<?>, Method> recoveryMethods;\n    private final Object[] args;"
  }
]
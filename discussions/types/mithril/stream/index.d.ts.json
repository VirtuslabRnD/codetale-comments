[
  {
    "id" : "d69e989f-160f-4f85-afae-29b2303a4d2a",
    "prId" : 37118,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/37118#pullrequestreview-267974866",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c6b76a16-2ede-4cfc-92c8-d19697645309",
        "parentId" : null,
        "authorId" : "b0995fe3-2324-4ecd-9828-cc6e6d2cfb5c",
        "body" : "Have you considered using indexed + tuple types here? They [patched it](https://github.com/Microsoft/TypeScript/pull/26063) to more helpfully return arrays for array input, and it could help make this much better typed.\r\n\r\n```suggestion\r\n\texport function combine<S extends any[], T>(combiner: (...streams: S) => T, streams: {[I in keyof S]: Stream<S[I]>}): Stream<T>;\r\n```\r\n\r\n(This is a breaking change from the previous `combine`, but it's v2 after all. ðŸ˜‰)",
        "createdAt" : "2019-07-27T19:55:48Z",
        "updatedAt" : "2019-07-29T02:52:33Z",
        "lastEditedBy" : "b0995fe3-2324-4ecd-9828-cc6e6d2cfb5c",
        "tags" : [
        ]
      },
      {
        "id" : "960f9ba3-a673-451c-b312-3829557cd042",
        "parentId" : "c6b76a16-2ede-4cfc-92c8-d19697645309",
        "authorId" : "0273d59b-ca99-4ec6-8b51-7d9c95bae853",
        "body" : "Okay. We'll need to bump the compiler version for this. But I guess that's fine being Mithril V2.",
        "createdAt" : "2019-07-27T20:51:44Z",
        "updatedAt" : "2019-07-29T02:52:33Z",
        "lastEditedBy" : "0273d59b-ca99-4ec6-8b51-7d9c95bae853",
        "tags" : [
        ]
      },
      {
        "id" : "13d79ba5-89cf-4c27-8be0-79f59453b11d",
        "parentId" : "c6b76a16-2ede-4cfc-92c8-d19697645309",
        "authorId" : "0273d59b-ca99-4ec6-8b51-7d9c95bae853",
        "body" : "I think I'll need some help with this one. With your signature, the combiner callback `streams` arguments types are unwrapped values, but they should be streams.",
        "createdAt" : "2019-07-28T18:34:17Z",
        "updatedAt" : "2019-07-29T02:52:33Z",
        "lastEditedBy" : "0273d59b-ca99-4ec6-8b51-7d9c95bae853",
        "tags" : [
        ]
      },
      {
        "id" : "46be3bad-dcc3-4da8-a10c-660db1dafd0f",
        "parentId" : "c6b76a16-2ede-4cfc-92c8-d19697645309",
        "authorId" : "0273d59b-ca99-4ec6-8b51-7d9c95bae853",
        "body" : "The following signature works, however it's wrong:\r\n```ts\r\nexport function combine<S extends Stream<any>[], T>(combiner: (...streams: S) => T, streams: {[I in keyof S]: S[I]}): Stream<T>;\r\n```\r\nThe final parameter for the combiner (`...streams`) is missing - it should be a `changed` stream. I don't see a way to write that.",
        "createdAt" : "2019-07-29T02:11:28Z",
        "updatedAt" : "2019-07-29T02:52:33Z",
        "lastEditedBy" : "0273d59b-ca99-4ec6-8b51-7d9c95bae853",
        "tags" : [
        ]
      },
      {
        "id" : "2c47bf01-d762-4c7c-8d76-b8b3d27264fa",
        "parentId" : "c6b76a16-2ede-4cfc-92c8-d19697645309",
        "authorId" : "b0995fe3-2324-4ecd-9828-cc6e6d2cfb5c",
        "body" : "I'm okay with keeping the current type for now, then, until https://github.com/microsoft/TypeScript/issues/1360 gets fixed. I *could* write a valid type that correctly types the parameters here, but the error message if you mismatch one of the `streams` arguments would be *awful*.",
        "createdAt" : "2019-07-29T18:54:16Z",
        "updatedAt" : "2019-07-29T18:54:16Z",
        "lastEditedBy" : "b0995fe3-2324-4ecd-9828-cc6e6d2cfb5c",
        "tags" : [
        ]
      }
    ],
    "commit" : "3b9cf28f620071f05a21c02011bf794277eea4ff",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +26,30 @@declare namespace Stream {\n\t/** Creates a computed stream that reactively updates if any of its upstreams are updated. */\n\texport function combine<T>(combiner: (...streams: any[]) => T, streams: Array<Stream<any>>): Stream<T>;\n\t/** Combines the values of one or more streams into a single stream that is updated whenever one or more of the sources are updated */\n\texport function lift<S extends any[], T>(fn: (...values: S) => T, ...streams: {[I in keyof S]: Stream<S[I]>}): Stream<T>;"
  }
]
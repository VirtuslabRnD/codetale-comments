[
  {
    "id" : "357bbb9c-0ab2-4494-b61e-6da8d71abf0d",
    "prId" : 36510,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36510#pullrequestreview-256300055",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8746f943-9be0-456b-a30b-147155c93541",
        "parentId" : null,
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "This test should actually fail, as performing filter on a a Dictionary<T> returns T[], thus performing map on it will need the following iterator:\r\n```\r\n(value: T, index: number, list: T[]): TResult\r\n```\r\nThe reason this test passes now is because of missing signature of filter for _Chain which should be:\r\n```ts\r\nfilter(iterator: _.ObjectIterator<T, boolean>, context?: any): _Chain<T, T[]>;\r\n```\r\nBut fixing it will not even help as the entire _Chain interface is malformed :-( and I'm working on a wide fix for it.\r\nI would rather you only add tests that use the fixed map method",
        "createdAt" : "2019-07-01T08:52:32Z",
        "updatedAt" : "2019-07-01T12:09:37Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "e23e8061-c83f-4604-b937-ac5f36741e04",
        "parentId" : "8746f943-9be0-456b-a30b-147155c93541",
        "authorId" : "fc2b87a1-31b1-453f-a095-f3215fe0becc",
        "body" : "You have right. I will stick in this test to 'map' function. I interface definition I was trying to test.",
        "createdAt" : "2019-07-01T12:17:09Z",
        "updatedAt" : "2019-07-01T12:29:53Z",
        "lastEditedBy" : "fc2b87a1-31b1-453f-a095-f3215fe0becc",
        "tags" : [
        ]
      }
    ],
    "commit" : "f197216080ed9b4deb9174023927ede6eaacbad9",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +221,225 @@};\n\nlet youngPeopleId: string[] = _.chain(usersData)\n    .map((p, k: string) => k)\n    .value();"
  },
  {
    "id" : "af17a1ba-7ac0-4415-9e94-5ecabe0c7da8",
    "prId" : 36510,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36510#pullrequestreview-256356102",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f346689e-c518-4ab1-8651-8dcecd628f17",
        "parentId" : null,
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "why did you remove the type here?\r\nIt is best to use the flatten() method here and then get the value",
        "createdAt" : "2019-07-01T13:35:44Z",
        "updatedAt" : "2019-07-01T13:36:15Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "c868502a-bb65-4dfc-840c-f063cadcd503",
        "parentId" : "f346689e-c518-4ab1-8651-8dcecd628f17",
        "authorId" : "fc2b87a1-31b1-453f-a095-f3215fe0becc",
        "body" : "because the type by the underscore should be like this one in the comment, But with current typescript definition, There is missing one level of array nest. \r\n`{ age: number; name: string; id: string }[][]  // type return by underscore`\r\n`{ age: number; name: string; id: string }[]    // type with is calculate base of current definitions`\r\nIt would require more changes in the underscore typescript definition. And I'm not certain what should be changed?\r\n`interface _ChainOfArrays<T> extends _Chain<T[]> `\r\nto \r\n`interface _ChainOfArrays<T> extends _Chain<T[], T[][]> `\r\nit will not match with data return from function 'groupBy'\r\n\r\n\r\n\r\n",
        "createdAt" : "2019-07-01T13:55:42Z",
        "updatedAt" : "2019-07-01T13:56:46Z",
        "lastEditedBy" : "fc2b87a1-31b1-453f-a095-f3215fe0becc",
        "tags" : [
        ]
      },
      {
        "id" : "b475de81-b18e-4a2b-b794-919b5a083a3e",
        "parentId" : "f346689e-c518-4ab1-8651-8dcecd628f17",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "You are correct. Lets leave it be for now",
        "createdAt" : "2019-07-01T14:01:38Z",
        "updatedAt" : "2019-07-01T14:01:39Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "f197216080ed9b4deb9174023927ede6eaacbad9",
    "line" : 26,
    "diffHunk" : "@@ -1,1 +232,236 @@\n// Test map function with _ChainOfArrays<>\nlet usersTable_2 /*: { age: number; name: string; id: string }[][]*/ = _.chain(usersData)\n    .map<{ age: number; name: string; id: string }>((p, k: string) => {\n        return [{ id: k, ...p }];"
  },
  {
    "id" : "e680e36d-f918-4896-874f-f57a93567aca",
    "prId" : 36510,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36510#pullrequestreview-256340559",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fe9830fc-c498-4b4a-8274-bcb325d060ea",
        "parentId" : null,
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "same here - why did you remove the type?",
        "createdAt" : "2019-07-01T13:36:12Z",
        "updatedAt" : "2019-07-01T13:36:15Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "f197216080ed9b4deb9174023927ede6eaacbad9",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +238,242 @@    .value();\n\nlet usersTable_3 /*: { score: number; fullName: string; login: string }[][]*/ = _.chain(usersTable)\n    .map<{ score: number; fullName: string; login: string }>(p => {\n        return ["
  },
  {
    "id" : "625ec46d-f5a3-4855-a7c5-32b0f3dbeddb",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-432929318",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3efbc67e-53bc-42c3-a5bb-622e23e7c93f",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "The problem with this example from #7931, though, is that while it passes with the current changes it's not a great example of what someone would actually want to do since most folks would want to use the values from the reduce call rather than just turning them all into ones. I tried doing something that someone would actually want to do in such a situation (shown below) and ran into trouble. Happily, it's trouble that I know how to deal with pretty quickly and easily from my long-term experimentation! Less happily, applying it will require a change to all return types that were previously `_ChainSingle`s and potentially the addition of more tests üòû.\r\n\r\n```TS\r\n_.chain([1, 2, 3])\r\n    .reduce((acc, x) => { acc.unshift(x); return acc; }, [] as number[])\r\n    .map(n => n + 1) // error - n is number[] when it should be number\r\n    .value();\r\n```\r\n\r\nTo deal with this, I can change all functions that were returning `_ChainSingle<T>` to return `_Chain<TypeOfCollection<T>, T>` rather than just `_Chain<T>`.\r\n\r\nSince I know what to do here, it won't be difficult to do, and it would be nice for this to work in situations like those described in the issue filed around this, I'll make that change and add a few more interesting tests around that. Sorry for not catching this until now üòû ",
        "createdAt" : "2020-06-18T03:44:10Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "605701a8-ce6b-48d8-93ba-88c898b2ac7e",
        "parentId" : "3efbc67e-53bc-42c3-a5bb-622e23e7c93f",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I should note, too, that this is specifically an issue with operations that result in collections; these changes would still work fine as-is with reduce and other operations previously resulting in a `_ChainSingle` that would yield non-collection items like objects with properties of multiple types, strings, and numbers.",
        "createdAt" : "2020-06-18T03:56:43Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "ef1d192f-0f1a-460e-8203-fb6b8ea1294a",
        "parentId" : "3efbc67e-53bc-42c3-a5bb-622e23e7c93f",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "The change is made! To do this, I reverted the change where I removed `_ChainSingle<T>` and instead redefined `_ChainSingle<V>` as `_Chain<TypeOfCollection<V>, V>`, which is admittedly how I ideally see `_Chain` itself being defined long-term anyway except with `V` being the first parameter and `T` technically not even needing to exist. One other advantage around making this change is that it reduces the likelihood of accidental foot-shooting because any type `V` that is not a collection will result in a `T` type of `never`, which makes calling the functions that expect to act on collections not work very well when tried on wrapped non-collections üòÅ \r\n\r\nThis also involved updating `Collection<T>` to something more useful, though I was planning on doing that in the next PR anyway.",
        "createdAt" : "2020-06-18T04:17:23Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +679,683 @@    .first()\n    .reduce((aggregate, n) => aggregate + n, 0)\n    .value();\n\n// common testing types and objects"
  },
  {
    "id" : "e81597cf-1052-4650-8d7a-8f3bae066797",
    "prId" : 45893,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#pullrequestreview-442828390",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I ran into an interesting issue with the `UnderscoreStatic` overloads of these functions specifically, which is why there are separate list and dictionary overloads of them at this time. For some reason if I use a `Collection` constraint and a `MemoCollectionIterator` in `UnderscoreStatic`, a `memo` value of `0` is not widened to `number` but instead causes the result type to be `0`, which doesn't work well. Super surprisingly, though, that behavior does not also occur in `Underscore` and `_Chain` overloads. I should probably look for an issue in the TS repository that explains why this might be occurring and file an issue asking about it if I can't find one.",
        "createdAt" : "2020-07-05T02:14:38Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "ed6dd2d8-850d-4969-90b0-efbd73faae75",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Oh yeah, this issue also only happens when the type for `memo` is not explicitly specified in the iteratee, which is why my tests didn't catch it since I always declare the iteratee separately with explicit parameter types. The alternation between a partial and full iterator signature was something I added as an attempt to figure out what was going on here, and I decided to keep it because it seemed like a nice case to cover.",
        "createdAt" : "2020-07-05T02:28:39Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "b935c9b1-7c76-4d12-b109-042d8108fb07",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I think the example below that shows the difference in type inference given a function vs. class generic `V` is as simple as I can make it and still have it repro:\r\n\r\n```TS\r\ninterface MemoIterator<TResult> {\r\n    (memo: TResult, num: number): TResult;\r\n}\r\n\r\ntype MemoCollectionIterator<TResult, V> =\r\n    V extends number[] ? MemoIterator<TResult>\r\n    : never;\r\n\r\ninterface FunctionGeneric {\r\n    reduce<V, TResult>(\r\n        collection: V,\r\n        iteratee: MemoCollectionIterator<TResult, V>,\r\n        memo: TResult\r\n    ): TResult;\r\n}\r\n\r\ninterface ClassGeneric<V> {\r\n    reduce<TResult>(\r\n        collection: V,\r\n        iteratee: MemoCollectionIterator<TResult, V>,\r\n        memo: TResult\r\n    ): TResult;\r\n}\r\n\r\ndeclare const functionGeneric: FunctionGeneric;\r\ndeclare const classGeneric: ClassGeneric<number[]>;\r\n\r\nfunctionGeneric.reduce([1, 2, 3], (memo, num) => memo + num, 0); // TResult is inferred as 0\r\nclassGeneric.reduce([1, 2, 3], (memo, num) => memo + num, 0); // TResult is inferred as number\r\n```",
        "createdAt" : "2020-07-05T09:25:48Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "2c4833bc-048c-41eb-8c58-bfb04bab1137",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I guess `V` isn't being inferred in the `ClassGeneric` case, so it probably isn't adding much, which I guess indicates that it's the inference of `V` that's causing issues.\r\n\r\n```TS\r\ninterface MemoIterator<TResult> {\r\n    (memo: TResult, num: number): TResult;\r\n}\r\n\r\ntype MemoCollectionIterator<TResult, V> =\r\n    V extends number[] ? MemoIterator<TResult>\r\n    : never;\r\n\r\ninterface Test {\r\n    reduce<V, TResult>(\r\n        collection: V,\r\n        iteratee: MemoCollectionIterator<TResult, V>,\r\n        memo: TResult\r\n    ): TResult;\r\n\r\n    reduce2<TResult>(\r\n        collection: number[],\r\n        iteratee: MemoCollectionIterator<TResult, number[]>,\r\n        memo: TResult\r\n    ): TResult;\r\n}\r\n\r\ndeclare const test: Test;\r\ntest.reduce([1, 2, 3], (memo, num) => memo + num, 0); // TResult is inferred as 0\r\ntest.reduce2([1, 2, 3], (memo, num) => memo + num, 0); // TResult is inferred as number\r\n```",
        "createdAt" : "2020-07-05T09:40:06Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "edffc9ab-da59-4934-85ed-39736318ef0c",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm not sure whether this is playing a direct role in your observations, but your reduced testcases remind me that the type of `_.reduce` is impossible to express precisely in TypeScript, anyway. All of the iteratee typings we have seen in the PR so far, i.e., both the pre-existing ones and your changes, assume that the iteratee is function that involves at most two types:\r\n\r\n```ts\r\n// with memo\r\ninterface Reducer<T, R> {\r\n    (memo: R, element: T): R;\r\n}\r\n\r\n// without memo\r\ninterface Reducer<T> {\r\n    (memo: T, element: T): T;\r\n}\r\n```\r\n\r\nBut in the general case, the two parameters and the return type can be all distinct and the reducer behaves like a finite state machine:\r\n\r\n```ts\r\n// simple case with a single terminal type\r\ninterface Reducer<T, R> {\r\n    (memo: T, element: T): R;\r\n    (memo: R, element: T): R;\r\n}\r\n\r\n// traffic light cycle\r\ninterface Reducer<T, R, S> {\r\n    (memo: T, element: T): R;\r\n    (memo: R, element: T): S;\r\n    (memo: S, element: T): T;\r\n}\r\n\r\n// total mayhem\r\ninterface Reducer<A, B, C, D, E> {\r\n    (memo: A, element: B): C;\r\n    (memo: A, element: D): C;\r\n    (memo: C, element: B): E;\r\n    (memo: C, element: D): A;\r\n    (memo: E, element: B): E;\r\n    (memo: E, element: D): A;\r\n}\r\n```\r\n\r\nThis is of course too expensive to infer in the general case and that's why `TResult` will often pretend to be a union type. But then still, strictly speaking, the memo can be *either* `T` *or* `TResult` in the most general case. I'm afraid this is just a situation where TypeScript cannot accurately represent JavaScript.",
        "createdAt" : "2020-07-05T19:55:25Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "6eab7a64-c0cb-4b3d-87f8-521a8d751ecb",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Even in the state machine case, I still think the use of a type union is correct because one still needs to figure out what one currently has and what one ends up with at the end of the call (though I suppose one could still possibly infer that without doing type checks by doing current index and collection size checks instead). I agree, though, that that is a good reason to still allow the memo to be augmented to more than just the collection element type, and I appreciate you raising that point. I feel like it would probably still be worth forcing the result type to at least include the collection element type when no memo is provided, though. I think that could probably be managed by updating the overload to include something like `TResult extends TypeOfCollection<V> = TypeOfCollection<V>`, but I'll experiment a bit and see whether that constraint works correctly with union types.",
        "createdAt" : "2020-07-06T01:05:29Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "0ed82db8-87f0-4f44-abec-e39dcab14be1",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Hmm, darn, another case that I didn't try that I should have is giving `reduce` and `reduceRight` an empty collection. It looks like these functions return `undefined` in the case of empty collections, so results should probably also be updated to include that.",
        "createdAt" : "2020-07-06T01:17:28Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "18b90e20-e7de-426b-811b-3f0fb29ed625",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I think I have a good set of overloads in theory, but I'm still working on getting them to be happy in practice since there's still some oddness going on with constant types not widening and also now a compilation issue that only occurs in TS3.3 and below. Here's what I'm thinking would be ideal to allow for a customizable final result but ensure that either the type of the memo (if one is specified) or the type of the collection (if one is not) is included in the results.\r\n\r\n```TS\r\n        reduce<V extends Collection<any>, TResult = TypeOfCollection<V>>(\r\n            collection: V,\r\n            iteratee: MemoCollectionIterator<TypeOfCollection<V>, TResult | TypeOfCollection<V>, V>,\r\n            memo?: undefined,\r\n            context?: any\r\n        ): TResult | TypeOfCollection<V> | undefined;\r\n        reduce<V extends Collection<any>, TMemo, TResult = TMemo>(\r\n            collection: V,\r\n            iteratee: MemoCollectionIterator<TypeOfCollection<V>, TResult | TMemo, V>,\r\n            memo: TMemo,\r\n            context?: any\r\n        ): TResult | TMemo | undefined;\r\n```",
        "createdAt" : "2020-07-06T03:00:19Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "eb528b96-814a-4976-8908-e35c42b60232",
        "parentId" : "df899a21-b555-4819-bc0e-b0b8fa051e90",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Alright, aside from the widening issue the first signature was working, it was just the second one that was having issues and I was finally able to resolve those in a way that seems satisfactory by dropping `TMemo` in favor of just using `TResult` for `memo` (which should be fine since it will still take any value that is of any one of the types in the result type union). I've added tests that demonstrate union type memo iterators working which includes putting back the test I removed; let me know what you think @jgonggrijp. With regards to the test that I added back, I put in the full expected result type but it's worth noting that it still forces the collection type to be included if the ~collection~ iterator type is omitted as shown below.\r\n\r\n```TS\r\n_.reduce<_.Dictionary<string>, number>({ 'a': '1', 'b': '2', 'c': '3' }, (memo, numstr) => (+memo) + (+numstr)); // $ExpectType string | number | undefined\r\n```",
        "createdAt" : "2020-07-06T07:19:34Z",
        "updatedAt" : "2020-07-07T22:52:06Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d952cf3c9669bd2a1b39f465bc3edc514d545609",
    "line" : 10,
    "diffHunk" : "@@ -1,1 +16,20 @@_.reduce<_.Dictionary<string>, number>({ 'a': '1', 'b': '2', 'c': '3' }, (memo, numstr) => (+memo) + (+numstr)); // $ExpectType string | number | undefined\n_.reduce({ 'a': '1', 'b': '2', 'c': '3' }, (memo: string | number, numstr) => (+memo) + (+numstr)); // $ExpectType string | number | undefined\n_.reduce([1, 2, 3], (memo, num) => memo + num, 0); // $ExpectType number\n_([1, 2, 3]).reduce((memo, num) => memo + num, 0); // $ExpectType number\n_.chain([1, 2, 3]).reduce((memo, num) => memo + num, 0).value(); // $ExpectType number"
  },
  {
    "id" : "03e2a1d8-68d9-4d36-9b56-55bb2f94e369",
    "prId" : 45893,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#pullrequestreview-444157500",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b22f0a74-9ae9-4198-bb60-32e201c55937",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Yes, this is easier to digest.",
        "createdAt" : "2020-07-07T18:46:48Z",
        "updatedAt" : "2020-07-07T18:47:36Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "d952cf3c9669bd2a1b39f465bc3edc514d545609",
    "line" : 431,
    "diffHunk" : "@@ -1,1 +1148,1152 @@    _.foldr(stringRecordDictionary, resultUnionPartialMemoIterator, stringMemo); // $ExpectType string | StringRecord\n    _(stringRecordDictionary).foldr(resultUnionPartialMemoIterator, stringMemo); // $ExpectType string | StringRecord\n    extractChainTypes(_.chain(stringRecordDictionary).foldr(resultUnionPartialMemoIterator, stringMemo)); // $ExpectType ChainType<string | StringRecord, string>\n\n    // no memo and union type result - strings - reduceRight"
  },
  {
    "id" : "1eccf2c7-be9a-495e-a6a6-07c6a2e15660",
    "prId" : 45894,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45894#pullrequestreview-442646177",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "90ab7a3a-e5e0-40f0-838b-c92e11c3b239",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Surprisingly for some reason using `anyValue` here does not end up changing the perceived type of `anyValue` to `Function`, so I thought it would be interesting to check something that was a more specific function type than `Function`.",
        "createdAt" : "2020-07-05T04:31:13Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "55626249833e5d8c4576a8609d4d6c3d06b81eef",
    "line" : 170,
    "diffHunk" : "@@ -1,1 +1122,1126 @@// isFunction\n{\n    _.isFunction(maybeFunction) ? maybeFunction : neverValue; // $ExpectType () => void\n    _(anyValue).isFunction(); // $ExpectType boolean\n    extractChainTypes(_.chain(anyValue).isFunction()); // $ExpectType ChainType<boolean, never>"
  },
  {
    "id" : "d65c50bf-1d9e-425c-8706-c7a303b84f2f",
    "prId" : 45894,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45894#pullrequestreview-444167768",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3e1aa4c8-b768-46a9-a65c-4a6f236c07c2",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Please explain to me how this works. This reminds me a bit of undefined behavior optimizations in C and C++ compilers, which is not a positive association in this context...",
        "createdAt" : "2020-07-05T22:33:41Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "5bce45e0-5b6d-4a2e-b836-2516dbacd2df",
        "parentId" : "3e1aa4c8-b768-46a9-a65c-4a6f236c07c2",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "The use of `_.isElement` in the check part of the ternary statement modifies the type of `anyValue` on the truthy branch of the statement to `Element`, TS determines the result type by unioning the types of the truthy and falsy branches of the ternary statement to `Element | never`, and the type is simplified to `Element` because [never is a subtype of every type](https://www.typescriptlang.org/docs/handbook/release-notes/overview.html#the-never-type).\r\n\r\nI'd be open to changing this to something else if you'd prefer. This seemed like a not-totally-unreasonable concise way to get the modified truthy type out of these checks, but the `never` magic to deal with the existence of the falsy branch is admittedly kind of hand-wavey.",
        "createdAt" : "2020-07-07T02:25:47Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "625bb713-40c4-4979-9459-25e9da842441",
        "parentId" : "3e1aa4c8-b768-46a9-a65c-4a6f236c07c2",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Well, \"magic\" was probably not the best word to use there since this behavior is at least explicitly called out in the documentation for the release of the `never` type, which says \"Because never is a subtype of every type, it is always omitted from union types.\"",
        "createdAt" : "2020-07-07T04:21:22Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "6cfb2f70-3343-4305-adff-baf3fce11b81",
        "parentId" : "3e1aa4c8-b768-46a9-a65c-4a6f236c07c2",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Given this explanation, I'm perfectly happy with the approach you've taken. A union with an identity type is fine.\r\n\r\nI was a bit afraid that this was some kind of fuzzy logic thing where the TS compiler goes \"oh, the false branch returns `never`. That cannot be the case so I guess we'll take the other branch\".",
        "createdAt" : "2020-07-07T18:59:42Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "55626249833e5d8c4576a8609d4d6c3d06b81eef",
    "line" : 123,
    "diffHunk" : "@@ -1,1 +1075,1079 @@// isElement\n{\n    _.isElement(anyValue) ? anyValue : neverValue; // $ExpectType Element\n    _(anyValue).isElement(); // $ExpectType boolean\n    extractChainTypes(_.chain(anyValue).isElement()); // $ExpectType ChainType<boolean, never>"
  },
  {
    "id" : "aa294e71-5f92-4b6b-8dce-9930c8cf49bf",
    "prId" : 45994,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45994#pullrequestreview-446699126",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "65460506-1791-4fc8-89d7-d6c8b9fbbecd",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm getting used to this way of testing. I'm even starting to like it.\r\n\r\nPerhaps do add a few cases (just a sampling) with an implicit `_.identity` iteratee.",
        "createdAt" : "2020-07-10T09:17:35Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "5364a74e-c234-4595-b6b6-473323819837",
        "parentId" : "65460506-1791-4fc8-89d7-d6c8b9fbbecd",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I added the identity iteratee tests and also switched to alternating between testing lists and dictionaries for non-function iteratee tests for find, filter, and reject since I feel like testing both of those in those cases is not super interesting. Let me know if you disagree with that, though.",
        "createdAt" : "2020-07-10T18:54:10Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "d61c7a09-2bda-4122-99f1-9e0abeecff2b",
        "parentId" : "65460506-1791-4fc8-89d7-d6c8b9fbbecd",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm fine with it. I'm a bit surprised that you choose to do sampling after so much combinatorial completeness, though. ;-)",
        "createdAt" : "2020-07-10T20:24:20Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "d154b302-10dc-4a77-8722-c00478df7cca",
        "parentId" : "65460506-1791-4fc8-89d7-d6c8b9fbbecd",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Just trying to find ways to stick to the middle ground where we're both somewhat happy üòÑ ",
        "createdAt" : "2020-07-10T21:02:29Z",
        "updatedAt" : "2020-07-10T21:02:29Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "71bbdd7fc4e25219a16c9985198471882e738c8c",
    "line" : 399,
    "diffHunk" : "@@ -1,1 +1175,1179 @@    _(stringRecordDictionary).reject(); // $ExpectType StringRecord[]\n    extractChainTypes(_.chain(stringRecordDictionary).reject()); // $ExpectType ChainType<StringRecord[], StringRecord>\n}\n\n// pluck"
  },
  {
    "id" : "d2947a5f-3fd1-415b-9315-a3794b826432",
    "prId" : 46035,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46035#pullrequestreview-447543167",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "af333509-8c68-4245-adeb-404d5c501402",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "My company's solution ends up with a new error around `Partial<T>` where we're assigning a `string | number | string[] | undefined` (which will actually always be a `string` in context) to a `properties` property that expects a `string | undefined`, which I was originally thinking was ok but as I think about it more I suppose it's not really important for the types for any property to match up exactly.\r\n\r\nI guess ideally TS would make sure that at least one of the types for each property is the same as the provided type for that property, but I'm not entirely sure how to make that happen. Doing something like `U extends Partial<T>` for the `properties` parameter doesn't seem to work.\r\n\r\nTo preserve property name checking but drop type checking for the type of each property, I could make something like a `PartalAny<T>` that applies `Partial` to `T` but also changes all of the types of all of the properties to `any`. Thoughts?\r\n\r\nAlso, I had thought that only inline declarations were required to include at least one property that is in the expected partial type, but that doesn't appear to be the case, so I should drop the \"inline\" from this comment. However, I still think that a lack of any expected property on a `properties` object is still a good error to surface since calling one of these functions with a `properties` object that can't possibly match anything isn't a useful thing to do.",
        "createdAt" : "2020-07-12T15:26:52Z",
        "updatedAt" : "2020-07-14T06:37:48Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "c6a2ba91-62fd-4af7-a7b5-796a7d1d579b",
        "parentId" : "af333509-8c68-4245-adeb-404d5c501402",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Too, I guess ideally any solution applied here should not involve an additional generic type argument and an `extends` check since ideally any change here would also be applied to the `Iteratee` type union, and it would be nice to not make that more complicated.",
        "createdAt" : "2020-07-12T15:39:03Z",
        "updatedAt" : "2020-07-14T06:37:48Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "ebb72cff-4ae9-49eb-8df6-8a2b71661e0c",
        "parentId" : "af333509-8c68-4245-adeb-404d5c501402",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I can't really comment on the other things you wrote, but I fully agree with this:\r\n\r\n> (...) I still think that a lack of any expected property on a `properties` object is still a good error to surface since calling one of these functions with a `properties` object that can't possibly match anything isn't a useful thing to do.",
        "createdAt" : "2020-07-12T16:12:27Z",
        "updatedAt" : "2020-07-14T06:37:48Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "876c5622-e183-401a-8589-eedc849dbd0f",
        "parentId" : "af333509-8c68-4245-adeb-404d5c501402",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "After having given this even more thought, I think my rationale for checking property names actually probably also applies to checking types - if the actual type of the value that ends up being provided as search criteria does not match one of the possible types on the items being searched, then it's not a useful search criteria. Therefore, I think I'll leave this as-is and require that folks either use type guards or assertions to remove types from a type union that might not be useful as search criteria.",
        "createdAt" : "2020-07-13T19:36:20Z",
        "updatedAt" : "2020-07-14T06:37:48Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "a702ec534210c6c37684ed0923c519dc77e5926a",
    "line" : 30,
    "diffHunk" : "@@ -1,1 +513,517 @@\n// verify that partial objects can be provided without error to where and findWhere for a union type collection\n// where no types in the union share the same property names\ndeclare const nonIntersectinglTypeUnion: _.Dictionary<{ one: string; } | { two: number; }>;\n"
  },
  {
    "id" : "98f11d6d-b14f-41b8-bea1-a948a473b76f",
    "prId" : 46035,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46035#pullrequestreview-447550428",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4973f7f4-6291-49b2-a1ad-44db49ff299a",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Shouldn't this be `ChainType<string | undefined, string | undefined>`?",
        "createdAt" : "2020-07-12T19:54:19Z",
        "updatedAt" : "2020-07-14T06:37:48Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "66761faf-cc8d-424a-bd8a-9484ef8dc631",
        "parentId" : "4973f7f4-6291-49b2-a1ad-44db49ff299a",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I don't believe so, no. The collection item type for a wrapped type of `string | undefined` technically ends up being `string | never` (where `string` is the collection item type for `string` since a string is technically also a list of strings and `never` is the collection item type for `undefined` since `undefined` is not a list or dictionary), but `never` gets removed from all type unions so it ends up just being `string`.",
        "createdAt" : "2020-07-13T19:47:46Z",
        "updatedAt" : "2020-07-14T06:37:48Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "a702ec534210c6c37684ed0923c519dc77e5926a",
    "line" : 153,
    "diffHunk" : "@@ -1,1 +1355,1359 @@    _.sample(simpleString); // $ExpectType string | undefined\n    _(simpleString).sample(); // $ExpectType string | undefined\n    extractChainTypes(_.chain(simpleString).sample()); // $ExpectType ChainType<string | undefined, string>\n\n    // with n - lists"
  },
  {
    "id" : "62af00b2-57a5-413d-be81-f0f2de3acb28",
    "prId" : 46035,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46035#pullrequestreview-448021011",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b3dc9d00-e71f-4ac1-bc2a-39fc8e777617",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Really nice that TS is now able to infer this without any type annotations.",
        "createdAt" : "2020-07-14T11:29:18Z",
        "updatedAt" : "2020-07-14T11:45:41Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "a702ec534210c6c37684ed0923c519dc77e5926a",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +487,491 @@    .value();\n\n// $ExpectType { valueProperty: string; } | undefined\n_.chain([\n    {"
  },
  {
    "id" : "701857bc-f7a4-48f1-bcac-1d353c250dfc",
    "prId" : 46068,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46068#pullrequestreview-448767006",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e7b14ddd-c5e6-4944-82ef-537ff9091522",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Any particular reason why you went with strings for the identity iteratee while using records for the other iteratees?",
        "createdAt" : "2020-07-14T12:37:27Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "ddad88d7-6eea-4a8a-a819-49cd8eb5c384",
        "parentId" : "e7b14ddd-c5e6-4944-82ef-537ff9091522",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I went with strings for the identity iteratee because records are not necessarily inherently usefully comparable, and I went with records for other iteratees because the elements produced when iterating over a string do not have selectable properties that are usefully comparable (they pretty much just have `length` and that is always 1).\r\n\r\nIt would be nice to constrain this function to only work with collection and iteratee combinations that are usefully comparable, but I don't think that's possible at this time because I don't think TS can differentiate between objects that have the default `toString` implementation and objects that have an overridden one.\r\n\r\nI guess since records could override `toString` I could use records for everything, but I don't know how prevalent overriding `toString` is in the JS community (just that I never do it) or how correct it's considered to be in general, and I'd like to not set a bad example with these tests.\r\n\r\nLet me know if you think it would be better to always compare records and assume a usefully overridden `toString` in identity iteratee tests. Conversely, let me know if overriding `toString` to make an object comparable is considered to be a major antipattern by the JS community in general that it would be useful to discourage by requiring that iteratees for this function always yield comparable primitives. Finally, let me know if I'm missing a way to assert in TS that an object type is (probably) usefully comparable because it overrides `toString` since then I could constrain iteratee results to primitives and usefully comparable objects.",
        "createdAt" : "2020-07-15T08:19:07Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "c6fba814-8b33-4902-bbe1-25069aa8b98a",
        "parentId" : "e7b14ddd-c5e6-4944-82ef-537ff9091522",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Hmm, after reviewing [the MDN article for less than](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Less_than) it looks like possibly the correct thing to do these days to make an object usefully comparable is to add a [Symbol.toPrimitive](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive) implementation to objects rather than overriding `toString` (though doing the latter still technically works). It looks like I could constrain objects against something like the below interface for this if you think that's a good idea.\r\n\r\n```TS\r\ninterface Comparable {\r\n    [Symbol.toPrimitive]: (hint: 'string' | 'number' | 'default') => string | number;\r\n}\r\n```",
        "createdAt" : "2020-07-15T08:38:32Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "7b56b73a-9cc1-47f4-aaa4-ae2859fa903e",
        "parentId" : "e7b14ddd-c5e6-4944-82ef-537ff9091522",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "> I went with strings for the identity iteratee because records are not necessarily inherently usefully comparable, and I went with records for other iteratees because the elements produced when iterating over a string do not have selectable properties that are usefully comparable (they pretty much just have `length` and that is always 1).\r\n\r\nThat makes perfect sense. Funny I didn't think of that.\r\n\r\n> \r\n> It would be nice to constrain this function to only work with collection and iteratee combinations that are usefully comparable,\r\n\r\nOh no, please don't go there. That would open a big can of worms for something that people probably aren't going to do much.\r\n\r\n> but I don't think that's possible at this time because I don't think TS can differentiate between objects that have the default `toString` implementation and objects that have an overridden one.\r\n> \r\n> I guess since records could override `toString` I could use records for everything, but I don't know how prevalent overriding `toString` is in the JS community (just that I never do it) or how correct it's considered to be in general, and I'd like to not set a bad example with these tests.\r\n\r\nThis is a bit of a moot point because I'm not recommending that you try to differentiate, but: I don't know how prevalent it is in the JS community at large, either. However, I think it is perfectly correct to override the method as long as the override actually makes sense. I can also think of some authoritative overrides:\r\n\r\n- Underscore's `_.prototype.toString`\r\n- The JS builtin `Number.prototype.toString`(`1.toString()` returns `'1'` while `Object.prototype.toString.call(1)` returns `[object Number]`) and likewise for `Boolean`, `String`, `Symbol`, `Date` and so on\r\n\r\n> \r\n> Let me know if you think it would be better to always compare records and assume a usefully overridden `toString` in identity iteratee tests.\r\n\r\nNo, I don't think so. Your tests are fine as they are.\r\n\r\n> Conversely, let me know if overriding `toString` to make an object comparable is considered to be a major antipattern by the JS community in general that it would be useful to discourage by requiring that iteratees for this function always yield comparable primitives.\r\n\r\nI've never seen a mention anywhere that this would be an antipattern. If I had seen it, I would have disagreed. I also don't think that a majority opinion is necessarily a reason to do something. For example, there seems to be a majority opinion in the JS community that 2-space indents are deep enough, but that is no reason for me to follow suit.\r\n\r\n> Finally, let me know if I'm missing a way to assert in TS that an object type is (probably) usefully comparable because it overrides `toString` since then I could constrain iteratee results to primitives and usefully comparable objects.\r\n\r\nI don't know of such a way, but again, I wouldn't be in favor of using it if I did.",
        "createdAt" : "2020-07-15T08:58:21Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "f9432cfe-9bb1-4379-b147-c35643bc7066",
        "parentId" : "e7b14ddd-c5e6-4944-82ef-537ff9091522",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I'll leave all of this as-is then, thanks!",
        "createdAt" : "2020-07-15T09:06:31Z",
        "updatedAt" : "2020-07-15T09:06:32Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ef7c589e1bbefbc057d10451a5b47995ac205d0",
    "line" : 144,
    "diffHunk" : "@@ -1,1 +1451,1455 @@    _.sortedIndex(simpleStringList, simpleString); // $ExpectType number\n    _(simpleStringList).sortedIndex(simpleString); // $ExpectType number\n    extractChainTypes(_.chain(simpleStringList).sortedIndex(simpleString)); // $ExpectType ChainType<number, never>\n\n    // function iteratee"
  },
  {
    "id" : "d96f3f03-b1b6-478e-9ae5-5f45c2a74e47",
    "prId" : 46120,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46120#pullrequestreview-450677951",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "89009f3a-2281-4b82-a319-1252fe6b1143",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Why is this check here and not in the previous tests?",
        "createdAt" : "2020-07-17T09:29:09Z",
        "updatedAt" : "2020-07-17T14:12:07Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "e51c880b-ff7b-4606-b848-90b1a71051c7",
        "parentId" : "89009f3a-2281-4b82-a319-1252fe6b1143",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Unlike with other types for which functions are excluded from matching `Partial<T>` because it ends up with properties that functions don't inherently have, functions match the propertyless `Partial<any>` type, so I need to do this to make `anyFunctionIteratee` not `CollectionIterator<...> | Partial<any>`. This also applies to the `isArray` check later in this file.",
        "createdAt" : "2020-07-17T13:55:22Z",
        "updatedAt" : "2020-07-17T14:58:27Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ef8fe2907257beac41e27c3dc2399a087eddb67",
    "line" : 110,
    "diffHunk" : "@@ -1,1 +707,711 @@        return element.a;\n    };\n    if (_.isFunction(anyFunctionIteratee)) {\n        anyFunctionIteratee(stringRecordDictionary['a'], 'a', stringRecordDictionary); // $ExpectType string\n    }"
  }
]
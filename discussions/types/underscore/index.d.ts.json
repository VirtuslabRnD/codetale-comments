[
  {
    "id" : "6baf527f-fce0-4dd1-8aa4-41ddafcad078",
    "prId" : 27804,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27804#pullrequestreview-144296300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "Why the weakening from `T` to `any` here? Was `T` the wrong type?",
        "createdAt" : "2018-08-07T21:08:55Z",
        "updatedAt" : "2018-08-08T07:15:39Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "a71f9c34-2035-4042-8181-b1875f3bea27",
        "parentId" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "authorId" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "body" : "`T` is indeed the wrong type. Take my test for example. `IYears` is assigned to `number[]`.",
        "createdAt" : "2018-08-08T07:23:59Z",
        "updatedAt" : "2018-08-08T07:23:59Z",
        "lastEditedBy" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "tags" : [
        ]
      },
      {
        "id" : "16bf86d0-2d4a-428f-9a6f-3cc7487ca053",
        "parentId" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "authorId" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "body" : "Also; `any` is what `values(object: any)` returns (the variant without `Chain`). ",
        "createdAt" : "2018-08-08T07:27:45Z",
        "updatedAt" : "2018-08-08T07:28:04Z",
        "lastEditedBy" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "89eff5086697c1a254da6e0fe63aa46f8d61b543",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +5693,5697 @@        * @see _.values\n        **/\n        values(): _Chain<any>;\n\n        /**"
  },
  {
    "id" : "2c3a1141-df5b-4d7f-b0d9-744871be6929",
    "prId" : 35977,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/35977#pullrequestreview-248649108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm missing two signatures from [the documentation](https://underscorejs.org/#pick):\r\n\r\n```ts\r\npick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\r\npick<T, K extends keyof T, V extends T[K]>(obj: T, predicate: ObjectIterator<V, boolean>): Pick<T, K>;\r\n```\r\n\r\nIn the second line, I'm not 100% sure about the notation of the third type parameter (`V extends T[K]`), but I'm sure such a signature needs to be there because `pick` accepts a predicate.",
        "createdAt" : "2019-06-09T20:06:55Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "4b5f2ded-6011-4d0f-aa8a-4d424c5e06c3",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "Hi,\r\n\r\nThe reason I didn't add the first one is that when I tested it, TypeScript failed to infer K automatically so I decided to drop it - but now I realize I was wrong... \r\nSame goes for the 2nd signature - TypeScript can't infer K by itslef but you are right we should at least enforce the predicate and return types.\r\n\r\nSo, I added the 2 missing signatures. but regarding the predicate signature - I changed it a bit and created a new `ObjectIterator` called `FullObjectIterator` as the object values doesn't have to be the same for all keys (like in the tests). I'm not sure about the name I gave it so please let me know your feedback on the matter.\r\n",
        "createdAt" : "2019-06-10T06:53:33Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "c3f1f072-0e56-49a7-b9f3-e16b5d0e615b",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "In my opinion, this is an improvement, but I think `T[K]` and the `ObjectIterator` interface work a bit differently than you seem to assume. If I'm right, I want to request a few more changes.\r\n\r\nLet's say we have the following `T`.\r\n\r\n```ts\r\ninterface T {\r\n    apple: string;\r\n    banana: number;\r\n    cherry: boolean;\r\n}\r\n```\r\n\r\nThen I think we agree that `keyof T` is `'apple' | 'banana' | 'cherry'`. I think we also agree that `T['apple']` is `string`. However, you seem to have different expectations about `T[keyof T]`. It expands to `T['apple' | 'banana' | 'cherry']`, so I think it will be `string | number | boolean`. The typescript handbook is not 100% clear on this situation, however.\r\n\r\nFurthermore, I think `T` is a subset of `Dictionary<string | number | boolean>`. Note that the element values don't need to be the same for all keys in such a `Dictionary`, either. This would mean that any `ObjectIterator` that accepts `string | number | boolean` as its first argument will be able to iterate over `T`. In this case, you don't need `FullObjectIterator`, although `FullObjectIterator` is arguably slightly more correct than `ObjectIterator`.\r\n\r\nReplacing `ObjectIterator`, or giving it a slightly different sibling, doesn't seem like a good idea to me. So I'd prefer that you stick closer to the predicate signature I suggested and just use `ObjectIterator`.\r\n\r\nIn `FullObjectIterator`, you wrote `K extends keyof T = keyof T` to provide a default when TS can't infer `K`. You can apply this trick to the `pick` function signatures too, if necessary.",
        "createdAt" : "2019-06-11T09:25:24Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "6edaf899-172a-43db-8da4-37cb0c10bcb4",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "Thanks for the detailed response!\r\nI agree with you completely! I removed my new predicate interface and reverted to use the already existing one.\r\nAs to your last suggestion - I don't it applies to the pick method as it doesn't make sense to perform a pick on all the keys of an object as it will act like a `copy` method, so I think it is better to let the user choose the subset of keys to pick.",
        "createdAt" : "2019-06-12T00:03:36Z",
        "updatedAt" : "2019-06-12T00:03:36Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "a7c6be07-2566-4854-9ca7-41c523ed5678",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "> I agree with you completely! I removed my new predicate interface and reverted to use the already existing one.\r\n\r\n👍 \r\n\r\n> As to your last suggestion - I don't it applies to the pick method as it doesn't make sense to perform a pick on all the keys of an object as it will act like a copy method, so I think it is better to let the user choose the subset of keys to pick.\r\n\r\nI kind of agree. I would worry a bit about breaking existing code, if not providing a default for `K` means that users will have to explicitly specify the type parameters to `pick` where they didn't previously need to do that. Fortunately, however, you are not explicitly specifying the types in your tests and they pass, so we should be safe.",
        "createdAt" : "2019-06-12T09:39:10Z",
        "updatedAt" : "2019-06-12T13:05:51Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fed08f905b684cb9f641e7f45f4d1be21b44fb2e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +3712,3716 @@        * @return Copy of `object` with only the `keys` properties.\n        **/\n        pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;\n        pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\n        pick<T, K extends keyof T>(obj: T, predicate: ObjectIterator<T[K], boolean>): Pick<T, K>;"
  },
  {
    "id" : "11ee99f1-3057-43e2-98d0-06e6cf53a27f",
    "prId" : 36230,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36230#pullrequestreview-250431907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a065d2d7-705c-4b0b-8591-fc9aeff04c86",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm a bit surprised that TypeScript allows you to make a *forward* reference to another type parameter. But the tests pass, so I'm not complaining.",
        "createdAt" : "2019-06-17T09:39:50Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "dddb7f09-0d87-4237-a0e1-e12ce9eb0944",
        "parentId" : "a065d2d7-705c-4b0b-8591-fc9aeff04c86",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "haha yes I was surprised as well :-)",
        "createdAt" : "2019-06-17T11:11:32Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd60bbc45b4ab1dedcc34273ba910a20717b4102",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +115,119 @@        <T>(value: _.List<T>): Underscore<T, _.List<T>>;\n        <T>(value: Array<T>): Underscore<T, Array<T>>;\n        <T extends TypeOfDictionary<V>, V extends _.Dictionary<any> = _.Dictionary<T>>(value: V): Underscore<T, V>;\n        <T>(value: T): Underscore<T>;\n"
  },
  {
    "id" : "584acf44-0989-4988-855f-705d330b59ff",
    "prId" : 36230,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36230#pullrequestreview-250432302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cbd3cea-8044-4b9f-b3c0-31d72700eb71",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Here you are using `T` as the default, so maybe you can do that with `Underscore<>` as well.",
        "createdAt" : "2019-06-17T09:51:15Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "62b5f5a2-452d-428b-a828-f39f32ddd407",
        "parentId" : "3cbd3cea-8044-4b9f-b3c0-31d72700eb71",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "sure sounds good",
        "createdAt" : "2019-06-17T11:12:41Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd60bbc45b4ab1dedcc34273ba910a20717b4102",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +5064,5068 @@    }\n\n    interface _Chain<T, V = T> {\n\n        /* *************"
  },
  {
    "id" : "c84a0faa-9938-4d19-8970-1fae010845a0",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-431549713",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "With regards to the performance impact of these changes, this will technically handle someone's custom extended array type, but that's probably not a common scenario. If this performance change is really a concern, I could change the Underscore and chain functions to use the below more static set of overloads instead and only be making this a tiny bit more inconvenient for those hopefully rare few that make lists or dictionaries that have extra bits tacked on.\r\n\r\n```TS\r\n        <T>(value: T[]): Underscore<T, T[]>;\r\n        <T>(value: List<T>): Underscore<T, List<T>>;\r\n        <T>(value: Dictionary<T>): Underscore<T, Dictionary<T>>;\r\n        <V>(value: V): Underscore<V>;\r\n```",
        "createdAt" : "2020-06-05T17:21:54Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "71b7ce79-c509-4673-8225-985e6f50b241",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Still probably not a big deal, but I suppose one common item that fits the bill of a list that might have extra bits tacked on is `arguments` (though the only extra bit I see right now in Chrome is `callee`).",
        "createdAt" : "2020-06-05T17:24:54Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "8721b917-bd22-41bb-be73-e40fbfe765b4",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Could you give some examples of code that typechecks with your changes but not with the old code? I think `arguments` and similar array-likes (including `Array` itself, in fact) are already covered by the `List<T>` case.\r\n\r\nWherever TS encounters a type such as `List<T>`, it will always also accept anything that extends that type. Constructions of the form `V extends List<T>` are generally only needed when you need to do your own type computations (like in this case, in order to distinguish the `Dictionary` case from the general fallback type).",
        "createdAt" : "2020-06-08T12:37:20Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "1bb67a8a-acc0-4129-8138-b4e28a67303c",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "There is one place that is immediately improved by these changes and two that would be improved in a future PR. The spot that is immediately improved is `.value()`, which will now provide the original wrapped type instead of an Underscore interface that may not exactly match the provided type. The first improvement in a later PR is `each`, which is expected to return the same object it was given. The second improvement in a later PR is the type of the original object that is provided as the third argument to iterators, though that will be applied to `Underscore` and `_Chain` but not `UnderscoreStatic` in the currently planned set of changes.\r\n\r\nAll that being said, it's not super useful to use the return value of `each` or to do something like `_(specialArray).value()` or `_.chain(specialArray).value()`, and it's probably not even terribly interesting to retain the original type for iterators (personally I've never actually written an iterator that's even used that third argument).\r\n\r\nIf the possibility of being given types that are assignable to but are not exactly the same as Underscore interfaces doesn't need to be handled, I don't think it's necessary to use the extra constraints for dictionaries either; `<T>(value: Dictionary<T>): Underscore<T, Dictionary<T>>;` should be a sufficient overload for dictionaries as long as it comes before the overload that takes any value. It seems like it would be nice to consistently treat special cases for both dictionaries and arrays in a similar fashion, but I will admit that special cases for dictionaries seem more likely to actually happen in the real world so I'd be ok with leaving `V extends Dictionary<T>` but removing the similar constraint for lists if you'd prefer.\r\n\r\nShort contrived examples of special dictionary and list types that would potentially benefit from inferring and propagating the specific dictionary and list types are below.\r\n\r\n```TS\r\n// lists when using an overload that does not propagate the full type\r\nconst stringListWithAddedBits = { 0: 'str', length: 1, nonListProperty: 'suffix' }; // full type is { 0: string, length: number, nonListProperty: string } but it is assignable to List<string>\r\n_(stringListWithAddedBits).value().nonListProperty; // error - nonListProperty does not exist\r\n_(stringListWithAddedBits).each(value => console.log(value)).nonListProperty; // error - nonListProperty does not exist\r\n_(stringListWithAddedBits).map((value, index, list) => value + list.nonListProperty); // error - nonListProperty does not exist\r\n\r\n// dictionaries when using an overload that does not propagate the full type\r\nconst dictionaryWithKnownProperties = {\r\n    numberProperty: 3,\r\n    alsoANumberProperty: 4\r\n}; // full type is { numberProperty: number, alsoANumberProperty: number } but it is assignable to Dictionary<number>\r\n_(dictionaryWithKnownProperties).value().numberProperty; // error - numberProperty does not exist\r\n_(dictionaryWithKnownProperties).each(value => console.log(value)).numberProperty; // error - numberProperty does not exist\r\n_(dictionaryWithKnownProperties).map((value, index, list) => value + list.numberProperty); // error - numberProperty does not exist\r\n```",
        "createdAt" : "2020-06-09T09:46:22Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "444bf9ef-4940-479b-adf2-170fd3b09063",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Actually, I'm mildly convinced. I agree that `_(x).value()` is useless, but the other bits are nice to have. I'd approve keeping this change.",
        "createdAt" : "2020-06-09T11:14:11Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "26ee0a62-ac75-43a6-b093-4f80e6c995de",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Sounds good, I suppose it would be good to add some tests around these cases as well so I'll go do that 😄 ",
        "createdAt" : "2020-06-09T16:17:26Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "f3694685-66b7-433b-bb75-90500aa39b13",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Surprisingly when putting together these tests I found that an automatically-typed new object can be inferred to be a dictionary with string properties but one with an interface containing only string properties cannot, which admittedly makes the dictionary case outlined above a little less useful.\r\n\r\n```TS\r\n// I tried using both non-string and string syntax when defining the property names below just to see if one would make TS happier than the other\r\ninterface StronglyKeyedSimpleStringObjectDictionary {\r\n    'a': SimpleStringObject;\r\n    'b': SimpleStringObject;\r\n    'c': SimpleStringObject;\r\n}\r\n\r\nconst rawSimpleSimpleObjectDictionary = { a: { a: 'a', b: 'c' }, b: { a: 'b', b: 'b' }, c: { a: 'c', b: 'a' } };\r\nconst stronglyKeyedSimpleStringObjectDictionary: StronglyKeyedSimpleStringObjectDictionary = rawSimpleSimpleObjectDictionary;\r\nconst simpleStringObjectDictionary1: _.Dictionary<SimpleStringObject> = rawSimpleSimpleObjectDictionary; // ok\r\nconst simpleStringObjectDictionary2: _.Dictionary<SimpleStringObject> = stronglyKeyedSimpleStringObjectDictionary; // error: Type 'StronglyKeyedSimpleStringObjectDictionary' is not assignable to type 'Dictionary<SimpleStringObject>'. Index signature is missing in type 'StronglyKeyedSimpleStringObjectDictionary'.\r\n```\r\n\r\nThat being said, it's still possible to define an interface that has properties that are known to be defined as well as an index signature, which could still be useful, so I added tests around that to close this out.",
        "createdAt" : "2020-06-16T14:14:06Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +127,131 @@         * @returns An Underscore wrapper around the supplied value.\n         **/\n        <T extends TypeOfList<V>, V extends List<any> = List<T>>(value: V): Underscore<T, V>;\n        <T extends TypeOfDictionary<V>, V extends Dictionary<any> = Dictionary<T>>(value: V): Underscore<T, V>;\n        <V>(value: V): Underscore<never, V>;"
  },
  {
    "id" : "7fd8f7ab-407b-45fc-a6e8-bd85a20527ba",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-432648045",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "271eb36c-a8d0-498a-8b38-c6b626564287",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Continueing the above discussion, this might already be enough to catch anything array-like:\r\n\r\n```suggestion\r\n        chain<T>(value: List<T>): _Chain<T, List<T>>;\r\n```",
        "createdAt" : "2020-06-08T12:44:37Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "e53409bb-0c4b-418d-9afa-084d21288f74",
        "parentId" : "271eb36c-a8d0-498a-8b38-c6b626564287",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Per [this comment](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#discussion_r437329713), I'm resolving this conversation without making changes.",
        "createdAt" : "2020-06-17T18:04:53Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +4122,4126 @@         * @returns An underscore chain wrapper around the supplied value.\n         **/\n        chain<T extends TypeOfList<V>, V extends List<any> = List<T>>(value: V): _Chain<T, V>;\n        chain<T extends TypeOfDictionary<V>, V extends Dictionary<any> = Dictionary<T>>(value: V): _Chain<T, V>;\n        chain<V>(value: V): _Chain<never, V>;"
  },
  {
    "id" : "85c42859-3bd8-4359-bc33-e8b5c9b58c77",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-433370691",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b13838e3-9d51-43b6-acae-36fce272e06e",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Is the use of `never` safe? It's just a guess, but my first impression is that the following will break:\r\n\r\n```ts\r\n_.chain([1, 2, 3]).find(n => n % 2).value();\r\n```",
        "createdAt" : "2020-06-18T13:35:28Z",
        "updatedAt" : "2020-06-18T13:35:28Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "8540a401-2ffa-4f3f-9104-d7f04aa268a6",
        "parentId" : "b13838e3-9d51-43b6-acae-36fce272e06e",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Happily `find` specifically has an extensive set of tests in a form that I actually based most of the tests I wrote off of (see [namespace TestFind in underscore-tests.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/underscore/underscore-tests.ts#L23)), so I can confidently say that the example you provide works as expected 😄 \r\n\r\nWhat happens there is that you end up with a `_Chain<T, V>` (where `T` represents the type of items in a collection and `V` represents the wrapped value) that is `_Chain<never, number | undefined>`, and since `value` is defined as `value(): V;` the result ends up being `number | undefined`.\r\n\r\nWhat the `never` does get in the way of is using subsequent functions that depend on the collection item type `T`; for example, the second find call below would get an `n` of `never` since the chain is not wrapping a collection type where having a collection item type makes sense.\r\n\r\n```TS\r\n_.chain([1, 2, 3]) // result is _Chain<number, number[]>\r\n    .find(n => n % 2) // result is _Chain<never, number | undefined>\r\n    .find(n => n % 2) // This seems like it should be an error, but apparently doing math on a `never` is allowed. It would prevent most other operations though.\r\n    .value(); // result is `undefined`, which is accurate (though admittedly that's more by luck than by design since I'm not really focusing on correct results for inappropriate usages at this time)\r\n```\r\n\r\n(Sigh) Or at least it would if `_Chain.find` didn't have a few issues with its present declaration including its own local redeclaration of the `T` generic and a union of iterator types that makes TS less good at automatically inferring the types that should be applied to callbacks.",
        "createdAt" : "2020-06-18T14:57:33Z",
        "updatedAt" : "2020-06-18T16:24:32Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +114,118 @@    type TypeOfCollection<V> = V extends _.Collection<infer T> ? T : never;\n\n    type _ChainSingle<V> = _Chain<TypeOfCollection<V>, V>;\n\n    interface Cancelable {"
  },
  {
    "id" : "e0a8554c-cc8e-4199-a2c7-b1592e818375",
    "prId" : 45763,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45763#pullrequestreview-442578084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a78857ee-0481-435b-abc1-869740a151d2",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Exciting to see this implemented!",
        "createdAt" : "2020-07-03T22:33:44Z",
        "updatedAt" : "2020-07-04T22:34:09Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "ba4d85b6-7a56-4056-b289-ec5152704ae3",
        "parentId" : "a78857ee-0481-435b-abc1-869740a151d2",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Definitely, thanks for coming up with it!",
        "createdAt" : "2020-07-04T00:45:13Z",
        "updatedAt" : "2020-07-04T22:34:09Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6bd9cb75d38e5ba10fcfcf81dbd3792c918bccf6",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +119,123 @@        : I extends EnumerableKey | Array<EnumerableKey> ? any\n        : I extends Partial<T> ? boolean\n        : never;\n\n    type PropertyTypeOrAny<T, K> = K extends keyof T ? T[K] : any;"
  }
]
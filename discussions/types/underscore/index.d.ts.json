[
  {
    "id" : "6baf527f-fce0-4dd1-8aa4-41ddafcad078",
    "prId" : 27804,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27804#pullrequestreview-144296300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "Why the weakening from `T` to `any` here? Was `T` the wrong type?",
        "createdAt" : "2018-08-07T21:08:55Z",
        "updatedAt" : "2018-08-08T07:15:39Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "a71f9c34-2035-4042-8181-b1875f3bea27",
        "parentId" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "authorId" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "body" : "`T` is indeed the wrong type. Take my test for example. `IYears` is assigned to `number[]`.",
        "createdAt" : "2018-08-08T07:23:59Z",
        "updatedAt" : "2018-08-08T07:23:59Z",
        "lastEditedBy" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "tags" : [
        ]
      },
      {
        "id" : "16bf86d0-2d4a-428f-9a6f-3cc7487ca053",
        "parentId" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "authorId" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "body" : "Also; `any` is what `values(object: any)` returns (the variant without `Chain`). ",
        "createdAt" : "2018-08-08T07:27:45Z",
        "updatedAt" : "2018-08-08T07:28:04Z",
        "lastEditedBy" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "89eff5086697c1a254da6e0fe63aa46f8d61b543",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +5693,5697 @@        * @see _.values\n        **/\n        values(): _Chain<any>;\n\n        /**"
  },
  {
    "id" : "2c3a1141-df5b-4d7f-b0d9-744871be6929",
    "prId" : 35977,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/35977#pullrequestreview-248649108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm missing two signatures from [the documentation](https://underscorejs.org/#pick):\r\n\r\n```ts\r\npick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\r\npick<T, K extends keyof T, V extends T[K]>(obj: T, predicate: ObjectIterator<V, boolean>): Pick<T, K>;\r\n```\r\n\r\nIn the second line, I'm not 100% sure about the notation of the third type parameter (`V extends T[K]`), but I'm sure such a signature needs to be there because `pick` accepts a predicate.",
        "createdAt" : "2019-06-09T20:06:55Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "4b5f2ded-6011-4d0f-aa8a-4d424c5e06c3",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "Hi,\r\n\r\nThe reason I didn't add the first one is that when I tested it, TypeScript failed to infer K automatically so I decided to drop it - but now I realize I was wrong... \r\nSame goes for the 2nd signature - TypeScript can't infer K by itslef but you are right we should at least enforce the predicate and return types.\r\n\r\nSo, I added the 2 missing signatures. but regarding the predicate signature - I changed it a bit and created a new `ObjectIterator` called `FullObjectIterator` as the object values doesn't have to be the same for all keys (like in the tests). I'm not sure about the name I gave it so please let me know your feedback on the matter.\r\n",
        "createdAt" : "2019-06-10T06:53:33Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "c3f1f072-0e56-49a7-b9f3-e16b5d0e615b",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "In my opinion, this is an improvement, but I think `T[K]` and the `ObjectIterator` interface work a bit differently than you seem to assume. If I'm right, I want to request a few more changes.\r\n\r\nLet's say we have the following `T`.\r\n\r\n```ts\r\ninterface T {\r\n    apple: string;\r\n    banana: number;\r\n    cherry: boolean;\r\n}\r\n```\r\n\r\nThen I think we agree that `keyof T` is `'apple' | 'banana' | 'cherry'`. I think we also agree that `T['apple']` is `string`. However, you seem to have different expectations about `T[keyof T]`. It expands to `T['apple' | 'banana' | 'cherry']`, so I think it will be `string | number | boolean`. The typescript handbook is not 100% clear on this situation, however.\r\n\r\nFurthermore, I think `T` is a subset of `Dictionary<string | number | boolean>`. Note that the element values don't need to be the same for all keys in such a `Dictionary`, either. This would mean that any `ObjectIterator` that accepts `string | number | boolean` as its first argument will be able to iterate over `T`. In this case, you don't need `FullObjectIterator`, although `FullObjectIterator` is arguably slightly more correct than `ObjectIterator`.\r\n\r\nReplacing `ObjectIterator`, or giving it a slightly different sibling, doesn't seem like a good idea to me. So I'd prefer that you stick closer to the predicate signature I suggested and just use `ObjectIterator`.\r\n\r\nIn `FullObjectIterator`, you wrote `K extends keyof T = keyof T` to provide a default when TS can't infer `K`. You can apply this trick to the `pick` function signatures too, if necessary.",
        "createdAt" : "2019-06-11T09:25:24Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "6edaf899-172a-43db-8da4-37cb0c10bcb4",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "Thanks for the detailed response!\r\nI agree with you completely! I removed my new predicate interface and reverted to use the already existing one.\r\nAs to your last suggestion - I don't it applies to the pick method as it doesn't make sense to perform a pick on all the keys of an object as it will act like a `copy` method, so I think it is better to let the user choose the subset of keys to pick.",
        "createdAt" : "2019-06-12T00:03:36Z",
        "updatedAt" : "2019-06-12T00:03:36Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "a7c6be07-2566-4854-9ca7-41c523ed5678",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "> I agree with you completely! I removed my new predicate interface and reverted to use the already existing one.\r\n\r\nðŸ‘ \r\n\r\n> As to your last suggestion - I don't it applies to the pick method as it doesn't make sense to perform a pick on all the keys of an object as it will act like a copy method, so I think it is better to let the user choose the subset of keys to pick.\r\n\r\nI kind of agree. I would worry a bit about breaking existing code, if not providing a default for `K` means that users will have to explicitly specify the type parameters to `pick` where they didn't previously need to do that. Fortunately, however, you are not explicitly specifying the types in your tests and they pass, so we should be safe.",
        "createdAt" : "2019-06-12T09:39:10Z",
        "updatedAt" : "2019-06-12T13:05:51Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fed08f905b684cb9f641e7f45f4d1be21b44fb2e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +3712,3716 @@        * @return Copy of `object` with only the `keys` properties.\n        **/\n        pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;\n        pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\n        pick<T, K extends keyof T>(obj: T, predicate: ObjectIterator<T[K], boolean>): Pick<T, K>;"
  },
  {
    "id" : "11ee99f1-3057-43e2-98d0-06e6cf53a27f",
    "prId" : 36230,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36230#pullrequestreview-250431907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a065d2d7-705c-4b0b-8591-fc9aeff04c86",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm a bit surprised that TypeScript allows you to make a *forward* reference to another type parameter. But the tests pass, so I'm not complaining.",
        "createdAt" : "2019-06-17T09:39:50Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "dddb7f09-0d87-4237-a0e1-e12ce9eb0944",
        "parentId" : "a065d2d7-705c-4b0b-8591-fc9aeff04c86",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "haha yes I was surprised as well :-)",
        "createdAt" : "2019-06-17T11:11:32Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd60bbc45b4ab1dedcc34273ba910a20717b4102",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +115,119 @@        <T>(value: _.List<T>): Underscore<T, _.List<T>>;\n        <T>(value: Array<T>): Underscore<T, Array<T>>;\n        <T extends TypeOfDictionary<V>, V extends _.Dictionary<any> = _.Dictionary<T>>(value: V): Underscore<T, V>;\n        <T>(value: T): Underscore<T>;\n"
  },
  {
    "id" : "584acf44-0989-4988-855f-705d330b59ff",
    "prId" : 36230,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36230#pullrequestreview-250432302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cbd3cea-8044-4b9f-b3c0-31d72700eb71",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Here you are using `T` as the default, so maybe you can do that with `Underscore<>` as well.",
        "createdAt" : "2019-06-17T09:51:15Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "62b5f5a2-452d-428b-a828-f39f32ddd407",
        "parentId" : "3cbd3cea-8044-4b9f-b3c0-31d72700eb71",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "sure sounds good",
        "createdAt" : "2019-06-17T11:12:41Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd60bbc45b4ab1dedcc34273ba910a20717b4102",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +5064,5068 @@    }\n\n    interface _Chain<T, V = T> {\n\n        /* *************"
  }
]
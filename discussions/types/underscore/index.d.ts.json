[
  {
    "id" : "6baf527f-fce0-4dd1-8aa4-41ddafcad078",
    "prId" : 27804,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27804#pullrequestreview-144296300",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "Why the weakening from `T` to `any` here? Was `T` the wrong type?",
        "createdAt" : "2018-08-07T21:08:55Z",
        "updatedAt" : "2018-08-08T07:15:39Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "a71f9c34-2035-4042-8181-b1875f3bea27",
        "parentId" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "authorId" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "body" : "`T` is indeed the wrong type. Take my test for example. `IYears` is assigned to `number[]`.",
        "createdAt" : "2018-08-08T07:23:59Z",
        "updatedAt" : "2018-08-08T07:23:59Z",
        "lastEditedBy" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "tags" : [
        ]
      },
      {
        "id" : "16bf86d0-2d4a-428f-9a6f-3cc7487ca053",
        "parentId" : "81187ade-c574-46f2-bd65-bc63864a180c",
        "authorId" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "body" : "Also; `any` is what `values(object: any)` returns (the variant without `Chain`). ",
        "createdAt" : "2018-08-08T07:27:45Z",
        "updatedAt" : "2018-08-08T07:28:04Z",
        "lastEditedBy" : "911e2f93-9085-4ca6-b474-83d69b674e0b",
        "tags" : [
        ]
      }
    ],
    "commit" : "89eff5086697c1a254da6e0fe63aa46f8d61b543",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +5693,5697 @@        * @see _.values\n        **/\n        values(): _Chain<any>;\n\n        /**"
  },
  {
    "id" : "2c3a1141-df5b-4d7f-b0d9-744871be6929",
    "prId" : 35977,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/35977#pullrequestreview-248649108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm missing two signatures from [the documentation](https://underscorejs.org/#pick):\r\n\r\n```ts\r\npick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\r\npick<T, K extends keyof T, V extends T[K]>(obj: T, predicate: ObjectIterator<V, boolean>): Pick<T, K>;\r\n```\r\n\r\nIn the second line, I'm not 100% sure about the notation of the third type parameter (`V extends T[K]`), but I'm sure such a signature needs to be there because `pick` accepts a predicate.",
        "createdAt" : "2019-06-09T20:06:55Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "4b5f2ded-6011-4d0f-aa8a-4d424c5e06c3",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "Hi,\r\n\r\nThe reason I didn't add the first one is that when I tested it, TypeScript failed to infer K automatically so I decided to drop it - but now I realize I was wrong... \r\nSame goes for the 2nd signature - TypeScript can't infer K by itslef but you are right we should at least enforce the predicate and return types.\r\n\r\nSo, I added the 2 missing signatures. but regarding the predicate signature - I changed it a bit and created a new `ObjectIterator` called `FullObjectIterator` as the object values doesn't have to be the same for all keys (like in the tests). I'm not sure about the name I gave it so please let me know your feedback on the matter.\r\n",
        "createdAt" : "2019-06-10T06:53:33Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "c3f1f072-0e56-49a7-b9f3-e16b5d0e615b",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "In my opinion, this is an improvement, but I think `T[K]` and the `ObjectIterator` interface work a bit differently than you seem to assume. If I'm right, I want to request a few more changes.\r\n\r\nLet's say we have the following `T`.\r\n\r\n```ts\r\ninterface T {\r\n    apple: string;\r\n    banana: number;\r\n    cherry: boolean;\r\n}\r\n```\r\n\r\nThen I think we agree that `keyof T` is `'apple' | 'banana' | 'cherry'`. I think we also agree that `T['apple']` is `string`. However, you seem to have different expectations about `T[keyof T]`. It expands to `T['apple' | 'banana' | 'cherry']`, so I think it will be `string | number | boolean`. The typescript handbook is not 100% clear on this situation, however.\r\n\r\nFurthermore, I think `T` is a subset of `Dictionary<string | number | boolean>`. Note that the element values don't need to be the same for all keys in such a `Dictionary`, either. This would mean that any `ObjectIterator` that accepts `string | number | boolean` as its first argument will be able to iterate over `T`. In this case, you don't need `FullObjectIterator`, although `FullObjectIterator` is arguably slightly more correct than `ObjectIterator`.\r\n\r\nReplacing `ObjectIterator`, or giving it a slightly different sibling, doesn't seem like a good idea to me. So I'd prefer that you stick closer to the predicate signature I suggested and just use `ObjectIterator`.\r\n\r\nIn `FullObjectIterator`, you wrote `K extends keyof T = keyof T` to provide a default when TS can't infer `K`. You can apply this trick to the `pick` function signatures too, if necessary.",
        "createdAt" : "2019-06-11T09:25:24Z",
        "updatedAt" : "2019-06-12T00:00:34Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "6edaf899-172a-43db-8da4-37cb0c10bcb4",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "Thanks for the detailed response!\r\nI agree with you completely! I removed my new predicate interface and reverted to use the already existing one.\r\nAs to your last suggestion - I don't it applies to the pick method as it doesn't make sense to perform a pick on all the keys of an object as it will act like a `copy` method, so I think it is better to let the user choose the subset of keys to pick.",
        "createdAt" : "2019-06-12T00:03:36Z",
        "updatedAt" : "2019-06-12T00:03:36Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      },
      {
        "id" : "a7c6be07-2566-4854-9ca7-41c523ed5678",
        "parentId" : "13d4ab18-9922-4783-a0f5-7ed3aff63d91",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "> I agree with you completely! I removed my new predicate interface and reverted to use the already existing one.\r\n\r\n👍 \r\n\r\n> As to your last suggestion - I don't it applies to the pick method as it doesn't make sense to perform a pick on all the keys of an object as it will act like a copy method, so I think it is better to let the user choose the subset of keys to pick.\r\n\r\nI kind of agree. I would worry a bit about breaking existing code, if not providing a default for `K` means that users will have to explicitly specify the type parameters to `pick` where they didn't previously need to do that. Fortunately, however, you are not explicitly specifying the types in your tests and they pass, so we should be safe.",
        "createdAt" : "2019-06-12T09:39:10Z",
        "updatedAt" : "2019-06-12T13:05:51Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "fed08f905b684cb9f641e7f45f4d1be21b44fb2e",
    "line" : 15,
    "diffHunk" : "@@ -1,1 +3712,3716 @@        * @return Copy of `object` with only the `keys` properties.\n        **/\n        pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;\n        pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K>;\n        pick<T, K extends keyof T>(obj: T, predicate: ObjectIterator<T[K], boolean>): Pick<T, K>;"
  },
  {
    "id" : "11ee99f1-3057-43e2-98d0-06e6cf53a27f",
    "prId" : 36230,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36230#pullrequestreview-250431907",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a065d2d7-705c-4b0b-8591-fc9aeff04c86",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm a bit surprised that TypeScript allows you to make a *forward* reference to another type parameter. But the tests pass, so I'm not complaining.",
        "createdAt" : "2019-06-17T09:39:50Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "dddb7f09-0d87-4237-a0e1-e12ce9eb0944",
        "parentId" : "a065d2d7-705c-4b0b-8591-fc9aeff04c86",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "haha yes I was surprised as well :-)",
        "createdAt" : "2019-06-17T11:11:32Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd60bbc45b4ab1dedcc34273ba910a20717b4102",
    "line" : 32,
    "diffHunk" : "@@ -1,1 +115,119 @@        <T>(value: _.List<T>): Underscore<T, _.List<T>>;\n        <T>(value: Array<T>): Underscore<T, Array<T>>;\n        <T extends TypeOfDictionary<V>, V extends _.Dictionary<any> = _.Dictionary<T>>(value: V): Underscore<T, V>;\n        <T>(value: T): Underscore<T>;\n"
  },
  {
    "id" : "584acf44-0989-4988-855f-705d330b59ff",
    "prId" : 36230,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36230#pullrequestreview-250432302",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3cbd3cea-8044-4b9f-b3c0-31d72700eb71",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Here you are using `T` as the default, so maybe you can do that with `Underscore<>` as well.",
        "createdAt" : "2019-06-17T09:51:15Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "62b5f5a2-452d-428b-a828-f39f32ddd407",
        "parentId" : "3cbd3cea-8044-4b9f-b3c0-31d72700eb71",
        "authorId" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "body" : "sure sounds good",
        "createdAt" : "2019-06-17T11:12:41Z",
        "updatedAt" : "2019-06-17T21:55:59Z",
        "lastEditedBy" : "2bb619c2-ecd2-48e8-8e59-d1208775b7ce",
        "tags" : [
        ]
      }
    ],
    "commit" : "dd60bbc45b4ab1dedcc34273ba910a20717b4102",
    "line" : 93,
    "diffHunk" : "@@ -1,1 +5064,5068 @@    }\n\n    interface _Chain<T, V = T> {\n\n        /* *************"
  },
  {
    "id" : "c84a0faa-9938-4d19-8970-1fae010845a0",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-431549713",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "With regards to the performance impact of these changes, this will technically handle someone's custom extended array type, but that's probably not a common scenario. If this performance change is really a concern, I could change the Underscore and chain functions to use the below more static set of overloads instead and only be making this a tiny bit more inconvenient for those hopefully rare few that make lists or dictionaries that have extra bits tacked on.\r\n\r\n```TS\r\n        <T>(value: T[]): Underscore<T, T[]>;\r\n        <T>(value: List<T>): Underscore<T, List<T>>;\r\n        <T>(value: Dictionary<T>): Underscore<T, Dictionary<T>>;\r\n        <V>(value: V): Underscore<V>;\r\n```",
        "createdAt" : "2020-06-05T17:21:54Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "71b7ce79-c509-4673-8225-985e6f50b241",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Still probably not a big deal, but I suppose one common item that fits the bill of a list that might have extra bits tacked on is `arguments` (though the only extra bit I see right now in Chrome is `callee`).",
        "createdAt" : "2020-06-05T17:24:54Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "8721b917-bd22-41bb-be73-e40fbfe765b4",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Could you give some examples of code that typechecks with your changes but not with the old code? I think `arguments` and similar array-likes (including `Array` itself, in fact) are already covered by the `List<T>` case.\r\n\r\nWherever TS encounters a type such as `List<T>`, it will always also accept anything that extends that type. Constructions of the form `V extends List<T>` are generally only needed when you need to do your own type computations (like in this case, in order to distinguish the `Dictionary` case from the general fallback type).",
        "createdAt" : "2020-06-08T12:37:20Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "1bb67a8a-acc0-4129-8138-b4e28a67303c",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "There is one place that is immediately improved by these changes and two that would be improved in a future PR. The spot that is immediately improved is `.value()`, which will now provide the original wrapped type instead of an Underscore interface that may not exactly match the provided type. The first improvement in a later PR is `each`, which is expected to return the same object it was given. The second improvement in a later PR is the type of the original object that is provided as the third argument to iterators, though that will be applied to `Underscore` and `_Chain` but not `UnderscoreStatic` in the currently planned set of changes.\r\n\r\nAll that being said, it's not super useful to use the return value of `each` or to do something like `_(specialArray).value()` or `_.chain(specialArray).value()`, and it's probably not even terribly interesting to retain the original type for iterators (personally I've never actually written an iterator that's even used that third argument).\r\n\r\nIf the possibility of being given types that are assignable to but are not exactly the same as Underscore interfaces doesn't need to be handled, I don't think it's necessary to use the extra constraints for dictionaries either; `<T>(value: Dictionary<T>): Underscore<T, Dictionary<T>>;` should be a sufficient overload for dictionaries as long as it comes before the overload that takes any value. It seems like it would be nice to consistently treat special cases for both dictionaries and arrays in a similar fashion, but I will admit that special cases for dictionaries seem more likely to actually happen in the real world so I'd be ok with leaving `V extends Dictionary<T>` but removing the similar constraint for lists if you'd prefer.\r\n\r\nShort contrived examples of special dictionary and list types that would potentially benefit from inferring and propagating the specific dictionary and list types are below.\r\n\r\n```TS\r\n// lists when using an overload that does not propagate the full type\r\nconst stringListWithAddedBits = { 0: 'str', length: 1, nonListProperty: 'suffix' }; // full type is { 0: string, length: number, nonListProperty: string } but it is assignable to List<string>\r\n_(stringListWithAddedBits).value().nonListProperty; // error - nonListProperty does not exist\r\n_(stringListWithAddedBits).each(value => console.log(value)).nonListProperty; // error - nonListProperty does not exist\r\n_(stringListWithAddedBits).map((value, index, list) => value + list.nonListProperty); // error - nonListProperty does not exist\r\n\r\n// dictionaries when using an overload that does not propagate the full type\r\nconst dictionaryWithKnownProperties = {\r\n    numberProperty: 3,\r\n    alsoANumberProperty: 4\r\n}; // full type is { numberProperty: number, alsoANumberProperty: number } but it is assignable to Dictionary<number>\r\n_(dictionaryWithKnownProperties).value().numberProperty; // error - numberProperty does not exist\r\n_(dictionaryWithKnownProperties).each(value => console.log(value)).numberProperty; // error - numberProperty does not exist\r\n_(dictionaryWithKnownProperties).map((value, index, list) => value + list.numberProperty); // error - numberProperty does not exist\r\n```",
        "createdAt" : "2020-06-09T09:46:22Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "444bf9ef-4940-479b-adf2-170fd3b09063",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Actually, I'm mildly convinced. I agree that `_(x).value()` is useless, but the other bits are nice to have. I'd approve keeping this change.",
        "createdAt" : "2020-06-09T11:14:11Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "26ee0a62-ac75-43a6-b093-4f80e6c995de",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Sounds good, I suppose it would be good to add some tests around these cases as well so I'll go do that 😄 ",
        "createdAt" : "2020-06-09T16:17:26Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "f3694685-66b7-433b-bb75-90500aa39b13",
        "parentId" : "52350452-6515-4160-b7e9-50beb83d02ce",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Surprisingly when putting together these tests I found that an automatically-typed new object can be inferred to be a dictionary with string properties but one with an interface containing only string properties cannot, which admittedly makes the dictionary case outlined above a little less useful.\r\n\r\n```TS\r\n// I tried using both non-string and string syntax when defining the property names below just to see if one would make TS happier than the other\r\ninterface StronglyKeyedSimpleStringObjectDictionary {\r\n    'a': SimpleStringObject;\r\n    'b': SimpleStringObject;\r\n    'c': SimpleStringObject;\r\n}\r\n\r\nconst rawSimpleSimpleObjectDictionary = { a: { a: 'a', b: 'c' }, b: { a: 'b', b: 'b' }, c: { a: 'c', b: 'a' } };\r\nconst stronglyKeyedSimpleStringObjectDictionary: StronglyKeyedSimpleStringObjectDictionary = rawSimpleSimpleObjectDictionary;\r\nconst simpleStringObjectDictionary1: _.Dictionary<SimpleStringObject> = rawSimpleSimpleObjectDictionary; // ok\r\nconst simpleStringObjectDictionary2: _.Dictionary<SimpleStringObject> = stronglyKeyedSimpleStringObjectDictionary; // error: Type 'StronglyKeyedSimpleStringObjectDictionary' is not assignable to type 'Dictionary<SimpleStringObject>'. Index signature is missing in type 'StronglyKeyedSimpleStringObjectDictionary'.\r\n```\r\n\r\nThat being said, it's still possible to define an interface that has properties that are known to be defined as well as an index signature, which could still be useful, so I added tests around that to close this out.",
        "createdAt" : "2020-06-16T14:14:06Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 64,
    "diffHunk" : "@@ -1,1 +127,131 @@         * @returns An Underscore wrapper around the supplied value.\n         **/\n        <T extends TypeOfList<V>, V extends List<any> = List<T>>(value: V): Underscore<T, V>;\n        <T extends TypeOfDictionary<V>, V extends Dictionary<any> = Dictionary<T>>(value: V): Underscore<T, V>;\n        <V>(value: V): Underscore<never, V>;"
  },
  {
    "id" : "7fd8f7ab-407b-45fc-a6e8-bd85a20527ba",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-432648045",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "271eb36c-a8d0-498a-8b38-c6b626564287",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Continueing the above discussion, this might already be enough to catch anything array-like:\r\n\r\n```suggestion\r\n        chain<T>(value: List<T>): _Chain<T, List<T>>;\r\n```",
        "createdAt" : "2020-06-08T12:44:37Z",
        "updatedAt" : "2020-06-18T04:46:45Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "e53409bb-0c4b-418d-9afa-084d21288f74",
        "parentId" : "271eb36c-a8d0-498a-8b38-c6b626564287",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Per [this comment](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#discussion_r437329713), I'm resolving this conversation without making changes.",
        "createdAt" : "2020-06-17T18:04:53Z",
        "updatedAt" : "2020-06-18T04:46:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 106,
    "diffHunk" : "@@ -1,1 +4122,4126 @@         * @returns An underscore chain wrapper around the supplied value.\n         **/\n        chain<T extends TypeOfList<V>, V extends List<any> = List<T>>(value: V): _Chain<T, V>;\n        chain<T extends TypeOfDictionary<V>, V extends Dictionary<any> = Dictionary<T>>(value: V): _Chain<T, V>;\n        chain<V>(value: V): _Chain<never, V>;"
  },
  {
    "id" : "85c42859-3bd8-4359-bc33-e8b5c9b58c77",
    "prId" : 45304,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45304#pullrequestreview-433370691",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b13838e3-9d51-43b6-acae-36fce272e06e",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Is the use of `never` safe? It's just a guess, but my first impression is that the following will break:\r\n\r\n```ts\r\n_.chain([1, 2, 3]).find(n => n % 2).value();\r\n```",
        "createdAt" : "2020-06-18T13:35:28Z",
        "updatedAt" : "2020-06-18T13:35:28Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "8540a401-2ffa-4f3f-9104-d7f04aa268a6",
        "parentId" : "b13838e3-9d51-43b6-acae-36fce272e06e",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Happily `find` specifically has an extensive set of tests in a form that I actually based most of the tests I wrote off of (see [namespace TestFind in underscore-tests.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/underscore/underscore-tests.ts#L23)), so I can confidently say that the example you provide works as expected 😄 \r\n\r\nWhat happens there is that you end up with a `_Chain<T, V>` (where `T` represents the type of items in a collection and `V` represents the wrapped value) that is `_Chain<never, number | undefined>`, and since `value` is defined as `value(): V;` the result ends up being `number | undefined`.\r\n\r\nWhat the `never` does get in the way of is using subsequent functions that depend on the collection item type `T`; for example, the second find call below would get an `n` of `never` since the chain is not wrapping a collection type where having a collection item type makes sense.\r\n\r\n```TS\r\n_.chain([1, 2, 3]) // result is _Chain<number, number[]>\r\n    .find(n => n % 2) // result is _Chain<never, number | undefined>\r\n    .find(n => n % 2) // This seems like it should be an error, but apparently doing math on a `never` is allowed. It would prevent most other operations though.\r\n    .value(); // result is `undefined`, which is accurate (though admittedly that's more by luck than by design since I'm not really focusing on correct results for inappropriate usages at this time)\r\n```\r\n\r\n(Sigh) Or at least it would if `_Chain.find` didn't have a few issues with its present declaration including its own local redeclaration of the `T` generic and a union of iterator types that makes TS less good at automatically inferring the types that should be applied to callbacks.",
        "createdAt" : "2020-06-18T14:57:33Z",
        "updatedAt" : "2020-06-18T16:24:32Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "3835c33848aed8f30912d06e75e9074c51cf5d6d",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +114,118 @@    type TypeOfCollection<V> = V extends _.Collection<infer T> ? T : never;\n\n    type _ChainSingle<V> = _Chain<TypeOfCollection<V>, V>;\n\n    interface Cancelable {"
  },
  {
    "id" : "e0a8554c-cc8e-4199-a2c7-b1592e818375",
    "prId" : 45763,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45763#pullrequestreview-442578084",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a78857ee-0481-435b-abc1-869740a151d2",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Exciting to see this implemented!",
        "createdAt" : "2020-07-03T22:33:44Z",
        "updatedAt" : "2020-07-04T22:34:09Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "ba4d85b6-7a56-4056-b289-ec5152704ae3",
        "parentId" : "a78857ee-0481-435b-abc1-869740a151d2",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Definitely, thanks for coming up with it!",
        "createdAt" : "2020-07-04T00:45:13Z",
        "updatedAt" : "2020-07-04T22:34:09Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "6bd9cb75d38e5ba10fcfcf81dbd3792c918bccf6",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +119,123 @@        : I extends EnumerableKey | Array<EnumerableKey> ? any\n        : I extends Partial<T> ? boolean\n        : never;\n\n    type PropertyTypeOrAny<T, K> = K extends keyof T ? T[K] : any;"
  },
  {
    "id" : "627601d3-7986-4787-bcf6-d07e09cdadcb",
    "prId" : 45893,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#pullrequestreview-442725651",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "da0fe91f-9776-431c-a95b-48c1aa304869",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Nice. 👍 ",
        "createdAt" : "2020-07-05T18:48:09Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "161d7efd-4898-4198-bfe2-feab2af4c5f0",
        "parentId" : "da0fe91f-9776-431c-a95b-48c1aa304869",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Thanks 😄 ",
        "createdAt" : "2020-07-06T01:06:08Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d952cf3c9669bd2a1b39f465bc3edc514d545609",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +137,141 @@        : V extends Dictionary<T> ? MemoObjectIterator<T, TResult, V>\n        : never;\n\n    type TypeOfList<V> = V extends List<infer T> ? T : never;\n"
  },
  {
    "id" : "73983f29-978e-44db-be94-4d8b2da7453d",
    "prId" : 45893,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#pullrequestreview-444301787",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I think if you just make `memo` optional, you have a fine signature that is better than what we had before.\r\n\r\n```suggestion\r\n            memo?: TResult,\r\n```",
        "createdAt" : "2020-07-05T19:05:13Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "27018606-6609-44ba-8c4d-b4239b53bf56",
        "parentId" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I have two reasons for preferring an overload that specifically handles the undefined case here. First, an undefined memo isn't friendly to type inference when it provides context for `TResult` (see examples below). Second, it's nice to force the collection item type into the result in the case of an undefined memo to more accurately portray Underscore's behavior in the single-item collection case.\r\n\r\n```TS\r\nconst result = _.reduce([1, 2, 3], (memo, num) => memo + num); // error - memo is of type \"unknown\"\r\nconst result = _.reduce([1, 2, 3], (memo, num) => memo + num, undefined, context); // error - memo is possibly \"undefined\" (which is its inferred type)\r\n```",
        "createdAt" : "2020-07-06T08:00:43Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "10e04afa-7737-4860-9350-86306e10ad7b",
        "parentId" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Can't `TResult` be inferred from the iteratee instead of relying on the optional third argument?",
        "createdAt" : "2020-07-06T23:29:33Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "888af404-55e4-465a-8bff-4f5ad617ab38",
        "parentId" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "A `?` means that one can fail to provide the argument at all, and I don't think it's reasonable to allow that in this overload. [This test](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#discussion_r449821966) could have done that and still gotten it wrong.",
        "createdAt" : "2020-07-07T00:38:58Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "c8034256-d86a-4df1-8915-c24dc3f6176b",
        "parentId" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "To add a little more detail here, one can still provide `undefined` as the value for this argument, but the lack of `?` makes it so `undefined` has to be be provided explicitly rather than just leaving the argument out, which I think is appropriate for this overload.",
        "createdAt" : "2020-07-07T01:26:42Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "ea8b8777-0bc9-4033-96e2-b373d507f00d",
        "parentId" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Despite the test that you linked to and the extra details, I'm not following you.",
        "createdAt" : "2020-07-07T18:38:08Z",
        "updatedAt" : "2020-07-07T18:38:09Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "3cc8a9d6-e2b0-4b12-93b8-89e45f7e9329",
        "parentId" : "d22803db-f50d-423a-8f36-1fbfa2636fe6",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Oh, sorry, I'll try to ~summarize quick~ tie it all together:\r\n\r\nYou're correct, `TResult` can be inferred from the iteratee, but if `memo` is omitted then this overload would allow the iteratee to specify any `TResult` whether or not it includes the collection item type, which can be dangerous since the first collection item ends up being the memo. The test I referenced is an example of where that occurred - `number` was specified as `TResult`, giving `memo` the type `number`, but since the first item it was given was the first string in the collection and it treated it like a `number` when it should have treated it like a `string | number` the actual JS result was the string `'123'`.\r\n\r\nAlso, since the other overload handles the case where `memo` is not specified, this overload should require `memo` because that's what makes it different from the other overload.",
        "createdAt" : "2020-07-07T22:48:48Z",
        "updatedAt" : "2020-07-08T08:45:34Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d952cf3c9669bd2a1b39f465bc3edc514d545609",
    "line" : 67,
    "diffHunk" : "@@ -1,1 +258,262 @@            collection: V,\n            iteratee: MemoIterator<TypeOfList<V>, TResult, V>,\n            memo: TResult,\n            context?: any\n        ): TResult;"
  },
  {
    "id" : "f90b1e1a-2070-4c34-99b5-0f0c7cd79990",
    "prId" : 45893,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#pullrequestreview-442698497",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "fdb118d6-8e65-4dfb-a310-7b72da2b526c",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Same four comments on `reduce` apply to `reduceRight` as well.",
        "createdAt" : "2020-07-05T19:07:14Z",
        "updatedAt" : "2020-07-07T16:00:46Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "d952cf3c9669bd2a1b39f465bc3edc514d545609",
    "line" : 150,
    "diffHunk" : "@@ -1,1 +307,311 @@            memo: TResult,\n            context?: any\n        ): TResult;\n        reduceRight<V extends List<any>, TResult = TypeOfList<V>>(\n            collection: V,"
  },
  {
    "id" : "026fafb4-f241-4b40-b2dd-0e50bd54a978",
    "prId" : 45893,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45893#pullrequestreview-444157500",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d18983e0-f1b3-4c7f-b707-d7aec8cdcdcf",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Yes, this looks correct to me now.",
        "createdAt" : "2020-07-07T18:44:32Z",
        "updatedAt" : "2020-07-07T18:47:35Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "d952cf3c9669bd2a1b39f465bc3edc514d545609",
    "line" : 83,
    "diffHunk" : "@@ -1,1 +274,278 @@            collection: V,\n            iteratee: MemoObjectIterator<TypeOfDictionary<V>, TResult | TypeOfDictionary<V>, V>\n        ): TResult | TypeOfDictionary<V> | undefined;\n\n        /**"
  },
  {
    "id" : "041a4c34-d6b6-4e66-b244-46fd815d8edc",
    "prId" : 45894,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45894#pullrequestreview-444227805",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "641fa333-3fd8-4961-ba53-7e3a8118d2a2",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "As a point of interest, just to see if it would work I tried changing the return type below to `this is Underscore<never, Element>` and using it as a type guard on a variable containing a wrapped `any`, and while the compiler didn't complain about that and it did have an effect that effect ended up changing the variable into an `Underscore<unknown, any> & Underscore<never, Element>`, which isn't quite right.",
        "createdAt" : "2020-07-05T16:24:37Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "14a425b7-3e4e-4e46-82ce-c2753e7320df",
        "parentId" : "641fa333-3fd8-4961-ba53-7e3a8118d2a2",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Why not `this is Underscore<Element, Element>`?",
        "createdAt" : "2020-07-05T22:27:19Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "441c7a43-19cb-4276-8039-452647839fb3",
        "parentId" : "641fa333-3fd8-4961-ba53-7e3a8118d2a2",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "That would be appropriate if `Element` was iterable and iterating it yielded `Element` objects, but `_.TypeOfCollection<Element>` results in `never` so that doesn't seem to be the case.\r\n\r\nI tried `this is` as an experiment but it doesn't seem to modify the type like I would have expected it to since it does an intersection rather than overriding the type completely. Trying out checking if a `string` is a `number`, though, I found that the resulting type is `never`, so maybe this isn't an unexpected result. Regardless, I feel like the intersection result prevents this from being a useful thing to do since I think to make the result useful one would unfortunately still have to assert the chain's type.\r\n\r\nIf you think it's useful to do that, though, I'd be happy to update these to modify the type of `this` since it seems to be possible to do so.",
        "createdAt" : "2020-07-07T01:52:04Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "3a65ac0a-a3db-4ed5-8c4c-839b342abc4f",
        "parentId" : "641fa333-3fd8-4961-ba53-7e3a8118d2a2",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Honestly, I have no idea. I trust you on this one.",
        "createdAt" : "2020-07-07T18:54:49Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "3f36ca36-063b-4060-89f2-af3db60609bb",
        "parentId" : "641fa333-3fd8-4961-ba53-7e3a8118d2a2",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I don't think this ends up yielding a terribly useful result unfortunately, and even if it did these functions are probably very rarely used outside of `UnderscoreStatic`, so I think I'll leave this as-is.",
        "createdAt" : "2020-07-07T20:31:44Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "55626249833e5d8c4576a8609d4d6c3d06b81eef",
    "line" : 278,
    "diffHunk" : "@@ -1,1 +4872,4876 @@         * Returns true if the wrapped object is a DOM element.\n         * @returns True if the wrapped object is a DOM element, otherwise false.\n         **/\n        isElement(): boolean;\n"
  },
  {
    "id" : "5c6ab9ee-0c72-4277-a23a-42b583d03079",
    "prId" : 45894,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45894#pullrequestreview-444171728",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38377c03-6293-4dec-8d8d-a3176a2e1f3d",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "Or anything that isn't a number, for that matter. But you don't have to add that.",
        "createdAt" : "2020-07-07T19:05:39Z",
        "updatedAt" : "2020-07-09T22:59:08Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "55626249833e5d8c4576a8609d4d6c3d06b81eef",
    "line" : 205,
    "diffHunk" : "@@ -1,1 +3934,3938 @@         * Returns true if `object` is NaN.\n         * Note: this is not the same as the native isNaN function,\n         * which will also return true if the variable is undefined.\n         * @param object The object to check.\n         * @returns True if `object` is NaN, otherwise false."
  },
  {
    "id" : "e6a9b796-f31d-412f-bf95-902273cd628c",
    "prId" : 45994,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45994#pullrequestreview-446662759",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9972e0b5-49b8-46b6-b43e-0feb0fae27b1",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "When I plugged this into my company's solution without this addition, I ran into the case where giving an `any` collection to `find` was resulting in `unknown | undefined` instead of `any` and found that `TypeOfCollection<any>` was resulting in `unknown`, which isn't the best for backwards compatibility. I found through experimentation that `extends never` seems to work as a way to determine if a generic type is `any` and added that case to `TypeOfCollection` to help make this more backwards compatible.\r\n\r\n`UnderscoreStatic` functions should still error out on a `never` collection because `V` is always constrained with `extends Collection<any>`, and passing a `never` to `_.chain` still results in a `_Chain<never, never>` rather than a `_Chain<any, never>`, which is surprising but nice.",
        "createdAt" : "2020-07-10T07:57:51Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "c0668bf6-c99b-418e-ae0b-a784437650bb",
        "parentId" : "9972e0b5-49b8-46b6-b43e-0feb0fae27b1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Microsoft/TypeScript#23182 provides an explanation for why `V extends never` evaluates to false for a `V` of `never`.",
        "createdAt" : "2020-07-10T08:51:01Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "686b3975-3c38-419c-b264-eaf07c0d885b",
        "parentId" : "9972e0b5-49b8-46b6-b43e-0feb0fae27b1",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "It does feel a bit scary though. I suggest adding some tests against `any` and `never` collections just to rule out that this is going to cause trouble.",
        "createdAt" : "2020-07-10T09:20:23Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "ca987575-e086-4fad-b316-30ac0795a0a1",
        "parentId" : "9972e0b5-49b8-46b6-b43e-0feb0fae27b1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "It's true, I was hoping to come across an issue or PR comment that explained that `any extends never => true` was also definitely expected and correct behavior, but the only reference I found to that was in microsoft/TypeScript#23838 and it admittedly wasn't exactly encouraging.\r\n\r\n> `A` ranges over all types, including `null` and `undefined`, but excluding `never`, `any`, `{}` and `unknown` itself.\r\n>\r\n> For the excluded cases and how they interact with each other, it's not always clear. In some cases it is, but I refer you to things like `any extends never ? true : false;` (try guessing what the result of that one is!).",
        "createdAt" : "2020-07-10T14:46:06Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "95a744d4-beb9-48a8-b68e-517bd327fb87",
        "parentId" : "9972e0b5-49b8-46b6-b43e-0feb0fae27b1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I added the requested tests for `any` and `never` to the OOP and chain test sections in addition to the test that chains an any through filter, reject, and find.",
        "createdAt" : "2020-07-10T18:51:48Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "3c665251-0528-4bca-b319-a013bf9b7269",
        "parentId" : "9972e0b5-49b8-46b6-b43e-0feb0fae27b1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I was having a bit of an issue adding `any` tests to each function because TS was inferring stuff from the function iteratee, but I figured that out and added `any` tests for each function as well.",
        "createdAt" : "2020-07-10T19:49:28Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "71bbdd7fc4e25219a16c9985198471882e738c8c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +143,147 @@\n    type TypeOfCollection<V> =\n        V extends never ? any\n        : V extends List<infer T> ? T\n        : V extends Dictionary<infer T> ? T"
  },
  {
    "id" : "18e15c72-a73c-4dc4-bdf5-84c71f5b6f46",
    "prId" : 45994,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/45994#pullrequestreview-446437796",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "a1c1ebef-72b8-40fa-bcc4-e7e7ee647642",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm still really excited about how `Iteratee` and `IterateeResult` have made it possible to cut down most functions to just a single overload that is also more accurate, by the way.",
        "createdAt" : "2020-07-10T09:05:46Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "2718301f-03b3-4e9f-8e36-d7539de40cbf",
        "parentId" : "a1c1ebef-72b8-40fa-bcc4-e7e7ee647642",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Me too, thanks for moving all of this in that direction!",
        "createdAt" : "2020-07-10T14:16:04Z",
        "updatedAt" : "2020-07-10T20:48:15Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "71bbdd7fc4e25219a16c9985198471882e738c8c",
    "line" : 85,
    "diffHunk" : "@@ -1,1 +338,342 @@            iteratee?: Iteratee<V, boolean>,\n            context?: any\n        ): TypeOfCollection<V> | undefined;\n\n        /**"
  },
  {
    "id" : "723ead6c-bc2e-4f71-b3c9-95376187591c",
    "prId" : 46068,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46068#pullrequestreview-448422249",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4ad829c8-d2e4-4ae3-9842-5f1b7e412632",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "The matcher-type iteratee doesn't seem super useful for `sortedIndex` or `uniq` (though I guess I could see the possibility of occasional usefulness for it in the latter), so I didn't add tests for them. I'm happy to add such tests if folks object, though.\r\n\r\nIf there are no objections to omitting tests, would it be worth going a step further by splitting `Iteratee` into two types like `Iteratee = <everything but matcher>` and `MatcherIteratee = Iteratee | Partial<T>` and only using the latter in places where using a matcher seems to make sense?",
        "createdAt" : "2020-07-14T06:13:42Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "60be56e7-d783-4c00-bac2-4d78ec5a9dfb",
        "parentId" : "4ad829c8-d2e4-4ae3-9842-5f1b7e412632",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "A matcher makes sense even for `sortedIndex`: you would use it if you want to keep all elements that pass the matcher at the end of the array. Or at the beginning, if you `_.negate` it.\r\n\r\nLike I prefer keeping `_Chain` a single interface because this most accurately aligns with reality, I'd prefer keeping `Iteratee` and `IterateeResult` single types, too.",
        "createdAt" : "2020-07-14T12:27:31Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "84866af4-c773-4e72-ad30-20a6349164db",
        "parentId" : "4ad829c8-d2e4-4ae3-9842-5f1b7e412632",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Per your approval comment, I'll add these tests back in.",
        "createdAt" : "2020-07-14T20:00:23Z",
        "updatedAt" : "2020-07-15T08:59:49Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "1ef7c589e1bbefbc057d10451a5b47995ac205d0",
    "line" : 129,
    "diffHunk" : "@@ -1,1 +1046,1050 @@            list: V,\n            value: TypeOfList<V>,\n            iteratee?: Iteratee<V, any>,\n            context?: any\n        ): number;"
  },
  {
    "id" : "5f1b9b03-a547-468e-a00d-4d8eb7efed5a",
    "prId" : 46120,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46120#pullrequestreview-450673448",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "478ee978-28bc-4239-aa39-5c4dcc94b4b1",
        "parentId" : null,
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "I'm not inherently opposed to changes like these, but I should point out that there is a caveat. `Array<T>` is subject to deferred inference while `T[]` is not. This has consequences for what TS is able to infer in some cases, for example when defining recursive types.",
        "createdAt" : "2020-07-17T09:19:26Z",
        "updatedAt" : "2020-07-17T14:12:07Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      },
      {
        "id" : "4d95e0f0-8a20-4b7b-b238-d89e3e52dee2",
        "parentId" : "478ee978-28bc-4239-aa39-5c4dcc94b4b1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I didn't know that, thanks! I'll keep that in mind in the future.",
        "createdAt" : "2020-07-17T13:49:44Z",
        "updatedAt" : "2020-07-17T14:12:07Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "5ef8fe2907257beac41e27c3dc2399a087eddb67",
    "line" : 39,
    "diffHunk" : "@@ -1,1 +105,109 @@        CollectionIterator<T, R, V> |\n        EnumerableKey |\n        EnumerableKey[] |\n        Partial<T> |\n        null |"
  },
  {
    "id" : "8f6122e2-9b86-46f4-8555-6ee3a7bc0711",
    "prId" : 46185,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46185#pullrequestreview-452012346",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "969e2a03-9313-4a45-af44-3ee2cd36e1e6",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Would it be worth splitting this back up into separate overloads for `List` and `Dictionary` that include and exclude this parameter respectively? It seemed like a summary comment note was probably good enough, especially since there's no great way to do the same in `Underscore` and `_Chain` at the moment, but I'd be happy to do so if folks would prefer that.",
        "createdAt" : "2020-07-20T00:55:09Z",
        "updatedAt" : "2020-07-21T00:10:45Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "adad9535-a626-402b-9586-7b09937899b8",
        "parentId" : "969e2a03-9313-4a45-af44-3ee2cd36e1e6",
        "authorId" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "body" : "No, I think having an optional parameter that will be ignored for collections is good enough.",
        "createdAt" : "2020-07-20T22:52:00Z",
        "updatedAt" : "2020-07-21T00:10:45Z",
        "lastEditedBy" : "d6dbc01c-d9ed-403c-aba1-4b9e918920b4",
        "tags" : [
        ]
      }
    ],
    "commit" : "f75bf29eb2f3afa45f13a4de1eadf4a08106bac6",
    "line" : 159,
    "diffHunk" : "@@ -1,1 +414,418 @@            collection: V,\n            value: any,\n            fromIndex?: number\n        ): boolean;\n"
  },
  {
    "id" : "05d05666-6ea9-4d9c-9cf5-f775d31a0e9f",
    "prId" : 46189,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46189#pullrequestreview-452498274",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8e7ce80c-30fd-4b7d-99ba-f1ccb2488b64",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "A quick note here: `-0` is treated as `0` by TS, `NaN` is not a constant with its own dedicated constant type at this time, and `0n` can't be added until TS3.2 is the minimum TS version without adding a versioned type definition.",
        "createdAt" : "2020-07-21T01:50:32Z",
        "updatedAt" : "2020-07-22T21:38:06Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "98471024-d815-484b-8d38-b008fc9af5fd",
        "parentId" : "8e7ce80c-30fd-4b7d-99ba-f1ccb2488b64",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I had generally thought that `void` was more or less an alias for `undefined`, but it looks like it might in reality be less since `void extends undefined` is false.\r\n\r\nActually, though, `undefined extends void` is true, so I guess they are related a little. I should ideally use `void` instead of `undefined` here though to cover `void` as well.",
        "createdAt" : "2020-07-21T13:26:14Z",
        "updatedAt" : "2020-07-22T21:38:06Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "936cb0f6-5b52-4c3a-922a-75a8ef594bc6",
        "parentId" : "8e7ce80c-30fd-4b7d-99ba-f1ccb2488b64",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "Oh, the linter doesn't like `void` being used outside of the context of a return type so making this change will fail the CI, oh well I guess.",
        "createdAt" : "2020-07-21T14:11:58Z",
        "updatedAt" : "2020-07-22T21:38:06Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "d9900505ff7bb6c93d6751c97ef08d7274ef0097",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +155,159 @@        : T;\n\n    type AnyFalsy = undefined | null | false | '' | 0;\n\n    type Truthy<T> = Exclude<T, AnyFalsy>;"
  },
  {
    "id" : "b7797fbf-987c-41de-9458-606bb5602c49",
    "prId" : 46240,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46240#pullrequestreview-455251638",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ece796c-cebd-4f2e-93d3-15a6babc5bc1",
        "parentId" : null,
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I suppose it could technically be interesting to split this back up into two overloads in which the identity-iteratee-only one accepts a collection of any type that includes `number` and returns `number` since Underscore will ignore all the non-numbers in the collection, but on the other hand 🤷 ",
        "createdAt" : "2020-07-21T22:49:31Z",
        "updatedAt" : "2020-07-25T02:24:19Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "f0d23a8a-aa02-43c9-bbcd-ba19916fc06c",
        "parentId" : "9ece796c-cebd-4f2e-93d3-15a6babc5bc1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "I suppose I could also use conditional types to figure that out if folks think it's worth it.",
        "createdAt" : "2020-07-24T02:43:48Z",
        "updatedAt" : "2020-07-25T02:24:19Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      },
      {
        "id" : "8a73363e-9aba-4cdc-9157-c8206f7bdf9a",
        "parentId" : "9ece796c-cebd-4f2e-93d3-15a6babc5bc1",
        "authorId" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "body" : "As pointed out in [this comment](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46240#discussion_r459967444), some of these types may be `NumberComparable` and thus may still be valid results even if they're not numbers, so I should not attempt to discard non-number types here.",
        "createdAt" : "2020-07-25T01:52:40Z",
        "updatedAt" : "2020-07-25T02:24:19Z",
        "lastEditedBy" : "96815620-060a-4548-941b-0e1ee9e23ed1",
        "tags" : [
        ]
      }
    ],
    "commit" : "ee9bd2d6b6bd40ee9d75658cf2e05f7a055b4e8a",
    "line" : 76,
    "diffHunk" : "@@ -1,1 +468,472 @@            iteratee?: Iteratee<V, any>,\n            context?: any\n        ): TypeOfCollection<V> | number;\n\n        /**"
  }
]
[
  {
    "id" : "c5a683c1-aea7-4613-aa38-0d006d8d532c",
    "prId" : 34941,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/34941#pullrequestreview-229597782",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1319db53-c72b-45d8-bd24-226592692136",
        "parentId" : null,
        "authorId" : "dbd3bb00-9e9e-4112-8e9f-ffeb4a920a3e",
        "body" : "Note: the old typings were actually incorrect: `db._query` wouldn't take any extra arguments if the first argument is a `Query` object. ArangoDB 3.5 adds support for passing a `Query` object with `QueryOptions`.",
        "createdAt" : "2019-04-23T14:42:09Z",
        "updatedAt" : "2019-04-23T15:02:30Z",
        "lastEditedBy" : "dbd3bb00-9e9e-4112-8e9f-ffeb4a920a3e",
        "tags" : [
        ]
      }
    ],
    "commit" : "639559a7f0b706e35ab404249fdd3e815caaff74",
    "line" : 37,
    "diffHunk" : "@@ -1,1 +957,961 @@        _query(query: Query, options?: QueryOptions): Cursor;\n        _query(\n            query: string,\n            bindVars?: object,\n            options?: QueryOptions"
  },
  {
    "id" : "284bff44-c518-437c-8bde-64f5088e1407",
    "prId" : 34941,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/34941#pullrequestreview-230242601",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "101a8d4d-4c81-4499-a1a6-771b4e395599",
        "parentId" : null,
        "authorId" : "dbd3bb00-9e9e-4112-8e9f-ffeb4a920a3e",
        "body" : "These are strictly mutually exclusive but `{bearer?: string} | {basic?: ...}` has unintuitive DX. I tried using `{bearer?: string, basic: never} | {bearer: never, basic?: ...}` but that didn't seem to guarantee exclusivity either.",
        "createdAt" : "2019-04-23T14:44:42Z",
        "updatedAt" : "2019-04-23T15:02:30Z",
        "lastEditedBy" : "dbd3bb00-9e9e-4112-8e9f-ffeb4a920a3e",
        "tags" : [
        ]
      },
      {
        "id" : "53fc073a-ee00-4f7b-8f7b-8905e686ee3c",
        "parentId" : "101a8d4d-4c81-4499-a1a6-771b4e395599",
        "authorId" : "ae1cf0f9-564e-40ad-9cdf-73f717fd1d58",
        "body" : "A union of two object types represents a type with all the properties of the first object type or all the properties of the second object type. However, this means that an object with all the properties of both objects satisfies this also.\r\n\r\nIn the definition with `never`, the error you're seeing is due to making the `never` typed property required instead of optional. If you change it a little, then it will work: [playground link](https://www.typescriptlang.org/play/index.html#src=type%20t%20%3D%20null%20%7C%20%7B%20bearer%3A%20string%2C%20basic%3F%3A%20never%20%7D%20%7C%20%7B%20bearer%3F%3A%20never%2C%20basic%3A%20%7B%20username%3F%3A%20string%2C%20password%3F%3A%20string%20%7D%20%7D%3B%0D%0A%0D%0Alet%20a%3A%20t%20%3D%20null%3B%20%2F%2F%20OK%0D%0Alet%20b%3A%20t%20%3D%20%7B%20bearer%3A%20%22b%22%20%7D%3B%20%2F%2FOK%0D%0Alet%20c%3A%20t%20%3D%20%7B%20basic%3A%20%7B%7D%20%7D%3B%20%2F%2F%20OK%0D%0Alet%20d%3A%20t%20%3D%20%7B%20bearer%3A%20%22d%22%2C%20basic%3A%20%7B%7D%20%7D%3B%20%2F%2F%20ERROR).",
        "createdAt" : "2019-04-23T17:37:16Z",
        "updatedAt" : "2019-04-23T17:37:27Z",
        "lastEditedBy" : "ae1cf0f9-564e-40ad-9cdf-73f717fd1d58",
        "tags" : [
        ]
      },
      {
        "id" : "7b015b3a-a217-4be2-ae76-8d14fb102531",
        "parentId" : "101a8d4d-4c81-4499-a1a6-771b4e395599",
        "authorId" : "dbd3bb00-9e9e-4112-8e9f-ffeb4a920a3e",
        "body" : "@PranavSenthilnathan This is a return value though. The logic I was trying to express is \"if bearer is present, basic is undefined; if basic is present, bearer is undefined\" and \"if basic.username is undefined, so is basic.password\".\r\n\r\nTyping this as `{ bearer: string } | { basic: { username?: string, password?: string } }` means I can't even check for existence of either property, which is awkward for users.\r\n\r\nTyping this with `never` means the following still works:\r\n\r\n```js\r\nif (auth.bearer) {\r\n  doSomething(auth.basic); // this property shouldn't be valid here\r\n}\r\n```\r\n\r\nSo it's effectively indistinguishable from the much simpler typing I've ended up with.",
        "createdAt" : "2019-04-24T09:29:14Z",
        "updatedAt" : "2019-04-24T09:29:14Z",
        "lastEditedBy" : "dbd3bb00-9e9e-4112-8e9f-ffeb4a920a3e",
        "tags" : [
        ]
      },
      {
        "id" : "105d393d-36f7-4828-88f1-8903fd11cbff",
        "parentId" : "101a8d4d-4c81-4499-a1a6-771b4e395599",
        "authorId" : "ae1cf0f9-564e-40ad-9cdf-73f717fd1d58",
        "body" : "If `doSomething` is typed to not accept `undefined` then you would get an error instead. I see what you're saying though - even though the property will be strongly typed as `unknown`, the property access will not be an error as it would be for accessing nonexistent properties on normal objects ",
        "createdAt" : "2019-04-24T17:10:27Z",
        "updatedAt" : "2019-04-24T17:10:28Z",
        "lastEditedBy" : "ae1cf0f9-564e-40ad-9cdf-73f717fd1d58",
        "tags" : [
        ]
      }
    ],
    "commit" : "639559a7f0b706e35ab404249fdd3e815caaff74",
    "line" : 57,
    "diffHunk" : "@@ -1,1 +1171,1175 @@            bearer?: string;\n            basic?: { username?: string; password?: string };\n        };\n        baseUrl: string;\n        body: any;"
  }
]
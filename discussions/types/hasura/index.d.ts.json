[
  {
    "id" : "1cd5d398-d61d-463f-802b-642631a4b7a3",
    "prId" : 48258,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/48258#pullrequestreview-498101544",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "60b43f69-c9da-4f8c-8a87-ce40ef922eb3",
        "parentId" : null,
        "authorId" : "e5ae6fc6-9e2b-4b96-8480-7066f2f51e54",
        "body" : "I think this is usually defined as\r\n```ts\r\ntype Equals<X, Y> = [X] extends [Y] ? [Y] extends [X] ? true : false : false;\r\n```\r\n\r\nThen you don't need to suppress the lint rule.",
        "createdAt" : "2020-09-28T21:30:09Z",
        "updatedAt" : "2020-09-29T06:21:02Z",
        "lastEditedBy" : "e5ae6fc6-9e2b-4b96-8480-7066f2f51e54",
        "tags" : [
        ]
      },
      {
        "id" : "70f8e5ba-307f-4158-9e6b-c4a40e42bbad",
        "parentId" : "60b43f69-c9da-4f8c-8a87-ce40ef922eb3",
        "authorId" : "49e06ebb-a7a8-46dd-b317-a76ba857932f",
        "body" : "I tried your suggestion, however, below equality check doesn't work anymore\r\n```ts\r\nexport type ScalarJSON<T> = T & {\r\n    __type?: 'json';\r\n}\r\n\r\nhasura.Equals<{ a: string }, hasura.ScalarJSON<{ a: string }>> // true\r\n```",
        "createdAt" : "2020-09-29T05:16:17Z",
        "updatedAt" : "2020-09-29T06:21:02Z",
        "lastEditedBy" : "49e06ebb-a7a8-46dd-b317-a76ba857932f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f604e562cdee1b4156b2136f4b00e845416695dc",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +39,43 @@}\n\ntype Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;\ntype ScalarType = string | number | boolean | ScalarJSON<unknown> | ScalarJSONB<unknown>;\ntype ObjectType = Record<string, ScalarType | Record<string, ScalarType> | Array<Record<string, ScalarType>>>;"
  },
  {
    "id" : "2ac155fd-da7e-4dd9-a1ac-2703095af2d6",
    "prId" : 48258,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/48258#pullrequestreview-498043861",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "49c711bc-accb-4678-be60-4cd5978764e0",
        "parentId" : null,
        "authorId" : "e5ae6fc6-9e2b-4b96-8480-7066f2f51e54",
        "body" : "This looks like it was intended to be a brand and brands aren't usually optional.  Am I missing something?",
        "createdAt" : "2020-09-28T21:43:15Z",
        "updatedAt" : "2020-09-29T06:21:02Z",
        "lastEditedBy" : "e5ae6fc6-9e2b-4b96-8480-7066f2f51e54",
        "tags" : [
        ]
      },
      {
        "id" : "06542407-fbba-4f97-9c89-e4625567ba05",
        "parentId" : "49c711bc-accb-4678-be60-4cd5978764e0",
        "authorId" : "49e06ebb-a7a8-46dd-b317-a76ba857932f",
        "body" : "@amcasey My idea is defining a wrapped type from original type `<T>`, so the Typescript's condition check can know it is JSON type. \r\n\r\nI tried to define \r\n```\r\ntype ScalarJSON<T> = T;\r\n```\r\nHowever the Equals check doesn't work. It still think 2 types are the same\r\n```ts\r\nEquals<T, ScalarJSON<T>> // true\r\n```\r\nSo I decide adding an optional field to make them different. The user doesn't need to know or input this field.\r\n\r\nHowever, if you have better idea, I'm really appreciated to know ",
        "createdAt" : "2020-09-29T03:46:58Z",
        "updatedAt" : "2020-09-29T06:21:02Z",
        "lastEditedBy" : "49e06ebb-a7a8-46dd-b317-a76ba857932f",
        "tags" : [
        ]
      }
    ],
    "commit" : "f604e562cdee1b4156b2136f4b00e845416695dc",
    "line" : 45,
    "diffHunk" : "@@ -1,1 +43,47 @@type ObjectType = Record<string, ScalarType | Record<string, ScalarType> | Array<Record<string, ScalarType>>>;\nexport type ScalarJSON<T> = T & {\n    __type?: 'json';\n};\nexport type ScalarJSONB<T> = T & {"
  }
]
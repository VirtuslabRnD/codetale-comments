[
  {
    "id" : "842b88d5-3dba-410f-a6bd-4386b7994e7b",
    "prId" : 32691,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/32691#pullrequestreview-200865266",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fe56766-f1d7-433f-bbba-e126772d0647",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "I'd have to look to see when this was added, but this value does not actually exist in NodeJS and most likely should also be removed.",
        "createdAt" : "2019-02-01T02:08:35Z",
        "updatedAt" : "2019-02-06T23:58:27Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "c25d281d-bfb0-4441-9916-db8671d76cc1",
        "parentId" : "1fe56766-f1d7-433f-bbba-e126772d0647",
        "authorId" : "e72002e7-e411-40da-ac47-9c0e8d147cda",
        "body" : "see #15093, #26034 (observable) and #25269 (asyncIterator)\r\nNot sure if the rxjs (v6) compatibility is still needed.",
        "createdAt" : "2019-02-06T23:50:46Z",
        "updatedAt" : "2019-02-06T23:58:27Z",
        "lastEditedBy" : "e72002e7-e411-40da-ac47-9c0e8d147cda",
        "tags" : [
        ]
      }
    ],
    "commit" : "77a6c2a9706e17d83a3623f2b1686aafa383e27b",
    "line" : 24,
    "diffHunk" : "@@ -1,1 +144,148 @@\ninterface SymbolConstructor {\n    readonly observable: symbol;\n}\n"
  },
  {
    "id" : "abaa0456-f0a7-4d20-ba8c-4283aae95540",
    "prId" : 33527,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/33527#pullrequestreview-209930882",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "7c55d4d8-0124-4e6d-bc67-7828f995b2c1",
        "parentId" : null,
        "authorId" : "e72002e7-e411-40da-ac47-9c0e8d147cda",
        "body" : "seems the variant `Buffer.from(object[, offsetOrEncoding[, length]])` is missing which was partly supported by this one, see https://nodejs.org/dist/latest-v11.x/docs/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length",
        "createdAt" : "2019-03-03T20:41:20Z",
        "updatedAt" : "2019-03-06T20:51:00Z",
        "lastEditedBy" : "e72002e7-e411-40da-ac47-9c0e8d147cda",
        "tags" : [
        ]
      },
      {
        "id" : "0171d273-68af-4dfb-a2c4-529787d38569",
        "parentId" : "7c55d4d8-0124-4e6d-bc67-7828f995b2c1",
        "authorId" : "4316e44d-461c-4e33-8f9e-87e705b6e3cc",
        "body" : "Symbols are tricky, I'm not touching this one, feel free to add it in another PR.\r\nPlease note this will likely only work in the `3.2` folder.",
        "createdAt" : "2019-03-03T21:09:06Z",
        "updatedAt" : "2019-03-06T20:51:00Z",
        "lastEditedBy" : "4316e44d-461c-4e33-8f9e-87e705b6e3cc",
        "tags" : [
        ]
      }
    ],
    "commit" : "a994a227d834d98580e515abf886b6350f3dff6c",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +361,365 @@     * @param data data to create a new Buffer\n     */\n    from(data: number[]): Buffer;\n    from(data: Uint8Array): Buffer;\n    /**"
  },
  {
    "id" : "529d9141-a670-4de0-b4e5-b40f80bf71b8",
    "prId" : 36660,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36660#pullrequestreview-263269964",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "Do we care about `Buffer` being subclassed? Specifying `constructor` prevents `Buffer` subclasses from having differing construct signatures. I'm aware this is an existing declaration, but it seems like it could be problematic.",
        "createdAt" : "2019-07-16T20:34:51Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "21b8ee7c-e7b4-4757-a036-53098a223eb7",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "4316e44d-461c-4e33-8f9e-87e705b6e3cc",
        "body" : "See previous discussion, I'm personally against defining it as it is a VERY niche use case, but it would be a breaking change.",
        "createdAt" : "2019-07-16T22:26:24Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "4316e44d-461c-4e33-8f9e-87e705b6e3cc",
        "tags" : [
        ]
      },
      {
        "id" : "cdfcd178-bbd7-4bc1-8629-3de53dae8637",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "f20e512d-d787-45a8-a000-96a979941658",
        "body" : "Until all classes T have `.constructor` as a type T, this is important for me to be able to correctly type `qs` (something i'm gradually exploring). It'd be appreciated if it wasn't removed.",
        "createdAt" : "2019-07-16T22:34:17Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "f20e512d-d787-45a8-a000-96a979941658",
        "tags" : [
        ]
      },
      {
        "id" : "187866a8-9bd8-47b4-9ad5-537469cbc811",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "> Until all classes T have .constructor as a type T, this is important for me to be able to correctly type qs (something i'm gradually exploring). It'd be appreciated if it wasn't removed.\r\n\r\nWe will probably never do this as it would break subclassing where the subclass has a differing construct signature:\r\n```ts\r\nclass SuperClass {\r\n  a: string;\r\n  constructor(a: string) {\r\n    this.a = a;\r\n  }\r\n}\r\n\r\nclass SubClass extends SuperClass {\r\n  b: string;\r\n  constructor(opts: { a: string, b: string }) {\r\n    super(opts.a);\r\n    this.b = opts.b;\r\n  }\r\n}\r\n\r\ninterface SuperClass {\r\n    constructor: typeof SuperClass;\r\n}\r\n\r\ninterface SubClass {\r\n    //    ^^^^^^^^\r\n    // error: class 'SubClass' incorrectly extends base class 'SuperClass'.\r\n    //  Types of property 'constructor' are incompatible.\r\n    //    Type 'typeof SubClass' is not assignable to type 'typeof SuperClass'.\r\n    //      Types of parameters 'opts' and 'a' are incompatible.\r\n    //        Type 'string' is not assignable to type '{ a: string; b: string; }'.\r\n    constructor: typeof SubClass;\r\n}\r\n```\r\n\r\nPlayground Link: https://www.typescriptlang.org/play/index.html#code/MYGwhgzhAEDKCuAHApgJwMLitA3gKGmjAC5oIAXVASwDsBzAbgOmAHsaLV5hzXUAKEmUq06ASlzNC5ABZUIAOjDQAvESaEAvnm15QkGAgBGmA9GQAPcshoATQ0jSns+QkdKdRGlu07deAqyI5BCkOEQeIvQANNDuwtT00JoSroRkjoHBimBi3tJyikaq0EEhCkbe2rq01qgAZmDAyHCZzjBphGwclP58pOQAniis9a0oGFgQTDU0dY3NrSZTkuk+PVw8-dBDI2PG7TNAA",
        "createdAt" : "2019-07-16T23:21:56Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "e8f45df4-7447-4e37-83a8-48e181091691",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "f20e512d-d787-45a8-a000-96a979941658",
        "body" : "I guess i don’t understand why, because the constructor property has no relationship to super, and I’d expect with the interface approach to have to subtract out the constructor, or union it.\r\n\r\nCertainly not directly relevant to this PR tho.",
        "createdAt" : "2019-07-16T23:40:33Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "f20e512d-d787-45a8-a000-96a979941658",
        "tags" : [
        ]
      },
      {
        "id" : "eb2868c5-6151-40ce-9957-c3697db601c4",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "If you type `.constructor` as `typeof SuperClass`, you might expect to be able to do this:\r\n```ts\r\nclass SuperClass {\r\n  a: string;\r\n  constructor(a: string) {\r\n    this.a = a;\r\n  }\r\n  clone() {\r\n    return new this.constructor(this.a);\r\n  }\r\n}\r\n```\r\nHowever, this isn't sound as any subclass could have an incompatible construct signature.",
        "createdAt" : "2019-07-16T23:47:54Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "b50b8464-21a0-4bae-8d3c-b23de0c3238f",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "f20e512d-d787-45a8-a000-96a979941658",
        "body" : "Then it should be the union of all constructor types, such that if they’re incompatible you need an explicit cast to call it.",
        "createdAt" : "2019-07-16T23:49:21Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "f20e512d-d787-45a8-a000-96a979941658",
        "tags" : [
        ]
      },
      {
        "id" : "d136e4c7-1305-44e8-b037-29ff929f1127",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "You can't have a \"union of all constructor types\" when typing `constructor` of `SuperClass`, because you can't know all of the possible subclasses at that time.\r\n\r\nFor your case, the more sound approach would be to do something like:\r\n```js\r\nconst { Buffer } = require(\"buffer\");\r\nconst { Buffer: SaferBuffer } = require(\"safer-buffer\");\r\nvar isBuffer = function isBuffer(obj) {\r\n  return Buffer.isBuffer(obj) || SaferBuffer.isBuffer(obj);\r\n}\r\n```\r\n\r\nI could see a *possible* future mechanism for `this.constructor` that returned the static side of the containing class *without* call or construct signatures (but retaining the apparent type of `Function`). Then in `qs` you would do `(obj: (Buffer | Value) & { constructor?: { isBuffer?(obj: any): boolean; } }) => boolean;`",
        "createdAt" : "2019-07-17T00:00:24Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "70ed9118-0367-445e-8f14-8e793f3df322",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "f20e512d-d787-45a8-a000-96a979941658",
        "body" : "In qs, we can’t add those deps since it would increase bundle size for everyone whether they’re using Buffer or not, nor can we even reference Buffer directly.",
        "createdAt" : "2019-07-17T00:03:35Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "f20e512d-d787-45a8-a000-96a979941658",
        "tags" : [
        ]
      },
      {
        "id" : "10dd2f98-628a-45d6-a6ef-6cbfb133c5c2",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "(though I suppose `SaferBuffer.isBuffer` is just `Buffer.isBuffer`)",
        "createdAt" : "2019-07-17T00:04:58Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "b808affb-2147-4e6e-8d36-cdc131e40017",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "Is it strictly necessary to enforce `Buffer`'s constructor is `Buffer` then? From a type-perspective the assumption is that if you are using the `Buffer` type from `@types/node` then you should be a `Buffer` (hand-wavy type-casts like `x as unknown as Buffer` aside). If you can't import or reference `Buffer` at runtime, your only type safety would be a duck-typed best-fit scenario:\r\n```js\r\nvar isBuffer = function (obj) {\r\n  ...\r\n  if (obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer.length >= 1) {\r\n    try {\r\n      const result = obj.constructor.isBuffer(obj);\r\n      return typeof result === \"boolean\" && result; // pretty sure this could be a buffer...\r\n    }\r\n    catch {\r\n      return false; // definitely not a buffer\r\n    }\r\n  }\r\n  return false; // no way to know  \r\n}\r\n```",
        "createdAt" : "2019-07-17T00:15:14Z",
        "updatedAt" : "2019-07-17T00:32:37Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "6bbb38c4-c80d-4f9b-b572-d95508956d2c",
        "parentId" : "f049e2c8-83aa-4c33-8d2a-1eb7c5f93bf2",
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "@ljharb: I filed https://github.com/microsoft/TypeScript/issues/32452 as a suggestion for improving the type of `constructor`. This includes a possible workaround for the subclassing issue that could be employed today: \r\n\r\n```ts\r\ntype StaticMembers<TClass extends Function> = Pick<TClass, keyof TClass> & Function;\r\ninterface Buffer {\r\n  constructor: StaticMembers<typeof Buffer>;\r\n}\r\n```",
        "createdAt" : "2019-07-17T19:31:39Z",
        "updatedAt" : "2019-07-17T19:31:40Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "e291047ee5678269937885193a55cac00118c23a",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +241,245 @@\ninterface Buffer {\n    constructor: typeof Buffer;\n}\n"
  }
]
[
  {
    "id" : "aff33a2e-947b-4094-9348-5524109b2e6f",
    "prId" : 15618,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/15618#pullrequestreview-30785846",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6a4189de-8e25-404c-a0f1-7b415153898a",
        "parentId" : null,
        "authorId" : "0a67fd49-8b41-42a0-9d85-8a4ba0bfcc90",
        "body" : "Is this correct? I think so https://github.com/fantasyland/fantasy-land#functor",
        "createdAt" : "2017-04-04T13:59:06Z",
        "updatedAt" : "2017-04-04T13:59:06Z",
        "lastEditedBy" : "0a67fd49-8b41-42a0-9d85-8a4ba0bfcc90",
        "tags" : [
        ]
      }
    ],
    "commit" : "9a694ef256d5319e3ac8d0fa9f51aa7635677ede",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +16,20 @@\n    interface Functor<T> {\n        map<U>(fn: (t: T) => U): Functor<U>;\n    }\n"
  },
  {
    "id" : "85765604-978c-470b-8b75-402363401516",
    "prId" : 17594,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/17594#pullrequestreview-47554772",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c18900cb-bff8-438f-b30a-20539f189378",
        "parentId" : null,
        "authorId" : "dd998dd7-4ffd-4af0-95b1-6d30ed3b6fa4",
        "body" : "Why do you have `K | string`?  Not just `K`?",
        "createdAt" : "2017-07-02T13:16:10Z",
        "updatedAt" : "2017-07-02T13:16:36Z",
        "lastEditedBy" : "dd998dd7-4ffd-4af0-95b1-6d30ed3b6fa4",
        "tags" : [
        ]
      },
      {
        "id" : "b0f6bc6f-4953-4064-bc04-37c76da027e9",
        "parentId" : "c18900cb-bff8-438f-b30a-20539f189378",
        "authorId" : "dc47236a-758b-4684-bfcb-ab5a861e42a9",
        "body" : "The string alternative must be there because it is possible to call the pick function with names which are not part of the supplied object.\r\nThere are a couple of tests that show this.",
        "createdAt" : "2017-07-02T17:15:27Z",
        "updatedAt" : "2017-07-02T17:15:27Z",
        "lastEditedBy" : "dc47236a-758b-4684-bfcb-ab5a861e42a9",
        "tags" : [
        ]
      }
    ],
    "commit" : "d80cb8f1f5f0d72aaed55745a0715c4748f38e8f",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +1185,1189 @@         * property is ignored.\n         */\n        pick<T, K extends keyof T>(names: Array<K | string>, obj: T): Pick<T, K>;\n        pick(names: string[]): <T, U>(obj: T) => U;\n"
  },
  {
    "id" : "3b2e8c00-9856-4f6f-9138-1fbc14884e44",
    "prId" : 20219,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/20219#pullrequestreview-66870063",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "927549aa-f23e-41c7-993c-63d19c13fef1",
        "parentId" : null,
        "authorId" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "body" : "Why is this not `Array<T | U>`? I guess it was already written this way...\r\n\r\nwat",
        "createdAt" : "2017-10-03T07:56:37Z",
        "updatedAt" : "2017-10-03T22:28:34Z",
        "lastEditedBy" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "tags" : [
        ]
      },
      {
        "id" : "25d53dfd-735e-4274-91ea-38035f5bab8d",
        "parentId" : "927549aa-f23e-41c7-993c-63d19c13fef1",
        "authorId" : "ad9f05a4-d336-4549-96b0-f8a3b95c9764",
        "body" : "convenience!",
        "createdAt" : "2017-10-03T19:29:03Z",
        "updatedAt" : "2017-10-03T22:28:34Z",
        "lastEditedBy" : "ad9f05a4-d336-4549-96b0-f8a3b95c9764",
        "tags" : [
        ]
      }
    ],
    "commit" : "b0dec6bc6ba8670bf725f432c16a6992ebe818c8",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +227,231 @@         */\n        append<U>(el: U): <T>(list: T[]) => Array<(T & U)>;\n        append<T, U>(el: U, list: T[]): Array<(T & U)>;\n        append<T>(el: T, list: string): Array<T & string>;\n"
  },
  {
    "id" : "7ed2084f-5448-4286-a9f1-9df180edbbab",
    "prId" : 20819,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/20819#pullrequestreview-73011475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "307a3297-1d25-433d-99ec-e9a4cca161c1",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "This overload does not have associated documentation. Consider copying the documentation from the preceding overload.",
        "createdAt" : "2017-10-30T22:51:18Z",
        "updatedAt" : "2017-11-01T09:57:47Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ba640f40ff15eb8cbf879dab1a74ce744013523",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +1160,1164 @@         */\n        once(fn: (...a: any[]) => any): (...a: any[]) => any;\n        once<T>(fn: (...a: any[]) => T): (...a: any[]) => T;\n\n        /**"
  },
  {
    "id" : "b7a58fe3-48c9-45ee-888a-af2d8dbd3e30",
    "prId" : 20819,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/20819#pullrequestreview-73011475",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "6ca65509-7461-469d-aa9d-2a326cf7e1e5",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "This overload does not have associated documentation. Consider copying the documentation from the preceding overload.",
        "createdAt" : "2017-10-30T22:51:23Z",
        "updatedAt" : "2017-11-01T09:57:47Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      }
    ],
    "commit" : "6ba640f40ff15eb8cbf879dab1a74ce744013523",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +1194,1198 @@         */\n        partial(fn: (...a: any[]) => any, ...args: any[]): (...a: any[]) => any;\n        partial<T>(fn: (...a: any[]) => T, ...args: any[]): (...a: any[]) => T;\n\n        /**"
  },
  {
    "id" : "797a1d8f-f549-4386-aa71-e5531eefda7a",
    "prId" : 21260,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/21260#pullrequestreview-75897634",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "parentId" : null,
        "authorId" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "body" : "What do you think of the following type instead?\r\n\r\n```ts\r\nprop<P extends string>(p: P): <T extends Record<P, any>(obj: T): Pick<T, P>;\r\n```",
        "createdAt" : "2017-11-09T22:49:50Z",
        "updatedAt" : "2017-11-09T22:49:50Z",
        "lastEditedBy" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "tags" : [
        ]
      },
      {
        "id" : "84978114-409d-4a0e-8457-0d4e88e31810",
        "parentId" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "authorId" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "body" : "AFAIK theyâ€™re equivalent; is there a reason to prefer that? I find yours a little more complex to read.",
        "createdAt" : "2017-11-09T23:05:11Z",
        "updatedAt" : "2017-11-09T23:09:07Z",
        "lastEditedBy" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "tags" : [
        ]
      },
      {
        "id" : "3ac50e7a-82a2-4830-b430-b77b343c04f1",
        "parentId" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "authorId" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "body" : "Wait, you mean `T[P]` instead of `Pick<T, P>`, donâ€™t you?",
        "createdAt" : "2017-11-09T23:12:57Z",
        "updatedAt" : "2017-11-09T23:15:47Z",
        "lastEditedBy" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "tags" : [
        ]
      },
      {
        "id" : "c669eecb-44ce-41aa-89f3-9504dd0c6f50",
        "parentId" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "authorId" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "body" : "Oh, yes, probably. Sorry about that.",
        "createdAt" : "2017-11-10T21:34:21Z",
        "updatedAt" : "2017-11-10T21:34:42Z",
        "lastEditedBy" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "tags" : [
        ]
      },
      {
        "id" : "e582433b-2735-4df9-a171-6895490fa711",
        "parentId" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "authorId" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "body" : "They're actually not exactly equivalent. With `Record<P, T>`, you're expecting an object that is homogeneous for some well-known `T` (meaning that if you have `{x: number, y: string}`, you'll get `number | string` if inference even determines it's appropriate to pick a union type there).\r\n\r\nIf you make `T` the object type, and then use an indexed access, you've delayed the evaluation of the return type until `T` is fully known, giving you a more accurate `prop`.",
        "createdAt" : "2017-11-10T21:36:49Z",
        "updatedAt" : "2017-11-10T21:37:57Z",
        "lastEditedBy" : "9ff3a857-4ac9-4a7e-b447-d0a2f6573899",
        "tags" : [
        ]
      },
      {
        "id" : "3a180ab7-84b4-4975-a491-5cef01378087",
        "parentId" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "authorId" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "body" : "@DanielRosenwasser ok, but in this case `P` can't be a union of multiple literals, since it's determined by a single `p: P`. So `Record<P, T>` amounts to just `{ [p]: T }`.",
        "createdAt" : "2017-11-10T22:14:52Z",
        "updatedAt" : "2017-11-10T22:14:52Z",
        "lastEditedBy" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "tags" : [
        ]
      },
      {
        "id" : "17c07c29-4c02-49f7-9ada-c0823b6a1cd9",
        "parentId" : "ad1c787a-b2cc-481d-9429-9fc8aadf379f",
        "authorId" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "body" : "Well, I guess you could always explicitly widen `P` to a union of literals or even `string`. Fair point, I think you're right.",
        "createdAt" : "2017-11-10T22:26:09Z",
        "updatedAt" : "2017-11-10T22:26:09Z",
        "lastEditedBy" : "a161efa3-ad0a-46da-bab2-b1f9e4f6d5c7",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb51b88dec1abd321a99dfa4517a6556ac737475",
    "line" : 20,
    "diffHunk" : "@@ -1,1 +1451,1455 @@         */\n        prop<P extends string, T>(p: P, obj: Record<P, T>): T;\n        prop<P extends string>(p: P): <T>(obj: Record<P, T>) => T;\n\n        /**"
  },
  {
    "id" : "5b27ff7c-a120-4124-bd86-99a85d1451c2",
    "prId" : 21486,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/21486#pullrequestreview-76372981",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "66a76ca8-aa35-44f8-a611-8fb28cd104be",
        "parentId" : null,
        "authorId" : "845fc937-970c-4a38-b5b0-3a625554507e",
        "body" : "Please update the curried version as well",
        "createdAt" : "2017-11-14T05:44:45Z",
        "updatedAt" : "2017-11-14T05:45:07Z",
        "lastEditedBy" : "845fc937-970c-4a38-b5b0-3a625554507e",
        "tags" : [
        ]
      },
      {
        "id" : "b617b78c-8066-4d67-a16b-17f1f8d167e8",
        "parentId" : "66a76ca8-aa35-44f8-a611-8fb28cd104be",
        "authorId" : "099adaba-888f-4a27-b043-8e55d5ec7a69",
        "body" : "@samsonkeung I don't know why, but curried version seems to work.",
        "createdAt" : "2017-11-14T09:17:09Z",
        "updatedAt" : "2017-11-14T09:17:09Z",
        "lastEditedBy" : "099adaba-888f-4a27-b043-8e55d5ec7a69",
        "tags" : [
        ]
      },
      {
        "id" : "0872c648-16e6-4ca9-98b8-f8e85e6d0760",
        "parentId" : "66a76ca8-aa35-44f8-a611-8fb28cd104be",
        "authorId" : "099adaba-888f-4a27-b043-8e55d5ec7a69",
        "body" : "If I wrote it like `prop<P extends keyof T, T>(p: P): (obj: T) => T[P];`, it wouldn't work (I don't know how to write it in different way so that it would work as expected. (It works as expected now though).",
        "createdAt" : "2017-11-14T09:19:19Z",
        "updatedAt" : "2017-11-14T09:19:36Z",
        "lastEditedBy" : "099adaba-888f-4a27-b043-8e55d5ec7a69",
        "tags" : [
        ]
      }
    ],
    "commit" : "3903644020d82e98c452656db4c2adb774ff2e49",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +1450,1454 @@         */\n        prop<P extends keyof T, T>(p: P, obj: T): T[P];\n        prop<P extends string>(p: P): <T>(obj: Record<P, T>) => T;\n\n        /**"
  },
  {
    "id" : "ed07ffdc-cd4c-4f04-b78c-3ad82d2ac543",
    "prId" : 21771,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/21771#pullrequestreview-83792490",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "9ef8d64c-039b-46ac-a7b2-9287e58a9605",
        "parentId" : null,
        "authorId" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "body" : "I don't understand these properties - are they really part of the API? Can you provide a doc reference please?",
        "createdAt" : "2017-12-11T22:42:36Z",
        "updatedAt" : "2018-01-02T23:21:22Z",
        "lastEditedBy" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "tags" : [
        ]
      },
      {
        "id" : "87e547ad-289d-437c-858a-66f746616c3a",
        "parentId" : "9ef8d64c-039b-46ac-a7b2-9287e58a9605",
        "authorId" : "139f2028-3c90-4cc2-bf49-2935b0a550f9",
        "body" : "Seems to me like they are:\r\nhttps://github.com/ramda/ramda/blob/master/source/internal/_reduced.js",
        "createdAt" : "2017-12-12T02:25:44Z",
        "updatedAt" : "2018-01-02T23:21:22Z",
        "lastEditedBy" : "139f2028-3c90-4cc2-bf49-2935b0a550f9",
        "tags" : [
        ]
      },
      {
        "id" : "5586fff2-4b34-4162-a4d9-8e1d29c39ad7",
        "parentId" : "9ef8d64c-039b-46ac-a7b2-9287e58a9605",
        "authorId" : "225dbac5-3b45-4369-bbcf-f18867216a42",
        "body" : "Yes they are. They are an implementation detail that is subject to change, but I still think we should include this in the type definitions. Unfortunately there is no way in JavaScript or TypeScript to enforce encapsulation without using classes, AFAIK. And I don't think it is the job of the TypeScript definitions to enforce that kind of thing either, it should just represent the actual types used in the JavaScript library.",
        "createdAt" : "2017-12-12T07:44:25Z",
        "updatedAt" : "2018-01-02T23:21:22Z",
        "lastEditedBy" : "225dbac5-3b45-4369-bbcf-f18867216a42",
        "tags" : [
        ]
      },
      {
        "id" : "7e5a5027-b9dc-40b2-a9fa-3fd2b1137a61",
        "parentId" : "9ef8d64c-039b-46ac-a7b2-9287e58a9605",
        "authorId" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "body" : "> And I don't think it is the job of the TypeScript definitions to enforce that kind of thing either, it should just represent the actual types used in the JavaScript library.\r\n\r\nThis is up to interpretation. Of course the typings should represent actual types, but the goal of the typings is to allow developers to easily write correct, maintainable code. More often than not, this involves excluding implementation details and undocumented properties.\r\n\r\nI'm not familiar with this particular library, so I'm going to need your help understanding the intention. To demonstrate, could you add a test case, showing a common use case, that would fail without your changes?",
        "createdAt" : "2017-12-12T17:07:57Z",
        "updatedAt" : "2018-01-02T23:21:22Z",
        "lastEditedBy" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "tags" : [
        ]
      },
      {
        "id" : "b8262804-b719-40b8-970d-0d7d669d9c10",
        "parentId" : "9ef8d64c-039b-46ac-a7b2-9287e58a9605",
        "authorId" : "225dbac5-3b45-4369-bbcf-f18867216a42",
        "body" : "Good idea, I will see if I can add a test case if I have the time",
        "createdAt" : "2017-12-15T12:16:17Z",
        "updatedAt" : "2018-01-02T23:21:22Z",
        "lastEditedBy" : "225dbac5-3b45-4369-bbcf-f18867216a42",
        "tags" : [
        ]
      }
    ],
    "commit" : "10fbc648ee5d8d02ed9cd23f60e588c213ccec29",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +150,154 @@\n    interface Reduced<T> {\n        '@@transducer/value': T;\n        '@@transducer/reduced': true;\n    }"
  },
  {
    "id" : "af9b57d0-9fa9-4013-aaef-cf68275e6dc4",
    "prId" : 21870,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/21870#pullrequestreview-84198607",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "068fde22-3833-41b4-9dd6-8fb9a00ab788",
        "parentId" : null,
        "authorId" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "body" : "Just confirming, is your intention to have a function type whose arguments are all the same type? Because that's the only thing that this allows. e.g.: `(a: string, b: string, c: string) => boolean`",
        "createdAt" : "2017-12-13T22:57:55Z",
        "updatedAt" : "2018-01-02T23:19:34Z",
        "lastEditedBy" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "tags" : [
        ]
      },
      {
        "id" : "c9983f0b-1be2-4e5e-b024-0a058b4e8b71",
        "parentId" : "068fde22-3833-41b4-9dd6-8fb9a00ab788",
        "authorId" : "0a67fd49-8b41-42a0-9d85-8a4ba0bfcc90",
        "body" : "Good point. We would need to add multiple overloads to support different parameter types.",
        "createdAt" : "2017-12-18T09:57:50Z",
        "updatedAt" : "2018-01-02T23:19:34Z",
        "lastEditedBy" : "0a67fd49-8b41-42a0-9d85-8a4ba0bfcc90",
        "tags" : [
        ]
      },
      {
        "id" : "0f54eb57-4253-4331-801f-7662ec36004d",
        "parentId" : "068fde22-3833-41b4-9dd6-8fb9a00ab788",
        "authorId" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "body" : "I think you can achieve a typed `anyPass` by simply using `extends` in the type parameter, without having to declare a new type.\r\n\r\n```ts\r\nanyPass<T extends Pred>(preds: T[]): T;\r\n```",
        "createdAt" : "2017-12-18T16:53:29Z",
        "updatedAt" : "2018-01-02T23:19:34Z",
        "lastEditedBy" : "d853babe-4254-41de-b4dc-f225efa4a6ff",
        "tags" : [
        ]
      }
    ],
    "commit" : "27b813172938e5128263d144ffaa23107a0c8dfe",
    "line" : 4,
    "diffHunk" : "@@ -1,1 +53,57 @@\n    type Pred = (...a: any[]) => boolean;\n    type SafePred<T> = (...a: T[]) => boolean;\n\n    type ObjPred = (value: any, key: string) => boolean;"
  },
  {
    "id" : "fefb7051-a1b1-406b-8947-2d8a09a3ed24",
    "prId" : 24895,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24895#pullrequestreview-113884811",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "parentId" : null,
        "authorId" : "ef9ed909-4847-44e0-93f7-80a4cd29e74e",
        "body" : "Is there any way to just parameterize `(...args: any[])` without the `=> any`? If there is, then perhaps we could get a narrower definition on this?",
        "createdAt" : "2018-04-18T16:01:08Z",
        "updatedAt" : "2018-04-18T16:01:08Z",
        "lastEditedBy" : "ef9ed909-4847-44e0-93f7-80a4cd29e74e",
        "tags" : [
        ]
      },
      {
        "id" : "4b4b938f-612f-4ecd-8b9e-31fed1a8d7c5",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "body" : "Sorry, but Iâ€™m not sure what do you mean by that.",
        "createdAt" : "2018-04-18T17:18:09Z",
        "updatedAt" : "2018-04-18T17:18:39Z",
        "lastEditedBy" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "tags" : [
        ]
      },
      {
        "id" : "5f088b55-579c-404c-a96d-9a5b16f2287a",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "5c71d53b-bfaf-416b-a5e5-2d7ac41e2664",
        "body" : "With the current definition any function type will be accepted as `T`. So whatever function you pass to `fn`, the second parameter, you get a function with the parameters and the return value of that function out of `memoizeWith`. So there is no need for narrowing there (as far as I can tell).\r\n\r\nThere is of course the `keyFn` parameter, which would ideally be a function with the same parameters as `fn` but always a string return value. I'm not sure but it might be achievable with conditional types.",
        "createdAt" : "2018-04-18T19:57:11Z",
        "updatedAt" : "2018-04-18T19:57:12Z",
        "lastEditedBy" : "5c71d53b-bfaf-416b-a5e5-2d7ac41e2664",
        "tags" : [
        ]
      },
      {
        "id" : "da8e9ffc-f1f3-4782-b8b0-c5745927c9b8",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "ef9ed909-4847-44e0-93f7-80a4cd29e74e",
        "body" : "@googol, that was precisely the question I was asking. Ideally we want to constrain the arguments lists to be the same type even though the output of `T` in one case and `string` in the other. If there is no way to express that in typescript, then I believe this is the best way forward so as to permit use of this function.",
        "createdAt" : "2018-04-19T16:22:57Z",
        "updatedAt" : "2018-04-19T16:22:57Z",
        "lastEditedBy" : "ef9ed909-4847-44e0-93f7-80a4cd29e74e",
        "tags" : [
        ]
      },
      {
        "id" : "e17e04a8-ebd8-4705-8386-9c328686eec4",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "body" : "To be honest, I don't want to force people to use `fn` and `keyFn` functions with the same arguments. Someone can easily need to memoize by, for example, just a first argument and forcing the same arguments for both functions can be quite annoying. \r\n\r\nAlso, I think that the whole purpose of a `keyFn` is to return some string, nothing more. The fact that the Ramda passes a provided parameters to `keyFn` is just a convenient bonus. So, forcing the arguments is probably not a very good idea.",
        "createdAt" : "2018-04-19T18:50:55Z",
        "updatedAt" : "2018-04-19T18:50:55Z",
        "lastEditedBy" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "tags" : [
        ]
      },
      {
        "id" : "4565b4c1-4d6c-451a-9036-ac084c268d65",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "ef9ed909-4847-44e0-93f7-80a4cd29e74e",
        "body" : "if they don't accept the same argument lists though, then how would you reasonably be able to memoize stuff? I understand that maybe you don't want to use the full set of arguments, but that's a specific optimization, the function signatures have to accept the same set of arguments or it wouldn't actually be memoization. I actually can't think of any situation where the functions would accept different parameter sets and produce expected behavior from the function.",
        "createdAt" : "2018-04-19T19:53:32Z",
        "updatedAt" : "2018-04-19T19:53:32Z",
        "lastEditedBy" : "ef9ed909-4847-44e0-93f7-80a4cd29e74e",
        "tags" : [
        ]
      },
      {
        "id" : "cf1b064b-2382-4675-a09e-7fa83a5a2c98",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "body" : "Well, Ramda is basically a helper library. When you want to convince people to use it, it must be simple to use. You can already have a good function, which returns a \"good enough\" string. This function can easily require more/less params then function, which you want to memoize. By forcing the same arguments list, you need to introduce a wrapper, which is basically a boilerplate code, to make TypeScript happy. Then, is Ramda really helping you if you need to introduce boilerplate to make type checker happy? That is a reason why people moved to languages without typedefs - a lot of boilerplate just to satisfy compiler.\r\n\r\nAlso, we are still in JavaScript. Providing more parameters to function, which actually accepts less arguments is a language feature. We are using TypeScript to help us, not to change the language behaviour. Consider lodash's `memoize` function. You can create the same memoize function in ramda by `memoizeWith(identity, fn)`. It will always use just a first argument.\r\n\r\nIn addition, we are talking about type definition of Ramda's `memoizeWith`. So, we should ask one simple question: Does this function require two functions with the same arguments? If yes, then ok, we should require them, if no, then we should not require them. I think the answer is NO.\r\n\r\nOn  the other side, I fully understand your suggestion. My opinion is just that a usage of helper library (Ramda) should be as easy as possible and without a necessary boilerplate.\r\n",
        "createdAt" : "2018-04-20T04:53:38Z",
        "updatedAt" : "2018-04-20T05:06:05Z",
        "lastEditedBy" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "tags" : [
        ]
      },
      {
        "id" : "a1be57b1-08b1-46d8-bad0-27b5b62c50a7",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "72973e8b-b1ba-4186-a2e7-1e30e4720971",
        "body" : "This is an argument about nothing.\r\n\r\nTypeScript will happily allow a function that accepts fewer arguments than suggested by a type, so the argument about wrapper functions is misguided at best. And if `keyFn` *requires* more arguments than `fn`, this would indeed be a type error. Remember, TypeScript uses *structural* equivalence, not *nominal*, so if types *can* be reasonably unified, they *will* be.\r\n\r\nHowever, there is currently no good way to express such relation between functions in TypeScript. There is a horrible way kinda similar to what we did in C++ before variadic templates, which I do not at all advocate using, and if anything I'm advocating against, but I am providing it here as a reference to make a point nonetheless:\r\n\r\n- [TS Playground](https://www.typescriptlang.org/play/#src=type%20SubsString%3CT%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E%20%3D%0AT%20extends%20(x1%3A%20infer%20U1%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2Cx5%3A%20infer%20U5%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2Cx5%3A%20U5%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2Cx5%3A%20infer%20U5%2Cx6%3A%20infer%20U6%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2Cx5%3A%20U5%2Cx6%3A%20U6%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2Cx5%3A%20infer%20U5%2Cx6%3A%20infer%20U6%2Cx7%3A%20infer%20U7%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2Cx5%3A%20U5%2Cx6%3A%20U6%2Cx7%3A%20U7%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2Cx5%3A%20infer%20U5%2Cx6%3A%20infer%20U6%2Cx7%3A%20infer%20U7%2Cx8%3A%20infer%20U8%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2Cx5%3A%20U5%2Cx6%3A%20U6%2Cx7%3A%20U7%2Cx8%3A%20U8%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2Cx5%3A%20infer%20U5%2Cx6%3A%20infer%20U6%2Cx7%3A%20infer%20U7%2Cx8%3A%20infer%20U8%2Cx9%3A%20infer%20U9%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2Cx5%3A%20U5%2Cx6%3A%20U6%2Cx7%3A%20U7%2Cx8%3A%20U8%2Cx9%3A%20U9%2C)%20%3D%3E%20string%3A%0AT%20extends%20(x1%3A%20infer%20U1%2Cx2%3A%20infer%20U2%2Cx3%3A%20infer%20U3%2Cx4%3A%20infer%20U4%2Cx5%3A%20infer%20U5%2Cx6%3A%20infer%20U6%2Cx7%3A%20infer%20U7%2Cx8%3A%20infer%20U8%2Cx9%3A%20infer%20U9%2Cx10%3A%20infer%20U10%2C)%20%3D%3E%20any%20%3F%20(x1%3A%20U1%2Cx2%3A%20U2%2Cx3%3A%20U3%2Cx4%3A%20U4%2Cx5%3A%20U5%2Cx6%3A%20U6%2Cx7%3A%20U7%2Cx8%3A%20U8%2Cx9%3A%20U9%2Cx10%3A%20U10%2C)%20%3D%3E%20string%3A%0A(...args%3A%20any%5B%5D)%20%3D%3E%20string%0A%0Adeclare%20function%20memoizeWith%3CT%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20any%3E(keyFn%3A%20SubsString%3CT%3E%2C%20fn%3A%20T)%3A%20T%0A%0Aconst%20f%20%3D%20memoizeWith(()%20%3D%3E%20%22%22%2C%20(a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20string)%20%3D%3E%20a%20%2B%20b%20%2B%20c)%20%2F%2F%20ok%0Aconst%20g%20%3D%20memoizeWith((x1%3A%20number)%20%3D%3E%20%22%22%2C%20(a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20string)%20%3D%3E%20a%20%2B%20b%20%2B%20c)%20%2F%2F%20ok%0Aconst%20h%20%3D%20memoizeWith((x1%3A%20string)%20%3D%3E%20%22%22%2C%20(a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20string)%20%3D%3E%20a%20%2B%20b%20%2B%20c)%20%2F%2F%20type%20error%0Aconst%20p%20%3D%20memoizeWith((x1%3A%20number%2C%20x2%3A%20number%2C%20x3%3A%20string)%20%3D%3E%20%22%22%2C%20(a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20string)%20%3D%3E%20a%20%2B%20b%20%2B%20c)%20%2F%2F%20ok%0Aconst%20r%20%3D%20memoizeWith((x1%3A%20number%2C%20x2%3A%20number%2C%20x3%3A%20string%2C%20x4%3F%3A%20boolean)%20%3D%3E%20%22%22%2C%20(a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20string)%20%3D%3E%20a%20%2B%20b%20%2B%20c)%20%2F%2F%20ok%0Aconst%20s%20%3D%20memoizeWith((x1%3A%20number%2C%20x2%3A%20number%2C%20x3%3A%20string%2C%20x4%3A%20boolean)%20%3D%3E%20%22%22%2C%20(a%3A%20number%2C%20b%3A%20number%2C%20c%3A%20string)%20%3D%3E%20a%20%2B%20b%20%2B%20c)%20%2F%2F%20type%20error)\r\n- [Gist](https://gist.github.com/lierdakil/f4d1888dd1d708df0378a53740965812)\r\n\r\nP.S. To summarize, there's no reason against narrowing `keyFn` argument types, but there's no good way to do it either -- unless you're fine with a convoluted limited mess that'll only work on TS 2.8.",
        "createdAt" : "2018-04-20T07:32:42Z",
        "updatedAt" : "2018-04-20T07:39:01Z",
        "lastEditedBy" : "72973e8b-b1ba-4186-a2e7-1e30e4720971",
        "tags" : [
        ]
      },
      {
        "id" : "2c929219-3ae9-46ae-8764-e8be69b0fd0e",
        "parentId" : "3175ea47-3556-4e48-b91e-74a95d3ae98b",
        "authorId" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "body" : "@lierdakil Awesome, thanks for a comment.\r\n\r\nI need to **apologies** to everyone as I didn't know that TypeScript will happily allows a function that accepts fewer arguments... It actually makes sense ðŸ™‚ \r\n\r\nWe should end this discussion with a conclusion:\r\nWe want to narrow `keyFn` types, but we need to wait (probably for an infinite amount of time) as not everyone is using TS 2.8. So, lets merge it as it is now.\r\n",
        "createdAt" : "2018-04-20T08:11:13Z",
        "updatedAt" : "2018-04-20T08:31:51Z",
        "lastEditedBy" : "8e07db17-97b9-4d1c-ada6-211e06f5b7e4",
        "tags" : [
        ]
      }
    ],
    "commit" : "f8a1249f017f05c34e4f31cb2da2ca709cb541c2",
    "line" : 17,
    "diffHunk" : "@@ -1,1 +1034,1038 @@         * Care must be taken when implementing key generation to avoid clashes that may overwrite previous entries erroneously.\n         */\n        memoizeWith<T extends (...args: any[]) => any>(keyFn: (...v: any[]) => string, fn: T): T;\n\n        /**"
  }
]
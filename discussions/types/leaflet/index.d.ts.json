[
  {
    "id" : "450dd623-7fa1-4f5a-be3a-e689ad6adbf0",
    "prId" : 24030,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24030#pullrequestreview-102415322",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "79b3499c-3e6a-4851-a28a-c8671259f595",
        "parentId" : null,
        "authorId" : "e69aeb27-47fc-4a1b-8bc1-8dc65c6b8bc0",
        "body" : "According to the [Leaflet documentation](http://leafletjs.com/reference-1.3.0.html#polyline-getlatlngs) it should return `LatLng[]` for simple polylines and `LatLng[][]` for multi-polylines. But you are also allowed to nest them as you with. For example also this type would be processed `LatLng[][][][][]`, but I think it makes no sense to make a long list of possible nesting. So in my opinions the return type should be: `LatLng[] | LatLng[][]`! It covers both different kinds of polylines and multi-polylines.\r\n\r\n@mcauer Do you have  a reason for `LatLng[][][]`?\r\n\r\nAnother approach would be a type like mentioned below, but as far as I know a circular type is not allowed:\r\n\r\n```typescript\r\ntype NestedPolyline = LatLng[] | NestedPolyline[];\r\n```",
        "createdAt" : "2018-03-08T08:12:24Z",
        "updatedAt" : "2018-03-08T08:13:12Z",
        "lastEditedBy" : "e69aeb27-47fc-4a1b-8bc1-8dc65c6b8bc0",
        "tags" : [
        ]
      },
      {
        "id" : "193543ee-2caa-4108-a7d4-1e0e583e58c9",
        "parentId" : "79b3499c-3e6a-4851-a28a-c8671259f595",
        "authorId" : "d5a0a2c6-8835-4d41-b5f1-54628abc891b",
        "body" : "I agree for Polylines. But as the method is also inherited by Polygons. A multipolygon with holes may return LatLng[][][]. See examples of Multipolygon: http://leafletjs.com/reference-1.3.0.html#polygon\r\nOr can we have different return types for the getLatLngs() method for Polylines and Polygons?",
        "createdAt" : "2018-03-08T09:03:39Z",
        "updatedAt" : "2018-03-08T09:03:39Z",
        "lastEditedBy" : "d5a0a2c6-8835-4d41-b5f1-54628abc891b",
        "tags" : [
        ]
      },
      {
        "id" : "b3858d1b-3ac1-4508-a12a-29c4a024ba0a",
        "parentId" : "79b3499c-3e6a-4851-a28a-c8671259f595",
        "authorId" : "e69aeb27-47fc-4a1b-8bc1-8dc65c6b8bc0",
        "body" : "For now it is the best result with less work. We can't inherit from Polyline when we want to make it exact. What do you think @alejo90? Should we make it exact and introduce other interfaces or classes that even do not exists - just for extending? Should we not extend from Polyline and \"rewrite\" Polygon without extending from Polyline? Or should we simply solve it with this PR?",
        "createdAt" : "2018-03-08T19:03:34Z",
        "updatedAt" : "2018-04-11T18:04:48Z",
        "lastEditedBy" : "e69aeb27-47fc-4a1b-8bc1-8dc65c6b8bc0",
        "tags" : [
        ]
      }
    ],
    "commit" : "d15cc69dfb10fc10e80c921917d7798387679b9e",
    "line" : 13,
    "diffHunk" : "@@ -1,1 +585,589 @@    constructor(latlngs: LatLngExpression[], options?: PolylineOptions);\n    toGeoJSON(): geojson.Feature<T, P>;\n    getLatLngs(): LatLng[] | LatLng[][] | LatLng[][][];\n    setLatLngs(latlngs: LatLngExpression[]): this;\n    isEmpty(): boolean;"
  }
]
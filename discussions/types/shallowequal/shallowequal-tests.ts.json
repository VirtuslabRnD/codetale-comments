[
  {
    "id" : "07763b50-b4b0-4fc9-a3a8-7a39b17d1c0c",
    "prId" : 31765,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/31765#pullrequestreview-188867361",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "f6cd815a-44db-40c7-8712-5a35e14636c4",
        "parentId" : null,
        "authorId" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "body" : "I don't know what the current state of the art is on the whole `* as` versus `= require` import styles in Typescript. I see you also deleted the `declare namespace`; will this work properly with both import styles?",
        "createdAt" : "2018-12-29T20:34:00Z",
        "updatedAt" : "2018-12-29T20:34:00Z",
        "lastEditedBy" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "tags" : [
        ]
      },
      {
        "id" : "4f25b4b8-ef3b-4b51-a48a-b5ffa134493e",
        "parentId" : "f6cd815a-44db-40c7-8712-5a35e14636c4",
        "authorId" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "body" : "No, it won't work any more, but this is on purpose.\r\n\r\nThere is a [clear statement](https://github.com/DefinitelyTyped/DefinitelyTyped#a-package-uses-export--but-i-prefer-to-use-default-imports-can-i-change-export--to-export-default) on how to handle synthetic default imports. It boils down to activating either `allowSyntheticDefaultImports` or `esModuleInterop` compiler options. This is nothing that has to be emulated via type definitions, especially if it won't actually work in some environments.",
        "createdAt" : "2018-12-29T20:52:21Z",
        "updatedAt" : "2018-12-29T20:52:21Z",
        "lastEditedBy" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "tags" : [
        ]
      },
      {
        "id" : "b2852248-ee7b-4d3a-a106-0f2a5518680e",
        "parentId" : "f6cd815a-44db-40c7-8712-5a35e14636c4",
        "authorId" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "body" : "I don't think that statement is relevant; neither of the import styles I mentioned are default imports. They should be more or less interchangeable because they both bind the imported name to the function, though they may compile differently (which is why I asked in the first place). That's why there was a `declare namespace` line originally. But I don't use these typings anymore anyway, so whatever.",
        "createdAt" : "2018-12-31T17:55:34Z",
        "updatedAt" : "2018-12-31T17:55:34Z",
        "lastEditedBy" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "tags" : [
        ]
      },
      {
        "id" : "5fbc9a16-014f-4ff0-972f-28aadaeb2620",
        "parentId" : "f6cd815a-44db-40c7-8712-5a35e14636c4",
        "authorId" : "8153deff-5248-4aa9-a800-b98b4fb63ca0",
        "body" : "It's more of a statement of fact - namespace imports cannot be callable or constructable in es6, so TS attempts to enforce that (it was loose before and a namespace merge could trip it up). So an `import = require` is the canonical way to do an interopy import that is just a require call, which can be callable or constructable.",
        "createdAt" : "2018-12-31T18:02:19Z",
        "updatedAt" : "2018-12-31T18:02:19Z",
        "lastEditedBy" : "8153deff-5248-4aa9-a800-b98b4fb63ca0",
        "tags" : [
        ]
      },
      {
        "id" : "91a385e1-dbda-4cd8-a23d-2861cd9eac6d",
        "parentId" : "f6cd815a-44db-40c7-8712-5a35e14636c4",
        "authorId" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "body" : "I see, thanks!",
        "createdAt" : "2019-01-02T23:35:31Z",
        "updatedAt" : "2019-01-02T23:35:32Z",
        "lastEditedBy" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "tags" : [
        ]
      }
    ],
    "commit" : "d374638afde9a7de8db56fa17aedbdf8dfc58f74",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +-1,3 @@import shallowEqual = require('shallowequal');\n\nconst a = {};"
  }
]
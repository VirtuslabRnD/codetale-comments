[
  {
    "id" : "d67d48ac-2927-46be-80be-11de06eec27f",
    "prId" : 32629,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/32629#pullrequestreview-199019331",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "parentId" : null,
        "authorId" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "body" : "A namespace for this is a little heavyweight; what about just doing an `export type` at the top level?",
        "createdAt" : "2019-01-30T20:56:42Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "tags" : [
        ]
      },
      {
        "id" : "605ce085-8031-4b9e-9ecf-bafea5709f01",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "9328a627-78d8-4ef0-963b-fb5cedadd300",
        "body" : "I'd like to go with the namespace approach, because it's not breaking existing codebases. Currently you can use multiple ways of importing the `shallowequal`, e.g.\r\n\r\n`import shallowequal from 'shallowequal`\r\n`import eq from 'shallowequal'`\r\n\r\nIf you export the type on top level, you break this, because you have to use\r\n\r\n`import { shallowEqual } from 'shallowequal'`\r\n\r\nor\r\n\r\n`import { shallowEqual, Comparer } from 'shallowequal'`\r\n\r\nSo I think it's a good tradeoff to have a namespace which might not be necessary instead of breaking existing codebases.",
        "createdAt" : "2019-01-31T09:12:07Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "9328a627-78d8-4ef0-963b-fb5cedadd300",
        "tags" : [
        ]
      },
      {
        "id" : "c2c206b9-5d7f-47f4-a267-9677ce0ec09b",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "body" : "To me, it's kinda more idiomatic to not return anything instead of an `undefined` value. Why did you change this, was there a technical reason or purely aethetical?",
        "createdAt" : "2019-01-31T16:42:19Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "tags" : [
        ]
      },
      {
        "id" : "3bd8d61a-ba33-4562-b22a-7313cb3e49ec",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "body" : "It's legal to mix default and non-default imports, so you should be able to `import eq, { Comparer } from 'shallowequal';` meaning it'll be backwards-compatible.\r\n\r\nIn any case, I don't mind either way aesthetically speaking, but I do know that namespace-merging is sometimes considered an anti-pattern, which is why I raised it.\r\n\r\nI'm okay with these changes as-is; I'll defer to @BendingBender to approve since they've got other comments.",
        "createdAt" : "2019-01-31T17:44:58Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "tags" : [
        ]
      },
      {
        "id" : "1bf7f3b5-7ea7-45f7-94b1-c0218a85ed06",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "9328a627-78d8-4ef0-963b-fb5cedadd300",
        "body" : "The change I made is not aesthetical.\r\n\r\nThe shallowequal documentation clearly stated, that the `customizer` function shall return `true`, `false` or `undefined`. This is also covered by the comparison in the code of shallowequal: \r\n```javascript\r\nif (ret === false || (ret === void 0 && valueA !== valueB)) {\r\n  return false;\r\n}\r\n```\r\n\r\n`void 0` is equal to `undefined`, while `void` may contain `null` or `undefined`. When using `boolean | void` as result for the compare function, implicit return of `undefined` is okayish. But it's also possible to return `null`, which is evaluated falsy. But based on the shallowequal code it's `true` for the comparison of `valueA` and `valueB`.\r\n\r\nSince you may not have compared the values in your code but accidentally return `null` when `strictNullChecks` is `false` (which I assume is in many legacy codebases), it's a source of hard to find errors. I agree that the accidentally return of `null` is not very likely when `strictNullChecks`\r\n\r\nBut considering all this: that's why I changed the signature to `undefined`.",
        "createdAt" : "2019-01-31T22:10:16Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "9328a627-78d8-4ef0-963b-fb5cedadd300",
        "tags" : [
        ]
      },
      {
        "id" : "e4f71e7e-3858-45d1-95df-bd8e7886c908",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "body" : "Sorry, maybe I misunderstand you, but I've tested what you said and it seems not to be correct.\r\n\r\nFollowing code was run with `\"strictNullChecks\": \"true\"`:\r\n```typescript\r\nconst u: undefined = null; // error\r\nconst n: null = undefined; // error\r\nconst v: void = null; // error\r\nconst v1: void = undefined; // ok\r\nconst v2: void = void 0; // ok\r\n\r\nfunction a(): void {\r\n  return undefined; // ok\r\n}\r\n\r\nfunction b(): undefined {} // error\r\n\r\nfunction c(): undefined {\r\n    return null; // error\r\n}\r\n```\r\n\r\nThe same code with `\"strictNullChecks\": \"false\"`:\r\n```typescript\r\nconst u: undefined = null; // ok\r\nconst n: null = undefined; // ok\r\nconst v: void = null; // ok\r\nconst v1: void = undefined; // ok\r\nconst v2: void = void 0; // ok\r\n\r\nfunction a(): void {\r\n  return undefined; // ok\r\n}\r\n\r\nfunction b(): undefined {} // error\r\n\r\nfunction c(): undefined {\r\n    return null; // ok\r\n}\r\n```\r\n\r\nSo actually, in non-`strictNullChecks` mode the only difference between `void` and `undefined` is that the former doesn't require a return value, while the latter requires an explicit return of `undefined`.\r\n\r\nIt doesn't protect you from incorrectly returning `null` in non-`strictNullChecks` mode.",
        "createdAt" : "2019-02-01T00:02:21Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "tags" : [
        ]
      },
      {
        "id" : "d9f47e56-4b1c-4456-8428-17407280896c",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "body" : "> I'd like to go with the namespace approach, because it's not breaking existing codebases. Currently you can use multiple ways of importing the `shallowequal`, e.g.\r\n> \r\n> `import shallowequal from 'shallowequal`\r\n> `import eq from 'shallowequal'`\r\n> \r\n> If you export the type on top level, you break this, because you have to use\r\n> \r\n> `import { shallowEqual } from 'shallowequal'`\r\n> \r\n> or\r\n> \r\n> `import { shallowEqual, Comparer } from 'shallowequal'`\r\n> \r\n> So I think it's a good tradeoff to have a namespace which might not be necessary instead of breaking existing codebases.\r\n\r\n@seansfkelley Actually, the way @arndissler implemented it is the only valid solution. You can't use a default export here because of what is described [here](https://github.com/DefinitelyTyped/DefinitelyTyped#a-package-uses-export--but-i-prefer-to-use-default-imports-can-i-change-export--to-export-default). And you can't have multiple `export` statements in a `d.ts` file that has a `export = ...` export.",
        "createdAt" : "2019-02-01T00:07:08Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "tags" : [
        ]
      },
      {
        "id" : "1ae6d575-0dbe-4728-b223-c8f224f9c9d5",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "body" : "Ah, thanks for the clarification. Default exports/CommonJS exports/namespace merging always get jumbled up in my head.\r\n\r\nFWIW, I think that\r\n\r\n> it's kinda more idiomatic to not return anything instead of an `undefined` value\r\n\r\nis true; if there is no type safety to be gained by changing from `void` to `undefined` then it's probably best left as `void`.\r\n\r\nIf you, like me, are the kind of person who doesn't like that idiom, you can always turn on `noImplicitReturns` to make sure you don't let control fall off the end of the function.",
        "createdAt" : "2019-02-01T02:23:32Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "dbc0e58d-9f4d-41a9-9fd8-c0b24e9aab13",
        "tags" : [
        ]
      },
      {
        "id" : "8052dd31-a122-46b9-8d93-ca68950fc291",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "9328a627-78d8-4ef0-963b-fb5cedadd300",
        "body" : "I totally agree that it's comfortable to not explicitly write a `return undefined`. \r\n\r\nAccording to how it is implemented in `shallowequal`, the only valid return values for the `customizer` function are `true`, `false`, `undefined`. If you **don't** enable `strictNullChecks` then the return types are `true`, `false`, `null` and `undefined`, which matches to `void`. My assumption was, that TypeScript's `strictNullCheck` will remove the nullable option from `boolean`, so I wrote `boolean | undefined` to avoid the nullability of `void`. \r\n\r\nMy mistake was that I didn't expect TypeScript to remove `null` from `void` when using `strictNullChecks`. So I'll go with changing it back to `void`. Thanks for the discussion üëç \r\n\r\nSince I will make some changes to this PR, should I change the name of the parameter `compare` and it's type `Comparer` to `customizer` and `Customizer`, so it matches with shallowequals documentation?",
        "createdAt" : "2019-02-01T08:56:47Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "9328a627-78d8-4ef0-963b-fb5cedadd300",
        "tags" : [
        ]
      },
      {
        "id" : "e3f0a5c7-7cfb-436e-b315-44986bf17e40",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "body" : "> Since I will make some changes to this PR, should I change the name of the parameter `compare` and it's type `Comparer` to `customizer` and `Customizer`, so it matches with shallowequals documentation?\r\n\r\nSounds reasonable to me.",
        "createdAt" : "2019-02-01T10:48:44Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "tags" : [
        ]
      },
      {
        "id" : "6bc44b70-6497-492f-957b-b7264248210f",
        "parentId" : "2dbe6d9d-ca49-4c50-b33b-ae8f816b4556",
        "authorId" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "body" : "> My mistake was that I didn't expect TypeScript to remove `null` from `void` when using `strictNullChecks`. So I'll go with changing it back to `void`. Thanks for the discussion üëç\r\n\r\nThank you for being patient with me being pedantic.",
        "createdAt" : "2019-02-01T10:50:10Z",
        "updatedAt" : "2019-02-02T20:20:35Z",
        "lastEditedBy" : "b020629e-b52b-403a-98c4-dd5d98f3aa6b",
        "tags" : [
        ]
      }
    ],
    "commit" : "b9aeb08f810ba67a9829d1a51e1f6492e76ec08f",
    "line" : 23,
    "diffHunk" : "@@ -1,1 +21,25 @@        indexOrKey?: number | string\n    ) => boolean | void;\n}\n\nexport = shallowEqual;"
  }
]
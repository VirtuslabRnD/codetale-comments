[
  {
    "id" : "d264d577-b801-45e7-bd17-5d06470207a8",
    "prId" : 17306,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/17306#pullrequestreview-47181682",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "parentId" : null,
        "authorId" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "body" : "Sorry to be so late in reviewing this, but does this work for something like:\r\n\r\n```js\r\nfooProm = fooProm.catch(CustomError1, booObject2, booPredicate3, error => {});\r\n```\r\n\r\nIt seems like the these new definitions only allow you to use predicate objects/functions **OR** error classes/constructors, but not both in the same `.catch()`. Am I mistaken?",
        "createdAt" : "2017-06-27T16:31:54Z",
        "updatedAt" : "2017-06-27T16:34:23Z",
        "lastEditedBy" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "tags" : [
        ]
      },
      {
        "id" : "7fea942e-db0b-44c6-9db6-9aa73cc43e33",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "70551236-3284-4045-ad07-d3700c786022",
        "body" : "Hi @jcready, thanks for your review.\r\n\r\nIndeed, actually there are two cases covered here:\r\n\r\n- For *any* `catch` where *all* `E extends Error`\r\n\r\n  ```typescript\r\n  filter1: (new (...args: any[]) => E1)\r\n  ```\r\n\r\n- For *any* `catch` where *all* _generic_  `E` are _predicates_ or _object_-like\r\n\r\n  ```typescript\r\n  filter1: ((error: E1) => boolean) | (E1 & object)\r\n  ```\r\n\r\nAnd both are mutually exclusive\r\n\r\n```typescript\r\nfooProm.catch(\r\n  CustomError1,\r\n  booObject2,\r\n  booPredicate3,\r\n  error => {}\r\n);\r\n```\r\n\r\nSo, your example will try to match the 2nd case, and I think it will pass because even if `CustomError1` is not an _instance_ it is still an _object_-like.",
        "createdAt" : "2017-06-27T18:39:55Z",
        "updatedAt" : "2017-06-27T18:39:55Z",
        "lastEditedBy" : "70551236-3284-4045-ad07-d3700c786022",
        "tags" : [
        ]
      },
      {
        "id" : "be93b339-6b88-49a5-aa80-10962dfd271b",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "body" : "Ah, okay. I guess the only downside in this case is that you might get auto-complete options for the static keys of `CustomError1` instead of the keys of an instance of `CustomError1`. Is that correct?",
        "createdAt" : "2017-06-27T18:52:12Z",
        "updatedAt" : "2017-06-27T18:52:12Z",
        "lastEditedBy" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "tags" : [
        ]
      },
      {
        "id" : "ebe697d7-2e8d-4c02-a3ae-e7b60b66245d",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "dddc05e9-6ff4-4fbc-927a-c3aa76c2c851",
        "body" : "@jcready Ah damn... I missed that. I don't see how we could \"easily\" fix this issue though, or do you?",
        "createdAt" : "2017-06-27T19:46:39Z",
        "updatedAt" : "2017-06-27T19:46:39Z",
        "lastEditedBy" : "dddc05e9-6ff4-4fbc-927a-c3aa76c2c851",
        "tags" : [
        ]
      },
      {
        "id" : "40ddaff7-e7a9-4e8b-8606-5443255d1bcb",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "body" : "@lhecker nope, not without listing out **every** combination for each arity. :hurtrealbad:",
        "createdAt" : "2017-06-27T19:51:33Z",
        "updatedAt" : "2017-06-27T19:51:33Z",
        "lastEditedBy" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "tags" : [
        ]
      },
      {
        "id" : "cc5248be-08b2-4235-adaa-bbe52194dd5c",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "70551236-3284-4045-ad07-d3700c786022",
        "body" : "not only that, but the generig match will mislead the type check",
        "createdAt" : "2017-06-27T19:53:00Z",
        "updatedAt" : "2017-06-27T19:53:00Z",
        "lastEditedBy" : "70551236-3284-4045-ad07-d3700c786022",
        "tags" : [
        ]
      },
      {
        "id" : "b7ec13cc-e1cd-4bda-b3d4-a7e7b98ad840",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "dddc05e9-6ff4-4fbc-927a-c3aa76c2c851",
        "body" : "@jcready @well1791 The solution in this PR still better than what we had before though, right?",
        "createdAt" : "2017-06-29T12:18:03Z",
        "updatedAt" : "2017-06-29T12:18:03Z",
        "lastEditedBy" : "dddc05e9-6ff4-4fbc-927a-c3aa76c2c851",
        "tags" : [
        ]
      },
      {
        "id" : "c2664037-bb45-428a-97ce-86af23cbcf4f",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "body" : "@lhecker yes it is certainly better. The problem is that it is still unsound.\r\n\r\n```js\r\nclass CustomError1 extends Error {\r\n  static foo : number = 1\r\n  constructor (message) {\r\n    super(message)\r\n    this.foo : string = 'bar'\r\n  }\r\n}\r\n\r\nfooProm.catch(CustomError1, booObject2, booPredicate3, (error) => {\r\n  error.foo // expecting a string, TS thinks it's a number\r\n})\r\n```\r\n\r\nI'm not sure which is worse for the developer. Having TS incorrectly refine the `error` or not having TS refine it at all (e.g. `any`).",
        "createdAt" : "2017-06-29T13:20:55Z",
        "updatedAt" : "2017-06-29T13:20:55Z",
        "lastEditedBy" : "9168b5fd-03a0-4992-b59f-a14bb9ae414c",
        "tags" : [
        ]
      },
      {
        "id" : "3ecfa61b-47f2-4b8e-96f3-1aea7f4505aa",
        "parentId" : "0f09ed63-282e-40c1-8930-80a0ee1968f0",
        "authorId" : "70551236-3284-4045-ad07-d3700c786022",
        "body" : "Well, the changes I did for this PR were mostly in this way\r\n\r\nTo check for `Error` instances\r\n\r\n```diff\r\ncatch<E1 extends Error, ..., E5 extends Error>\r\n-  filter1: (new (...args: any[]) => E1) | ((error: E1) => boolean) | E1,\r\n+  filter1: (new (...args: any[]) => E1),\r\n```\r\n\r\nand for any primitive type (as bluebird allow it)\r\n\r\n```diff\r\ncatch<E1, ..., E5>(\r\n-  filter1: ((error: E1) => boolean) | E1,\r\n+  filter1: ((error: E1) => boolean) | E1 & object,\r\n```\r\n\r\nBut, the problem remains in that `E1` is (still) too generic, so I'm afraid you may end up loosing type check for error instances.\r\n\r\nThe only thing that comes to my mind is to have a _complement_ type, which excludes all possible values between 2 types, something like `E excepts Error` or `E excludes Error`:\r\n\r\n```typescript\r\ncatch<E1 extends Error, ..., E5 extends Error>\r\n  filter1: (new (...args: any[]) => E1) | ((error: E1) => boolean) | E1,\r\n```\r\n\r\n```typescript\r\ncatch<E1 excepts Error, ..., E5 excepts Error>(\r\n  filter1: ((error: E1) => boolean) | E1,\r\n```",
        "createdAt" : "2017-06-29T16:34:37Z",
        "updatedAt" : "2017-06-29T16:34:37Z",
        "lastEditedBy" : "70551236-3284-4045-ad07-d3700c786022",
        "tags" : [
        ]
      }
    ],
    "commit" : "a8617ad7c7c5b12e04d668d60d2cfeffef9c9236",
    "line" : 27,
    "diffHunk" : "@@ -1,1 +397,401 @@\tfooProm = fooProm.catch(booObject1, booObject2, booObject3, error => {});\n\tfooProm = fooProm.catch(booObject1, booObject2, booObject3, booObject4, error => {});\n\tfooProm = fooProm.catch(booObject1, booObject2, booObject3, booObject4, booObject5, error => {});\n}\n"
  },
  {
    "id" : "389d261f-67a3-4fbe-86f2-7a4484b57f56",
    "prId" : 22167,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/22167#pullrequestreview-83312043",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "efc3e870-a03d-44e8-9705-381a22d1c62e",
        "parentId" : null,
        "authorId" : "83dd42c5-fd1b-4f69-a4a9-cb89643caf20",
        "body" : "Changed this so that the tests will fail if this isn't inferred correctly.",
        "createdAt" : "2017-12-13T20:46:53Z",
        "updatedAt" : "2017-12-13T20:46:53Z",
        "lastEditedBy" : "83dd42c5-fd1b-4f69-a4a9-cb89643caf20",
        "tags" : [
        ]
      }
    ],
    "commit" : "42b8e18474291dc7ee3e233b19b3c8cf60bac967",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +353,357 @@}\n// $ExpectType Bluebird<void | Foo>\nfooProm.catch(CustomError, reason => {\n\tlet a: number = reason.customField;\n});"
  },
  {
    "id" : "d7d659f4-3ce1-4085-9986-8b4fb9d18790",
    "prId" : 26773,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/26773#pullrequestreview-131394687",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e03e79c6-4eed-4cd2-a892-ce67fb1b0ecf",
        "parentId" : null,
        "authorId" : "26c05778-4426-489f-a8a1-2a6af08f6974",
        "body" : "This test doesn't really do much. It asserts that `Promise.method(anyFunc)` will return `(...args: any[]) => Promise<any>`, which does not test the overload cases.",
        "createdAt" : "2018-06-23T13:27:01Z",
        "updatedAt" : "2018-06-23T13:27:01Z",
        "lastEditedBy" : "26c05778-4426-489f-a8a1-2a6af08f6974",
        "tags" : [
        ]
      }
    ],
    "commit" : "e4204b79f7a0b06f60caabaa8862f7f39fa61303",
    "line" : 3,
    "diffHunk" : "@@ -1,1 +784,788 @@// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nasyncfunc = Promise.method(() => {});\n{\n\tconst noArg: () => Promise<void> = Promise.method(() => {});"
  }
]
[
  {
    "id" : "5341304b-8632-4b55-b54f-b76e619faf98",
    "prId" : 31948,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/31948#pullrequestreview-189996480",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "2938397f-a61c-4b66-8d9d-3e1c59ab3918",
        "parentId" : null,
        "authorId" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "body" : "may be worth using `unknown[]`, though it wouldn't make a difference other than one less `any` :p",
        "createdAt" : "2019-01-07T20:33:23Z",
        "updatedAt" : "2019-01-07T20:33:23Z",
        "lastEditedBy" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "tags" : [
        ]
      },
      {
        "id" : "930c5371-2900-4a34-89b4-fdb8b367eafd",
        "parentId" : "2938397f-a61c-4b66-8d9d-3e1c59ab3918",
        "authorId" : "4316e44d-461c-4e33-8f9e-87e705b6e3cc",
        "body" : "For arguments you pass it's pretty much irrelevant as `any` and `unknown` would be equivalent in this case, if it was the return value I'd agree.",
        "createdAt" : "2019-01-07T20:57:24Z",
        "updatedAt" : "2019-01-07T20:57:24Z",
        "lastEditedBy" : "4316e44d-461c-4e33-8f9e-87e705b6e3cc",
        "tags" : [
        ]
      },
      {
        "id" : "b2d15915-93e7-409c-a0e3-c1ae18ba9a72",
        "parentId" : "2938397f-a61c-4b66-8d9d-3e1c59ab3918",
        "authorId" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "body" : "Of course, as I had already mentioned it makes no difference but means one day we could have a no-any lint rule on which is nice. Just personal preference",
        "createdAt" : "2019-01-07T21:16:38Z",
        "updatedAt" : "2019-01-07T21:16:38Z",
        "lastEditedBy" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "tags" : [
        ]
      }
    ],
    "commit" : "cb292ea19ee36d2d0cf19605b24d6fcecf69db86",
    "line" : 7,
    "diffHunk" : "@@ -1,1 +1445,1449 @@         * Requires the value to be in the specified array.\n         */\n        in(allowed: any[]): SinonMatcher;\n        /**\n         * Requires the value to strictly equal ref."
  },
  {
    "id" : "5eb96379-3789-4c0b-9b0d-838a73ed5951",
    "prId" : 34048,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/34048#pullrequestreview-241080780",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "5bc5dbab-f61f-4f93-9f3d-7a8438b77cc4",
        "parentId" : null,
        "authorId" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "body" : "Unfortunately this does not work quite as intended. I assume your intention is that you can undersupply `TArgs`, i.e.:\r\n\r\n```ts\r\nlet spy: SinonSpy<[number, string, boolean], void>;\r\nspy.calledWith(1, \"a\", true); // fully supplied\r\nspy.calledWith(1, \"a\"); // undersupplied\r\nspy.calledWith(1); // undersupplied\r\nspy.calledWith(); // undersupplied\r\n```\r\n\r\nThe problem is that `Partial<[number, string, boolean]>` results in `[number?, string?, boolean?]`. While this *does* allow you to undersupply arguments, keep in mind that \r\nthe types in the tuple are actually expanded to `[(number | undefined)?, (string | undefined)?, (boolean | undefined)?]`, meaning that the following are *also* legal:\r\n\r\n```ts\r\nspy.calledWith(undefined, undefined, undefined); // fully supplied but invalid\r\nspy.calledWith(undefined, undefined); // undersupplied but invalid\r\nspy.calledWith(undefined); // undersupplied but invalid\r\n```\r\n\r\nUnfortunately, what you probably wanted was `[] | [number] | [number, string] | [number, string, boolean]`. Unfortunately, the type system today does not have a way\r\nto express this. It could be that this is an acceptable risk with regards to the soundness of `calledWith`. It *is* important to note that sinon does distinguish between\r\n`spy.calledWith(1, undefined)` and `spy.calledWith(1)` since it uses `arguments.length` to handle undersupplied arguments, so `spy.calledWith(undefined)` will probably just\r\nreturn `false`.",
        "createdAt" : "2019-05-22T23:08:40Z",
        "updatedAt" : "2019-05-23T09:27:13Z",
        "lastEditedBy" : "0762ec2f-c2e9-4296-915b-f2139e71b5ad",
        "tags" : [
        ]
      },
      {
        "id" : "6c87d062-a457-4911-98c5-00aa16e6f2b6",
        "parentId" : "5bc5dbab-f61f-4f93-9f3d-7a8438b77cc4",
        "authorId" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "body" : "i was aware of this but it seems until we have a way of representing it in the type system, its the closest solution and is still better than what we had (as what we had is broken, in that valid sinon code will not compile).\r\n\r\nif you agree then ill leave it as it is here, its an unfortunate compromise but again is better than what we have currently IMO",
        "createdAt" : "2019-05-23T09:16:47Z",
        "updatedAt" : "2019-05-23T09:27:13Z",
        "lastEditedBy" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "tags" : [
        ]
      }
    ],
    "commit" : "5d8c11028cf172e8e4592cc3677b50e3ae0e9bf0",
    "line" : 16,
    "diffHunk" : "@@ -1,1 +32,36 @@         * @param args\n         */\n        calledWith(...args: Partial<MatchArguments<TArgs>>): boolean;\n        /**\n         * Returns true if spy was called at least once with the provided arguments and no others."
  },
  {
    "id" : "bc6bd9a8-db10-4101-b16b-078d411567de",
    "prId" : 36119,
    "prUrl" : "https://github.com/DefinitelyTyped/DefinitelyTyped/pull/36119#pullrequestreview-248603212",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e5ee4745-1151-4670-b05f-ac564d896f22",
        "parentId" : null,
        "authorId" : "87ea4081-19b2-45ee-ba2f-f5165089f32e",
        "body" : "but this now means that if you do pass in the wrong type, the whole thing falls back to any and you lose all strong typing.\r\n\r\ni.e. if your stub returns `Promise<number>` and you do:\r\n\r\n```typescript\r\nmyStub.resolves('hello');\r\n```\r\n\r\nNow the inference will fail, and this falls back to `'hello'` which means this is broken.\r\n\r\nWhat happens if you resolve to `unknown` instead, then you could at least cast bad values:\r\n\r\n```typescript\r\nmyStub.resolves('hello' as unknown);\r\n```\r\n\r\n",
        "createdAt" : "2019-06-11T20:26:56Z",
        "updatedAt" : "2019-06-12T08:07:16Z",
        "lastEditedBy" : "87ea4081-19b2-45ee-ba2f-f5165089f32e",
        "tags" : [
        ]
      },
      {
        "id" : "723a3ebd-9930-4f7a-8935-bebf7b806d38",
        "parentId" : "e5ee4745-1151-4670-b05f-ac564d896f22",
        "authorId" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "body" : "no, it will not.\r\n\r\n`TReturnValue` is from the type parameters of the stub. You can't pass a string in, `TReturnValue` is `Promise<number>` which extends `PromiseLike<number>` which means `resolves(value?: number)` here.\r\n\r\nThis conditional type is nothing to do with what you've passed in, the condition is on the stub's return type, not the value you pass in.",
        "createdAt" : "2019-06-12T08:04:31Z",
        "updatedAt" : "2019-06-12T08:07:16Z",
        "lastEditedBy" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "tags" : [
        ]
      },
      {
        "id" : "edcca968-ca74-4deb-b4ce-add208c2fcbc",
        "parentId" : "e5ee4745-1151-4670-b05f-ac564d896f22",
        "authorId" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "body" : "i've added a test now to show you this is the case.\r\n\r\ndoes it make more sense now?",
        "createdAt" : "2019-06-12T08:07:57Z",
        "updatedAt" : "2019-06-12T08:11:25Z",
        "lastEditedBy" : "6aed7036-ec9d-4b50-94bf-43195544a50a",
        "tags" : [
        ]
      }
    ],
    "commit" : "add35b30683530131e35ce7c7d252ba7c57103af",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +405,409 @@         * Since sinon@2.0.0\n         */\n        resolves(value?: TReturnValue extends PromiseLike<infer TResolveValue> ? TResolveValue : any): SinonStub<TArgs, TReturnValue>;\n        /**\n         * Causes the stub to return a Promise which resolves to the argument at the provided index."
  }
]
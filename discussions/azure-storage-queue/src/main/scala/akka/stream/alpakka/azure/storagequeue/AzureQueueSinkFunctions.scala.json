[
  {
    "id" : "893e3f1b-17b5-4b48-8450-9d2399f8d9d4",
    "prId" : 287,
    "prUrl" : "https://github.com/akka/alpakka/pull/287#pullrequestreview-37600098",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "0ece934c-a19f-4270-ae7f-e16055ed6d8b",
        "parentId" : null,
        "authorId" : "7b601e48-f550-477f-a23e-0dc6ca34c971",
        "body" : "All these operations are blocking on network and must not be run on the default dispatcher but on a dedicated dispatcher for blocking operations, just like the future inside the `AzureQueueSourceStage`. \r\n\r\nI think the easiest way would be to actually get this right would be to get rid of that `FlowMapECStage`, take an implicit `ActorSystem` to the individual methods, look up the `akka.stream.default-blocking-io-dispatcher` from it and pass that as EC to the `mapAsync`s.\r\n\r\nAnother option would be to rather wrap these in a custom minimal stage and configure that to run on the blocking dispatcher using attributes (see other existing connectors for samples of this)",
        "createdAt" : "2017-05-11T15:15:41Z",
        "updatedAt" : "2017-05-17T05:32:42Z",
        "lastEditedBy" : "7b601e48-f550-477f-a23e-0dc6ca34c971",
        "tags" : [
        ]
      }
    ],
    "commit" : "a6f90f55866cc4e540bd1b670c3b1ed2b87a7c22",
    "line" : 12,
    "diffHunk" : "@@ -1,1 +10,14 @@case class UpdateVisibility(timeout: Int) extends DeleteOrUpdateMessage\n\nprivate[storagequeue] object AzureQueueSinkFunctions {\n  def addMessage(\n      cloudQueue: () => CloudQueue"
  }
]
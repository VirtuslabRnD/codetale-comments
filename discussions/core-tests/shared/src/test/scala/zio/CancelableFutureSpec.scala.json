[
  {
    "id" : "7c2f61d0-b552-4e0a-9243-c178555242ca",
    "prId" : 4115,
    "prUrl" : "https://github.com/zio/zio/pull/4115#pullrequestreview-471986570",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "d24ff9b5-dd4d-480a-8c52-30a6fa5bd16a",
        "parentId" : null,
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "It looks like we are hanging on attempting to interrupt, I think because our thread is waiting for the future to complete so it can return from the interruption rather than completing execution of the future.",
        "createdAt" : "2020-08-19T21:19:41Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "14e9e7ed-09d5-4e89-a089-8018f6e36938",
        "parentId" : "d24ff9b5-dd4d-480a-8c52-30a6fa5bd16a",
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "We could make sure that `unsafeRunToFuture` implementation does not block, but rather, uses Scala `Promise`.",
        "createdAt" : "2020-08-20T02:26:18Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      },
      {
        "id" : "3b0cb25e-22e5-499a-b2e7-cb2fdb39b5e0",
        "parentId" : "d24ff9b5-dd4d-480a-8c52-30a6fa5bd16a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "It actually does use `Promise` already, but apparently the current implementation is not sufficient.",
        "createdAt" : "2020-08-20T17:53:29Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      },
      {
        "id" : "0cc87ac4-8a50-4a0f-b8d1-67c54df191fe",
        "parentId" : "d24ff9b5-dd4d-480a-8c52-30a6fa5bd16a",
        "authorId" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "body" : "The issue was that the cancelation action returned by `unsafeRunAsyncCancelable` blocks for the cancelation to complete, which we can't afford to do when we only have a single thread. Added a new variant that takes a callback we can use to complete a Scala `Promise` and implemented the blocking version in terms of it.",
        "createdAt" : "2020-08-20T21:07:18Z",
        "updatedAt" : "2020-08-25T16:58:51Z",
        "lastEditedBy" : "e51a12a9-b5b7-4e30-a51d-293206825c6f",
        "tags" : [
        ]
      }
    ],
    "commit" : "e3fac45cf9f8ec359dadc1637487ba5e1d05608b",
    "line" : 1,
    "diffHunk" : "@@ -1,1 +49,53 @@          runtime <- ZIO.runtime[Any]\n          f        = runtime.unsafeRunToFuture(UIO.never)\n          _       <- UIO(f.cancel())\n          r       <- ZIO.fromFuture(_ => f).run\n        } yield assert(r.succeeded)(isFalse) // not interrupted, as the Future fails when the effect in interrupted."
  },
  {
    "id" : "28859f55-e184-4b70-861b-b7ca69aea8e6",
    "prId" : 1655,
    "prUrl" : "https://github.com/zio/zio/pull/1655#pullrequestreview-287619793",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "8945e3e7-b8c2-4587-8473-ca086570fc5a",
        "parentId" : null,
        "authorId" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "body" : "Love the new ZIO Test!",
        "createdAt" : "2019-09-12T18:23:33Z",
        "updatedAt" : "2019-09-28T09:29:30Z",
        "lastEditedBy" : "fb116aef-1bf2-4605-9639-255437a2e564",
        "tags" : [
        ]
      }
    ],
    "commit" : "e80ed91d9f0eabade892b391cb0f97aeb76761d5",
    "line" : 8,
    "diffHunk" : "@@ -1,1 +6,10 @@object CancelableFutureSpec\n    extends ZIOBaseSpec(\n      suite(\"CancelableFutureSpec\")(\n        testM(\"interrupts the underlying task on cancel\") {\n          for {"
  }
]
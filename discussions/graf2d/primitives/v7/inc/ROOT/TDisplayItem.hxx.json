[
  {
    "id" : "610d53df-05bd-414e-a4ca-ae035680024a",
    "prId" : 1653,
    "prUrl" : "https://github.com/root-project/root/pull/1653#pullrequestreview-98708662",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "172433e5-0a28-46e5-a20d-9a6db8743222",
        "parentId" : null,
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "Are we guaranteed that the lifetime of the `TOrdinaryDisplayItem` exceeds the lifetime of the object `fObject` points to? Or should this be a `weak_ptr` or even `shared_ptr`?",
        "createdAt" : "2018-02-20T17:19:40Z",
        "updatedAt" : "2018-02-20T17:23:07Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "be149dd7-65f9-43d5-bea8-39af4a046a23",
        "parentId" : "172433e5-0a28-46e5-a20d-9a6db8743222",
        "authorId" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "body" : "> Are we guaranteed that the lifetime of the TOrdinaryDisplayItem exceeds the lifetime of the object fObject points to?\r\n\r\n``TOrdinaryDisplayItem`` should be used only for the objects, which exists longer than painter method of canvas/pad are executed. This is typically drawables (or objects inside drawables).\r\nAfter painting is finished, all display items should be destroyed. \r\nIf we want to use ``weak_ptr`` or ``shared_ptr``, we could create appropriate template classes.\r\nBut first we should solve I/O limitation with ``shared_ptr``, while ``TDisplayItem`` have to be streamed and send to client  ",
        "createdAt" : "2018-02-20T17:41:08Z",
        "updatedAt" : "2018-02-20T17:41:08Z",
        "lastEditedBy" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "tags" : [
        ]
      },
      {
        "id" : "2820b452-06ed-4959-b891-4133fe6338a9",
        "parentId" : "172433e5-0a28-46e5-a20d-9a6db8743222",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "But objects inside drawables can be `weak_ptr`. We get a shared_ptr from that - and now how do we keep that `shared_ptr` alive during the lifetime of the display item? We must do that, because someone else might remove the object, expiring the `weak_ptr` - and how does the display item learn about that? (But I do understand the limitation of the shared_ptr I/O and I agree that we cannot fix this - if I'm right and this needs fixing - until we have shared_ptr support.)",
        "createdAt" : "2018-02-22T19:33:16Z",
        "updatedAt" : "2018-02-22T19:34:05Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      },
      {
        "id" : "3ca371f9-9782-4475-8238-c0cc1f8b2cd9",
        "parentId" : "172433e5-0a28-46e5-a20d-9a6db8743222",
        "authorId" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "body" : "Is weak_ptr supported by ROOT I/O?\r\nCan one create weak_ptr from **this**, without using shared_ptr<TDrawable> which is stored in the list of pad primitives? ",
        "createdAt" : "2018-02-22T19:39:43Z",
        "updatedAt" : "2018-02-22T19:39:44Z",
        "lastEditedBy" : "e4571402-a12a-4377-8cca-960e88b81e3d",
        "tags" : [
        ]
      },
      {
        "id" : "f93b876a-2f1a-40b4-bfc8-d9c0d82ba74c",
        "parentId" : "172433e5-0a28-46e5-a20d-9a6db8743222",
        "authorId" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "body" : "As I said - we need to wait for I/O support before we can fix this if it needs fixing. And yes, there's `std::enable_shared_from_this`. Unless `this` is `T` - then we need to make `T` a `weak_ptr<T>` (i.e. pass the `weak_ptr` directly to the display item).\r\n\r\nWe should take note and fix it later.",
        "createdAt" : "2018-02-22T20:03:05Z",
        "updatedAt" : "2018-02-22T20:03:05Z",
        "lastEditedBy" : "09b7e073-cbeb-42e8-aa22-8b1468de56ae",
        "tags" : [
        ]
      }
    ],
    "commit" : "7eef4aa51ce282f71666c40ec9bf3ef4ed7ed435",
    "line" : 52,
    "diffHunk" : "@@ -1,1 +50,54 @@class TOrdinaryDisplayItem : public TDisplayItem {\nprotected:\n   const T *fObject{nullptr}; ///<  direct pointer without ownership\n\npublic:"
  }
]